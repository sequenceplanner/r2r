pub mod msg { use super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct StereoCameraInfo { pub header : std_msgs :: msg :: Header , pub left_info : sensor_msgs :: msg :: CameraInfo , pub right_info : sensor_msgs :: msg :: CameraInfo , pub q : Vec < f64 > , pub t_left_right : Vec < f64 > , pub r_left_right : Vec < f64 > } impl WrappedTypesupport for StereoCameraInfo { type CStruct = nerian_stereo__msg__StereoCameraInfo ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__nerian_stereo__msg__StereoCameraInfo () } } fn create_msg () -> * mut nerian_stereo__msg__StereoCameraInfo { unsafe { nerian_stereo__msg__StereoCameraInfo__create () } } fn destroy_msg (msg : * mut nerian_stereo__msg__StereoCameraInfo) -> () { unsafe { nerian_stereo__msg__StereoCameraInfo__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> StereoCameraInfo { StereoCameraInfo { header : std_msgs :: msg :: Header :: from_native (& msg . header) , left_info : sensor_msgs :: msg :: CameraInfo :: from_native (& msg . left_info) , right_info : sensor_msgs :: msg :: CameraInfo :: from_native (& msg . right_info) , q : msg . q . to_vec () , t_left_right : msg . t_left_right . to_vec () , r_left_right : msg . r_left_right . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; self . left_info . copy_to_native (& mut msg . left_info) ; self . right_info . copy_to_native (& mut msg . right_info) ; assert_eq ! (self . q . len () , 16usize , "Field {} is fixed size of {}!" , "q" , 16usize) ; msg . q . copy_from_slice (& self . q [.. 16usize]) ; assert_eq ! (self . t_left_right . len () , 3usize , "Field {} is fixed size of {}!" , "t_left_right" , 3usize) ; msg . t_left_right . copy_from_slice (& self . t_left_right [.. 3usize]) ; assert_eq ! (self . r_left_right . len () , 9usize , "Field {} is fixed size of {}!" , "r_left_right" , 9usize) ; msg . r_left_right . copy_from_slice (& self . r_left_right [.. 9usize]) ; } } impl Default for StereoCameraInfo { fn default () -> Self { let msg_native = WrappedNativeMsg :: < StereoCameraInfo > :: new () ; StereoCameraInfo :: from_native (& msg_native) } } }