pub mod msg { use super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Message { pub header : std_msgs :: msg :: Header , pub message : Vec < u8 > } impl WrappedTypesupport for Message { type CStruct = rtcm_msgs__msg__Message ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rtcm_msgs__msg__Message () } } fn create_msg () -> * mut rtcm_msgs__msg__Message { unsafe { rtcm_msgs__msg__Message__create () } } fn destroy_msg (msg : * mut rtcm_msgs__msg__Message) -> () { unsafe { rtcm_msgs__msg__Message__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Message { Message { header : std_msgs :: msg :: Header :: from_native (& msg . header) , message : msg . message . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . message . update (& self . message) ; } } impl Default for Message { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Message > :: new () ; Message :: from_native (& msg_native) } } }