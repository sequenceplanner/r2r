pub mod msg { use super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct SbgAirData { pub header : std_msgs :: msg :: Header , pub time_stamp : u32 , pub status : sbg_driver :: msg :: SbgAirDataStatus , pub pressure_abs : f64 , pub altitude : f64 , pub pressure_diff : f64 , pub true_air_speed : f64 , pub air_temperature : f64 } impl WrappedTypesupport for SbgAirData { type CStruct = sbg_driver__msg__SbgAirData ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__sbg_driver__msg__SbgAirData () } } fn create_msg () -> * mut sbg_driver__msg__SbgAirData { unsafe { sbg_driver__msg__SbgAirData__create () } } fn destroy_msg (msg : * mut sbg_driver__msg__SbgAirData) -> () { unsafe { sbg_driver__msg__SbgAirData__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> SbgAirData { SbgAirData { header : std_msgs :: msg :: Header :: from_native (& msg . header) , time_stamp : msg . time_stamp , status : sbg_driver :: msg :: SbgAirDataStatus :: from_native (& msg . status) , pressure_abs : msg . pressure_abs , altitude : msg . altitude , pressure_diff : msg . pressure_diff , true_air_speed : msg . true_air_speed , air_temperature : msg . air_temperature , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . time_stamp = self . time_stamp ; self . status . copy_to_native (& mut msg . status) ; msg . pressure_abs = self . pressure_abs ; msg . altitude = self . altitude ; msg . pressure_diff = self . pressure_diff ; msg . true_air_speed = self . true_air_speed ; msg . air_temperature = self . air_temperature ; } } impl Default for SbgAirData { fn default () -> Self { let msg_native = WrappedNativeMsg :: < SbgAirData > :: new () ; SbgAirData :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct SbgAirDataStatus { pub is_delay_time : bool , pub pressure_valid : bool , pub altitude_valid : bool , pub pressure_diff_valid : bool , pub air_speed_valid : bool , pub air_temperature_valid : bool } impl WrappedTypesupport for SbgAirDataStatus { type CStruct = sbg_driver__msg__SbgAirDataStatus ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__sbg_driver__msg__SbgAirDataStatus () } } fn create_msg () -> * mut sbg_driver__msg__SbgAirDataStatus { unsafe { sbg_driver__msg__SbgAirDataStatus__create () } } fn destroy_msg (msg : * mut sbg_driver__msg__SbgAirDataStatus) -> () { unsafe { sbg_driver__msg__SbgAirDataStatus__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> SbgAirDataStatus { SbgAirDataStatus { is_delay_time : msg . is_delay_time , pressure_valid : msg . pressure_valid , altitude_valid : msg . altitude_valid , pressure_diff_valid : msg . pressure_diff_valid , air_speed_valid : msg . air_speed_valid , air_temperature_valid : msg . air_temperature_valid , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . is_delay_time = self . is_delay_time ; msg . pressure_valid = self . pressure_valid ; msg . altitude_valid = self . altitude_valid ; msg . pressure_diff_valid = self . pressure_diff_valid ; msg . air_speed_valid = self . air_speed_valid ; msg . air_temperature_valid = self . air_temperature_valid ; } } impl Default for SbgAirDataStatus { fn default () -> Self { let msg_native = WrappedNativeMsg :: < SbgAirDataStatus > :: new () ; SbgAirDataStatus :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct SbgEkfEuler { pub header : std_msgs :: msg :: Header , pub time_stamp : u32 , pub angle : geometry_msgs :: msg :: Vector3 , pub accuracy : geometry_msgs :: msg :: Vector3 , pub status : sbg_driver :: msg :: SbgEkfStatus } impl WrappedTypesupport for SbgEkfEuler { type CStruct = sbg_driver__msg__SbgEkfEuler ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__sbg_driver__msg__SbgEkfEuler () } } fn create_msg () -> * mut sbg_driver__msg__SbgEkfEuler { unsafe { sbg_driver__msg__SbgEkfEuler__create () } } fn destroy_msg (msg : * mut sbg_driver__msg__SbgEkfEuler) -> () { unsafe { sbg_driver__msg__SbgEkfEuler__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> SbgEkfEuler { SbgEkfEuler { header : std_msgs :: msg :: Header :: from_native (& msg . header) , time_stamp : msg . time_stamp , angle : geometry_msgs :: msg :: Vector3 :: from_native (& msg . angle) , accuracy : geometry_msgs :: msg :: Vector3 :: from_native (& msg . accuracy) , status : sbg_driver :: msg :: SbgEkfStatus :: from_native (& msg . status) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . time_stamp = self . time_stamp ; self . angle . copy_to_native (& mut msg . angle) ; self . accuracy . copy_to_native (& mut msg . accuracy) ; self . status . copy_to_native (& mut msg . status) ; } } impl Default for SbgEkfEuler { fn default () -> Self { let msg_native = WrappedNativeMsg :: < SbgEkfEuler > :: new () ; SbgEkfEuler :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct SbgEkfNav { pub header : std_msgs :: msg :: Header , pub time_stamp : u32 , pub velocity : geometry_msgs :: msg :: Vector3 , pub velocity_accuracy : geometry_msgs :: msg :: Vector3 , pub latitude : f64 , pub longitude : f64 , pub altitude : f64 , pub undulation : f32 , pub position_accuracy : geometry_msgs :: msg :: Vector3 , pub status : sbg_driver :: msg :: SbgEkfStatus } impl WrappedTypesupport for SbgEkfNav { type CStruct = sbg_driver__msg__SbgEkfNav ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__sbg_driver__msg__SbgEkfNav () } } fn create_msg () -> * mut sbg_driver__msg__SbgEkfNav { unsafe { sbg_driver__msg__SbgEkfNav__create () } } fn destroy_msg (msg : * mut sbg_driver__msg__SbgEkfNav) -> () { unsafe { sbg_driver__msg__SbgEkfNav__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> SbgEkfNav { SbgEkfNav { header : std_msgs :: msg :: Header :: from_native (& msg . header) , time_stamp : msg . time_stamp , velocity : geometry_msgs :: msg :: Vector3 :: from_native (& msg . velocity) , velocity_accuracy : geometry_msgs :: msg :: Vector3 :: from_native (& msg . velocity_accuracy) , latitude : msg . latitude , longitude : msg . longitude , altitude : msg . altitude , undulation : msg . undulation , position_accuracy : geometry_msgs :: msg :: Vector3 :: from_native (& msg . position_accuracy) , status : sbg_driver :: msg :: SbgEkfStatus :: from_native (& msg . status) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . time_stamp = self . time_stamp ; self . velocity . copy_to_native (& mut msg . velocity) ; self . velocity_accuracy . copy_to_native (& mut msg . velocity_accuracy) ; msg . latitude = self . latitude ; msg . longitude = self . longitude ; msg . altitude = self . altitude ; msg . undulation = self . undulation ; self . position_accuracy . copy_to_native (& mut msg . position_accuracy) ; self . status . copy_to_native (& mut msg . status) ; } } impl Default for SbgEkfNav { fn default () -> Self { let msg_native = WrappedNativeMsg :: < SbgEkfNav > :: new () ; SbgEkfNav :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct SbgEkfQuat { pub header : std_msgs :: msg :: Header , pub time_stamp : u32 , pub quaternion : geometry_msgs :: msg :: Quaternion , pub accuracy : geometry_msgs :: msg :: Vector3 , pub status : sbg_driver :: msg :: SbgEkfStatus } impl WrappedTypesupport for SbgEkfQuat { type CStruct = sbg_driver__msg__SbgEkfQuat ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__sbg_driver__msg__SbgEkfQuat () } } fn create_msg () -> * mut sbg_driver__msg__SbgEkfQuat { unsafe { sbg_driver__msg__SbgEkfQuat__create () } } fn destroy_msg (msg : * mut sbg_driver__msg__SbgEkfQuat) -> () { unsafe { sbg_driver__msg__SbgEkfQuat__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> SbgEkfQuat { SbgEkfQuat { header : std_msgs :: msg :: Header :: from_native (& msg . header) , time_stamp : msg . time_stamp , quaternion : geometry_msgs :: msg :: Quaternion :: from_native (& msg . quaternion) , accuracy : geometry_msgs :: msg :: Vector3 :: from_native (& msg . accuracy) , status : sbg_driver :: msg :: SbgEkfStatus :: from_native (& msg . status) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . time_stamp = self . time_stamp ; self . quaternion . copy_to_native (& mut msg . quaternion) ; self . accuracy . copy_to_native (& mut msg . accuracy) ; self . status . copy_to_native (& mut msg . status) ; } } impl Default for SbgEkfQuat { fn default () -> Self { let msg_native = WrappedNativeMsg :: < SbgEkfQuat > :: new () ; SbgEkfQuat :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct SbgEkfStatus { pub solution_mode : u8 , pub attitude_valid : bool , pub heading_valid : bool , pub velocity_valid : bool , pub position_valid : bool , pub vert_ref_used : bool , pub mag_ref_used : bool , pub gps1_vel_used : bool , pub gps1_pos_used : bool , pub gps1_course_used : bool , pub gps1_hdt_used : bool , pub gps2_vel_used : bool , pub gps2_pos_used : bool , pub gps2_course_used : bool , pub gps2_hdt_used : bool , pub odo_used : bool } impl WrappedTypesupport for SbgEkfStatus { type CStruct = sbg_driver__msg__SbgEkfStatus ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__sbg_driver__msg__SbgEkfStatus () } } fn create_msg () -> * mut sbg_driver__msg__SbgEkfStatus { unsafe { sbg_driver__msg__SbgEkfStatus__create () } } fn destroy_msg (msg : * mut sbg_driver__msg__SbgEkfStatus) -> () { unsafe { sbg_driver__msg__SbgEkfStatus__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> SbgEkfStatus { SbgEkfStatus { solution_mode : msg . solution_mode , attitude_valid : msg . attitude_valid , heading_valid : msg . heading_valid , velocity_valid : msg . velocity_valid , position_valid : msg . position_valid , vert_ref_used : msg . vert_ref_used , mag_ref_used : msg . mag_ref_used , gps1_vel_used : msg . gps1_vel_used , gps1_pos_used : msg . gps1_pos_used , gps1_course_used : msg . gps1_course_used , gps1_hdt_used : msg . gps1_hdt_used , gps2_vel_used : msg . gps2_vel_used , gps2_pos_used : msg . gps2_pos_used , gps2_course_used : msg . gps2_course_used , gps2_hdt_used : msg . gps2_hdt_used , odo_used : msg . odo_used , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . solution_mode = self . solution_mode ; msg . attitude_valid = self . attitude_valid ; msg . heading_valid = self . heading_valid ; msg . velocity_valid = self . velocity_valid ; msg . position_valid = self . position_valid ; msg . vert_ref_used = self . vert_ref_used ; msg . mag_ref_used = self . mag_ref_used ; msg . gps1_vel_used = self . gps1_vel_used ; msg . gps1_pos_used = self . gps1_pos_used ; msg . gps1_course_used = self . gps1_course_used ; msg . gps1_hdt_used = self . gps1_hdt_used ; msg . gps2_vel_used = self . gps2_vel_used ; msg . gps2_pos_used = self . gps2_pos_used ; msg . gps2_course_used = self . gps2_course_used ; msg . gps2_hdt_used = self . gps2_hdt_used ; msg . odo_used = self . odo_used ; } } impl Default for SbgEkfStatus { fn default () -> Self { let msg_native = WrappedNativeMsg :: < SbgEkfStatus > :: new () ; SbgEkfStatus :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct SbgEvent { pub header : std_msgs :: msg :: Header , pub time_stamp : u32 , pub overflow : bool , pub offset_0_valid : bool , pub offset_1_valid : bool , pub offset_2_valid : bool , pub offset_3_valid : bool , pub time_offset_0 : u16 , pub time_offset_1 : u16 , pub time_offset_2 : u16 , pub time_offset_3 : u16 } impl WrappedTypesupport for SbgEvent { type CStruct = sbg_driver__msg__SbgEvent ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__sbg_driver__msg__SbgEvent () } } fn create_msg () -> * mut sbg_driver__msg__SbgEvent { unsafe { sbg_driver__msg__SbgEvent__create () } } fn destroy_msg (msg : * mut sbg_driver__msg__SbgEvent) -> () { unsafe { sbg_driver__msg__SbgEvent__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> SbgEvent { SbgEvent { header : std_msgs :: msg :: Header :: from_native (& msg . header) , time_stamp : msg . time_stamp , overflow : msg . overflow , offset_0_valid : msg . offset_0_valid , offset_1_valid : msg . offset_1_valid , offset_2_valid : msg . offset_2_valid , offset_3_valid : msg . offset_3_valid , time_offset_0 : msg . time_offset_0 , time_offset_1 : msg . time_offset_1 , time_offset_2 : msg . time_offset_2 , time_offset_3 : msg . time_offset_3 , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . time_stamp = self . time_stamp ; msg . overflow = self . overflow ; msg . offset_0_valid = self . offset_0_valid ; msg . offset_1_valid = self . offset_1_valid ; msg . offset_2_valid = self . offset_2_valid ; msg . offset_3_valid = self . offset_3_valid ; msg . time_offset_0 = self . time_offset_0 ; msg . time_offset_1 = self . time_offset_1 ; msg . time_offset_2 = self . time_offset_2 ; msg . time_offset_3 = self . time_offset_3 ; } } impl Default for SbgEvent { fn default () -> Self { let msg_native = WrappedNativeMsg :: < SbgEvent > :: new () ; SbgEvent :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct SbgGpsHdt { pub header : std_msgs :: msg :: Header , pub time_stamp : u32 , pub status : u16 , pub tow : u32 , pub true_heading : f32 , pub true_heading_acc : f32 , pub pitch : f32 , pub pitch_acc : f32 , pub baseline : f32 } impl WrappedTypesupport for SbgGpsHdt { type CStruct = sbg_driver__msg__SbgGpsHdt ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__sbg_driver__msg__SbgGpsHdt () } } fn create_msg () -> * mut sbg_driver__msg__SbgGpsHdt { unsafe { sbg_driver__msg__SbgGpsHdt__create () } } fn destroy_msg (msg : * mut sbg_driver__msg__SbgGpsHdt) -> () { unsafe { sbg_driver__msg__SbgGpsHdt__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> SbgGpsHdt { SbgGpsHdt { header : std_msgs :: msg :: Header :: from_native (& msg . header) , time_stamp : msg . time_stamp , status : msg . status , tow : msg . tow , true_heading : msg . true_heading , true_heading_acc : msg . true_heading_acc , pitch : msg . pitch , pitch_acc : msg . pitch_acc , baseline : msg . baseline , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . time_stamp = self . time_stamp ; msg . status = self . status ; msg . tow = self . tow ; msg . true_heading = self . true_heading ; msg . true_heading_acc = self . true_heading_acc ; msg . pitch = self . pitch ; msg . pitch_acc = self . pitch_acc ; msg . baseline = self . baseline ; } } impl Default for SbgGpsHdt { fn default () -> Self { let msg_native = WrappedNativeMsg :: < SbgGpsHdt > :: new () ; SbgGpsHdt :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct SbgGpsPos { pub header : std_msgs :: msg :: Header , pub time_stamp : u32 , pub status : sbg_driver :: msg :: SbgGpsPosStatus , pub gps_tow : u32 , pub latitude : f64 , pub longitude : f64 , pub altitude : f64 , pub undulation : f32 , pub position_accuracy : geometry_msgs :: msg :: Vector3 , pub num_sv_used : u8 , pub base_station_id : u16 , pub diff_age : u16 } impl WrappedTypesupport for SbgGpsPos { type CStruct = sbg_driver__msg__SbgGpsPos ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__sbg_driver__msg__SbgGpsPos () } } fn create_msg () -> * mut sbg_driver__msg__SbgGpsPos { unsafe { sbg_driver__msg__SbgGpsPos__create () } } fn destroy_msg (msg : * mut sbg_driver__msg__SbgGpsPos) -> () { unsafe { sbg_driver__msg__SbgGpsPos__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> SbgGpsPos { SbgGpsPos { header : std_msgs :: msg :: Header :: from_native (& msg . header) , time_stamp : msg . time_stamp , status : sbg_driver :: msg :: SbgGpsPosStatus :: from_native (& msg . status) , gps_tow : msg . gps_tow , latitude : msg . latitude , longitude : msg . longitude , altitude : msg . altitude , undulation : msg . undulation , position_accuracy : geometry_msgs :: msg :: Vector3 :: from_native (& msg . position_accuracy) , num_sv_used : msg . num_sv_used , base_station_id : msg . base_station_id , diff_age : msg . diff_age , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . time_stamp = self . time_stamp ; self . status . copy_to_native (& mut msg . status) ; msg . gps_tow = self . gps_tow ; msg . latitude = self . latitude ; msg . longitude = self . longitude ; msg . altitude = self . altitude ; msg . undulation = self . undulation ; self . position_accuracy . copy_to_native (& mut msg . position_accuracy) ; msg . num_sv_used = self . num_sv_used ; msg . base_station_id = self . base_station_id ; msg . diff_age = self . diff_age ; } } impl Default for SbgGpsPos { fn default () -> Self { let msg_native = WrappedNativeMsg :: < SbgGpsPos > :: new () ; SbgGpsPos :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct SbgGpsPosStatus { pub status : u8 , # [serde (rename = "type")] pub type_ : u8 , pub gps_l1_used : bool , pub gps_l2_used : bool , pub gps_l5_used : bool , pub glo_l1_used : bool , pub glo_l2_used : bool } impl WrappedTypesupport for SbgGpsPosStatus { type CStruct = sbg_driver__msg__SbgGpsPosStatus ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__sbg_driver__msg__SbgGpsPosStatus () } } fn create_msg () -> * mut sbg_driver__msg__SbgGpsPosStatus { unsafe { sbg_driver__msg__SbgGpsPosStatus__create () } } fn destroy_msg (msg : * mut sbg_driver__msg__SbgGpsPosStatus) -> () { unsafe { sbg_driver__msg__SbgGpsPosStatus__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> SbgGpsPosStatus { SbgGpsPosStatus { status : msg . status , type_ : msg . type_ , gps_l1_used : msg . gps_l1_used , gps_l2_used : msg . gps_l2_used , gps_l5_used : msg . gps_l5_used , glo_l1_used : msg . glo_l1_used , glo_l2_used : msg . glo_l2_used , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . status = self . status ; msg . type_ = self . type_ ; msg . gps_l1_used = self . gps_l1_used ; msg . gps_l2_used = self . gps_l2_used ; msg . gps_l5_used = self . gps_l5_used ; msg . glo_l1_used = self . glo_l1_used ; msg . glo_l2_used = self . glo_l2_used ; } } impl Default for SbgGpsPosStatus { fn default () -> Self { let msg_native = WrappedNativeMsg :: < SbgGpsPosStatus > :: new () ; SbgGpsPosStatus :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct SbgGpsRaw { pub header : std_msgs :: msg :: Header , pub data : Vec < u8 > } impl WrappedTypesupport for SbgGpsRaw { type CStruct = sbg_driver__msg__SbgGpsRaw ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__sbg_driver__msg__SbgGpsRaw () } } fn create_msg () -> * mut sbg_driver__msg__SbgGpsRaw { unsafe { sbg_driver__msg__SbgGpsRaw__create () } } fn destroy_msg (msg : * mut sbg_driver__msg__SbgGpsRaw) -> () { unsafe { sbg_driver__msg__SbgGpsRaw__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> SbgGpsRaw { SbgGpsRaw { header : std_msgs :: msg :: Header :: from_native (& msg . header) , data : msg . data . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . data . update (& self . data) ; } } impl Default for SbgGpsRaw { fn default () -> Self { let msg_native = WrappedNativeMsg :: < SbgGpsRaw > :: new () ; SbgGpsRaw :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct SbgGpsVel { pub header : std_msgs :: msg :: Header , pub time_stamp : u32 , pub status : sbg_driver :: msg :: SbgGpsVelStatus , pub gps_tow : u32 , pub velocity : geometry_msgs :: msg :: Vector3 , pub velocity_accuracy : geometry_msgs :: msg :: Vector3 , pub course : f32 , pub course_acc : f32 } impl WrappedTypesupport for SbgGpsVel { type CStruct = sbg_driver__msg__SbgGpsVel ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__sbg_driver__msg__SbgGpsVel () } } fn create_msg () -> * mut sbg_driver__msg__SbgGpsVel { unsafe { sbg_driver__msg__SbgGpsVel__create () } } fn destroy_msg (msg : * mut sbg_driver__msg__SbgGpsVel) -> () { unsafe { sbg_driver__msg__SbgGpsVel__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> SbgGpsVel { SbgGpsVel { header : std_msgs :: msg :: Header :: from_native (& msg . header) , time_stamp : msg . time_stamp , status : sbg_driver :: msg :: SbgGpsVelStatus :: from_native (& msg . status) , gps_tow : msg . gps_tow , velocity : geometry_msgs :: msg :: Vector3 :: from_native (& msg . velocity) , velocity_accuracy : geometry_msgs :: msg :: Vector3 :: from_native (& msg . velocity_accuracy) , course : msg . course , course_acc : msg . course_acc , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . time_stamp = self . time_stamp ; self . status . copy_to_native (& mut msg . status) ; msg . gps_tow = self . gps_tow ; self . velocity . copy_to_native (& mut msg . velocity) ; self . velocity_accuracy . copy_to_native (& mut msg . velocity_accuracy) ; msg . course = self . course ; msg . course_acc = self . course_acc ; } } impl Default for SbgGpsVel { fn default () -> Self { let msg_native = WrappedNativeMsg :: < SbgGpsVel > :: new () ; SbgGpsVel :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct SbgGpsVelStatus { pub vel_status : u8 , pub vel_type : u8 } impl WrappedTypesupport for SbgGpsVelStatus { type CStruct = sbg_driver__msg__SbgGpsVelStatus ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__sbg_driver__msg__SbgGpsVelStatus () } } fn create_msg () -> * mut sbg_driver__msg__SbgGpsVelStatus { unsafe { sbg_driver__msg__SbgGpsVelStatus__create () } } fn destroy_msg (msg : * mut sbg_driver__msg__SbgGpsVelStatus) -> () { unsafe { sbg_driver__msg__SbgGpsVelStatus__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> SbgGpsVelStatus { SbgGpsVelStatus { vel_status : msg . vel_status , vel_type : msg . vel_type , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . vel_status = self . vel_status ; msg . vel_type = self . vel_type ; } } impl Default for SbgGpsVelStatus { fn default () -> Self { let msg_native = WrappedNativeMsg :: < SbgGpsVelStatus > :: new () ; SbgGpsVelStatus :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct SbgImuData { pub header : std_msgs :: msg :: Header , pub time_stamp : u32 , pub imu_status : sbg_driver :: msg :: SbgImuStatus , pub accel : geometry_msgs :: msg :: Vector3 , pub gyro : geometry_msgs :: msg :: Vector3 , pub temp : f32 , pub delta_vel : geometry_msgs :: msg :: Vector3 , pub delta_angle : geometry_msgs :: msg :: Vector3 } impl WrappedTypesupport for SbgImuData { type CStruct = sbg_driver__msg__SbgImuData ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__sbg_driver__msg__SbgImuData () } } fn create_msg () -> * mut sbg_driver__msg__SbgImuData { unsafe { sbg_driver__msg__SbgImuData__create () } } fn destroy_msg (msg : * mut sbg_driver__msg__SbgImuData) -> () { unsafe { sbg_driver__msg__SbgImuData__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> SbgImuData { SbgImuData { header : std_msgs :: msg :: Header :: from_native (& msg . header) , time_stamp : msg . time_stamp , imu_status : sbg_driver :: msg :: SbgImuStatus :: from_native (& msg . imu_status) , accel : geometry_msgs :: msg :: Vector3 :: from_native (& msg . accel) , gyro : geometry_msgs :: msg :: Vector3 :: from_native (& msg . gyro) , temp : msg . temp , delta_vel : geometry_msgs :: msg :: Vector3 :: from_native (& msg . delta_vel) , delta_angle : geometry_msgs :: msg :: Vector3 :: from_native (& msg . delta_angle) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . time_stamp = self . time_stamp ; self . imu_status . copy_to_native (& mut msg . imu_status) ; self . accel . copy_to_native (& mut msg . accel) ; self . gyro . copy_to_native (& mut msg . gyro) ; msg . temp = self . temp ; self . delta_vel . copy_to_native (& mut msg . delta_vel) ; self . delta_angle . copy_to_native (& mut msg . delta_angle) ; } } impl Default for SbgImuData { fn default () -> Self { let msg_native = WrappedNativeMsg :: < SbgImuData > :: new () ; SbgImuData :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct SbgImuShort { pub header : std_msgs :: msg :: Header , pub time_stamp : u32 , pub imu_status : sbg_driver :: msg :: SbgImuStatus , pub delta_velocity : geometry_msgs :: msg :: Vector3 , pub delta_angle : geometry_msgs :: msg :: Vector3 , pub temperature : i16 } impl WrappedTypesupport for SbgImuShort { type CStruct = sbg_driver__msg__SbgImuShort ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__sbg_driver__msg__SbgImuShort () } } fn create_msg () -> * mut sbg_driver__msg__SbgImuShort { unsafe { sbg_driver__msg__SbgImuShort__create () } } fn destroy_msg (msg : * mut sbg_driver__msg__SbgImuShort) -> () { unsafe { sbg_driver__msg__SbgImuShort__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> SbgImuShort { SbgImuShort { header : std_msgs :: msg :: Header :: from_native (& msg . header) , time_stamp : msg . time_stamp , imu_status : sbg_driver :: msg :: SbgImuStatus :: from_native (& msg . imu_status) , delta_velocity : geometry_msgs :: msg :: Vector3 :: from_native (& msg . delta_velocity) , delta_angle : geometry_msgs :: msg :: Vector3 :: from_native (& msg . delta_angle) , temperature : msg . temperature , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . time_stamp = self . time_stamp ; self . imu_status . copy_to_native (& mut msg . imu_status) ; self . delta_velocity . copy_to_native (& mut msg . delta_velocity) ; self . delta_angle . copy_to_native (& mut msg . delta_angle) ; msg . temperature = self . temperature ; } } impl Default for SbgImuShort { fn default () -> Self { let msg_native = WrappedNativeMsg :: < SbgImuShort > :: new () ; SbgImuShort :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct SbgImuStatus { pub imu_com : bool , pub imu_status : bool , pub imu_accel_x : bool , pub imu_accel_y : bool , pub imu_accel_z : bool , pub imu_gyro_x : bool , pub imu_gyro_y : bool , pub imu_gyro_z : bool , pub imu_accels_in_range : bool , pub imu_gyros_in_range : bool } impl WrappedTypesupport for SbgImuStatus { type CStruct = sbg_driver__msg__SbgImuStatus ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__sbg_driver__msg__SbgImuStatus () } } fn create_msg () -> * mut sbg_driver__msg__SbgImuStatus { unsafe { sbg_driver__msg__SbgImuStatus__create () } } fn destroy_msg (msg : * mut sbg_driver__msg__SbgImuStatus) -> () { unsafe { sbg_driver__msg__SbgImuStatus__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> SbgImuStatus { SbgImuStatus { imu_com : msg . imu_com , imu_status : msg . imu_status , imu_accel_x : msg . imu_accel_x , imu_accel_y : msg . imu_accel_y , imu_accel_z : msg . imu_accel_z , imu_gyro_x : msg . imu_gyro_x , imu_gyro_y : msg . imu_gyro_y , imu_gyro_z : msg . imu_gyro_z , imu_accels_in_range : msg . imu_accels_in_range , imu_gyros_in_range : msg . imu_gyros_in_range , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . imu_com = self . imu_com ; msg . imu_status = self . imu_status ; msg . imu_accel_x = self . imu_accel_x ; msg . imu_accel_y = self . imu_accel_y ; msg . imu_accel_z = self . imu_accel_z ; msg . imu_gyro_x = self . imu_gyro_x ; msg . imu_gyro_y = self . imu_gyro_y ; msg . imu_gyro_z = self . imu_gyro_z ; msg . imu_accels_in_range = self . imu_accels_in_range ; msg . imu_gyros_in_range = self . imu_gyros_in_range ; } } impl Default for SbgImuStatus { fn default () -> Self { let msg_native = WrappedNativeMsg :: < SbgImuStatus > :: new () ; SbgImuStatus :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct SbgMag { pub header : std_msgs :: msg :: Header , pub time_stamp : u32 , pub mag : geometry_msgs :: msg :: Vector3 , pub accel : geometry_msgs :: msg :: Vector3 , pub status : sbg_driver :: msg :: SbgMagStatus } impl WrappedTypesupport for SbgMag { type CStruct = sbg_driver__msg__SbgMag ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__sbg_driver__msg__SbgMag () } } fn create_msg () -> * mut sbg_driver__msg__SbgMag { unsafe { sbg_driver__msg__SbgMag__create () } } fn destroy_msg (msg : * mut sbg_driver__msg__SbgMag) -> () { unsafe { sbg_driver__msg__SbgMag__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> SbgMag { SbgMag { header : std_msgs :: msg :: Header :: from_native (& msg . header) , time_stamp : msg . time_stamp , mag : geometry_msgs :: msg :: Vector3 :: from_native (& msg . mag) , accel : geometry_msgs :: msg :: Vector3 :: from_native (& msg . accel) , status : sbg_driver :: msg :: SbgMagStatus :: from_native (& msg . status) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . time_stamp = self . time_stamp ; self . mag . copy_to_native (& mut msg . mag) ; self . accel . copy_to_native (& mut msg . accel) ; self . status . copy_to_native (& mut msg . status) ; } } impl Default for SbgMag { fn default () -> Self { let msg_native = WrappedNativeMsg :: < SbgMag > :: new () ; SbgMag :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct SbgMagCalib { pub header : std_msgs :: msg :: Header } impl WrappedTypesupport for SbgMagCalib { type CStruct = sbg_driver__msg__SbgMagCalib ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__sbg_driver__msg__SbgMagCalib () } } fn create_msg () -> * mut sbg_driver__msg__SbgMagCalib { unsafe { sbg_driver__msg__SbgMagCalib__create () } } fn destroy_msg (msg : * mut sbg_driver__msg__SbgMagCalib) -> () { unsafe { sbg_driver__msg__SbgMagCalib__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> SbgMagCalib { SbgMagCalib { header : std_msgs :: msg :: Header :: from_native (& msg . header) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; } } impl Default for SbgMagCalib { fn default () -> Self { let msg_native = WrappedNativeMsg :: < SbgMagCalib > :: new () ; SbgMagCalib :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct SbgMagStatus { pub mag_x : bool , pub mag_y : bool , pub mag_z : bool , pub accel_x : bool , pub accel_y : bool , pub accel_z : bool , pub mags_in_range : bool , pub accels_in_range : bool , pub calibration : bool } impl WrappedTypesupport for SbgMagStatus { type CStruct = sbg_driver__msg__SbgMagStatus ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__sbg_driver__msg__SbgMagStatus () } } fn create_msg () -> * mut sbg_driver__msg__SbgMagStatus { unsafe { sbg_driver__msg__SbgMagStatus__create () } } fn destroy_msg (msg : * mut sbg_driver__msg__SbgMagStatus) -> () { unsafe { sbg_driver__msg__SbgMagStatus__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> SbgMagStatus { SbgMagStatus { mag_x : msg . mag_x , mag_y : msg . mag_y , mag_z : msg . mag_z , accel_x : msg . accel_x , accel_y : msg . accel_y , accel_z : msg . accel_z , mags_in_range : msg . mags_in_range , accels_in_range : msg . accels_in_range , calibration : msg . calibration , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . mag_x = self . mag_x ; msg . mag_y = self . mag_y ; msg . mag_z = self . mag_z ; msg . accel_x = self . accel_x ; msg . accel_y = self . accel_y ; msg . accel_z = self . accel_z ; msg . mags_in_range = self . mags_in_range ; msg . accels_in_range = self . accels_in_range ; msg . calibration = self . calibration ; } } impl Default for SbgMagStatus { fn default () -> Self { let msg_native = WrappedNativeMsg :: < SbgMagStatus > :: new () ; SbgMagStatus :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct SbgOdoVel { pub header : std_msgs :: msg :: Header , pub time_stamp : u32 , pub status : bool , pub vel : f32 } impl WrappedTypesupport for SbgOdoVel { type CStruct = sbg_driver__msg__SbgOdoVel ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__sbg_driver__msg__SbgOdoVel () } } fn create_msg () -> * mut sbg_driver__msg__SbgOdoVel { unsafe { sbg_driver__msg__SbgOdoVel__create () } } fn destroy_msg (msg : * mut sbg_driver__msg__SbgOdoVel) -> () { unsafe { sbg_driver__msg__SbgOdoVel__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> SbgOdoVel { SbgOdoVel { header : std_msgs :: msg :: Header :: from_native (& msg . header) , time_stamp : msg . time_stamp , status : msg . status , vel : msg . vel , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . time_stamp = self . time_stamp ; msg . status = self . status ; msg . vel = self . vel ; } } impl Default for SbgOdoVel { fn default () -> Self { let msg_native = WrappedNativeMsg :: < SbgOdoVel > :: new () ; SbgOdoVel :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct SbgShipMotion { pub header : std_msgs :: msg :: Header , pub time_stamp : u32 , pub heave_period : u16 , pub ship_motion : geometry_msgs :: msg :: Vector3 , pub acceleration : geometry_msgs :: msg :: Vector3 , pub velocity : geometry_msgs :: msg :: Vector3 , pub status : sbg_driver :: msg :: SbgShipMotionStatus } impl WrappedTypesupport for SbgShipMotion { type CStruct = sbg_driver__msg__SbgShipMotion ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__sbg_driver__msg__SbgShipMotion () } } fn create_msg () -> * mut sbg_driver__msg__SbgShipMotion { unsafe { sbg_driver__msg__SbgShipMotion__create () } } fn destroy_msg (msg : * mut sbg_driver__msg__SbgShipMotion) -> () { unsafe { sbg_driver__msg__SbgShipMotion__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> SbgShipMotion { SbgShipMotion { header : std_msgs :: msg :: Header :: from_native (& msg . header) , time_stamp : msg . time_stamp , heave_period : msg . heave_period , ship_motion : geometry_msgs :: msg :: Vector3 :: from_native (& msg . ship_motion) , acceleration : geometry_msgs :: msg :: Vector3 :: from_native (& msg . acceleration) , velocity : geometry_msgs :: msg :: Vector3 :: from_native (& msg . velocity) , status : sbg_driver :: msg :: SbgShipMotionStatus :: from_native (& msg . status) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . time_stamp = self . time_stamp ; msg . heave_period = self . heave_period ; self . ship_motion . copy_to_native (& mut msg . ship_motion) ; self . acceleration . copy_to_native (& mut msg . acceleration) ; self . velocity . copy_to_native (& mut msg . velocity) ; self . status . copy_to_native (& mut msg . status) ; } } impl Default for SbgShipMotion { fn default () -> Self { let msg_native = WrappedNativeMsg :: < SbgShipMotion > :: new () ; SbgShipMotion :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct SbgShipMotionStatus { pub heave_valid : bool , pub heave_vel_aided : bool , pub period_available : bool , pub period_valid : bool } impl WrappedTypesupport for SbgShipMotionStatus { type CStruct = sbg_driver__msg__SbgShipMotionStatus ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__sbg_driver__msg__SbgShipMotionStatus () } } fn create_msg () -> * mut sbg_driver__msg__SbgShipMotionStatus { unsafe { sbg_driver__msg__SbgShipMotionStatus__create () } } fn destroy_msg (msg : * mut sbg_driver__msg__SbgShipMotionStatus) -> () { unsafe { sbg_driver__msg__SbgShipMotionStatus__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> SbgShipMotionStatus { SbgShipMotionStatus { heave_valid : msg . heave_valid , heave_vel_aided : msg . heave_vel_aided , period_available : msg . period_available , period_valid : msg . period_valid , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . heave_valid = self . heave_valid ; msg . heave_vel_aided = self . heave_vel_aided ; msg . period_available = self . period_available ; msg . period_valid = self . period_valid ; } } impl Default for SbgShipMotionStatus { fn default () -> Self { let msg_native = WrappedNativeMsg :: < SbgShipMotionStatus > :: new () ; SbgShipMotionStatus :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct SbgStatus { pub header : std_msgs :: msg :: Header , pub time_stamp : u32 , pub status_general : sbg_driver :: msg :: SbgStatusGeneral , pub status_com : sbg_driver :: msg :: SbgStatusCom , pub status_aiding : sbg_driver :: msg :: SbgStatusAiding } impl WrappedTypesupport for SbgStatus { type CStruct = sbg_driver__msg__SbgStatus ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__sbg_driver__msg__SbgStatus () } } fn create_msg () -> * mut sbg_driver__msg__SbgStatus { unsafe { sbg_driver__msg__SbgStatus__create () } } fn destroy_msg (msg : * mut sbg_driver__msg__SbgStatus) -> () { unsafe { sbg_driver__msg__SbgStatus__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> SbgStatus { SbgStatus { header : std_msgs :: msg :: Header :: from_native (& msg . header) , time_stamp : msg . time_stamp , status_general : sbg_driver :: msg :: SbgStatusGeneral :: from_native (& msg . status_general) , status_com : sbg_driver :: msg :: SbgStatusCom :: from_native (& msg . status_com) , status_aiding : sbg_driver :: msg :: SbgStatusAiding :: from_native (& msg . status_aiding) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . time_stamp = self . time_stamp ; self . status_general . copy_to_native (& mut msg . status_general) ; self . status_com . copy_to_native (& mut msg . status_com) ; self . status_aiding . copy_to_native (& mut msg . status_aiding) ; } } impl Default for SbgStatus { fn default () -> Self { let msg_native = WrappedNativeMsg :: < SbgStatus > :: new () ; SbgStatus :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct SbgStatusAiding { pub gps1_pos_recv : bool , pub gps1_vel_recv : bool , pub gps1_hdt_recv : bool , pub gps1_utc_recv : bool , pub mag_recv : bool , pub odo_recv : bool , pub dvl_recv : bool } impl WrappedTypesupport for SbgStatusAiding { type CStruct = sbg_driver__msg__SbgStatusAiding ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__sbg_driver__msg__SbgStatusAiding () } } fn create_msg () -> * mut sbg_driver__msg__SbgStatusAiding { unsafe { sbg_driver__msg__SbgStatusAiding__create () } } fn destroy_msg (msg : * mut sbg_driver__msg__SbgStatusAiding) -> () { unsafe { sbg_driver__msg__SbgStatusAiding__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> SbgStatusAiding { SbgStatusAiding { gps1_pos_recv : msg . gps1_pos_recv , gps1_vel_recv : msg . gps1_vel_recv , gps1_hdt_recv : msg . gps1_hdt_recv , gps1_utc_recv : msg . gps1_utc_recv , mag_recv : msg . mag_recv , odo_recv : msg . odo_recv , dvl_recv : msg . dvl_recv , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . gps1_pos_recv = self . gps1_pos_recv ; msg . gps1_vel_recv = self . gps1_vel_recv ; msg . gps1_hdt_recv = self . gps1_hdt_recv ; msg . gps1_utc_recv = self . gps1_utc_recv ; msg . mag_recv = self . mag_recv ; msg . odo_recv = self . odo_recv ; msg . dvl_recv = self . dvl_recv ; } } impl Default for SbgStatusAiding { fn default () -> Self { let msg_native = WrappedNativeMsg :: < SbgStatusAiding > :: new () ; SbgStatusAiding :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct SbgStatusCom { pub port_a : bool , pub port_b : bool , pub port_c : bool , pub port_d : bool , pub port_e : bool , pub port_a_rx : bool , pub port_a_tx : bool , pub port_b_rx : bool , pub port_b_tx : bool , pub port_c_rx : bool , pub port_c_tx : bool , pub port_d_rx : bool , pub port_d_tx : bool , pub port_e_rx : bool , pub port_e_tx : bool , pub can_rx : bool , pub can_tx : bool , pub can_status : u8 } impl WrappedTypesupport for SbgStatusCom { type CStruct = sbg_driver__msg__SbgStatusCom ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__sbg_driver__msg__SbgStatusCom () } } fn create_msg () -> * mut sbg_driver__msg__SbgStatusCom { unsafe { sbg_driver__msg__SbgStatusCom__create () } } fn destroy_msg (msg : * mut sbg_driver__msg__SbgStatusCom) -> () { unsafe { sbg_driver__msg__SbgStatusCom__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> SbgStatusCom { SbgStatusCom { port_a : msg . port_a , port_b : msg . port_b , port_c : msg . port_c , port_d : msg . port_d , port_e : msg . port_e , port_a_rx : msg . port_a_rx , port_a_tx : msg . port_a_tx , port_b_rx : msg . port_b_rx , port_b_tx : msg . port_b_tx , port_c_rx : msg . port_c_rx , port_c_tx : msg . port_c_tx , port_d_rx : msg . port_d_rx , port_d_tx : msg . port_d_tx , port_e_rx : msg . port_e_rx , port_e_tx : msg . port_e_tx , can_rx : msg . can_rx , can_tx : msg . can_tx , can_status : msg . can_status , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . port_a = self . port_a ; msg . port_b = self . port_b ; msg . port_c = self . port_c ; msg . port_d = self . port_d ; msg . port_e = self . port_e ; msg . port_a_rx = self . port_a_rx ; msg . port_a_tx = self . port_a_tx ; msg . port_b_rx = self . port_b_rx ; msg . port_b_tx = self . port_b_tx ; msg . port_c_rx = self . port_c_rx ; msg . port_c_tx = self . port_c_tx ; msg . port_d_rx = self . port_d_rx ; msg . port_d_tx = self . port_d_tx ; msg . port_e_rx = self . port_e_rx ; msg . port_e_tx = self . port_e_tx ; msg . can_rx = self . can_rx ; msg . can_tx = self . can_tx ; msg . can_status = self . can_status ; } } impl Default for SbgStatusCom { fn default () -> Self { let msg_native = WrappedNativeMsg :: < SbgStatusCom > :: new () ; SbgStatusCom :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct SbgStatusGeneral { pub main_power : bool , pub imu_power : bool , pub gps_power : bool , pub settings : bool , pub temperature : bool } impl WrappedTypesupport for SbgStatusGeneral { type CStruct = sbg_driver__msg__SbgStatusGeneral ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__sbg_driver__msg__SbgStatusGeneral () } } fn create_msg () -> * mut sbg_driver__msg__SbgStatusGeneral { unsafe { sbg_driver__msg__SbgStatusGeneral__create () } } fn destroy_msg (msg : * mut sbg_driver__msg__SbgStatusGeneral) -> () { unsafe { sbg_driver__msg__SbgStatusGeneral__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> SbgStatusGeneral { SbgStatusGeneral { main_power : msg . main_power , imu_power : msg . imu_power , gps_power : msg . gps_power , settings : msg . settings , temperature : msg . temperature , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . main_power = self . main_power ; msg . imu_power = self . imu_power ; msg . gps_power = self . gps_power ; msg . settings = self . settings ; msg . temperature = self . temperature ; } } impl Default for SbgStatusGeneral { fn default () -> Self { let msg_native = WrappedNativeMsg :: < SbgStatusGeneral > :: new () ; SbgStatusGeneral :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct SbgUtcTime { pub header : std_msgs :: msg :: Header , pub time_stamp : u32 , pub clock_status : sbg_driver :: msg :: SbgUtcTimeStatus , pub year : u16 , pub month : u8 , pub day : u8 , pub hour : u8 , pub min : u8 , pub sec : u8 , pub nanosec : u32 , pub gps_tow : u32 } impl WrappedTypesupport for SbgUtcTime { type CStruct = sbg_driver__msg__SbgUtcTime ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__sbg_driver__msg__SbgUtcTime () } } fn create_msg () -> * mut sbg_driver__msg__SbgUtcTime { unsafe { sbg_driver__msg__SbgUtcTime__create () } } fn destroy_msg (msg : * mut sbg_driver__msg__SbgUtcTime) -> () { unsafe { sbg_driver__msg__SbgUtcTime__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> SbgUtcTime { SbgUtcTime { header : std_msgs :: msg :: Header :: from_native (& msg . header) , time_stamp : msg . time_stamp , clock_status : sbg_driver :: msg :: SbgUtcTimeStatus :: from_native (& msg . clock_status) , year : msg . year , month : msg . month , day : msg . day , hour : msg . hour , min : msg . min , sec : msg . sec , nanosec : msg . nanosec , gps_tow : msg . gps_tow , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . time_stamp = self . time_stamp ; self . clock_status . copy_to_native (& mut msg . clock_status) ; msg . year = self . year ; msg . month = self . month ; msg . day = self . day ; msg . hour = self . hour ; msg . min = self . min ; msg . sec = self . sec ; msg . nanosec = self . nanosec ; msg . gps_tow = self . gps_tow ; } } impl Default for SbgUtcTime { fn default () -> Self { let msg_native = WrappedNativeMsg :: < SbgUtcTime > :: new () ; SbgUtcTime :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct SbgUtcTimeStatus { pub clock_stable : bool , pub clock_status : u8 , pub clock_utc_sync : bool , pub clock_utc_status : u8 } impl WrappedTypesupport for SbgUtcTimeStatus { type CStruct = sbg_driver__msg__SbgUtcTimeStatus ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__sbg_driver__msg__SbgUtcTimeStatus () } } fn create_msg () -> * mut sbg_driver__msg__SbgUtcTimeStatus { unsafe { sbg_driver__msg__SbgUtcTimeStatus__create () } } fn destroy_msg (msg : * mut sbg_driver__msg__SbgUtcTimeStatus) -> () { unsafe { sbg_driver__msg__SbgUtcTimeStatus__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> SbgUtcTimeStatus { SbgUtcTimeStatus { clock_stable : msg . clock_stable , clock_status : msg . clock_status , clock_utc_sync : msg . clock_utc_sync , clock_utc_status : msg . clock_utc_status , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . clock_stable = self . clock_stable ; msg . clock_status = self . clock_status ; msg . clock_utc_sync = self . clock_utc_sync ; msg . clock_utc_status = self . clock_utc_status ; } } impl Default for SbgUtcTimeStatus { fn default () -> Self { let msg_native = WrappedNativeMsg :: < SbgUtcTimeStatus > :: new () ; SbgUtcTimeStatus :: from_native (& msg_native) } } }