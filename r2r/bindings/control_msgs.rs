pub mod action { # [allow (non_snake_case)] pub mod FollowJointTrajectory { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Action () ; impl WrappedActionTypeSupport for Action { type Goal = Goal ; type Result = Result ; type Feedback = Feedback ; type FeedbackMessage = FeedbackMessage ; type SendGoal = SendGoal :: Service ; type GetResult = GetResult :: Service ; fn get_ts () -> & 'static rosidl_action_type_support_t { unsafe { & * rosidl_typesupport_c__get_action_type_support_handle__control_msgs__action__FollowJointTrajectory () } } fn make_goal_request_msg (goal_id : unique_identifier_msgs :: msg :: UUID , goal : Goal) -> SendGoal :: Request { SendGoal :: Request { goal_id , goal } } fn make_goal_response_msg (accepted : bool , stamp : builtin_interfaces :: msg :: Time) -> SendGoal :: Response { SendGoal :: Response { accepted , stamp } } fn make_feedback_msg (goal_id : unique_identifier_msgs :: msg :: UUID , feedback : Feedback) -> FeedbackMessage { FeedbackMessage { goal_id , feedback } } fn make_result_request_msg (goal_id : unique_identifier_msgs :: msg :: UUID) -> GetResult :: Request { GetResult :: Request { goal_id , } } fn make_result_response_msg (status : i8 , result : Result) -> GetResult :: Response { GetResult :: Response { status , result , } } fn destructure_goal_request_msg (msg : SendGoal :: Request) -> (unique_identifier_msgs :: msg :: UUID , Goal) { (msg . goal_id , msg . goal) } fn destructure_goal_response_msg (msg : SendGoal :: Response) -> (bool , builtin_interfaces :: msg :: Time) { (msg . accepted , msg . stamp) } fn destructure_feedback_msg (msg : FeedbackMessage) -> (unique_identifier_msgs :: msg :: UUID , Feedback) { (msg . goal_id , msg . feedback) } fn destructure_result_response_msg (msg : GetResult :: Response) -> (i8 , Result) { (msg . status , msg . result) } fn destructure_result_request_msg (msg : GetResult :: Request) -> unique_identifier_msgs :: msg :: UUID { msg . goal_id } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Goal { pub trajectory : trajectory_msgs :: msg :: JointTrajectory , pub multi_dof_trajectory : trajectory_msgs :: msg :: MultiDOFJointTrajectory , pub path_tolerance : Vec < control_msgs :: msg :: JointTolerance > , pub component_path_tolerance : Vec < control_msgs :: msg :: JointComponentTolerance > , pub goal_tolerance : Vec < control_msgs :: msg :: JointTolerance > , pub component_goal_tolerance : Vec < control_msgs :: msg :: JointComponentTolerance > , pub goal_time_tolerance : builtin_interfaces :: msg :: Duration } impl WrappedTypesupport for Goal { type CStruct = control_msgs__action__FollowJointTrajectory_Goal ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__control_msgs__action__FollowJointTrajectory_Goal () } } fn create_msg () -> * mut control_msgs__action__FollowJointTrajectory_Goal { unsafe { control_msgs__action__FollowJointTrajectory_Goal__create () } } fn destroy_msg (msg : * mut control_msgs__action__FollowJointTrajectory_Goal) -> () { unsafe { control_msgs__action__FollowJointTrajectory_Goal__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Goal { Goal { trajectory : trajectory_msgs :: msg :: JointTrajectory :: from_native (& msg . trajectory) , multi_dof_trajectory : trajectory_msgs :: msg :: MultiDOFJointTrajectory :: from_native (& msg . multi_dof_trajectory) , path_tolerance : { let mut temp = Vec :: with_capacity (msg . path_tolerance . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . path_tolerance . data , msg . path_tolerance . size) } ; for s in slice { temp . push (control_msgs :: msg :: JointTolerance :: from_native (s)) ; } temp } , component_path_tolerance : { let mut temp = Vec :: with_capacity (msg . component_path_tolerance . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . component_path_tolerance . data , msg . component_path_tolerance . size) } ; for s in slice { temp . push (control_msgs :: msg :: JointComponentTolerance :: from_native (s)) ; } temp } , goal_tolerance : { let mut temp = Vec :: with_capacity (msg . goal_tolerance . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . goal_tolerance . data , msg . goal_tolerance . size) } ; for s in slice { temp . push (control_msgs :: msg :: JointTolerance :: from_native (s)) ; } temp } , component_goal_tolerance : { let mut temp = Vec :: with_capacity (msg . component_goal_tolerance . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . component_goal_tolerance . data , msg . component_goal_tolerance . size) } ; for s in slice { temp . push (control_msgs :: msg :: JointComponentTolerance :: from_native (s)) ; } temp } , goal_time_tolerance : builtin_interfaces :: msg :: Duration :: from_native (& msg . goal_time_tolerance) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . trajectory . copy_to_native (& mut msg . trajectory) ; self . multi_dof_trajectory . copy_to_native (& mut msg . multi_dof_trajectory) ; unsafe { control_msgs__msg__JointTolerance__Sequence__fini (& mut msg . path_tolerance) ; control_msgs__msg__JointTolerance__Sequence__init (& mut msg . path_tolerance , self . path_tolerance . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . path_tolerance . data , msg . path_tolerance . size) ; for (t , s) in slice . iter_mut () . zip (& self . path_tolerance) { s . copy_to_native (t) ; } } unsafe { control_msgs__msg__JointComponentTolerance__Sequence__fini (& mut msg . component_path_tolerance) ; control_msgs__msg__JointComponentTolerance__Sequence__init (& mut msg . component_path_tolerance , self . component_path_tolerance . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . component_path_tolerance . data , msg . component_path_tolerance . size) ; for (t , s) in slice . iter_mut () . zip (& self . component_path_tolerance) { s . copy_to_native (t) ; } } unsafe { control_msgs__msg__JointTolerance__Sequence__fini (& mut msg . goal_tolerance) ; control_msgs__msg__JointTolerance__Sequence__init (& mut msg . goal_tolerance , self . goal_tolerance . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . goal_tolerance . data , msg . goal_tolerance . size) ; for (t , s) in slice . iter_mut () . zip (& self . goal_tolerance) { s . copy_to_native (t) ; } } unsafe { control_msgs__msg__JointComponentTolerance__Sequence__fini (& mut msg . component_goal_tolerance) ; control_msgs__msg__JointComponentTolerance__Sequence__init (& mut msg . component_goal_tolerance , self . component_goal_tolerance . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . component_goal_tolerance . data , msg . component_goal_tolerance . size) ; for (t , s) in slice . iter_mut () . zip (& self . component_goal_tolerance) { s . copy_to_native (t) ; } } self . goal_time_tolerance . copy_to_native (& mut msg . goal_time_tolerance) ; } } impl Default for Goal { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Goal > :: new () ; Goal :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Result { pub error_code : i32 , pub error_string : std :: string :: String } impl WrappedTypesupport for Result { type CStruct = control_msgs__action__FollowJointTrajectory_Result ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__control_msgs__action__FollowJointTrajectory_Result () } } fn create_msg () -> * mut control_msgs__action__FollowJointTrajectory_Result { unsafe { control_msgs__action__FollowJointTrajectory_Result__create () } } fn destroy_msg (msg : * mut control_msgs__action__FollowJointTrajectory_Result) -> () { unsafe { control_msgs__action__FollowJointTrajectory_Result__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Result { Result { error_code : msg . error_code , error_string : msg . error_string . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . error_code = self . error_code ; msg . error_string . assign (& self . error_string) ; } } impl Default for Result { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Result > :: new () ; Result :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl Result { pub const GOAL_TOLERANCE_VIOLATED : _bindgen_ty_159 = control_msgs__action__FollowJointTrajectory_Result__GOAL_TOLERANCE_VIOLATED ; pub const INVALID_GOAL : _bindgen_ty_155 = control_msgs__action__FollowJointTrajectory_Result__INVALID_GOAL ; pub const INVALID_JOINTS : _bindgen_ty_156 = control_msgs__action__FollowJointTrajectory_Result__INVALID_JOINTS ; pub const OLD_HEADER_TIMESTAMP : _bindgen_ty_157 = control_msgs__action__FollowJointTrajectory_Result__OLD_HEADER_TIMESTAMP ; pub const PATH_TOLERANCE_VIOLATED : _bindgen_ty_158 = control_msgs__action__FollowJointTrajectory_Result__PATH_TOLERANCE_VIOLATED ; pub const SUCCESSFUL : _bindgen_ty_154 = control_msgs__action__FollowJointTrajectory_Result__SUCCESSFUL ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Feedback { pub header : std_msgs :: msg :: Header , pub joint_names : Vec < std :: string :: String > , pub desired : trajectory_msgs :: msg :: JointTrajectoryPoint , pub actual : trajectory_msgs :: msg :: JointTrajectoryPoint , pub error : trajectory_msgs :: msg :: JointTrajectoryPoint , pub multi_dof_joint_names : Vec < std :: string :: String > , pub multi_dof_desired : trajectory_msgs :: msg :: MultiDOFJointTrajectoryPoint , pub multi_dof_actual : trajectory_msgs :: msg :: MultiDOFJointTrajectoryPoint , pub multi_dof_error : trajectory_msgs :: msg :: MultiDOFJointTrajectoryPoint } impl WrappedTypesupport for Feedback { type CStruct = control_msgs__action__FollowJointTrajectory_Feedback ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__control_msgs__action__FollowJointTrajectory_Feedback () } } fn create_msg () -> * mut control_msgs__action__FollowJointTrajectory_Feedback { unsafe { control_msgs__action__FollowJointTrajectory_Feedback__create () } } fn destroy_msg (msg : * mut control_msgs__action__FollowJointTrajectory_Feedback) -> () { unsafe { control_msgs__action__FollowJointTrajectory_Feedback__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Feedback { Feedback { header : std_msgs :: msg :: Header :: from_native (& msg . header) , joint_names : msg . joint_names . to_vec () , desired : trajectory_msgs :: msg :: JointTrajectoryPoint :: from_native (& msg . desired) , actual : trajectory_msgs :: msg :: JointTrajectoryPoint :: from_native (& msg . actual) , error : trajectory_msgs :: msg :: JointTrajectoryPoint :: from_native (& msg . error) , multi_dof_joint_names : msg . multi_dof_joint_names . to_vec () , multi_dof_desired : trajectory_msgs :: msg :: MultiDOFJointTrajectoryPoint :: from_native (& msg . multi_dof_desired) , multi_dof_actual : trajectory_msgs :: msg :: MultiDOFJointTrajectoryPoint :: from_native (& msg . multi_dof_actual) , multi_dof_error : trajectory_msgs :: msg :: MultiDOFJointTrajectoryPoint :: from_native (& msg . multi_dof_error) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . joint_names . update (& self . joint_names) ; self . desired . copy_to_native (& mut msg . desired) ; self . actual . copy_to_native (& mut msg . actual) ; self . error . copy_to_native (& mut msg . error) ; msg . multi_dof_joint_names . update (& self . multi_dof_joint_names) ; self . multi_dof_desired . copy_to_native (& mut msg . multi_dof_desired) ; self . multi_dof_actual . copy_to_native (& mut msg . multi_dof_actual) ; self . multi_dof_error . copy_to_native (& mut msg . multi_dof_error) ; } } impl Default for Feedback { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Feedback > :: new () ; Feedback :: from_native (& msg_native) } } # [allow (non_snake_case)] pub mod SendGoal { use super :: super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__control_msgs__action__FollowJointTrajectory_SendGoal () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub goal_id : unique_identifier_msgs :: msg :: UUID , pub goal : control_msgs :: action :: FollowJointTrajectory :: Goal } impl WrappedTypesupport for Request { type CStruct = control_msgs__action__FollowJointTrajectory_SendGoal_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__control_msgs__action__FollowJointTrajectory_SendGoal_Request () } } fn create_msg () -> * mut control_msgs__action__FollowJointTrajectory_SendGoal_Request { unsafe { control_msgs__action__FollowJointTrajectory_SendGoal_Request__create () } } fn destroy_msg (msg : * mut control_msgs__action__FollowJointTrajectory_SendGoal_Request) -> () { unsafe { control_msgs__action__FollowJointTrajectory_SendGoal_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { goal_id : unique_identifier_msgs :: msg :: UUID :: from_native (& msg . goal_id) , goal : control_msgs :: action :: FollowJointTrajectory :: Goal :: from_native (& msg . goal) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . goal_id . copy_to_native (& mut msg . goal_id) ; self . goal . copy_to_native (& mut msg . goal) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub accepted : bool , pub stamp : builtin_interfaces :: msg :: Time } impl WrappedTypesupport for Response { type CStruct = control_msgs__action__FollowJointTrajectory_SendGoal_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__control_msgs__action__FollowJointTrajectory_SendGoal_Response () } } fn create_msg () -> * mut control_msgs__action__FollowJointTrajectory_SendGoal_Response { unsafe { control_msgs__action__FollowJointTrajectory_SendGoal_Response__create () } } fn destroy_msg (msg : * mut control_msgs__action__FollowJointTrajectory_SendGoal_Response) -> () { unsafe { control_msgs__action__FollowJointTrajectory_SendGoal_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { accepted : msg . accepted , stamp : builtin_interfaces :: msg :: Time :: from_native (& msg . stamp) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . accepted = self . accepted ; self . stamp . copy_to_native (& mut msg . stamp) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetResult { use super :: super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__control_msgs__action__FollowJointTrajectory_GetResult () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub goal_id : unique_identifier_msgs :: msg :: UUID } impl WrappedTypesupport for Request { type CStruct = control_msgs__action__FollowJointTrajectory_GetResult_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__control_msgs__action__FollowJointTrajectory_GetResult_Request () } } fn create_msg () -> * mut control_msgs__action__FollowJointTrajectory_GetResult_Request { unsafe { control_msgs__action__FollowJointTrajectory_GetResult_Request__create () } } fn destroy_msg (msg : * mut control_msgs__action__FollowJointTrajectory_GetResult_Request) -> () { unsafe { control_msgs__action__FollowJointTrajectory_GetResult_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { goal_id : unique_identifier_msgs :: msg :: UUID :: from_native (& msg . goal_id) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . goal_id . copy_to_native (& mut msg . goal_id) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub status : i8 , pub result : control_msgs :: action :: FollowJointTrajectory :: Result } impl WrappedTypesupport for Response { type CStruct = control_msgs__action__FollowJointTrajectory_GetResult_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__control_msgs__action__FollowJointTrajectory_GetResult_Response () } } fn create_msg () -> * mut control_msgs__action__FollowJointTrajectory_GetResult_Response { unsafe { control_msgs__action__FollowJointTrajectory_GetResult_Response__create () } } fn destroy_msg (msg : * mut control_msgs__action__FollowJointTrajectory_GetResult_Response) -> () { unsafe { control_msgs__action__FollowJointTrajectory_GetResult_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { status : msg . status , result : control_msgs :: action :: FollowJointTrajectory :: Result :: from_native (& msg . result) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . status = self . status ; self . result . copy_to_native (& mut msg . result) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct FeedbackMessage { pub goal_id : unique_identifier_msgs :: msg :: UUID , pub feedback : control_msgs :: action :: FollowJointTrajectory :: Feedback } impl WrappedTypesupport for FeedbackMessage { type CStruct = control_msgs__action__FollowJointTrajectory_FeedbackMessage ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__control_msgs__action__FollowJointTrajectory_FeedbackMessage () } } fn create_msg () -> * mut control_msgs__action__FollowJointTrajectory_FeedbackMessage { unsafe { control_msgs__action__FollowJointTrajectory_FeedbackMessage__create () } } fn destroy_msg (msg : * mut control_msgs__action__FollowJointTrajectory_FeedbackMessage) -> () { unsafe { control_msgs__action__FollowJointTrajectory_FeedbackMessage__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> FeedbackMessage { FeedbackMessage { goal_id : unique_identifier_msgs :: msg :: UUID :: from_native (& msg . goal_id) , feedback : control_msgs :: action :: FollowJointTrajectory :: Feedback :: from_native (& msg . feedback) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . goal_id . copy_to_native (& mut msg . goal_id) ; self . feedback . copy_to_native (& mut msg . feedback) ; } } impl Default for FeedbackMessage { fn default () -> Self { let msg_native = WrappedNativeMsg :: < FeedbackMessage > :: new () ; FeedbackMessage :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GripperCommand { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Action () ; impl WrappedActionTypeSupport for Action { type Goal = Goal ; type Result = Result ; type Feedback = Feedback ; type FeedbackMessage = FeedbackMessage ; type SendGoal = SendGoal :: Service ; type GetResult = GetResult :: Service ; fn get_ts () -> & 'static rosidl_action_type_support_t { unsafe { & * rosidl_typesupport_c__get_action_type_support_handle__control_msgs__action__GripperCommand () } } fn make_goal_request_msg (goal_id : unique_identifier_msgs :: msg :: UUID , goal : Goal) -> SendGoal :: Request { SendGoal :: Request { goal_id , goal } } fn make_goal_response_msg (accepted : bool , stamp : builtin_interfaces :: msg :: Time) -> SendGoal :: Response { SendGoal :: Response { accepted , stamp } } fn make_feedback_msg (goal_id : unique_identifier_msgs :: msg :: UUID , feedback : Feedback) -> FeedbackMessage { FeedbackMessage { goal_id , feedback } } fn make_result_request_msg (goal_id : unique_identifier_msgs :: msg :: UUID) -> GetResult :: Request { GetResult :: Request { goal_id , } } fn make_result_response_msg (status : i8 , result : Result) -> GetResult :: Response { GetResult :: Response { status , result , } } fn destructure_goal_request_msg (msg : SendGoal :: Request) -> (unique_identifier_msgs :: msg :: UUID , Goal) { (msg . goal_id , msg . goal) } fn destructure_goal_response_msg (msg : SendGoal :: Response) -> (bool , builtin_interfaces :: msg :: Time) { (msg . accepted , msg . stamp) } fn destructure_feedback_msg (msg : FeedbackMessage) -> (unique_identifier_msgs :: msg :: UUID , Feedback) { (msg . goal_id , msg . feedback) } fn destructure_result_response_msg (msg : GetResult :: Response) -> (i8 , Result) { (msg . status , msg . result) } fn destructure_result_request_msg (msg : GetResult :: Request) -> unique_identifier_msgs :: msg :: UUID { msg . goal_id } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Goal { pub command : control_msgs :: msg :: GripperCommand } impl WrappedTypesupport for Goal { type CStruct = control_msgs__action__GripperCommand_Goal ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__control_msgs__action__GripperCommand_Goal () } } fn create_msg () -> * mut control_msgs__action__GripperCommand_Goal { unsafe { control_msgs__action__GripperCommand_Goal__create () } } fn destroy_msg (msg : * mut control_msgs__action__GripperCommand_Goal) -> () { unsafe { control_msgs__action__GripperCommand_Goal__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Goal { Goal { command : control_msgs :: msg :: GripperCommand :: from_native (& msg . command) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . command . copy_to_native (& mut msg . command) ; } } impl Default for Goal { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Goal > :: new () ; Goal :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Result { pub position : f64 , pub effort : f64 , pub stalled : bool , pub reached_goal : bool } impl WrappedTypesupport for Result { type CStruct = control_msgs__action__GripperCommand_Result ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__control_msgs__action__GripperCommand_Result () } } fn create_msg () -> * mut control_msgs__action__GripperCommand_Result { unsafe { control_msgs__action__GripperCommand_Result__create () } } fn destroy_msg (msg : * mut control_msgs__action__GripperCommand_Result) -> () { unsafe { control_msgs__action__GripperCommand_Result__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Result { Result { position : msg . position , effort : msg . effort , stalled : msg . stalled , reached_goal : msg . reached_goal , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . position = self . position ; msg . effort = self . effort ; msg . stalled = self . stalled ; msg . reached_goal = self . reached_goal ; } } impl Default for Result { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Result > :: new () ; Result :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Feedback { pub position : f64 , pub effort : f64 , pub stalled : bool , pub reached_goal : bool } impl WrappedTypesupport for Feedback { type CStruct = control_msgs__action__GripperCommand_Feedback ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__control_msgs__action__GripperCommand_Feedback () } } fn create_msg () -> * mut control_msgs__action__GripperCommand_Feedback { unsafe { control_msgs__action__GripperCommand_Feedback__create () } } fn destroy_msg (msg : * mut control_msgs__action__GripperCommand_Feedback) -> () { unsafe { control_msgs__action__GripperCommand_Feedback__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Feedback { Feedback { position : msg . position , effort : msg . effort , stalled : msg . stalled , reached_goal : msg . reached_goal , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . position = self . position ; msg . effort = self . effort ; msg . stalled = self . stalled ; msg . reached_goal = self . reached_goal ; } } impl Default for Feedback { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Feedback > :: new () ; Feedback :: from_native (& msg_native) } } # [allow (non_snake_case)] pub mod SendGoal { use super :: super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__control_msgs__action__GripperCommand_SendGoal () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub goal_id : unique_identifier_msgs :: msg :: UUID , pub goal : control_msgs :: action :: GripperCommand :: Goal } impl WrappedTypesupport for Request { type CStruct = control_msgs__action__GripperCommand_SendGoal_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__control_msgs__action__GripperCommand_SendGoal_Request () } } fn create_msg () -> * mut control_msgs__action__GripperCommand_SendGoal_Request { unsafe { control_msgs__action__GripperCommand_SendGoal_Request__create () } } fn destroy_msg (msg : * mut control_msgs__action__GripperCommand_SendGoal_Request) -> () { unsafe { control_msgs__action__GripperCommand_SendGoal_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { goal_id : unique_identifier_msgs :: msg :: UUID :: from_native (& msg . goal_id) , goal : control_msgs :: action :: GripperCommand :: Goal :: from_native (& msg . goal) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . goal_id . copy_to_native (& mut msg . goal_id) ; self . goal . copy_to_native (& mut msg . goal) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub accepted : bool , pub stamp : builtin_interfaces :: msg :: Time } impl WrappedTypesupport for Response { type CStruct = control_msgs__action__GripperCommand_SendGoal_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__control_msgs__action__GripperCommand_SendGoal_Response () } } fn create_msg () -> * mut control_msgs__action__GripperCommand_SendGoal_Response { unsafe { control_msgs__action__GripperCommand_SendGoal_Response__create () } } fn destroy_msg (msg : * mut control_msgs__action__GripperCommand_SendGoal_Response) -> () { unsafe { control_msgs__action__GripperCommand_SendGoal_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { accepted : msg . accepted , stamp : builtin_interfaces :: msg :: Time :: from_native (& msg . stamp) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . accepted = self . accepted ; self . stamp . copy_to_native (& mut msg . stamp) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetResult { use super :: super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__control_msgs__action__GripperCommand_GetResult () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub goal_id : unique_identifier_msgs :: msg :: UUID } impl WrappedTypesupport for Request { type CStruct = control_msgs__action__GripperCommand_GetResult_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__control_msgs__action__GripperCommand_GetResult_Request () } } fn create_msg () -> * mut control_msgs__action__GripperCommand_GetResult_Request { unsafe { control_msgs__action__GripperCommand_GetResult_Request__create () } } fn destroy_msg (msg : * mut control_msgs__action__GripperCommand_GetResult_Request) -> () { unsafe { control_msgs__action__GripperCommand_GetResult_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { goal_id : unique_identifier_msgs :: msg :: UUID :: from_native (& msg . goal_id) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . goal_id . copy_to_native (& mut msg . goal_id) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub status : i8 , pub result : control_msgs :: action :: GripperCommand :: Result } impl WrappedTypesupport for Response { type CStruct = control_msgs__action__GripperCommand_GetResult_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__control_msgs__action__GripperCommand_GetResult_Response () } } fn create_msg () -> * mut control_msgs__action__GripperCommand_GetResult_Response { unsafe { control_msgs__action__GripperCommand_GetResult_Response__create () } } fn destroy_msg (msg : * mut control_msgs__action__GripperCommand_GetResult_Response) -> () { unsafe { control_msgs__action__GripperCommand_GetResult_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { status : msg . status , result : control_msgs :: action :: GripperCommand :: Result :: from_native (& msg . result) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . status = self . status ; self . result . copy_to_native (& mut msg . result) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct FeedbackMessage { pub goal_id : unique_identifier_msgs :: msg :: UUID , pub feedback : control_msgs :: action :: GripperCommand :: Feedback } impl WrappedTypesupport for FeedbackMessage { type CStruct = control_msgs__action__GripperCommand_FeedbackMessage ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__control_msgs__action__GripperCommand_FeedbackMessage () } } fn create_msg () -> * mut control_msgs__action__GripperCommand_FeedbackMessage { unsafe { control_msgs__action__GripperCommand_FeedbackMessage__create () } } fn destroy_msg (msg : * mut control_msgs__action__GripperCommand_FeedbackMessage) -> () { unsafe { control_msgs__action__GripperCommand_FeedbackMessage__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> FeedbackMessage { FeedbackMessage { goal_id : unique_identifier_msgs :: msg :: UUID :: from_native (& msg . goal_id) , feedback : control_msgs :: action :: GripperCommand :: Feedback :: from_native (& msg . feedback) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . goal_id . copy_to_native (& mut msg . goal_id) ; self . feedback . copy_to_native (& mut msg . feedback) ; } } impl Default for FeedbackMessage { fn default () -> Self { let msg_native = WrappedNativeMsg :: < FeedbackMessage > :: new () ; FeedbackMessage :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod JointTrajectory { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Action () ; impl WrappedActionTypeSupport for Action { type Goal = Goal ; type Result = Result ; type Feedback = Feedback ; type FeedbackMessage = FeedbackMessage ; type SendGoal = SendGoal :: Service ; type GetResult = GetResult :: Service ; fn get_ts () -> & 'static rosidl_action_type_support_t { unsafe { & * rosidl_typesupport_c__get_action_type_support_handle__control_msgs__action__JointTrajectory () } } fn make_goal_request_msg (goal_id : unique_identifier_msgs :: msg :: UUID , goal : Goal) -> SendGoal :: Request { SendGoal :: Request { goal_id , goal } } fn make_goal_response_msg (accepted : bool , stamp : builtin_interfaces :: msg :: Time) -> SendGoal :: Response { SendGoal :: Response { accepted , stamp } } fn make_feedback_msg (goal_id : unique_identifier_msgs :: msg :: UUID , feedback : Feedback) -> FeedbackMessage { FeedbackMessage { goal_id , feedback } } fn make_result_request_msg (goal_id : unique_identifier_msgs :: msg :: UUID) -> GetResult :: Request { GetResult :: Request { goal_id , } } fn make_result_response_msg (status : i8 , result : Result) -> GetResult :: Response { GetResult :: Response { status , result , } } fn destructure_goal_request_msg (msg : SendGoal :: Request) -> (unique_identifier_msgs :: msg :: UUID , Goal) { (msg . goal_id , msg . goal) } fn destructure_goal_response_msg (msg : SendGoal :: Response) -> (bool , builtin_interfaces :: msg :: Time) { (msg . accepted , msg . stamp) } fn destructure_feedback_msg (msg : FeedbackMessage) -> (unique_identifier_msgs :: msg :: UUID , Feedback) { (msg . goal_id , msg . feedback) } fn destructure_result_response_msg (msg : GetResult :: Response) -> (i8 , Result) { (msg . status , msg . result) } fn destructure_result_request_msg (msg : GetResult :: Request) -> unique_identifier_msgs :: msg :: UUID { msg . goal_id } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Goal { pub trajectory : trajectory_msgs :: msg :: JointTrajectory } impl WrappedTypesupport for Goal { type CStruct = control_msgs__action__JointTrajectory_Goal ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__control_msgs__action__JointTrajectory_Goal () } } fn create_msg () -> * mut control_msgs__action__JointTrajectory_Goal { unsafe { control_msgs__action__JointTrajectory_Goal__create () } } fn destroy_msg (msg : * mut control_msgs__action__JointTrajectory_Goal) -> () { unsafe { control_msgs__action__JointTrajectory_Goal__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Goal { Goal { trajectory : trajectory_msgs :: msg :: JointTrajectory :: from_native (& msg . trajectory) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . trajectory . copy_to_native (& mut msg . trajectory) ; } } impl Default for Goal { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Goal > :: new () ; Goal :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Result { } impl WrappedTypesupport for Result { type CStruct = control_msgs__action__JointTrajectory_Result ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__control_msgs__action__JointTrajectory_Result () } } fn create_msg () -> * mut control_msgs__action__JointTrajectory_Result { unsafe { control_msgs__action__JointTrajectory_Result__create () } } fn destroy_msg (msg : * mut control_msgs__action__JointTrajectory_Result) -> () { unsafe { control_msgs__action__JointTrajectory_Result__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Result { Result { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Result { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Result > :: new () ; Result :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Feedback { } impl WrappedTypesupport for Feedback { type CStruct = control_msgs__action__JointTrajectory_Feedback ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__control_msgs__action__JointTrajectory_Feedback () } } fn create_msg () -> * mut control_msgs__action__JointTrajectory_Feedback { unsafe { control_msgs__action__JointTrajectory_Feedback__create () } } fn destroy_msg (msg : * mut control_msgs__action__JointTrajectory_Feedback) -> () { unsafe { control_msgs__action__JointTrajectory_Feedback__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Feedback { Feedback { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Feedback { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Feedback > :: new () ; Feedback :: from_native (& msg_native) } } # [allow (non_snake_case)] pub mod SendGoal { use super :: super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__control_msgs__action__JointTrajectory_SendGoal () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub goal_id : unique_identifier_msgs :: msg :: UUID , pub goal : control_msgs :: action :: JointTrajectory :: Goal } impl WrappedTypesupport for Request { type CStruct = control_msgs__action__JointTrajectory_SendGoal_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__control_msgs__action__JointTrajectory_SendGoal_Request () } } fn create_msg () -> * mut control_msgs__action__JointTrajectory_SendGoal_Request { unsafe { control_msgs__action__JointTrajectory_SendGoal_Request__create () } } fn destroy_msg (msg : * mut control_msgs__action__JointTrajectory_SendGoal_Request) -> () { unsafe { control_msgs__action__JointTrajectory_SendGoal_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { goal_id : unique_identifier_msgs :: msg :: UUID :: from_native (& msg . goal_id) , goal : control_msgs :: action :: JointTrajectory :: Goal :: from_native (& msg . goal) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . goal_id . copy_to_native (& mut msg . goal_id) ; self . goal . copy_to_native (& mut msg . goal) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub accepted : bool , pub stamp : builtin_interfaces :: msg :: Time } impl WrappedTypesupport for Response { type CStruct = control_msgs__action__JointTrajectory_SendGoal_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__control_msgs__action__JointTrajectory_SendGoal_Response () } } fn create_msg () -> * mut control_msgs__action__JointTrajectory_SendGoal_Response { unsafe { control_msgs__action__JointTrajectory_SendGoal_Response__create () } } fn destroy_msg (msg : * mut control_msgs__action__JointTrajectory_SendGoal_Response) -> () { unsafe { control_msgs__action__JointTrajectory_SendGoal_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { accepted : msg . accepted , stamp : builtin_interfaces :: msg :: Time :: from_native (& msg . stamp) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . accepted = self . accepted ; self . stamp . copy_to_native (& mut msg . stamp) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetResult { use super :: super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__control_msgs__action__JointTrajectory_GetResult () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub goal_id : unique_identifier_msgs :: msg :: UUID } impl WrappedTypesupport for Request { type CStruct = control_msgs__action__JointTrajectory_GetResult_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__control_msgs__action__JointTrajectory_GetResult_Request () } } fn create_msg () -> * mut control_msgs__action__JointTrajectory_GetResult_Request { unsafe { control_msgs__action__JointTrajectory_GetResult_Request__create () } } fn destroy_msg (msg : * mut control_msgs__action__JointTrajectory_GetResult_Request) -> () { unsafe { control_msgs__action__JointTrajectory_GetResult_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { goal_id : unique_identifier_msgs :: msg :: UUID :: from_native (& msg . goal_id) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . goal_id . copy_to_native (& mut msg . goal_id) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub status : i8 , pub result : control_msgs :: action :: JointTrajectory :: Result } impl WrappedTypesupport for Response { type CStruct = control_msgs__action__JointTrajectory_GetResult_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__control_msgs__action__JointTrajectory_GetResult_Response () } } fn create_msg () -> * mut control_msgs__action__JointTrajectory_GetResult_Response { unsafe { control_msgs__action__JointTrajectory_GetResult_Response__create () } } fn destroy_msg (msg : * mut control_msgs__action__JointTrajectory_GetResult_Response) -> () { unsafe { control_msgs__action__JointTrajectory_GetResult_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { status : msg . status , result : control_msgs :: action :: JointTrajectory :: Result :: from_native (& msg . result) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . status = self . status ; self . result . copy_to_native (& mut msg . result) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct FeedbackMessage { pub goal_id : unique_identifier_msgs :: msg :: UUID , pub feedback : control_msgs :: action :: JointTrajectory :: Feedback } impl WrappedTypesupport for FeedbackMessage { type CStruct = control_msgs__action__JointTrajectory_FeedbackMessage ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__control_msgs__action__JointTrajectory_FeedbackMessage () } } fn create_msg () -> * mut control_msgs__action__JointTrajectory_FeedbackMessage { unsafe { control_msgs__action__JointTrajectory_FeedbackMessage__create () } } fn destroy_msg (msg : * mut control_msgs__action__JointTrajectory_FeedbackMessage) -> () { unsafe { control_msgs__action__JointTrajectory_FeedbackMessage__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> FeedbackMessage { FeedbackMessage { goal_id : unique_identifier_msgs :: msg :: UUID :: from_native (& msg . goal_id) , feedback : control_msgs :: action :: JointTrajectory :: Feedback :: from_native (& msg . feedback) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . goal_id . copy_to_native (& mut msg . goal_id) ; self . feedback . copy_to_native (& mut msg . feedback) ; } } impl Default for FeedbackMessage { fn default () -> Self { let msg_native = WrappedNativeMsg :: < FeedbackMessage > :: new () ; FeedbackMessage :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod PointHead { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Action () ; impl WrappedActionTypeSupport for Action { type Goal = Goal ; type Result = Result ; type Feedback = Feedback ; type FeedbackMessage = FeedbackMessage ; type SendGoal = SendGoal :: Service ; type GetResult = GetResult :: Service ; fn get_ts () -> & 'static rosidl_action_type_support_t { unsafe { & * rosidl_typesupport_c__get_action_type_support_handle__control_msgs__action__PointHead () } } fn make_goal_request_msg (goal_id : unique_identifier_msgs :: msg :: UUID , goal : Goal) -> SendGoal :: Request { SendGoal :: Request { goal_id , goal } } fn make_goal_response_msg (accepted : bool , stamp : builtin_interfaces :: msg :: Time) -> SendGoal :: Response { SendGoal :: Response { accepted , stamp } } fn make_feedback_msg (goal_id : unique_identifier_msgs :: msg :: UUID , feedback : Feedback) -> FeedbackMessage { FeedbackMessage { goal_id , feedback } } fn make_result_request_msg (goal_id : unique_identifier_msgs :: msg :: UUID) -> GetResult :: Request { GetResult :: Request { goal_id , } } fn make_result_response_msg (status : i8 , result : Result) -> GetResult :: Response { GetResult :: Response { status , result , } } fn destructure_goal_request_msg (msg : SendGoal :: Request) -> (unique_identifier_msgs :: msg :: UUID , Goal) { (msg . goal_id , msg . goal) } fn destructure_goal_response_msg (msg : SendGoal :: Response) -> (bool , builtin_interfaces :: msg :: Time) { (msg . accepted , msg . stamp) } fn destructure_feedback_msg (msg : FeedbackMessage) -> (unique_identifier_msgs :: msg :: UUID , Feedback) { (msg . goal_id , msg . feedback) } fn destructure_result_response_msg (msg : GetResult :: Response) -> (i8 , Result) { (msg . status , msg . result) } fn destructure_result_request_msg (msg : GetResult :: Request) -> unique_identifier_msgs :: msg :: UUID { msg . goal_id } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Goal { pub target : geometry_msgs :: msg :: PointStamped , pub pointing_axis : geometry_msgs :: msg :: Vector3 , pub pointing_frame : std :: string :: String , pub min_duration : builtin_interfaces :: msg :: Duration , pub max_velocity : f64 } impl WrappedTypesupport for Goal { type CStruct = control_msgs__action__PointHead_Goal ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__control_msgs__action__PointHead_Goal () } } fn create_msg () -> * mut control_msgs__action__PointHead_Goal { unsafe { control_msgs__action__PointHead_Goal__create () } } fn destroy_msg (msg : * mut control_msgs__action__PointHead_Goal) -> () { unsafe { control_msgs__action__PointHead_Goal__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Goal { Goal { target : geometry_msgs :: msg :: PointStamped :: from_native (& msg . target) , pointing_axis : geometry_msgs :: msg :: Vector3 :: from_native (& msg . pointing_axis) , pointing_frame : msg . pointing_frame . to_str () . to_owned () , min_duration : builtin_interfaces :: msg :: Duration :: from_native (& msg . min_duration) , max_velocity : msg . max_velocity , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . target . copy_to_native (& mut msg . target) ; self . pointing_axis . copy_to_native (& mut msg . pointing_axis) ; msg . pointing_frame . assign (& self . pointing_frame) ; self . min_duration . copy_to_native (& mut msg . min_duration) ; msg . max_velocity = self . max_velocity ; } } impl Default for Goal { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Goal > :: new () ; Goal :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Result { } impl WrappedTypesupport for Result { type CStruct = control_msgs__action__PointHead_Result ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__control_msgs__action__PointHead_Result () } } fn create_msg () -> * mut control_msgs__action__PointHead_Result { unsafe { control_msgs__action__PointHead_Result__create () } } fn destroy_msg (msg : * mut control_msgs__action__PointHead_Result) -> () { unsafe { control_msgs__action__PointHead_Result__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Result { Result { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Result { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Result > :: new () ; Result :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Feedback { pub pointing_angle_error : f64 } impl WrappedTypesupport for Feedback { type CStruct = control_msgs__action__PointHead_Feedback ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__control_msgs__action__PointHead_Feedback () } } fn create_msg () -> * mut control_msgs__action__PointHead_Feedback { unsafe { control_msgs__action__PointHead_Feedback__create () } } fn destroy_msg (msg : * mut control_msgs__action__PointHead_Feedback) -> () { unsafe { control_msgs__action__PointHead_Feedback__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Feedback { Feedback { pointing_angle_error : msg . pointing_angle_error , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . pointing_angle_error = self . pointing_angle_error ; } } impl Default for Feedback { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Feedback > :: new () ; Feedback :: from_native (& msg_native) } } # [allow (non_snake_case)] pub mod SendGoal { use super :: super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__control_msgs__action__PointHead_SendGoal () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub goal_id : unique_identifier_msgs :: msg :: UUID , pub goal : control_msgs :: action :: PointHead :: Goal } impl WrappedTypesupport for Request { type CStruct = control_msgs__action__PointHead_SendGoal_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__control_msgs__action__PointHead_SendGoal_Request () } } fn create_msg () -> * mut control_msgs__action__PointHead_SendGoal_Request { unsafe { control_msgs__action__PointHead_SendGoal_Request__create () } } fn destroy_msg (msg : * mut control_msgs__action__PointHead_SendGoal_Request) -> () { unsafe { control_msgs__action__PointHead_SendGoal_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { goal_id : unique_identifier_msgs :: msg :: UUID :: from_native (& msg . goal_id) , goal : control_msgs :: action :: PointHead :: Goal :: from_native (& msg . goal) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . goal_id . copy_to_native (& mut msg . goal_id) ; self . goal . copy_to_native (& mut msg . goal) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub accepted : bool , pub stamp : builtin_interfaces :: msg :: Time } impl WrappedTypesupport for Response { type CStruct = control_msgs__action__PointHead_SendGoal_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__control_msgs__action__PointHead_SendGoal_Response () } } fn create_msg () -> * mut control_msgs__action__PointHead_SendGoal_Response { unsafe { control_msgs__action__PointHead_SendGoal_Response__create () } } fn destroy_msg (msg : * mut control_msgs__action__PointHead_SendGoal_Response) -> () { unsafe { control_msgs__action__PointHead_SendGoal_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { accepted : msg . accepted , stamp : builtin_interfaces :: msg :: Time :: from_native (& msg . stamp) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . accepted = self . accepted ; self . stamp . copy_to_native (& mut msg . stamp) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetResult { use super :: super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__control_msgs__action__PointHead_GetResult () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub goal_id : unique_identifier_msgs :: msg :: UUID } impl WrappedTypesupport for Request { type CStruct = control_msgs__action__PointHead_GetResult_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__control_msgs__action__PointHead_GetResult_Request () } } fn create_msg () -> * mut control_msgs__action__PointHead_GetResult_Request { unsafe { control_msgs__action__PointHead_GetResult_Request__create () } } fn destroy_msg (msg : * mut control_msgs__action__PointHead_GetResult_Request) -> () { unsafe { control_msgs__action__PointHead_GetResult_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { goal_id : unique_identifier_msgs :: msg :: UUID :: from_native (& msg . goal_id) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . goal_id . copy_to_native (& mut msg . goal_id) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub status : i8 , pub result : control_msgs :: action :: PointHead :: Result } impl WrappedTypesupport for Response { type CStruct = control_msgs__action__PointHead_GetResult_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__control_msgs__action__PointHead_GetResult_Response () } } fn create_msg () -> * mut control_msgs__action__PointHead_GetResult_Response { unsafe { control_msgs__action__PointHead_GetResult_Response__create () } } fn destroy_msg (msg : * mut control_msgs__action__PointHead_GetResult_Response) -> () { unsafe { control_msgs__action__PointHead_GetResult_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { status : msg . status , result : control_msgs :: action :: PointHead :: Result :: from_native (& msg . result) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . status = self . status ; self . result . copy_to_native (& mut msg . result) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct FeedbackMessage { pub goal_id : unique_identifier_msgs :: msg :: UUID , pub feedback : control_msgs :: action :: PointHead :: Feedback } impl WrappedTypesupport for FeedbackMessage { type CStruct = control_msgs__action__PointHead_FeedbackMessage ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__control_msgs__action__PointHead_FeedbackMessage () } } fn create_msg () -> * mut control_msgs__action__PointHead_FeedbackMessage { unsafe { control_msgs__action__PointHead_FeedbackMessage__create () } } fn destroy_msg (msg : * mut control_msgs__action__PointHead_FeedbackMessage) -> () { unsafe { control_msgs__action__PointHead_FeedbackMessage__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> FeedbackMessage { FeedbackMessage { goal_id : unique_identifier_msgs :: msg :: UUID :: from_native (& msg . goal_id) , feedback : control_msgs :: action :: PointHead :: Feedback :: from_native (& msg . feedback) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . goal_id . copy_to_native (& mut msg . goal_id) ; self . feedback . copy_to_native (& mut msg . feedback) ; } } impl Default for FeedbackMessage { fn default () -> Self { let msg_native = WrappedNativeMsg :: < FeedbackMessage > :: new () ; FeedbackMessage :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod SingleJointPosition { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Action () ; impl WrappedActionTypeSupport for Action { type Goal = Goal ; type Result = Result ; type Feedback = Feedback ; type FeedbackMessage = FeedbackMessage ; type SendGoal = SendGoal :: Service ; type GetResult = GetResult :: Service ; fn get_ts () -> & 'static rosidl_action_type_support_t { unsafe { & * rosidl_typesupport_c__get_action_type_support_handle__control_msgs__action__SingleJointPosition () } } fn make_goal_request_msg (goal_id : unique_identifier_msgs :: msg :: UUID , goal : Goal) -> SendGoal :: Request { SendGoal :: Request { goal_id , goal } } fn make_goal_response_msg (accepted : bool , stamp : builtin_interfaces :: msg :: Time) -> SendGoal :: Response { SendGoal :: Response { accepted , stamp } } fn make_feedback_msg (goal_id : unique_identifier_msgs :: msg :: UUID , feedback : Feedback) -> FeedbackMessage { FeedbackMessage { goal_id , feedback } } fn make_result_request_msg (goal_id : unique_identifier_msgs :: msg :: UUID) -> GetResult :: Request { GetResult :: Request { goal_id , } } fn make_result_response_msg (status : i8 , result : Result) -> GetResult :: Response { GetResult :: Response { status , result , } } fn destructure_goal_request_msg (msg : SendGoal :: Request) -> (unique_identifier_msgs :: msg :: UUID , Goal) { (msg . goal_id , msg . goal) } fn destructure_goal_response_msg (msg : SendGoal :: Response) -> (bool , builtin_interfaces :: msg :: Time) { (msg . accepted , msg . stamp) } fn destructure_feedback_msg (msg : FeedbackMessage) -> (unique_identifier_msgs :: msg :: UUID , Feedback) { (msg . goal_id , msg . feedback) } fn destructure_result_response_msg (msg : GetResult :: Response) -> (i8 , Result) { (msg . status , msg . result) } fn destructure_result_request_msg (msg : GetResult :: Request) -> unique_identifier_msgs :: msg :: UUID { msg . goal_id } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Goal { pub position : f64 , pub min_duration : builtin_interfaces :: msg :: Duration , pub max_velocity : f64 } impl WrappedTypesupport for Goal { type CStruct = control_msgs__action__SingleJointPosition_Goal ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__control_msgs__action__SingleJointPosition_Goal () } } fn create_msg () -> * mut control_msgs__action__SingleJointPosition_Goal { unsafe { control_msgs__action__SingleJointPosition_Goal__create () } } fn destroy_msg (msg : * mut control_msgs__action__SingleJointPosition_Goal) -> () { unsafe { control_msgs__action__SingleJointPosition_Goal__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Goal { Goal { position : msg . position , min_duration : builtin_interfaces :: msg :: Duration :: from_native (& msg . min_duration) , max_velocity : msg . max_velocity , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . position = self . position ; self . min_duration . copy_to_native (& mut msg . min_duration) ; msg . max_velocity = self . max_velocity ; } } impl Default for Goal { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Goal > :: new () ; Goal :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Result { } impl WrappedTypesupport for Result { type CStruct = control_msgs__action__SingleJointPosition_Result ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__control_msgs__action__SingleJointPosition_Result () } } fn create_msg () -> * mut control_msgs__action__SingleJointPosition_Result { unsafe { control_msgs__action__SingleJointPosition_Result__create () } } fn destroy_msg (msg : * mut control_msgs__action__SingleJointPosition_Result) -> () { unsafe { control_msgs__action__SingleJointPosition_Result__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Result { Result { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Result { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Result > :: new () ; Result :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Feedback { pub header : std_msgs :: msg :: Header , pub position : f64 , pub velocity : f64 , pub error : f64 } impl WrappedTypesupport for Feedback { type CStruct = control_msgs__action__SingleJointPosition_Feedback ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__control_msgs__action__SingleJointPosition_Feedback () } } fn create_msg () -> * mut control_msgs__action__SingleJointPosition_Feedback { unsafe { control_msgs__action__SingleJointPosition_Feedback__create () } } fn destroy_msg (msg : * mut control_msgs__action__SingleJointPosition_Feedback) -> () { unsafe { control_msgs__action__SingleJointPosition_Feedback__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Feedback { Feedback { header : std_msgs :: msg :: Header :: from_native (& msg . header) , position : msg . position , velocity : msg . velocity , error : msg . error , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . position = self . position ; msg . velocity = self . velocity ; msg . error = self . error ; } } impl Default for Feedback { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Feedback > :: new () ; Feedback :: from_native (& msg_native) } } # [allow (non_snake_case)] pub mod SendGoal { use super :: super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__control_msgs__action__SingleJointPosition_SendGoal () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub goal_id : unique_identifier_msgs :: msg :: UUID , pub goal : control_msgs :: action :: SingleJointPosition :: Goal } impl WrappedTypesupport for Request { type CStruct = control_msgs__action__SingleJointPosition_SendGoal_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__control_msgs__action__SingleJointPosition_SendGoal_Request () } } fn create_msg () -> * mut control_msgs__action__SingleJointPosition_SendGoal_Request { unsafe { control_msgs__action__SingleJointPosition_SendGoal_Request__create () } } fn destroy_msg (msg : * mut control_msgs__action__SingleJointPosition_SendGoal_Request) -> () { unsafe { control_msgs__action__SingleJointPosition_SendGoal_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { goal_id : unique_identifier_msgs :: msg :: UUID :: from_native (& msg . goal_id) , goal : control_msgs :: action :: SingleJointPosition :: Goal :: from_native (& msg . goal) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . goal_id . copy_to_native (& mut msg . goal_id) ; self . goal . copy_to_native (& mut msg . goal) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub accepted : bool , pub stamp : builtin_interfaces :: msg :: Time } impl WrappedTypesupport for Response { type CStruct = control_msgs__action__SingleJointPosition_SendGoal_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__control_msgs__action__SingleJointPosition_SendGoal_Response () } } fn create_msg () -> * mut control_msgs__action__SingleJointPosition_SendGoal_Response { unsafe { control_msgs__action__SingleJointPosition_SendGoal_Response__create () } } fn destroy_msg (msg : * mut control_msgs__action__SingleJointPosition_SendGoal_Response) -> () { unsafe { control_msgs__action__SingleJointPosition_SendGoal_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { accepted : msg . accepted , stamp : builtin_interfaces :: msg :: Time :: from_native (& msg . stamp) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . accepted = self . accepted ; self . stamp . copy_to_native (& mut msg . stamp) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetResult { use super :: super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__control_msgs__action__SingleJointPosition_GetResult () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub goal_id : unique_identifier_msgs :: msg :: UUID } impl WrappedTypesupport for Request { type CStruct = control_msgs__action__SingleJointPosition_GetResult_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__control_msgs__action__SingleJointPosition_GetResult_Request () } } fn create_msg () -> * mut control_msgs__action__SingleJointPosition_GetResult_Request { unsafe { control_msgs__action__SingleJointPosition_GetResult_Request__create () } } fn destroy_msg (msg : * mut control_msgs__action__SingleJointPosition_GetResult_Request) -> () { unsafe { control_msgs__action__SingleJointPosition_GetResult_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { goal_id : unique_identifier_msgs :: msg :: UUID :: from_native (& msg . goal_id) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . goal_id . copy_to_native (& mut msg . goal_id) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub status : i8 , pub result : control_msgs :: action :: SingleJointPosition :: Result } impl WrappedTypesupport for Response { type CStruct = control_msgs__action__SingleJointPosition_GetResult_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__control_msgs__action__SingleJointPosition_GetResult_Response () } } fn create_msg () -> * mut control_msgs__action__SingleJointPosition_GetResult_Response { unsafe { control_msgs__action__SingleJointPosition_GetResult_Response__create () } } fn destroy_msg (msg : * mut control_msgs__action__SingleJointPosition_GetResult_Response) -> () { unsafe { control_msgs__action__SingleJointPosition_GetResult_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { status : msg . status , result : control_msgs :: action :: SingleJointPosition :: Result :: from_native (& msg . result) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . status = self . status ; self . result . copy_to_native (& mut msg . result) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct FeedbackMessage { pub goal_id : unique_identifier_msgs :: msg :: UUID , pub feedback : control_msgs :: action :: SingleJointPosition :: Feedback } impl WrappedTypesupport for FeedbackMessage { type CStruct = control_msgs__action__SingleJointPosition_FeedbackMessage ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__control_msgs__action__SingleJointPosition_FeedbackMessage () } } fn create_msg () -> * mut control_msgs__action__SingleJointPosition_FeedbackMessage { unsafe { control_msgs__action__SingleJointPosition_FeedbackMessage__create () } } fn destroy_msg (msg : * mut control_msgs__action__SingleJointPosition_FeedbackMessage) -> () { unsafe { control_msgs__action__SingleJointPosition_FeedbackMessage__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> FeedbackMessage { FeedbackMessage { goal_id : unique_identifier_msgs :: msg :: UUID :: from_native (& msg . goal_id) , feedback : control_msgs :: action :: SingleJointPosition :: Feedback :: from_native (& msg . feedback) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . goal_id . copy_to_native (& mut msg . goal_id) ; self . feedback . copy_to_native (& mut msg . feedback) ; } } impl Default for FeedbackMessage { fn default () -> Self { let msg_native = WrappedNativeMsg :: < FeedbackMessage > :: new () ; FeedbackMessage :: from_native (& msg_native) } } } } pub mod msg { use super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct DynamicJointState { pub header : std_msgs :: msg :: Header , pub joint_names : Vec < std :: string :: String > , pub interface_values : Vec < control_msgs :: msg :: InterfaceValue > } impl WrappedTypesupport for DynamicJointState { type CStruct = control_msgs__msg__DynamicJointState ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__control_msgs__msg__DynamicJointState () } } fn create_msg () -> * mut control_msgs__msg__DynamicJointState { unsafe { control_msgs__msg__DynamicJointState__create () } } fn destroy_msg (msg : * mut control_msgs__msg__DynamicJointState) -> () { unsafe { control_msgs__msg__DynamicJointState__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> DynamicJointState { DynamicJointState { header : std_msgs :: msg :: Header :: from_native (& msg . header) , joint_names : msg . joint_names . to_vec () , interface_values : { let mut temp = Vec :: with_capacity (msg . interface_values . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . interface_values . data , msg . interface_values . size) } ; for s in slice { temp . push (control_msgs :: msg :: InterfaceValue :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . joint_names . update (& self . joint_names) ; unsafe { control_msgs__msg__InterfaceValue__Sequence__fini (& mut msg . interface_values) ; control_msgs__msg__InterfaceValue__Sequence__init (& mut msg . interface_values , self . interface_values . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . interface_values . data , msg . interface_values . size) ; for (t , s) in slice . iter_mut () . zip (& self . interface_values) { s . copy_to_native (t) ; } } } } impl Default for DynamicJointState { fn default () -> Self { let msg_native = WrappedNativeMsg :: < DynamicJointState > :: new () ; DynamicJointState :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct GripperCommand { pub position : f64 , pub max_effort : f64 } impl WrappedTypesupport for GripperCommand { type CStruct = control_msgs__msg__GripperCommand ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__control_msgs__msg__GripperCommand () } } fn create_msg () -> * mut control_msgs__msg__GripperCommand { unsafe { control_msgs__msg__GripperCommand__create () } } fn destroy_msg (msg : * mut control_msgs__msg__GripperCommand) -> () { unsafe { control_msgs__msg__GripperCommand__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> GripperCommand { GripperCommand { position : msg . position , max_effort : msg . max_effort , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . position = self . position ; msg . max_effort = self . max_effort ; } } impl Default for GripperCommand { fn default () -> Self { let msg_native = WrappedNativeMsg :: < GripperCommand > :: new () ; GripperCommand :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct InterfaceValue { pub interface_names : Vec < std :: string :: String > , pub values : Vec < f64 > } impl WrappedTypesupport for InterfaceValue { type CStruct = control_msgs__msg__InterfaceValue ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__control_msgs__msg__InterfaceValue () } } fn create_msg () -> * mut control_msgs__msg__InterfaceValue { unsafe { control_msgs__msg__InterfaceValue__create () } } fn destroy_msg (msg : * mut control_msgs__msg__InterfaceValue) -> () { unsafe { control_msgs__msg__InterfaceValue__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> InterfaceValue { InterfaceValue { interface_names : msg . interface_names . to_vec () , values : msg . values . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . interface_names . update (& self . interface_names) ; msg . values . update (& self . values) ; } } impl Default for InterfaceValue { fn default () -> Self { let msg_native = WrappedNativeMsg :: < InterfaceValue > :: new () ; InterfaceValue :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct JointComponentTolerance { pub joint_name : std :: string :: String , pub component : u16 , pub position : f64 , pub velocity : f64 , pub acceleration : f64 } impl WrappedTypesupport for JointComponentTolerance { type CStruct = control_msgs__msg__JointComponentTolerance ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__control_msgs__msg__JointComponentTolerance () } } fn create_msg () -> * mut control_msgs__msg__JointComponentTolerance { unsafe { control_msgs__msg__JointComponentTolerance__create () } } fn destroy_msg (msg : * mut control_msgs__msg__JointComponentTolerance) -> () { unsafe { control_msgs__msg__JointComponentTolerance__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> JointComponentTolerance { JointComponentTolerance { joint_name : msg . joint_name . to_str () . to_owned () , component : msg . component , position : msg . position , velocity : msg . velocity , acceleration : msg . acceleration , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . joint_name . assign (& self . joint_name) ; msg . component = self . component ; msg . position = self . position ; msg . velocity = self . velocity ; msg . acceleration = self . acceleration ; } } impl Default for JointComponentTolerance { fn default () -> Self { let msg_native = WrappedNativeMsg :: < JointComponentTolerance > :: new () ; JointComponentTolerance :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl JointComponentTolerance { pub const ROTATION : _bindgen_ty_153 = control_msgs__msg__JointComponentTolerance__ROTATION ; pub const TRANSLATION : _bindgen_ty_152 = control_msgs__msg__JointComponentTolerance__TRANSLATION ; pub const X_AXIS : _bindgen_ty_149 = control_msgs__msg__JointComponentTolerance__X_AXIS ; pub const Y_AXIS : _bindgen_ty_150 = control_msgs__msg__JointComponentTolerance__Y_AXIS ; pub const Z_AXIS : _bindgen_ty_151 = control_msgs__msg__JointComponentTolerance__Z_AXIS ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct JointControllerState { pub header : std_msgs :: msg :: Header , pub set_point : f64 , pub process_value : f64 , pub process_value_dot : f64 , pub error : f64 , pub time_step : f64 , pub command : f64 , pub p : f64 , pub i : f64 , pub d : f64 , pub i_clamp : f64 , pub antiwindup : bool } impl WrappedTypesupport for JointControllerState { type CStruct = control_msgs__msg__JointControllerState ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__control_msgs__msg__JointControllerState () } } fn create_msg () -> * mut control_msgs__msg__JointControllerState { unsafe { control_msgs__msg__JointControllerState__create () } } fn destroy_msg (msg : * mut control_msgs__msg__JointControllerState) -> () { unsafe { control_msgs__msg__JointControllerState__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> JointControllerState { JointControllerState { header : std_msgs :: msg :: Header :: from_native (& msg . header) , set_point : msg . set_point , process_value : msg . process_value , process_value_dot : msg . process_value_dot , error : msg . error , time_step : msg . time_step , command : msg . command , p : msg . p , i : msg . i , d : msg . d , i_clamp : msg . i_clamp , antiwindup : msg . antiwindup , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . set_point = self . set_point ; msg . process_value = self . process_value ; msg . process_value_dot = self . process_value_dot ; msg . error = self . error ; msg . time_step = self . time_step ; msg . command = self . command ; msg . p = self . p ; msg . i = self . i ; msg . d = self . d ; msg . i_clamp = self . i_clamp ; msg . antiwindup = self . antiwindup ; } } impl Default for JointControllerState { fn default () -> Self { let msg_native = WrappedNativeMsg :: < JointControllerState > :: new () ; JointControllerState :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct JointJog { pub header : std_msgs :: msg :: Header , pub joint_names : Vec < std :: string :: String > , pub displacements : Vec < f64 > , pub velocities : Vec < f64 > , pub duration : f64 } impl WrappedTypesupport for JointJog { type CStruct = control_msgs__msg__JointJog ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__control_msgs__msg__JointJog () } } fn create_msg () -> * mut control_msgs__msg__JointJog { unsafe { control_msgs__msg__JointJog__create () } } fn destroy_msg (msg : * mut control_msgs__msg__JointJog) -> () { unsafe { control_msgs__msg__JointJog__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> JointJog { JointJog { header : std_msgs :: msg :: Header :: from_native (& msg . header) , joint_names : msg . joint_names . to_vec () , displacements : msg . displacements . to_vec () , velocities : msg . velocities . to_vec () , duration : msg . duration , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . joint_names . update (& self . joint_names) ; msg . displacements . update (& self . displacements) ; msg . velocities . update (& self . velocities) ; msg . duration = self . duration ; } } impl Default for JointJog { fn default () -> Self { let msg_native = WrappedNativeMsg :: < JointJog > :: new () ; JointJog :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct JointTolerance { pub name : std :: string :: String , pub position : f64 , pub velocity : f64 , pub acceleration : f64 } impl WrappedTypesupport for JointTolerance { type CStruct = control_msgs__msg__JointTolerance ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__control_msgs__msg__JointTolerance () } } fn create_msg () -> * mut control_msgs__msg__JointTolerance { unsafe { control_msgs__msg__JointTolerance__create () } } fn destroy_msg (msg : * mut control_msgs__msg__JointTolerance) -> () { unsafe { control_msgs__msg__JointTolerance__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> JointTolerance { JointTolerance { name : msg . name . to_str () . to_owned () , position : msg . position , velocity : msg . velocity , acceleration : msg . acceleration , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . name . assign (& self . name) ; msg . position = self . position ; msg . velocity = self . velocity ; msg . acceleration = self . acceleration ; } } impl Default for JointTolerance { fn default () -> Self { let msg_native = WrappedNativeMsg :: < JointTolerance > :: new () ; JointTolerance :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct JointTrajectoryControllerState { pub header : std_msgs :: msg :: Header , pub joint_names : Vec < std :: string :: String > , pub desired : trajectory_msgs :: msg :: JointTrajectoryPoint , pub actual : trajectory_msgs :: msg :: JointTrajectoryPoint , pub error : trajectory_msgs :: msg :: JointTrajectoryPoint } impl WrappedTypesupport for JointTrajectoryControllerState { type CStruct = control_msgs__msg__JointTrajectoryControllerState ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__control_msgs__msg__JointTrajectoryControllerState () } } fn create_msg () -> * mut control_msgs__msg__JointTrajectoryControllerState { unsafe { control_msgs__msg__JointTrajectoryControllerState__create () } } fn destroy_msg (msg : * mut control_msgs__msg__JointTrajectoryControllerState) -> () { unsafe { control_msgs__msg__JointTrajectoryControllerState__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> JointTrajectoryControllerState { JointTrajectoryControllerState { header : std_msgs :: msg :: Header :: from_native (& msg . header) , joint_names : msg . joint_names . to_vec () , desired : trajectory_msgs :: msg :: JointTrajectoryPoint :: from_native (& msg . desired) , actual : trajectory_msgs :: msg :: JointTrajectoryPoint :: from_native (& msg . actual) , error : trajectory_msgs :: msg :: JointTrajectoryPoint :: from_native (& msg . error) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . joint_names . update (& self . joint_names) ; self . desired . copy_to_native (& mut msg . desired) ; self . actual . copy_to_native (& mut msg . actual) ; self . error . copy_to_native (& mut msg . error) ; } } impl Default for JointTrajectoryControllerState { fn default () -> Self { let msg_native = WrappedNativeMsg :: < JointTrajectoryControllerState > :: new () ; JointTrajectoryControllerState :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct PidState { pub header : std_msgs :: msg :: Header , pub timestep : builtin_interfaces :: msg :: Duration , pub error : f64 , pub error_dot : f64 , pub p_error : f64 , pub i_error : f64 , pub d_error : f64 , pub p_term : f64 , pub i_term : f64 , pub d_term : f64 , pub i_max : f64 , pub i_min : f64 , pub output : f64 } impl WrappedTypesupport for PidState { type CStruct = control_msgs__msg__PidState ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__control_msgs__msg__PidState () } } fn create_msg () -> * mut control_msgs__msg__PidState { unsafe { control_msgs__msg__PidState__create () } } fn destroy_msg (msg : * mut control_msgs__msg__PidState) -> () { unsafe { control_msgs__msg__PidState__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> PidState { PidState { header : std_msgs :: msg :: Header :: from_native (& msg . header) , timestep : builtin_interfaces :: msg :: Duration :: from_native (& msg . timestep) , error : msg . error , error_dot : msg . error_dot , p_error : msg . p_error , i_error : msg . i_error , d_error : msg . d_error , p_term : msg . p_term , i_term : msg . i_term , d_term : msg . d_term , i_max : msg . i_max , i_min : msg . i_min , output : msg . output , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; self . timestep . copy_to_native (& mut msg . timestep) ; msg . error = self . error ; msg . error_dot = self . error_dot ; msg . p_error = self . p_error ; msg . i_error = self . i_error ; msg . d_error = self . d_error ; msg . p_term = self . p_term ; msg . i_term = self . i_term ; msg . d_term = self . d_term ; msg . i_max = self . i_max ; msg . i_min = self . i_min ; msg . output = self . output ; } } impl Default for PidState { fn default () -> Self { let msg_native = WrappedNativeMsg :: < PidState > :: new () ; PidState :: from_native (& msg_native) } } } pub mod srv { # [allow (non_snake_case)] pub mod QueryCalibrationState { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__control_msgs__srv__QueryCalibrationState () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { } impl WrappedTypesupport for Request { type CStruct = control_msgs__srv__QueryCalibrationState_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__control_msgs__srv__QueryCalibrationState_Request () } } fn create_msg () -> * mut control_msgs__srv__QueryCalibrationState_Request { unsafe { control_msgs__srv__QueryCalibrationState_Request__create () } } fn destroy_msg (msg : * mut control_msgs__srv__QueryCalibrationState_Request) -> () { unsafe { control_msgs__srv__QueryCalibrationState_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub is_calibrated : bool } impl WrappedTypesupport for Response { type CStruct = control_msgs__srv__QueryCalibrationState_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__control_msgs__srv__QueryCalibrationState_Response () } } fn create_msg () -> * mut control_msgs__srv__QueryCalibrationState_Response { unsafe { control_msgs__srv__QueryCalibrationState_Response__create () } } fn destroy_msg (msg : * mut control_msgs__srv__QueryCalibrationState_Response) -> () { unsafe { control_msgs__srv__QueryCalibrationState_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { is_calibrated : msg . is_calibrated , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . is_calibrated = self . is_calibrated ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod QueryTrajectoryState { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__control_msgs__srv__QueryTrajectoryState () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub time : builtin_interfaces :: msg :: Time } impl WrappedTypesupport for Request { type CStruct = control_msgs__srv__QueryTrajectoryState_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__control_msgs__srv__QueryTrajectoryState_Request () } } fn create_msg () -> * mut control_msgs__srv__QueryTrajectoryState_Request { unsafe { control_msgs__srv__QueryTrajectoryState_Request__create () } } fn destroy_msg (msg : * mut control_msgs__srv__QueryTrajectoryState_Request) -> () { unsafe { control_msgs__srv__QueryTrajectoryState_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { time : builtin_interfaces :: msg :: Time :: from_native (& msg . time) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . time . copy_to_native (& mut msg . time) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool , pub message : std :: string :: String , pub name : Vec < std :: string :: String > , pub position : Vec < f64 > , pub velocity : Vec < f64 > , pub acceleration : Vec < f64 > } impl WrappedTypesupport for Response { type CStruct = control_msgs__srv__QueryTrajectoryState_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__control_msgs__srv__QueryTrajectoryState_Response () } } fn create_msg () -> * mut control_msgs__srv__QueryTrajectoryState_Response { unsafe { control_msgs__srv__QueryTrajectoryState_Response__create () } } fn destroy_msg (msg : * mut control_msgs__srv__QueryTrajectoryState_Response) -> () { unsafe { control_msgs__srv__QueryTrajectoryState_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , message : msg . message . to_str () . to_owned () , name : msg . name . to_vec () , position : msg . position . to_vec () , velocity : msg . velocity . to_vec () , acceleration : msg . acceleration . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; msg . message . assign (& self . message) ; msg . name . update (& self . name) ; msg . position . update (& self . position) ; msg . velocity . update (& self . velocity) ; msg . acceleration . update (& self . acceleration) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } }