pub mod msg { use super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct CarrSoln { pub status : u8 } impl WrappedTypesupport for CarrSoln { type CStruct = ublox_ubx_msgs__msg__CarrSoln ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ublox_ubx_msgs__msg__CarrSoln () } } fn create_msg () -> * mut ublox_ubx_msgs__msg__CarrSoln { unsafe { ublox_ubx_msgs__msg__CarrSoln__create () } } fn destroy_msg (msg : * mut ublox_ubx_msgs__msg__CarrSoln) -> () { unsafe { ublox_ubx_msgs__msg__CarrSoln__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> CarrSoln { CarrSoln { status : msg . status , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . status = self . status ; } } impl Default for CarrSoln { fn default () -> Self { let msg_native = WrappedNativeMsg :: < CarrSoln > :: new () ; CarrSoln :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl CarrSoln { pub const CARRIER_SOLUTION_NO_CARRIER_RANGE_SOLUTION : _bindgen_ty_2450 = ublox_ubx_msgs__msg__CarrSoln__CARRIER_SOLUTION_NO_CARRIER_RANGE_SOLUTION ; pub const CARRIER_SOLUTION_PHASE_WITH_FIXED_AMBIGUITIES : _bindgen_ty_2452 = ublox_ubx_msgs__msg__CarrSoln__CARRIER_SOLUTION_PHASE_WITH_FIXED_AMBIGUITIES ; pub const CARRIER_SOLUTION_PHASE_WITH_FLOATING_AMBIGUITIES : _bindgen_ty_2451 = ublox_ubx_msgs__msg__CarrSoln__CARRIER_SOLUTION_PHASE_WITH_FLOATING_AMBIGUITIES ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct GpsFix { pub fix_type : u8 } impl WrappedTypesupport for GpsFix { type CStruct = ublox_ubx_msgs__msg__GpsFix ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ublox_ubx_msgs__msg__GpsFix () } } fn create_msg () -> * mut ublox_ubx_msgs__msg__GpsFix { unsafe { ublox_ubx_msgs__msg__GpsFix__create () } } fn destroy_msg (msg : * mut ublox_ubx_msgs__msg__GpsFix) -> () { unsafe { ublox_ubx_msgs__msg__GpsFix__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> GpsFix { GpsFix { fix_type : msg . fix_type , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . fix_type = self . fix_type ; } } impl Default for GpsFix { fn default () -> Self { let msg_native = WrappedNativeMsg :: < GpsFix > :: new () ; GpsFix :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl GpsFix { pub const GPS_DEAD_RECKONING_ONLY : _bindgen_ty_2454 = ublox_ubx_msgs__msg__GpsFix__GPS_DEAD_RECKONING_ONLY ; pub const GPS_FIX_2D : _bindgen_ty_2455 = ublox_ubx_msgs__msg__GpsFix__GPS_FIX_2D ; pub const GPS_FIX_3D : _bindgen_ty_2456 = ublox_ubx_msgs__msg__GpsFix__GPS_FIX_3D ; pub const GPS_NO_FIX : _bindgen_ty_2453 = ublox_ubx_msgs__msg__GpsFix__GPS_NO_FIX ; pub const GPS_PLUS_DEAD_RECKONING : _bindgen_ty_2457 = ublox_ubx_msgs__msg__GpsFix__GPS_PLUS_DEAD_RECKONING ; pub const GPS_TIME_ONLY : _bindgen_ty_2458 = ublox_ubx_msgs__msg__GpsFix__GPS_TIME_ONLY ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct MapMatching { pub status : u8 } impl WrappedTypesupport for MapMatching { type CStruct = ublox_ubx_msgs__msg__MapMatching ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ublox_ubx_msgs__msg__MapMatching () } } fn create_msg () -> * mut ublox_ubx_msgs__msg__MapMatching { unsafe { ublox_ubx_msgs__msg__MapMatching__create () } } fn destroy_msg (msg : * mut ublox_ubx_msgs__msg__MapMatching) -> () { unsafe { ublox_ubx_msgs__msg__MapMatching__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> MapMatching { MapMatching { status : msg . status , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . status = self . status ; } } impl Default for MapMatching { fn default () -> Self { let msg_native = WrappedNativeMsg :: < MapMatching > :: new () ; MapMatching :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl MapMatching { pub const MAP_MATCHING_NONE : _bindgen_ty_2459 = ublox_ubx_msgs__msg__MapMatching__MAP_MATCHING_NONE ; pub const MAP_MATCHING_VALID_AND_USED : _bindgen_ty_2461 = ublox_ubx_msgs__msg__MapMatching__MAP_MATCHING_VALID_AND_USED ; pub const MAP_MATCHING_VALID_DEAD_RECKONING : _bindgen_ty_2462 = ublox_ubx_msgs__msg__MapMatching__MAP_MATCHING_VALID_DEAD_RECKONING ; pub const MAP_MATCHING_VALID_NOT_USED : _bindgen_ty_2460 = ublox_ubx_msgs__msg__MapMatching__MAP_MATCHING_VALID_NOT_USED ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct PSMPVT { pub state : u8 } impl WrappedTypesupport for PSMPVT { type CStruct = ublox_ubx_msgs__msg__PSMPVT ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ublox_ubx_msgs__msg__PSMPVT () } } fn create_msg () -> * mut ublox_ubx_msgs__msg__PSMPVT { unsafe { ublox_ubx_msgs__msg__PSMPVT__create () } } fn destroy_msg (msg : * mut ublox_ubx_msgs__msg__PSMPVT) -> () { unsafe { ublox_ubx_msgs__msg__PSMPVT__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> PSMPVT { PSMPVT { state : msg . state , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . state = self . state ; } } impl Default for PSMPVT { fn default () -> Self { let msg_native = WrappedNativeMsg :: < PSMPVT > :: new () ; PSMPVT :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl PSMPVT { pub const PSM_STATE_ACQUISITION : _bindgen_ty_2469 = ublox_ubx_msgs__msg__PSMPVT__PSM_STATE_ACQUISITION ; pub const PSM_STATE_ENABLED : _bindgen_ty_2468 = ublox_ubx_msgs__msg__PSMPVT__PSM_STATE_ENABLED ; pub const PSM_STATE_INACTIVE : _bindgen_ty_2472 = ublox_ubx_msgs__msg__PSMPVT__PSM_STATE_INACTIVE ; pub const PSM_STATE_NOT_ACTIVE : _bindgen_ty_2467 = ublox_ubx_msgs__msg__PSMPVT__PSM_STATE_NOT_ACTIVE ; pub const PSM_STATE_POWER_OPTIMIZED_TRACKING : _bindgen_ty_2471 = ublox_ubx_msgs__msg__PSMPVT__PSM_STATE_POWER_OPTIMIZED_TRACKING ; pub const PSM_STATE_TRACKING : _bindgen_ty_2470 = ublox_ubx_msgs__msg__PSMPVT__PSM_STATE_TRACKING ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct PSMStatus { pub state : u8 } impl WrappedTypesupport for PSMStatus { type CStruct = ublox_ubx_msgs__msg__PSMStatus ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ublox_ubx_msgs__msg__PSMStatus () } } fn create_msg () -> * mut ublox_ubx_msgs__msg__PSMStatus { unsafe { ublox_ubx_msgs__msg__PSMStatus__create () } } fn destroy_msg (msg : * mut ublox_ubx_msgs__msg__PSMStatus) -> () { unsafe { ublox_ubx_msgs__msg__PSMStatus__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> PSMStatus { PSMStatus { state : msg . state , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . state = self . state ; } } impl Default for PSMStatus { fn default () -> Self { let msg_native = WrappedNativeMsg :: < PSMStatus > :: new () ; PSMStatus :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl PSMStatus { pub const PSM_STATE_ACQUISITION : _bindgen_ty_2463 = ublox_ubx_msgs__msg__PSMStatus__PSM_STATE_ACQUISITION ; pub const PSM_STATE_INACTIVE : _bindgen_ty_2466 = ublox_ubx_msgs__msg__PSMStatus__PSM_STATE_INACTIVE ; pub const PSM_STATE_POWER_OPTIMIZED_TRACKING : _bindgen_ty_2465 = ublox_ubx_msgs__msg__PSMStatus__PSM_STATE_POWER_OPTIMIZED_TRACKING ; pub const PSM_STATE_TRACKING : _bindgen_ty_2464 = ublox_ubx_msgs__msg__PSMStatus__PSM_STATE_TRACKING ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct SpoofDet { pub state : u8 } impl WrappedTypesupport for SpoofDet { type CStruct = ublox_ubx_msgs__msg__SpoofDet ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ublox_ubx_msgs__msg__SpoofDet () } } fn create_msg () -> * mut ublox_ubx_msgs__msg__SpoofDet { unsafe { ublox_ubx_msgs__msg__SpoofDet__create () } } fn destroy_msg (msg : * mut ublox_ubx_msgs__msg__SpoofDet) -> () { unsafe { ublox_ubx_msgs__msg__SpoofDet__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> SpoofDet { SpoofDet { state : msg . state , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . state = self . state ; } } impl Default for SpoofDet { fn default () -> Self { let msg_native = WrappedNativeMsg :: < SpoofDet > :: new () ; SpoofDet :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl SpoofDet { pub const SPOOF_DET_MULTIPLE_SPOOFING : _bindgen_ty_2476 = ublox_ubx_msgs__msg__SpoofDet__SPOOF_DET_MULTIPLE_SPOOFING ; pub const SPOOF_DET_NO_SPOOFING : _bindgen_ty_2474 = ublox_ubx_msgs__msg__SpoofDet__SPOOF_DET_NO_SPOOFING ; pub const SPOOF_DET_SPOOFING : _bindgen_ty_2475 = ublox_ubx_msgs__msg__SpoofDet__SPOOF_DET_SPOOFING ; pub const SPOOF_DET_UNKNOWN : _bindgen_ty_2473 = ublox_ubx_msgs__msg__SpoofDet__SPOOF_DET_UNKNOWN ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct UBXNavClock { pub header : std_msgs :: msg :: Header , pub itow : u32 , pub clk_b : i32 , pub clk_d : i32 , pub t_acc : u32 , pub f_acc : u32 } impl WrappedTypesupport for UBXNavClock { type CStruct = ublox_ubx_msgs__msg__UBXNavClock ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ublox_ubx_msgs__msg__UBXNavClock () } } fn create_msg () -> * mut ublox_ubx_msgs__msg__UBXNavClock { unsafe { ublox_ubx_msgs__msg__UBXNavClock__create () } } fn destroy_msg (msg : * mut ublox_ubx_msgs__msg__UBXNavClock) -> () { unsafe { ublox_ubx_msgs__msg__UBXNavClock__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> UBXNavClock { UBXNavClock { header : std_msgs :: msg :: Header :: from_native (& msg . header) , itow : msg . itow , clk_b : msg . clk_b , clk_d : msg . clk_d , t_acc : msg . t_acc , f_acc : msg . f_acc , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . itow = self . itow ; msg . clk_b = self . clk_b ; msg . clk_d = self . clk_d ; msg . t_acc = self . t_acc ; msg . f_acc = self . f_acc ; } } impl Default for UBXNavClock { fn default () -> Self { let msg_native = WrappedNativeMsg :: < UBXNavClock > :: new () ; UBXNavClock :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct UBXNavCov { pub header : std_msgs :: msg :: Header , pub itow : u32 , pub version : u8 , pub pos_cor_valid : bool , pub vel_cor_valid : bool , pub pos_cov_nn : f32 , pub pos_cov_ne : f32 , pub pos_cov_nd : f32 , pub pos_cov_ee : f32 , pub pos_cov_ed : f32 , pub pos_cov_dd : f32 , pub vel_cov_nn : f32 , pub vel_cov_ne : f32 , pub vel_cov_nd : f32 , pub vel_cov_ee : f32 , pub vel_cov_ed : f32 , pub vel_cov_dd : f32 } impl WrappedTypesupport for UBXNavCov { type CStruct = ublox_ubx_msgs__msg__UBXNavCov ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ublox_ubx_msgs__msg__UBXNavCov () } } fn create_msg () -> * mut ublox_ubx_msgs__msg__UBXNavCov { unsafe { ublox_ubx_msgs__msg__UBXNavCov__create () } } fn destroy_msg (msg : * mut ublox_ubx_msgs__msg__UBXNavCov) -> () { unsafe { ublox_ubx_msgs__msg__UBXNavCov__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> UBXNavCov { UBXNavCov { header : std_msgs :: msg :: Header :: from_native (& msg . header) , itow : msg . itow , version : msg . version , pos_cor_valid : msg . pos_cor_valid , vel_cor_valid : msg . vel_cor_valid , pos_cov_nn : msg . pos_cov_nn , pos_cov_ne : msg . pos_cov_ne , pos_cov_nd : msg . pos_cov_nd , pos_cov_ee : msg . pos_cov_ee , pos_cov_ed : msg . pos_cov_ed , pos_cov_dd : msg . pos_cov_dd , vel_cov_nn : msg . vel_cov_nn , vel_cov_ne : msg . vel_cov_ne , vel_cov_nd : msg . vel_cov_nd , vel_cov_ee : msg . vel_cov_ee , vel_cov_ed : msg . vel_cov_ed , vel_cov_dd : msg . vel_cov_dd , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . itow = self . itow ; msg . version = self . version ; msg . pos_cor_valid = self . pos_cor_valid ; msg . vel_cor_valid = self . vel_cor_valid ; msg . pos_cov_nn = self . pos_cov_nn ; msg . pos_cov_ne = self . pos_cov_ne ; msg . pos_cov_nd = self . pos_cov_nd ; msg . pos_cov_ee = self . pos_cov_ee ; msg . pos_cov_ed = self . pos_cov_ed ; msg . pos_cov_dd = self . pos_cov_dd ; msg . vel_cov_nn = self . vel_cov_nn ; msg . vel_cov_ne = self . vel_cov_ne ; msg . vel_cov_nd = self . vel_cov_nd ; msg . vel_cov_ee = self . vel_cov_ee ; msg . vel_cov_ed = self . vel_cov_ed ; msg . vel_cov_dd = self . vel_cov_dd ; } } impl Default for UBXNavCov { fn default () -> Self { let msg_native = WrappedNativeMsg :: < UBXNavCov > :: new () ; UBXNavCov :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct UBXNavDOP { pub header : std_msgs :: msg :: Header , pub itow : u32 , pub g_dop : u32 , pub p_dop : u32 , pub t_dop : u32 , pub v_dop : u32 , pub h_dop : u32 , pub n_dop : u32 , pub e_dop : u32 } impl WrappedTypesupport for UBXNavDOP { type CStruct = ublox_ubx_msgs__msg__UBXNavDOP ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ublox_ubx_msgs__msg__UBXNavDOP () } } fn create_msg () -> * mut ublox_ubx_msgs__msg__UBXNavDOP { unsafe { ublox_ubx_msgs__msg__UBXNavDOP__create () } } fn destroy_msg (msg : * mut ublox_ubx_msgs__msg__UBXNavDOP) -> () { unsafe { ublox_ubx_msgs__msg__UBXNavDOP__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> UBXNavDOP { UBXNavDOP { header : std_msgs :: msg :: Header :: from_native (& msg . header) , itow : msg . itow , g_dop : msg . g_dop , p_dop : msg . p_dop , t_dop : msg . t_dop , v_dop : msg . v_dop , h_dop : msg . h_dop , n_dop : msg . n_dop , e_dop : msg . e_dop , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . itow = self . itow ; msg . g_dop = self . g_dop ; msg . p_dop = self . p_dop ; msg . t_dop = self . t_dop ; msg . v_dop = self . v_dop ; msg . h_dop = self . h_dop ; msg . n_dop = self . n_dop ; msg . e_dop = self . e_dop ; } } impl Default for UBXNavDOP { fn default () -> Self { let msg_native = WrappedNativeMsg :: < UBXNavDOP > :: new () ; UBXNavDOP :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct UBXNavEOE { pub header : std_msgs :: msg :: Header , pub itow : u32 } impl WrappedTypesupport for UBXNavEOE { type CStruct = ublox_ubx_msgs__msg__UBXNavEOE ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ublox_ubx_msgs__msg__UBXNavEOE () } } fn create_msg () -> * mut ublox_ubx_msgs__msg__UBXNavEOE { unsafe { ublox_ubx_msgs__msg__UBXNavEOE__create () } } fn destroy_msg (msg : * mut ublox_ubx_msgs__msg__UBXNavEOE) -> () { unsafe { ublox_ubx_msgs__msg__UBXNavEOE__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> UBXNavEOE { UBXNavEOE { header : std_msgs :: msg :: Header :: from_native (& msg . header) , itow : msg . itow , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . itow = self . itow ; } } impl Default for UBXNavEOE { fn default () -> Self { let msg_native = WrappedNativeMsg :: < UBXNavEOE > :: new () ; UBXNavEOE :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct UBXNavHPPosECEF { pub header : std_msgs :: msg :: Header , pub version : u8 , pub itow : u32 , pub ecef_x : i32 , pub ecef_y : i32 , pub ecef_z : i32 , pub ecef_x_hp : i8 , pub ecef_y_hp : i8 , pub ecef_z_hp : i8 , pub invalid_ecef_x : bool , pub invalid_ecef_y : bool , pub invalid_ecef_z : bool , pub invalid_ecef_x_hp : bool , pub invalid_ecef_y_hp : bool , pub invalid_ecef_z_hp : bool , pub p_acc : u32 } impl WrappedTypesupport for UBXNavHPPosECEF { type CStruct = ublox_ubx_msgs__msg__UBXNavHPPosECEF ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ublox_ubx_msgs__msg__UBXNavHPPosECEF () } } fn create_msg () -> * mut ublox_ubx_msgs__msg__UBXNavHPPosECEF { unsafe { ublox_ubx_msgs__msg__UBXNavHPPosECEF__create () } } fn destroy_msg (msg : * mut ublox_ubx_msgs__msg__UBXNavHPPosECEF) -> () { unsafe { ublox_ubx_msgs__msg__UBXNavHPPosECEF__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> UBXNavHPPosECEF { UBXNavHPPosECEF { header : std_msgs :: msg :: Header :: from_native (& msg . header) , version : msg . version , itow : msg . itow , ecef_x : msg . ecef_x , ecef_y : msg . ecef_y , ecef_z : msg . ecef_z , ecef_x_hp : msg . ecef_x_hp , ecef_y_hp : msg . ecef_y_hp , ecef_z_hp : msg . ecef_z_hp , invalid_ecef_x : msg . invalid_ecef_x , invalid_ecef_y : msg . invalid_ecef_y , invalid_ecef_z : msg . invalid_ecef_z , invalid_ecef_x_hp : msg . invalid_ecef_x_hp , invalid_ecef_y_hp : msg . invalid_ecef_y_hp , invalid_ecef_z_hp : msg . invalid_ecef_z_hp , p_acc : msg . p_acc , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . version = self . version ; msg . itow = self . itow ; msg . ecef_x = self . ecef_x ; msg . ecef_y = self . ecef_y ; msg . ecef_z = self . ecef_z ; msg . ecef_x_hp = self . ecef_x_hp ; msg . ecef_y_hp = self . ecef_y_hp ; msg . ecef_z_hp = self . ecef_z_hp ; msg . invalid_ecef_x = self . invalid_ecef_x ; msg . invalid_ecef_y = self . invalid_ecef_y ; msg . invalid_ecef_z = self . invalid_ecef_z ; msg . invalid_ecef_x_hp = self . invalid_ecef_x_hp ; msg . invalid_ecef_y_hp = self . invalid_ecef_y_hp ; msg . invalid_ecef_z_hp = self . invalid_ecef_z_hp ; msg . p_acc = self . p_acc ; } } impl Default for UBXNavHPPosECEF { fn default () -> Self { let msg_native = WrappedNativeMsg :: < UBXNavHPPosECEF > :: new () ; UBXNavHPPosECEF :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct UBXNavHPPosLLH { pub header : std_msgs :: msg :: Header , pub version : u8 , pub invalid_lon : bool , pub invalid_lat : bool , pub invalid_height : bool , pub invalid_hmsl : bool , pub invalid_lon_hp : bool , pub invalid_lat_hp : bool , pub invalid_height_hp : bool , pub invalid_hmsl_hp : bool , pub itow : u32 , pub lon : i32 , pub lat : i32 , pub height : i32 , pub hmsl : i32 , pub lon_hp : i8 , pub lat_hp : i8 , pub height_hp : i8 , pub hmsl_hp : i8 , pub h_acc : u32 , pub v_acc : u32 } impl WrappedTypesupport for UBXNavHPPosLLH { type CStruct = ublox_ubx_msgs__msg__UBXNavHPPosLLH ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ublox_ubx_msgs__msg__UBXNavHPPosLLH () } } fn create_msg () -> * mut ublox_ubx_msgs__msg__UBXNavHPPosLLH { unsafe { ublox_ubx_msgs__msg__UBXNavHPPosLLH__create () } } fn destroy_msg (msg : * mut ublox_ubx_msgs__msg__UBXNavHPPosLLH) -> () { unsafe { ublox_ubx_msgs__msg__UBXNavHPPosLLH__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> UBXNavHPPosLLH { UBXNavHPPosLLH { header : std_msgs :: msg :: Header :: from_native (& msg . header) , version : msg . version , invalid_lon : msg . invalid_lon , invalid_lat : msg . invalid_lat , invalid_height : msg . invalid_height , invalid_hmsl : msg . invalid_hmsl , invalid_lon_hp : msg . invalid_lon_hp , invalid_lat_hp : msg . invalid_lat_hp , invalid_height_hp : msg . invalid_height_hp , invalid_hmsl_hp : msg . invalid_hmsl_hp , itow : msg . itow , lon : msg . lon , lat : msg . lat , height : msg . height , hmsl : msg . hmsl , lon_hp : msg . lon_hp , lat_hp : msg . lat_hp , height_hp : msg . height_hp , hmsl_hp : msg . hmsl_hp , h_acc : msg . h_acc , v_acc : msg . v_acc , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . version = self . version ; msg . invalid_lon = self . invalid_lon ; msg . invalid_lat = self . invalid_lat ; msg . invalid_height = self . invalid_height ; msg . invalid_hmsl = self . invalid_hmsl ; msg . invalid_lon_hp = self . invalid_lon_hp ; msg . invalid_lat_hp = self . invalid_lat_hp ; msg . invalid_height_hp = self . invalid_height_hp ; msg . invalid_hmsl_hp = self . invalid_hmsl_hp ; msg . itow = self . itow ; msg . lon = self . lon ; msg . lat = self . lat ; msg . height = self . height ; msg . hmsl = self . hmsl ; msg . lon_hp = self . lon_hp ; msg . lat_hp = self . lat_hp ; msg . height_hp = self . height_hp ; msg . hmsl_hp = self . hmsl_hp ; msg . h_acc = self . h_acc ; msg . v_acc = self . v_acc ; } } impl Default for UBXNavHPPosLLH { fn default () -> Self { let msg_native = WrappedNativeMsg :: < UBXNavHPPosLLH > :: new () ; UBXNavHPPosLLH :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct UBXNavOdo { pub header : std_msgs :: msg :: Header , pub version : u8 , pub itow : u32 , pub distance : u32 , pub total_distance : u32 , pub distance_std : u32 } impl WrappedTypesupport for UBXNavOdo { type CStruct = ublox_ubx_msgs__msg__UBXNavOdo ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ublox_ubx_msgs__msg__UBXNavOdo () } } fn create_msg () -> * mut ublox_ubx_msgs__msg__UBXNavOdo { unsafe { ublox_ubx_msgs__msg__UBXNavOdo__create () } } fn destroy_msg (msg : * mut ublox_ubx_msgs__msg__UBXNavOdo) -> () { unsafe { ublox_ubx_msgs__msg__UBXNavOdo__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> UBXNavOdo { UBXNavOdo { header : std_msgs :: msg :: Header :: from_native (& msg . header) , version : msg . version , itow : msg . itow , distance : msg . distance , total_distance : msg . total_distance , distance_std : msg . distance_std , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . version = self . version ; msg . itow = self . itow ; msg . distance = self . distance ; msg . total_distance = self . total_distance ; msg . distance_std = self . distance_std ; } } impl Default for UBXNavOdo { fn default () -> Self { let msg_native = WrappedNativeMsg :: < UBXNavOdo > :: new () ; UBXNavOdo :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct UBXNavPVT { pub header : std_msgs :: msg :: Header , pub itow : u32 , pub year : u16 , pub month : u8 , pub day : u8 , pub hour : u8 , pub min : u8 , pub sec : u8 , pub valid_date : bool , pub valid_time : bool , pub fully_resolved : bool , pub valid_mag : bool , pub t_acc : u32 , pub nano : i32 , pub gps_fix : ublox_ubx_msgs :: msg :: GpsFix , pub gnss_fix_ok : bool , pub diff_soln : bool , pub psm : ublox_ubx_msgs :: msg :: PSMPVT , pub head_veh_valid : bool , pub carr_soln : ublox_ubx_msgs :: msg :: CarrSoln , pub confirmed_avail : bool , pub confirmed_date : bool , pub confirmed_time : bool , pub num_sv : u8 , pub lon : i32 , pub lat : i32 , pub height : i32 , pub hmsl : i32 , pub h_acc : u32 , pub v_acc : u32 , pub vel_n : i32 , pub vel_e : i32 , pub vel_d : i32 , pub g_speed : i32 , pub head_mot : i32 , pub s_acc : u32 , pub head_acc : u32 , pub p_dop : u16 , pub invalid_llh : bool , pub head_veh : i32 , pub mag_dec : i16 , pub mag_acc : u16 } impl WrappedTypesupport for UBXNavPVT { type CStruct = ublox_ubx_msgs__msg__UBXNavPVT ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ublox_ubx_msgs__msg__UBXNavPVT () } } fn create_msg () -> * mut ublox_ubx_msgs__msg__UBXNavPVT { unsafe { ublox_ubx_msgs__msg__UBXNavPVT__create () } } fn destroy_msg (msg : * mut ublox_ubx_msgs__msg__UBXNavPVT) -> () { unsafe { ublox_ubx_msgs__msg__UBXNavPVT__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> UBXNavPVT { UBXNavPVT { header : std_msgs :: msg :: Header :: from_native (& msg . header) , itow : msg . itow , year : msg . year , month : msg . month , day : msg . day , hour : msg . hour , min : msg . min , sec : msg . sec , valid_date : msg . valid_date , valid_time : msg . valid_time , fully_resolved : msg . fully_resolved , valid_mag : msg . valid_mag , t_acc : msg . t_acc , nano : msg . nano , gps_fix : ublox_ubx_msgs :: msg :: GpsFix :: from_native (& msg . gps_fix) , gnss_fix_ok : msg . gnss_fix_ok , diff_soln : msg . diff_soln , psm : ublox_ubx_msgs :: msg :: PSMPVT :: from_native (& msg . psm) , head_veh_valid : msg . head_veh_valid , carr_soln : ublox_ubx_msgs :: msg :: CarrSoln :: from_native (& msg . carr_soln) , confirmed_avail : msg . confirmed_avail , confirmed_date : msg . confirmed_date , confirmed_time : msg . confirmed_time , num_sv : msg . num_sv , lon : msg . lon , lat : msg . lat , height : msg . height , hmsl : msg . hmsl , h_acc : msg . h_acc , v_acc : msg . v_acc , vel_n : msg . vel_n , vel_e : msg . vel_e , vel_d : msg . vel_d , g_speed : msg . g_speed , head_mot : msg . head_mot , s_acc : msg . s_acc , head_acc : msg . head_acc , p_dop : msg . p_dop , invalid_llh : msg . invalid_llh , head_veh : msg . head_veh , mag_dec : msg . mag_dec , mag_acc : msg . mag_acc , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . itow = self . itow ; msg . year = self . year ; msg . month = self . month ; msg . day = self . day ; msg . hour = self . hour ; msg . min = self . min ; msg . sec = self . sec ; msg . valid_date = self . valid_date ; msg . valid_time = self . valid_time ; msg . fully_resolved = self . fully_resolved ; msg . valid_mag = self . valid_mag ; msg . t_acc = self . t_acc ; msg . nano = self . nano ; self . gps_fix . copy_to_native (& mut msg . gps_fix) ; msg . gnss_fix_ok = self . gnss_fix_ok ; msg . diff_soln = self . diff_soln ; self . psm . copy_to_native (& mut msg . psm) ; msg . head_veh_valid = self . head_veh_valid ; self . carr_soln . copy_to_native (& mut msg . carr_soln) ; msg . confirmed_avail = self . confirmed_avail ; msg . confirmed_date = self . confirmed_date ; msg . confirmed_time = self . confirmed_time ; msg . num_sv = self . num_sv ; msg . lon = self . lon ; msg . lat = self . lat ; msg . height = self . height ; msg . hmsl = self . hmsl ; msg . h_acc = self . h_acc ; msg . v_acc = self . v_acc ; msg . vel_n = self . vel_n ; msg . vel_e = self . vel_e ; msg . vel_d = self . vel_d ; msg . g_speed = self . g_speed ; msg . head_mot = self . head_mot ; msg . s_acc = self . s_acc ; msg . head_acc = self . head_acc ; msg . p_dop = self . p_dop ; msg . invalid_llh = self . invalid_llh ; msg . head_veh = self . head_veh ; msg . mag_dec = self . mag_dec ; msg . mag_acc = self . mag_acc ; } } impl Default for UBXNavPVT { fn default () -> Self { let msg_native = WrappedNativeMsg :: < UBXNavPVT > :: new () ; UBXNavPVT :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct UBXNavPosECEF { pub header : std_msgs :: msg :: Header , pub itow : u32 , pub ecef_x : i32 , pub ecef_y : i32 , pub ecef_z : i32 , pub p_acc : u32 } impl WrappedTypesupport for UBXNavPosECEF { type CStruct = ublox_ubx_msgs__msg__UBXNavPosECEF ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ublox_ubx_msgs__msg__UBXNavPosECEF () } } fn create_msg () -> * mut ublox_ubx_msgs__msg__UBXNavPosECEF { unsafe { ublox_ubx_msgs__msg__UBXNavPosECEF__create () } } fn destroy_msg (msg : * mut ublox_ubx_msgs__msg__UBXNavPosECEF) -> () { unsafe { ublox_ubx_msgs__msg__UBXNavPosECEF__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> UBXNavPosECEF { UBXNavPosECEF { header : std_msgs :: msg :: Header :: from_native (& msg . header) , itow : msg . itow , ecef_x : msg . ecef_x , ecef_y : msg . ecef_y , ecef_z : msg . ecef_z , p_acc : msg . p_acc , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . itow = self . itow ; msg . ecef_x = self . ecef_x ; msg . ecef_y = self . ecef_y ; msg . ecef_z = self . ecef_z ; msg . p_acc = self . p_acc ; } } impl Default for UBXNavPosECEF { fn default () -> Self { let msg_native = WrappedNativeMsg :: < UBXNavPosECEF > :: new () ; UBXNavPosECEF :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct UBXNavPosLLH { pub header : std_msgs :: msg :: Header , pub itow : u32 , pub lon : i32 , pub lat : i32 , pub height : i32 , pub hmsl : i32 , pub h_acc : u32 , pub v_acc : u32 } impl WrappedTypesupport for UBXNavPosLLH { type CStruct = ublox_ubx_msgs__msg__UBXNavPosLLH ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ublox_ubx_msgs__msg__UBXNavPosLLH () } } fn create_msg () -> * mut ublox_ubx_msgs__msg__UBXNavPosLLH { unsafe { ublox_ubx_msgs__msg__UBXNavPosLLH__create () } } fn destroy_msg (msg : * mut ublox_ubx_msgs__msg__UBXNavPosLLH) -> () { unsafe { ublox_ubx_msgs__msg__UBXNavPosLLH__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> UBXNavPosLLH { UBXNavPosLLH { header : std_msgs :: msg :: Header :: from_native (& msg . header) , itow : msg . itow , lon : msg . lon , lat : msg . lat , height : msg . height , hmsl : msg . hmsl , h_acc : msg . h_acc , v_acc : msg . v_acc , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . itow = self . itow ; msg . lon = self . lon ; msg . lat = self . lat ; msg . height = self . height ; msg . hmsl = self . hmsl ; msg . h_acc = self . h_acc ; msg . v_acc = self . v_acc ; } } impl Default for UBXNavPosLLH { fn default () -> Self { let msg_native = WrappedNativeMsg :: < UBXNavPosLLH > :: new () ; UBXNavPosLLH :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct UBXNavRelPosNED { pub header : std_msgs :: msg :: Header , pub version : u8 , pub ref_station_id : u16 , pub itow : u32 , pub rel_pos_n : i32 , pub rel_pos_e : i32 , pub rel_pos_d : i32 , pub rel_pos_length : i32 , pub rel_pos_heading : i32 , pub rel_pos_hp_n : i8 , pub rel_pos_hp_e : i8 , pub rel_pos_hp_d : i8 , pub rel_pos_hp_length : i8 , pub acc_n : u32 , pub acc_e : u32 , pub acc_d : u32 , pub acc_length : u32 , pub acc_heading : u32 , pub gnss_fix_ok : bool , pub diff_soln : bool , pub rel_pos_valid : bool , pub carr_soln : ublox_ubx_msgs :: msg :: CarrSoln , pub is_moving : bool , pub ref_pos_miss : bool , pub ref_obs_miss : bool , pub rel_pos_heading_valid : bool , pub rel_pos_normalized : bool } impl WrappedTypesupport for UBXNavRelPosNED { type CStruct = ublox_ubx_msgs__msg__UBXNavRelPosNED ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ublox_ubx_msgs__msg__UBXNavRelPosNED () } } fn create_msg () -> * mut ublox_ubx_msgs__msg__UBXNavRelPosNED { unsafe { ublox_ubx_msgs__msg__UBXNavRelPosNED__create () } } fn destroy_msg (msg : * mut ublox_ubx_msgs__msg__UBXNavRelPosNED) -> () { unsafe { ublox_ubx_msgs__msg__UBXNavRelPosNED__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> UBXNavRelPosNED { UBXNavRelPosNED { header : std_msgs :: msg :: Header :: from_native (& msg . header) , version : msg . version , ref_station_id : msg . ref_station_id , itow : msg . itow , rel_pos_n : msg . rel_pos_n , rel_pos_e : msg . rel_pos_e , rel_pos_d : msg . rel_pos_d , rel_pos_length : msg . rel_pos_length , rel_pos_heading : msg . rel_pos_heading , rel_pos_hp_n : msg . rel_pos_hp_n , rel_pos_hp_e : msg . rel_pos_hp_e , rel_pos_hp_d : msg . rel_pos_hp_d , rel_pos_hp_length : msg . rel_pos_hp_length , acc_n : msg . acc_n , acc_e : msg . acc_e , acc_d : msg . acc_d , acc_length : msg . acc_length , acc_heading : msg . acc_heading , gnss_fix_ok : msg . gnss_fix_ok , diff_soln : msg . diff_soln , rel_pos_valid : msg . rel_pos_valid , carr_soln : ublox_ubx_msgs :: msg :: CarrSoln :: from_native (& msg . carr_soln) , is_moving : msg . is_moving , ref_pos_miss : msg . ref_pos_miss , ref_obs_miss : msg . ref_obs_miss , rel_pos_heading_valid : msg . rel_pos_heading_valid , rel_pos_normalized : msg . rel_pos_normalized , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . version = self . version ; msg . ref_station_id = self . ref_station_id ; msg . itow = self . itow ; msg . rel_pos_n = self . rel_pos_n ; msg . rel_pos_e = self . rel_pos_e ; msg . rel_pos_d = self . rel_pos_d ; msg . rel_pos_length = self . rel_pos_length ; msg . rel_pos_heading = self . rel_pos_heading ; msg . rel_pos_hp_n = self . rel_pos_hp_n ; msg . rel_pos_hp_e = self . rel_pos_hp_e ; msg . rel_pos_hp_d = self . rel_pos_hp_d ; msg . rel_pos_hp_length = self . rel_pos_hp_length ; msg . acc_n = self . acc_n ; msg . acc_e = self . acc_e ; msg . acc_d = self . acc_d ; msg . acc_length = self . acc_length ; msg . acc_heading = self . acc_heading ; msg . gnss_fix_ok = self . gnss_fix_ok ; msg . diff_soln = self . diff_soln ; msg . rel_pos_valid = self . rel_pos_valid ; self . carr_soln . copy_to_native (& mut msg . carr_soln) ; msg . is_moving = self . is_moving ; msg . ref_pos_miss = self . ref_pos_miss ; msg . ref_obs_miss = self . ref_obs_miss ; msg . rel_pos_heading_valid = self . rel_pos_heading_valid ; msg . rel_pos_normalized = self . rel_pos_normalized ; } } impl Default for UBXNavRelPosNED { fn default () -> Self { let msg_native = WrappedNativeMsg :: < UBXNavRelPosNED > :: new () ; UBXNavRelPosNED :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct UBXNavStatus { pub header : std_msgs :: msg :: Header , pub itow : u32 , pub gps_fix : ublox_ubx_msgs :: msg :: GpsFix , pub gps_fix_ok : bool , pub diff_soln : bool , pub wkn_set : bool , pub tow_set : bool , pub diff_corr : bool , pub carr_soln_valid : bool , pub map_matching : ublox_ubx_msgs :: msg :: MapMatching , pub psm : ublox_ubx_msgs :: msg :: PSMStatus , pub spoof_det : ublox_ubx_msgs :: msg :: SpoofDet , pub carr_soln : ublox_ubx_msgs :: msg :: CarrSoln , pub ttff : u32 , pub msss : u32 } impl WrappedTypesupport for UBXNavStatus { type CStruct = ublox_ubx_msgs__msg__UBXNavStatus ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ublox_ubx_msgs__msg__UBXNavStatus () } } fn create_msg () -> * mut ublox_ubx_msgs__msg__UBXNavStatus { unsafe { ublox_ubx_msgs__msg__UBXNavStatus__create () } } fn destroy_msg (msg : * mut ublox_ubx_msgs__msg__UBXNavStatus) -> () { unsafe { ublox_ubx_msgs__msg__UBXNavStatus__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> UBXNavStatus { UBXNavStatus { header : std_msgs :: msg :: Header :: from_native (& msg . header) , itow : msg . itow , gps_fix : ublox_ubx_msgs :: msg :: GpsFix :: from_native (& msg . gps_fix) , gps_fix_ok : msg . gps_fix_ok , diff_soln : msg . diff_soln , wkn_set : msg . wkn_set , tow_set : msg . tow_set , diff_corr : msg . diff_corr , carr_soln_valid : msg . carr_soln_valid , map_matching : ublox_ubx_msgs :: msg :: MapMatching :: from_native (& msg . map_matching) , psm : ublox_ubx_msgs :: msg :: PSMStatus :: from_native (& msg . psm) , spoof_det : ublox_ubx_msgs :: msg :: SpoofDet :: from_native (& msg . spoof_det) , carr_soln : ublox_ubx_msgs :: msg :: CarrSoln :: from_native (& msg . carr_soln) , ttff : msg . ttff , msss : msg . msss , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . itow = self . itow ; self . gps_fix . copy_to_native (& mut msg . gps_fix) ; msg . gps_fix_ok = self . gps_fix_ok ; msg . diff_soln = self . diff_soln ; msg . wkn_set = self . wkn_set ; msg . tow_set = self . tow_set ; msg . diff_corr = self . diff_corr ; msg . carr_soln_valid = self . carr_soln_valid ; self . map_matching . copy_to_native (& mut msg . map_matching) ; self . psm . copy_to_native (& mut msg . psm) ; self . spoof_det . copy_to_native (& mut msg . spoof_det) ; self . carr_soln . copy_to_native (& mut msg . carr_soln) ; msg . ttff = self . ttff ; msg . msss = self . msss ; } } impl Default for UBXNavStatus { fn default () -> Self { let msg_native = WrappedNativeMsg :: < UBXNavStatus > :: new () ; UBXNavStatus :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct UBXNavTimeUTC { pub header : std_msgs :: msg :: Header , pub itow : u32 , pub t_acc : u32 , pub nano : i32 , pub year : i16 , pub month : i8 , pub day : i8 , pub hour : i8 , pub min : i8 , pub sec : i8 , pub valid_tow : bool , pub valid_wkn : bool , pub valid_utc : bool , pub utc_std : ublox_ubx_msgs :: msg :: UtcStd } impl WrappedTypesupport for UBXNavTimeUTC { type CStruct = ublox_ubx_msgs__msg__UBXNavTimeUTC ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ublox_ubx_msgs__msg__UBXNavTimeUTC () } } fn create_msg () -> * mut ublox_ubx_msgs__msg__UBXNavTimeUTC { unsafe { ublox_ubx_msgs__msg__UBXNavTimeUTC__create () } } fn destroy_msg (msg : * mut ublox_ubx_msgs__msg__UBXNavTimeUTC) -> () { unsafe { ublox_ubx_msgs__msg__UBXNavTimeUTC__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> UBXNavTimeUTC { UBXNavTimeUTC { header : std_msgs :: msg :: Header :: from_native (& msg . header) , itow : msg . itow , t_acc : msg . t_acc , nano : msg . nano , year : msg . year , month : msg . month , day : msg . day , hour : msg . hour , min : msg . min , sec : msg . sec , valid_tow : msg . valid_tow , valid_wkn : msg . valid_wkn , valid_utc : msg . valid_utc , utc_std : ublox_ubx_msgs :: msg :: UtcStd :: from_native (& msg . utc_std) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . itow = self . itow ; msg . t_acc = self . t_acc ; msg . nano = self . nano ; msg . year = self . year ; msg . month = self . month ; msg . day = self . day ; msg . hour = self . hour ; msg . min = self . min ; msg . sec = self . sec ; msg . valid_tow = self . valid_tow ; msg . valid_wkn = self . valid_wkn ; msg . valid_utc = self . valid_utc ; self . utc_std . copy_to_native (& mut msg . utc_std) ; } } impl Default for UBXNavTimeUTC { fn default () -> Self { let msg_native = WrappedNativeMsg :: < UBXNavTimeUTC > :: new () ; UBXNavTimeUTC :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct UBXNavVelECEF { pub header : std_msgs :: msg :: Header , pub itow : u32 , pub ecef_vx : i32 , pub ecef_vy : i32 , pub ecef_vz : i32 , pub s_acc : u32 } impl WrappedTypesupport for UBXNavVelECEF { type CStruct = ublox_ubx_msgs__msg__UBXNavVelECEF ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ublox_ubx_msgs__msg__UBXNavVelECEF () } } fn create_msg () -> * mut ublox_ubx_msgs__msg__UBXNavVelECEF { unsafe { ublox_ubx_msgs__msg__UBXNavVelECEF__create () } } fn destroy_msg (msg : * mut ublox_ubx_msgs__msg__UBXNavVelECEF) -> () { unsafe { ublox_ubx_msgs__msg__UBXNavVelECEF__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> UBXNavVelECEF { UBXNavVelECEF { header : std_msgs :: msg :: Header :: from_native (& msg . header) , itow : msg . itow , ecef_vx : msg . ecef_vx , ecef_vy : msg . ecef_vy , ecef_vz : msg . ecef_vz , s_acc : msg . s_acc , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . itow = self . itow ; msg . ecef_vx = self . ecef_vx ; msg . ecef_vy = self . ecef_vy ; msg . ecef_vz = self . ecef_vz ; msg . s_acc = self . s_acc ; } } impl Default for UBXNavVelECEF { fn default () -> Self { let msg_native = WrappedNativeMsg :: < UBXNavVelECEF > :: new () ; UBXNavVelECEF :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct UBXNavVelNED { pub header : std_msgs :: msg :: Header , pub itow : u32 , pub vel_n : i32 , pub vel_e : i32 , pub vel_d : i32 , pub speed : u32 , pub g_speed : u32 , pub heading : i32 , pub s_acc : u32 , pub c_acc : u32 } impl WrappedTypesupport for UBXNavVelNED { type CStruct = ublox_ubx_msgs__msg__UBXNavVelNED ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ublox_ubx_msgs__msg__UBXNavVelNED () } } fn create_msg () -> * mut ublox_ubx_msgs__msg__UBXNavVelNED { unsafe { ublox_ubx_msgs__msg__UBXNavVelNED__create () } } fn destroy_msg (msg : * mut ublox_ubx_msgs__msg__UBXNavVelNED) -> () { unsafe { ublox_ubx_msgs__msg__UBXNavVelNED__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> UBXNavVelNED { UBXNavVelNED { header : std_msgs :: msg :: Header :: from_native (& msg . header) , itow : msg . itow , vel_n : msg . vel_n , vel_e : msg . vel_e , vel_d : msg . vel_d , speed : msg . speed , g_speed : msg . g_speed , heading : msg . heading , s_acc : msg . s_acc , c_acc : msg . c_acc , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . itow = self . itow ; msg . vel_n = self . vel_n ; msg . vel_e = self . vel_e ; msg . vel_d = self . vel_d ; msg . speed = self . speed ; msg . g_speed = self . g_speed ; msg . heading = self . heading ; msg . s_acc = self . s_acc ; msg . c_acc = self . c_acc ; } } impl Default for UBXNavVelNED { fn default () -> Self { let msg_native = WrappedNativeMsg :: < UBXNavVelNED > :: new () ; UBXNavVelNED :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct UtcStd { pub id : u8 } impl WrappedTypesupport for UtcStd { type CStruct = ublox_ubx_msgs__msg__UtcStd ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ublox_ubx_msgs__msg__UtcStd () } } fn create_msg () -> * mut ublox_ubx_msgs__msg__UtcStd { unsafe { ublox_ubx_msgs__msg__UtcStd__create () } } fn destroy_msg (msg : * mut ublox_ubx_msgs__msg__UtcStd) -> () { unsafe { ublox_ubx_msgs__msg__UtcStd__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> UtcStd { UtcStd { id : msg . id , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . id = self . id ; } } impl Default for UtcStd { fn default () -> Self { let msg_native = WrappedNativeMsg :: < UtcStd > :: new () ; UtcStd :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl UtcStd { pub const BIPM : _bindgen_ty_2481 = ublox_ubx_msgs__msg__UtcStd__BIPM ; pub const CRL : _bindgen_ty_2478 = ublox_ubx_msgs__msg__UtcStd__CRL ; pub const EURO : _bindgen_ty_2482 = ublox_ubx_msgs__msg__UtcStd__EURO ; pub const NIST : _bindgen_ty_2479 = ublox_ubx_msgs__msg__UtcStd__NIST ; pub const NOT_AVAILABLE : _bindgen_ty_2477 = ublox_ubx_msgs__msg__UtcStd__NOT_AVAILABLE ; pub const NTSC : _bindgen_ty_2484 = ublox_ubx_msgs__msg__UtcStd__NTSC ; pub const SU : _bindgen_ty_2483 = ublox_ubx_msgs__msg__UtcStd__SU ; pub const USNO : _bindgen_ty_2480 = ublox_ubx_msgs__msg__UtcStd__USNO ; pub const UTC_UNKNOWN : _bindgen_ty_2485 = ublox_ubx_msgs__msg__UtcStd__UTC_UNKNOWN ; } }