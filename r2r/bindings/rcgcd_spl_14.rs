pub mod msg { use super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct RCGCD { pub packet_number : u8 , pub players_per_team : u8 , pub competition_phase : u8 , pub competition_type : u8 , pub game_phase : u8 , pub state : u8 , pub set_play : u8 , pub first_half : u8 , pub kicking_team : u8 , pub secs_remaining : i16 , pub secondary_time : i16 , pub teams : Vec < rcgcd_spl_14 :: msg :: TeamInfo > } impl WrappedTypesupport for RCGCD { type CStruct = rcgcd_spl_14__msg__RCGCD ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rcgcd_spl_14__msg__RCGCD () } } fn create_msg () -> * mut rcgcd_spl_14__msg__RCGCD { unsafe { rcgcd_spl_14__msg__RCGCD__create () } } fn destroy_msg (msg : * mut rcgcd_spl_14__msg__RCGCD) -> () { unsafe { rcgcd_spl_14__msg__RCGCD__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> RCGCD { RCGCD { packet_number : msg . packet_number , players_per_team : msg . players_per_team , competition_phase : msg . competition_phase , competition_type : msg . competition_type , game_phase : msg . game_phase , state : msg . state , set_play : msg . set_play , first_half : msg . first_half , kicking_team : msg . kicking_team , secs_remaining : msg . secs_remaining , secondary_time : msg . secondary_time , teams : { let vec : Vec < _ > = msg . teams . iter () . map (| s | rcgcd_spl_14 :: msg :: TeamInfo :: from_native (s)) . collect () ; vec } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . packet_number = self . packet_number ; msg . players_per_team = self . players_per_team ; msg . competition_phase = self . competition_phase ; msg . competition_type = self . competition_type ; msg . game_phase = self . game_phase ; msg . state = self . state ; msg . set_play = self . set_play ; msg . first_half = self . first_half ; msg . kicking_team = self . kicking_team ; msg . secs_remaining = self . secs_remaining ; msg . secondary_time = self . secondary_time ; assert_eq ! (self . teams . len () , 2usize , "Field {} is fixed size of {}!" , "teams" , 2usize) ; for (t , s) in msg . teams . iter_mut () . zip (& self . teams) { s . copy_to_native (t) ; } } } impl Default for RCGCD { fn default () -> Self { let msg_native = WrappedNativeMsg :: < RCGCD > :: new () ; RCGCD :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl RCGCD { pub const COMPETIION_PHASE_PLAYOFF : _bindgen_ty_1432 = rcgcd_spl_14__msg__RCGCD__COMPETIION_PHASE_PLAYOFF ; pub const COMPETITION_PHASE_ROUNDROBIN : _bindgen_ty_1431 = rcgcd_spl_14__msg__RCGCD__COMPETITION_PHASE_ROUNDROBIN ; pub const COMPETITION_TYPE_7V7 : _bindgen_ty_1435 = rcgcd_spl_14__msg__RCGCD__COMPETITION_TYPE_7V7 ; pub const COMPETITION_TYPE_CHALLENGE_SHIELD : _bindgen_ty_1434 = rcgcd_spl_14__msg__RCGCD__COMPETITION_TYPE_CHALLENGE_SHIELD ; pub const COMPETITION_TYPE_DYNAMIC_BALL_HANDLING : _bindgen_ty_1436 = rcgcd_spl_14__msg__RCGCD__COMPETITION_TYPE_DYNAMIC_BALL_HANDLING ; pub const COMPETITION_TYPE_NORMAL : _bindgen_ty_1433 = rcgcd_spl_14__msg__RCGCD__COMPETITION_TYPE_NORMAL ; pub const GAME_PHASE_NORMAL : _bindgen_ty_1437 = rcgcd_spl_14__msg__RCGCD__GAME_PHASE_NORMAL ; pub const GAME_PHASE_OVERTIME : _bindgen_ty_1439 = rcgcd_spl_14__msg__RCGCD__GAME_PHASE_OVERTIME ; pub const GAME_PHASE_PENALTYSHOOT : _bindgen_ty_1438 = rcgcd_spl_14__msg__RCGCD__GAME_PHASE_PENALTYSHOOT ; pub const GAME_PHASE_TIMEOUT : _bindgen_ty_1440 = rcgcd_spl_14__msg__RCGCD__GAME_PHASE_TIMEOUT ; pub const SET_PLAY_CORNER_KICK : _bindgen_ty_1449 = rcgcd_spl_14__msg__RCGCD__SET_PLAY_CORNER_KICK ; pub const SET_PLAY_GOAL_KICK : _bindgen_ty_1447 = rcgcd_spl_14__msg__RCGCD__SET_PLAY_GOAL_KICK ; pub const SET_PLAY_KICK_IN : _bindgen_ty_1450 = rcgcd_spl_14__msg__RCGCD__SET_PLAY_KICK_IN ; pub const SET_PLAY_NONE : _bindgen_ty_1446 = rcgcd_spl_14__msg__RCGCD__SET_PLAY_NONE ; pub const SET_PLAY_PENALTY_KICK : _bindgen_ty_1451 = rcgcd_spl_14__msg__RCGCD__SET_PLAY_PENALTY_KICK ; pub const SET_PLAY_PUSHING_FREE_KICK : _bindgen_ty_1448 = rcgcd_spl_14__msg__RCGCD__SET_PLAY_PUSHING_FREE_KICK ; pub const STATE_FINISHED : _bindgen_ty_1445 = rcgcd_spl_14__msg__RCGCD__STATE_FINISHED ; pub const STATE_INITIAL : _bindgen_ty_1441 = rcgcd_spl_14__msg__RCGCD__STATE_INITIAL ; pub const STATE_PLAYING : _bindgen_ty_1444 = rcgcd_spl_14__msg__RCGCD__STATE_PLAYING ; pub const STATE_READY : _bindgen_ty_1442 = rcgcd_spl_14__msg__RCGCD__STATE_READY ; pub const STATE_SET : _bindgen_ty_1443 = rcgcd_spl_14__msg__RCGCD__STATE_SET ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct RobotInfo { pub penalty : u8 , pub secs_till_unpenalised : u8 } impl WrappedTypesupport for RobotInfo { type CStruct = rcgcd_spl_14__msg__RobotInfo ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rcgcd_spl_14__msg__RobotInfo () } } fn create_msg () -> * mut rcgcd_spl_14__msg__RobotInfo { unsafe { rcgcd_spl_14__msg__RobotInfo__create () } } fn destroy_msg (msg : * mut rcgcd_spl_14__msg__RobotInfo) -> () { unsafe { rcgcd_spl_14__msg__RobotInfo__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> RobotInfo { RobotInfo { penalty : msg . penalty , secs_till_unpenalised : msg . secs_till_unpenalised , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . penalty = self . penalty ; msg . secs_till_unpenalised = self . secs_till_unpenalised ; } } impl Default for RobotInfo { fn default () -> Self { let msg_native = WrappedNativeMsg :: < RobotInfo > :: new () ; RobotInfo :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl RobotInfo { pub const PENALTY_MANUAL : _bindgen_ty_1473 = rcgcd_spl_14__msg__RobotInfo__PENALTY_MANUAL ; pub const PENALTY_NONE : _bindgen_ty_1462 = rcgcd_spl_14__msg__RobotInfo__PENALTY_NONE ; pub const PENALTY_SPL_ILLEGAL_BALL_CONTACT : _bindgen_ty_1463 = rcgcd_spl_14__msg__RobotInfo__PENALTY_SPL_ILLEGAL_BALL_CONTACT ; pub const PENALTY_SPL_ILLEGAL_MOTION_IN_SET : _bindgen_ty_1465 = rcgcd_spl_14__msg__RobotInfo__PENALTY_SPL_ILLEGAL_MOTION_IN_SET ; pub const PENALTY_SPL_ILLEGAL_POSITION : _bindgen_ty_1467 = rcgcd_spl_14__msg__RobotInfo__PENALTY_SPL_ILLEGAL_POSITION ; pub const PENALTY_SPL_ILLEGAL_POSITION_IN_SET : _bindgen_ty_1471 = rcgcd_spl_14__msg__RobotInfo__PENALTY_SPL_ILLEGAL_POSITION_IN_SET ; pub const PENALTY_SPL_INACTIVE_PLAYER : _bindgen_ty_1466 = rcgcd_spl_14__msg__RobotInfo__PENALTY_SPL_INACTIVE_PLAYER ; pub const PENALTY_SPL_LEAVING_THE_FIELD : _bindgen_ty_1468 = rcgcd_spl_14__msg__RobotInfo__PENALTY_SPL_LEAVING_THE_FIELD ; pub const PENALTY_SPL_LOCAL_GAME_STUCK : _bindgen_ty_1470 = rcgcd_spl_14__msg__RobotInfo__PENALTY_SPL_LOCAL_GAME_STUCK ; pub const PENALTY_SPL_PLAYER_PUSHING : _bindgen_ty_1464 = rcgcd_spl_14__msg__RobotInfo__PENALTY_SPL_PLAYER_PUSHING ; pub const PENALTY_SPL_REQUEST_FOR_PICKUP : _bindgen_ty_1469 = rcgcd_spl_14__msg__RobotInfo__PENALTY_SPL_REQUEST_FOR_PICKUP ; pub const PENALTY_SUBSTITUTE : _bindgen_ty_1472 = rcgcd_spl_14__msg__RobotInfo__PENALTY_SUBSTITUTE ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct TeamInfo { pub team_number : u8 , pub team_colour : u8 , pub score : u8 , pub penalty_shot : u8 , pub single_shots : u16 , pub message_budget : u16 , pub players : Vec < rcgcd_spl_14 :: msg :: RobotInfo > } impl WrappedTypesupport for TeamInfo { type CStruct = rcgcd_spl_14__msg__TeamInfo ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rcgcd_spl_14__msg__TeamInfo () } } fn create_msg () -> * mut rcgcd_spl_14__msg__TeamInfo { unsafe { rcgcd_spl_14__msg__TeamInfo__create () } } fn destroy_msg (msg : * mut rcgcd_spl_14__msg__TeamInfo) -> () { unsafe { rcgcd_spl_14__msg__TeamInfo__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> TeamInfo { TeamInfo { team_number : msg . team_number , team_colour : msg . team_colour , score : msg . score , penalty_shot : msg . penalty_shot , single_shots : msg . single_shots , message_budget : msg . message_budget , players : { let vec : Vec < _ > = msg . players . iter () . map (| s | rcgcd_spl_14 :: msg :: RobotInfo :: from_native (s)) . collect () ; vec } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . team_number = self . team_number ; msg . team_colour = self . team_colour ; msg . score = self . score ; msg . penalty_shot = self . penalty_shot ; msg . single_shots = self . single_shots ; msg . message_budget = self . message_budget ; assert_eq ! (self . players . len () , 7usize , "Field {} is fixed size of {}!" , "players" , 7usize) ; for (t , s) in msg . players . iter_mut () . zip (& self . players) { s . copy_to_native (t) ; } } } impl Default for TeamInfo { fn default () -> Self { let msg_native = WrappedNativeMsg :: < TeamInfo > :: new () ; TeamInfo :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl TeamInfo { pub const TEAM_BLACK : _bindgen_ty_1455 = rcgcd_spl_14__msg__TeamInfo__TEAM_BLACK ; pub const TEAM_BLUE : _bindgen_ty_1452 = rcgcd_spl_14__msg__TeamInfo__TEAM_BLUE ; pub const TEAM_BROWN : _bindgen_ty_1460 = rcgcd_spl_14__msg__TeamInfo__TEAM_BROWN ; pub const TEAM_GRAY : _bindgen_ty_1461 = rcgcd_spl_14__msg__TeamInfo__TEAM_GRAY ; pub const TEAM_GREEN : _bindgen_ty_1457 = rcgcd_spl_14__msg__TeamInfo__TEAM_GREEN ; pub const TEAM_ORANGE : _bindgen_ty_1458 = rcgcd_spl_14__msg__TeamInfo__TEAM_ORANGE ; pub const TEAM_PURPLE : _bindgen_ty_1459 = rcgcd_spl_14__msg__TeamInfo__TEAM_PURPLE ; pub const TEAM_RED : _bindgen_ty_1453 = rcgcd_spl_14__msg__TeamInfo__TEAM_RED ; pub const TEAM_WHITE : _bindgen_ty_1456 = rcgcd_spl_14__msg__TeamInfo__TEAM_WHITE ; pub const TEAM_YELLOW : _bindgen_ty_1454 = rcgcd_spl_14__msg__TeamInfo__TEAM_YELLOW ; } }