pub mod srv { # [allow (non_snake_case)] pub mod SetIO { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__ur_msgs__srv__SetIO () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub fun : i8 , pub pin : i8 , pub state : f32 } impl WrappedTypesupport for Request { type CStruct = ur_msgs__srv__SetIO_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ur_msgs__srv__SetIO_Request () } } fn create_msg () -> * mut ur_msgs__srv__SetIO_Request { unsafe { ur_msgs__srv__SetIO_Request__create () } } fn destroy_msg (msg : * mut ur_msgs__srv__SetIO_Request) -> () { unsafe { ur_msgs__srv__SetIO_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { fun : msg . fun , pin : msg . pin , state : msg . state , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . fun = self . fun ; msg . pin = self . pin ; msg . state = self . state ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl Request { pub const FUN_SET_ANALOG_OUT : _bindgen_ty_2538 = ur_msgs__srv__SetIO_Request__FUN_SET_ANALOG_OUT ; pub const FUN_SET_DIGITAL_OUT : _bindgen_ty_2536 = ur_msgs__srv__SetIO_Request__FUN_SET_DIGITAL_OUT ; pub const FUN_SET_FLAG : _bindgen_ty_2537 = ur_msgs__srv__SetIO_Request__FUN_SET_FLAG ; pub const FUN_SET_TOOL_VOLTAGE : _bindgen_ty_2539 = ur_msgs__srv__SetIO_Request__FUN_SET_TOOL_VOLTAGE ; pub const PIN_AOUT0 : _bindgen_ty_2516 = ur_msgs__srv__SetIO_Request__PIN_AOUT0 ; pub const PIN_AOUT1 : _bindgen_ty_2517 = ur_msgs__srv__SetIO_Request__PIN_AOUT1 ; pub const PIN_CONF_OUT0 : _bindgen_ty_2526 = ur_msgs__srv__SetIO_Request__PIN_CONF_OUT0 ; pub const PIN_CONF_OUT1 : _bindgen_ty_2527 = ur_msgs__srv__SetIO_Request__PIN_CONF_OUT1 ; pub const PIN_CONF_OUT2 : _bindgen_ty_2528 = ur_msgs__srv__SetIO_Request__PIN_CONF_OUT2 ; pub const PIN_CONF_OUT3 : _bindgen_ty_2529 = ur_msgs__srv__SetIO_Request__PIN_CONF_OUT3 ; pub const PIN_CONF_OUT4 : _bindgen_ty_2530 = ur_msgs__srv__SetIO_Request__PIN_CONF_OUT4 ; pub const PIN_CONF_OUT5 : _bindgen_ty_2531 = ur_msgs__srv__SetIO_Request__PIN_CONF_OUT5 ; pub const PIN_CONF_OUT6 : _bindgen_ty_2532 = ur_msgs__srv__SetIO_Request__PIN_CONF_OUT6 ; pub const PIN_CONF_OUT7 : _bindgen_ty_2533 = ur_msgs__srv__SetIO_Request__PIN_CONF_OUT7 ; pub const PIN_DOUT0 : _bindgen_ty_2518 = ur_msgs__srv__SetIO_Request__PIN_DOUT0 ; pub const PIN_DOUT1 : _bindgen_ty_2519 = ur_msgs__srv__SetIO_Request__PIN_DOUT1 ; pub const PIN_DOUT2 : _bindgen_ty_2520 = ur_msgs__srv__SetIO_Request__PIN_DOUT2 ; pub const PIN_DOUT3 : _bindgen_ty_2521 = ur_msgs__srv__SetIO_Request__PIN_DOUT3 ; pub const PIN_DOUT4 : _bindgen_ty_2522 = ur_msgs__srv__SetIO_Request__PIN_DOUT4 ; pub const PIN_DOUT5 : _bindgen_ty_2523 = ur_msgs__srv__SetIO_Request__PIN_DOUT5 ; pub const PIN_DOUT6 : _bindgen_ty_2524 = ur_msgs__srv__SetIO_Request__PIN_DOUT6 ; pub const PIN_DOUT7 : _bindgen_ty_2525 = ur_msgs__srv__SetIO_Request__PIN_DOUT7 ; pub const PIN_TOOL_DOUT0 : _bindgen_ty_2534 = ur_msgs__srv__SetIO_Request__PIN_TOOL_DOUT0 ; pub const PIN_TOOL_DOUT1 : _bindgen_ty_2535 = ur_msgs__srv__SetIO_Request__PIN_TOOL_DOUT1 ; pub const STATE_OFF : _bindgen_ty_2540 = ur_msgs__srv__SetIO_Request__STATE_OFF ; pub const STATE_ON : _bindgen_ty_2541 = ur_msgs__srv__SetIO_Request__STATE_ON ; pub const STATE_TOOL_VOLTAGE_0V : _bindgen_ty_2542 = ur_msgs__srv__SetIO_Request__STATE_TOOL_VOLTAGE_0V ; pub const STATE_TOOL_VOLTAGE_12V : _bindgen_ty_2543 = ur_msgs__srv__SetIO_Request__STATE_TOOL_VOLTAGE_12V ; pub const STATE_TOOL_VOLTAGE_24V : _bindgen_ty_2544 = ur_msgs__srv__SetIO_Request__STATE_TOOL_VOLTAGE_24V ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool } impl WrappedTypesupport for Response { type CStruct = ur_msgs__srv__SetIO_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ur_msgs__srv__SetIO_Response () } } fn create_msg () -> * mut ur_msgs__srv__SetIO_Response { unsafe { ur_msgs__srv__SetIO_Response__create () } } fn destroy_msg (msg : * mut ur_msgs__srv__SetIO_Response) -> () { unsafe { ur_msgs__srv__SetIO_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod SetPayload { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__ur_msgs__srv__SetPayload () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub mass : f32 , pub center_of_gravity : geometry_msgs :: msg :: Vector3 } impl WrappedTypesupport for Request { type CStruct = ur_msgs__srv__SetPayload_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ur_msgs__srv__SetPayload_Request () } } fn create_msg () -> * mut ur_msgs__srv__SetPayload_Request { unsafe { ur_msgs__srv__SetPayload_Request__create () } } fn destroy_msg (msg : * mut ur_msgs__srv__SetPayload_Request) -> () { unsafe { ur_msgs__srv__SetPayload_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { mass : msg . mass , center_of_gravity : geometry_msgs :: msg :: Vector3 :: from_native (& msg . center_of_gravity) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . mass = self . mass ; self . center_of_gravity . copy_to_native (& mut msg . center_of_gravity) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool } impl WrappedTypesupport for Response { type CStruct = ur_msgs__srv__SetPayload_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ur_msgs__srv__SetPayload_Response () } } fn create_msg () -> * mut ur_msgs__srv__SetPayload_Response { unsafe { ur_msgs__srv__SetPayload_Response__create () } } fn destroy_msg (msg : * mut ur_msgs__srv__SetPayload_Response) -> () { unsafe { ur_msgs__srv__SetPayload_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod SetSpeedSliderFraction { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__ur_msgs__srv__SetSpeedSliderFraction () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub speed_slider_fraction : f64 } impl WrappedTypesupport for Request { type CStruct = ur_msgs__srv__SetSpeedSliderFraction_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ur_msgs__srv__SetSpeedSliderFraction_Request () } } fn create_msg () -> * mut ur_msgs__srv__SetSpeedSliderFraction_Request { unsafe { ur_msgs__srv__SetSpeedSliderFraction_Request__create () } } fn destroy_msg (msg : * mut ur_msgs__srv__SetSpeedSliderFraction_Request) -> () { unsafe { ur_msgs__srv__SetSpeedSliderFraction_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { speed_slider_fraction : msg . speed_slider_fraction , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . speed_slider_fraction = self . speed_slider_fraction ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool } impl WrappedTypesupport for Response { type CStruct = ur_msgs__srv__SetSpeedSliderFraction_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ur_msgs__srv__SetSpeedSliderFraction_Response () } } fn create_msg () -> * mut ur_msgs__srv__SetSpeedSliderFraction_Response { unsafe { ur_msgs__srv__SetSpeedSliderFraction_Response__create () } } fn destroy_msg (msg : * mut ur_msgs__srv__SetSpeedSliderFraction_Response) -> () { unsafe { ur_msgs__srv__SetSpeedSliderFraction_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } } pub mod msg { use super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Analog { pub pin : u8 , pub domain : u8 , pub state : f32 } impl WrappedTypesupport for Analog { type CStruct = ur_msgs__msg__Analog ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ur_msgs__msg__Analog () } } fn create_msg () -> * mut ur_msgs__msg__Analog { unsafe { ur_msgs__msg__Analog__create () } } fn destroy_msg (msg : * mut ur_msgs__msg__Analog) -> () { unsafe { ur_msgs__msg__Analog__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Analog { Analog { pin : msg . pin , domain : msg . domain , state : msg . state , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . pin = self . pin ; msg . domain = self . domain ; msg . state = self . state ; } } impl Default for Analog { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Analog > :: new () ; Analog :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl Analog { pub const CURRENT : _bindgen_ty_2509 = ur_msgs__msg__Analog__CURRENT ; pub const VOLTAGE : _bindgen_ty_2510 = ur_msgs__msg__Analog__VOLTAGE ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Digital { pub pin : u8 , pub state : bool } impl WrappedTypesupport for Digital { type CStruct = ur_msgs__msg__Digital ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ur_msgs__msg__Digital () } } fn create_msg () -> * mut ur_msgs__msg__Digital { unsafe { ur_msgs__msg__Digital__create () } } fn destroy_msg (msg : * mut ur_msgs__msg__Digital) -> () { unsafe { ur_msgs__msg__Digital__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Digital { Digital { pin : msg . pin , state : msg . state , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . pin = self . pin ; msg . state = self . state ; } } impl Default for Digital { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Digital > :: new () ; Digital :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct IOStates { pub digital_in_states : Vec < ur_msgs :: msg :: Digital > , pub digital_out_states : Vec < ur_msgs :: msg :: Digital > , pub flag_states : Vec < ur_msgs :: msg :: Digital > , pub analog_in_states : Vec < ur_msgs :: msg :: Analog > , pub analog_out_states : Vec < ur_msgs :: msg :: Analog > } impl WrappedTypesupport for IOStates { type CStruct = ur_msgs__msg__IOStates ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ur_msgs__msg__IOStates () } } fn create_msg () -> * mut ur_msgs__msg__IOStates { unsafe { ur_msgs__msg__IOStates__create () } } fn destroy_msg (msg : * mut ur_msgs__msg__IOStates) -> () { unsafe { ur_msgs__msg__IOStates__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> IOStates { IOStates { digital_in_states : { let mut temp = Vec :: with_capacity (msg . digital_in_states . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . digital_in_states . data , msg . digital_in_states . size) } ; for s in slice { temp . push (ur_msgs :: msg :: Digital :: from_native (s)) ; } temp } , digital_out_states : { let mut temp = Vec :: with_capacity (msg . digital_out_states . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . digital_out_states . data , msg . digital_out_states . size) } ; for s in slice { temp . push (ur_msgs :: msg :: Digital :: from_native (s)) ; } temp } , flag_states : { let mut temp = Vec :: with_capacity (msg . flag_states . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . flag_states . data , msg . flag_states . size) } ; for s in slice { temp . push (ur_msgs :: msg :: Digital :: from_native (s)) ; } temp } , analog_in_states : { let mut temp = Vec :: with_capacity (msg . analog_in_states . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . analog_in_states . data , msg . analog_in_states . size) } ; for s in slice { temp . push (ur_msgs :: msg :: Analog :: from_native (s)) ; } temp } , analog_out_states : { let mut temp = Vec :: with_capacity (msg . analog_out_states . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . analog_out_states . data , msg . analog_out_states . size) } ; for s in slice { temp . push (ur_msgs :: msg :: Analog :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { unsafe { ur_msgs__msg__Digital__Sequence__fini (& mut msg . digital_in_states) ; ur_msgs__msg__Digital__Sequence__init (& mut msg . digital_in_states , self . digital_in_states . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . digital_in_states . data , msg . digital_in_states . size) ; for (t , s) in slice . iter_mut () . zip (& self . digital_in_states) { s . copy_to_native (t) ; } } unsafe { ur_msgs__msg__Digital__Sequence__fini (& mut msg . digital_out_states) ; ur_msgs__msg__Digital__Sequence__init (& mut msg . digital_out_states , self . digital_out_states . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . digital_out_states . data , msg . digital_out_states . size) ; for (t , s) in slice . iter_mut () . zip (& self . digital_out_states) { s . copy_to_native (t) ; } } unsafe { ur_msgs__msg__Digital__Sequence__fini (& mut msg . flag_states) ; ur_msgs__msg__Digital__Sequence__init (& mut msg . flag_states , self . flag_states . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . flag_states . data , msg . flag_states . size) ; for (t , s) in slice . iter_mut () . zip (& self . flag_states) { s . copy_to_native (t) ; } } unsafe { ur_msgs__msg__Analog__Sequence__fini (& mut msg . analog_in_states) ; ur_msgs__msg__Analog__Sequence__init (& mut msg . analog_in_states , self . analog_in_states . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . analog_in_states . data , msg . analog_in_states . size) ; for (t , s) in slice . iter_mut () . zip (& self . analog_in_states) { s . copy_to_native (t) ; } } unsafe { ur_msgs__msg__Analog__Sequence__fini (& mut msg . analog_out_states) ; ur_msgs__msg__Analog__Sequence__init (& mut msg . analog_out_states , self . analog_out_states . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . analog_out_states . data , msg . analog_out_states . size) ; for (t , s) in slice . iter_mut () . zip (& self . analog_out_states) { s . copy_to_native (t) ; } } } } impl Default for IOStates { fn default () -> Self { let msg_native = WrappedNativeMsg :: < IOStates > :: new () ; IOStates :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct MasterboardDataMsg { pub digital_input_bits : u32 , pub digital_output_bits : u32 , pub analog_input_range0 : i8 , pub analog_input_range1 : i8 , pub analog_input0 : f64 , pub analog_input1 : f64 , pub analog_output_domain0 : i8 , pub analog_output_domain1 : i8 , pub analog_output0 : f64 , pub analog_output1 : f64 , pub masterboard_temperature : f32 , pub robot_voltage_48v : f32 , pub robot_current : f32 , pub master_io_current : f32 , pub master_safety_state : u8 , pub master_onoff_state : u8 } impl WrappedTypesupport for MasterboardDataMsg { type CStruct = ur_msgs__msg__MasterboardDataMsg ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ur_msgs__msg__MasterboardDataMsg () } } fn create_msg () -> * mut ur_msgs__msg__MasterboardDataMsg { unsafe { ur_msgs__msg__MasterboardDataMsg__create () } } fn destroy_msg (msg : * mut ur_msgs__msg__MasterboardDataMsg) -> () { unsafe { ur_msgs__msg__MasterboardDataMsg__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> MasterboardDataMsg { MasterboardDataMsg { digital_input_bits : msg . digital_input_bits , digital_output_bits : msg . digital_output_bits , analog_input_range0 : msg . analog_input_range0 , analog_input_range1 : msg . analog_input_range1 , analog_input0 : msg . analog_input0 , analog_input1 : msg . analog_input1 , analog_output_domain0 : msg . analog_output_domain0 , analog_output_domain1 : msg . analog_output_domain1 , analog_output0 : msg . analog_output0 , analog_output1 : msg . analog_output1 , masterboard_temperature : msg . masterboard_temperature , robot_voltage_48v : msg . robot_voltage_48v , robot_current : msg . robot_current , master_io_current : msg . master_io_current , master_safety_state : msg . master_safety_state , master_onoff_state : msg . master_onoff_state , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . digital_input_bits = self . digital_input_bits ; msg . digital_output_bits = self . digital_output_bits ; msg . analog_input_range0 = self . analog_input_range0 ; msg . analog_input_range1 = self . analog_input_range1 ; msg . analog_input0 = self . analog_input0 ; msg . analog_input1 = self . analog_input1 ; msg . analog_output_domain0 = self . analog_output_domain0 ; msg . analog_output_domain1 = self . analog_output_domain1 ; msg . analog_output0 = self . analog_output0 ; msg . analog_output1 = self . analog_output1 ; msg . masterboard_temperature = self . masterboard_temperature ; msg . robot_voltage_48v = self . robot_voltage_48v ; msg . robot_current = self . robot_current ; msg . master_io_current = self . master_io_current ; msg . master_safety_state = self . master_safety_state ; msg . master_onoff_state = self . master_onoff_state ; } } impl Default for MasterboardDataMsg { fn default () -> Self { let msg_native = WrappedNativeMsg :: < MasterboardDataMsg > :: new () ; MasterboardDataMsg :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct RobotModeDataMsg { pub timestamp : u64 , pub is_robot_connected : bool , pub is_real_robot_enabled : bool , pub is_power_on_robot : bool , pub is_emergency_stopped : bool , pub is_protective_stopped : bool , pub is_program_running : bool , pub is_program_paused : bool } impl WrappedTypesupport for RobotModeDataMsg { type CStruct = ur_msgs__msg__RobotModeDataMsg ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ur_msgs__msg__RobotModeDataMsg () } } fn create_msg () -> * mut ur_msgs__msg__RobotModeDataMsg { unsafe { ur_msgs__msg__RobotModeDataMsg__create () } } fn destroy_msg (msg : * mut ur_msgs__msg__RobotModeDataMsg) -> () { unsafe { ur_msgs__msg__RobotModeDataMsg__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> RobotModeDataMsg { RobotModeDataMsg { timestamp : msg . timestamp , is_robot_connected : msg . is_robot_connected , is_real_robot_enabled : msg . is_real_robot_enabled , is_power_on_robot : msg . is_power_on_robot , is_emergency_stopped : msg . is_emergency_stopped , is_protective_stopped : msg . is_protective_stopped , is_program_running : msg . is_program_running , is_program_paused : msg . is_program_paused , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . timestamp = self . timestamp ; msg . is_robot_connected = self . is_robot_connected ; msg . is_real_robot_enabled = self . is_real_robot_enabled ; msg . is_power_on_robot = self . is_power_on_robot ; msg . is_emergency_stopped = self . is_emergency_stopped ; msg . is_protective_stopped = self . is_protective_stopped ; msg . is_program_running = self . is_program_running ; msg . is_program_paused = self . is_program_paused ; } } impl Default for RobotModeDataMsg { fn default () -> Self { let msg_native = WrappedNativeMsg :: < RobotModeDataMsg > :: new () ; RobotModeDataMsg :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct RobotStateRTMsg { pub time : f64 , pub q_target : Vec < f64 > , pub qd_target : Vec < f64 > , pub qdd_target : Vec < f64 > , pub i_target : Vec < f64 > , pub m_target : Vec < f64 > , pub q_actual : Vec < f64 > , pub qd_actual : Vec < f64 > , pub i_actual : Vec < f64 > , pub tool_acc_values : Vec < f64 > , pub tcp_force : Vec < f64 > , pub tool_vector : Vec < f64 > , pub tcp_speed : Vec < f64 > , pub digital_input_bits : f64 , pub motor_temperatures : Vec < f64 > , pub controller_timer : f64 , pub test_value : f64 , pub robot_mode : f64 , pub joint_modes : Vec < f64 > } impl WrappedTypesupport for RobotStateRTMsg { type CStruct = ur_msgs__msg__RobotStateRTMsg ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ur_msgs__msg__RobotStateRTMsg () } } fn create_msg () -> * mut ur_msgs__msg__RobotStateRTMsg { unsafe { ur_msgs__msg__RobotStateRTMsg__create () } } fn destroy_msg (msg : * mut ur_msgs__msg__RobotStateRTMsg) -> () { unsafe { ur_msgs__msg__RobotStateRTMsg__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> RobotStateRTMsg { RobotStateRTMsg { time : msg . time , q_target : msg . q_target . to_vec () , qd_target : msg . qd_target . to_vec () , qdd_target : msg . qdd_target . to_vec () , i_target : msg . i_target . to_vec () , m_target : msg . m_target . to_vec () , q_actual : msg . q_actual . to_vec () , qd_actual : msg . qd_actual . to_vec () , i_actual : msg . i_actual . to_vec () , tool_acc_values : msg . tool_acc_values . to_vec () , tcp_force : msg . tcp_force . to_vec () , tool_vector : msg . tool_vector . to_vec () , tcp_speed : msg . tcp_speed . to_vec () , digital_input_bits : msg . digital_input_bits , motor_temperatures : msg . motor_temperatures . to_vec () , controller_timer : msg . controller_timer , test_value : msg . test_value , robot_mode : msg . robot_mode , joint_modes : msg . joint_modes . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . time = self . time ; msg . q_target . update (& self . q_target) ; msg . qd_target . update (& self . qd_target) ; msg . qdd_target . update (& self . qdd_target) ; msg . i_target . update (& self . i_target) ; msg . m_target . update (& self . m_target) ; msg . q_actual . update (& self . q_actual) ; msg . qd_actual . update (& self . qd_actual) ; msg . i_actual . update (& self . i_actual) ; msg . tool_acc_values . update (& self . tool_acc_values) ; msg . tcp_force . update (& self . tcp_force) ; msg . tool_vector . update (& self . tool_vector) ; msg . tcp_speed . update (& self . tcp_speed) ; msg . digital_input_bits = self . digital_input_bits ; msg . motor_temperatures . update (& self . motor_temperatures) ; msg . controller_timer = self . controller_timer ; msg . test_value = self . test_value ; msg . robot_mode = self . robot_mode ; msg . joint_modes . update (& self . joint_modes) ; } } impl Default for RobotStateRTMsg { fn default () -> Self { let msg_native = WrappedNativeMsg :: < RobotStateRTMsg > :: new () ; RobotStateRTMsg :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ToolDataMsg { pub analog_input_range2 : i8 , pub analog_input_range3 : i8 , pub analog_input2 : f64 , pub analog_input3 : f64 , pub tool_voltage_48v : f32 , pub tool_output_voltage : u8 , pub tool_current : f32 , pub tool_temperature : f32 , pub tool_mode : u8 } impl WrappedTypesupport for ToolDataMsg { type CStruct = ur_msgs__msg__ToolDataMsg ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ur_msgs__msg__ToolDataMsg () } } fn create_msg () -> * mut ur_msgs__msg__ToolDataMsg { unsafe { ur_msgs__msg__ToolDataMsg__create () } } fn destroy_msg (msg : * mut ur_msgs__msg__ToolDataMsg) -> () { unsafe { ur_msgs__msg__ToolDataMsg__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ToolDataMsg { ToolDataMsg { analog_input_range2 : msg . analog_input_range2 , analog_input_range3 : msg . analog_input_range3 , analog_input2 : msg . analog_input2 , analog_input3 : msg . analog_input3 , tool_voltage_48v : msg . tool_voltage_48v , tool_output_voltage : msg . tool_output_voltage , tool_current : msg . tool_current , tool_temperature : msg . tool_temperature , tool_mode : msg . tool_mode , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . analog_input_range2 = self . analog_input_range2 ; msg . analog_input_range3 = self . analog_input_range3 ; msg . analog_input2 = self . analog_input2 ; msg . analog_input3 = self . analog_input3 ; msg . tool_voltage_48v = self . tool_voltage_48v ; msg . tool_output_voltage = self . tool_output_voltage ; msg . tool_current = self . tool_current ; msg . tool_temperature = self . tool_temperature ; msg . tool_mode = self . tool_mode ; } } impl Default for ToolDataMsg { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ToolDataMsg > :: new () ; ToolDataMsg :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl ToolDataMsg { pub const ANALOG_INPUT_RANGE_CURRENT : _bindgen_ty_2511 = ur_msgs__msg__ToolDataMsg__ANALOG_INPUT_RANGE_CURRENT ; pub const ANALOG_INPUT_RANGE_VOLTAGE : _bindgen_ty_2512 = ur_msgs__msg__ToolDataMsg__ANALOG_INPUT_RANGE_VOLTAGE ; pub const TOOL_BOOTLOADER_MODE : _bindgen_ty_2513 = ur_msgs__msg__ToolDataMsg__TOOL_BOOTLOADER_MODE ; pub const TOOL_IDLE_MODE : _bindgen_ty_2515 = ur_msgs__msg__ToolDataMsg__TOOL_IDLE_MODE ; pub const TOOL_RUNNING_MODE : _bindgen_ty_2514 = ur_msgs__msg__ToolDataMsg__TOOL_RUNNING_MODE ; } }