pub mod msg { use super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct SPLSM { pub player_num : u8 , pub team_num : u8 , pub fallen : u8 , pub pose : Vec < f32 > , pub ball_age : f32 , pub ball : Vec < f32 > , pub data : Vec < u8 > } impl WrappedTypesupport for SPLSM { type CStruct = splsm_7__msg__SPLSM ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__splsm_7__msg__SPLSM () } } fn create_msg () -> * mut splsm_7__msg__SPLSM { unsafe { splsm_7__msg__SPLSM__create () } } fn destroy_msg (msg : * mut splsm_7__msg__SPLSM) -> () { unsafe { splsm_7__msg__SPLSM__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> SPLSM { SPLSM { player_num : msg . player_num , team_num : msg . team_num , fallen : msg . fallen , pose : msg . pose . to_vec () , ball_age : msg . ball_age , ball : msg . ball . to_vec () , data : msg . data . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . player_num = self . player_num ; msg . team_num = self . team_num ; msg . fallen = self . fallen ; assert_eq ! (self . pose . len () , 3usize , "Field {} is fixed size of {}!" , "pose" , 3usize) ; msg . pose . copy_from_slice (& self . pose [.. 3usize]) ; msg . ball_age = self . ball_age ; assert_eq ! (self . ball . len () , 2usize , "Field {} is fixed size of {}!" , "ball" , 2usize) ; msg . ball . copy_from_slice (& self . ball [.. 2usize]) ; assert ! (self . data . len () <= 474usize , "Field {} is upper bounded by {}!" , "data" , 474usize) ; msg . data . update (& self . data) ; } } impl Default for SPLSM { fn default () -> Self { let msg_native = WrappedNativeMsg :: < SPLSM > :: new () ; SPLSM :: from_native (& msg_native) } } }