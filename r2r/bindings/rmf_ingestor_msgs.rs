pub mod msg { use super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct IngestorRequest { pub time : builtin_interfaces :: msg :: Time , pub request_guid : std :: string :: String , pub target_guid : std :: string :: String , pub transporter_type : std :: string :: String , pub items : Vec < rmf_ingestor_msgs :: msg :: IngestorRequestItem > } impl WrappedTypesupport for IngestorRequest { type CStruct = rmf_ingestor_msgs__msg__IngestorRequest ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_ingestor_msgs__msg__IngestorRequest () } } fn create_msg () -> * mut rmf_ingestor_msgs__msg__IngestorRequest { unsafe { rmf_ingestor_msgs__msg__IngestorRequest__create () } } fn destroy_msg (msg : * mut rmf_ingestor_msgs__msg__IngestorRequest) -> () { unsafe { rmf_ingestor_msgs__msg__IngestorRequest__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> IngestorRequest { IngestorRequest { time : builtin_interfaces :: msg :: Time :: from_native (& msg . time) , request_guid : msg . request_guid . to_str () . to_owned () , target_guid : msg . target_guid . to_str () . to_owned () , transporter_type : msg . transporter_type . to_str () . to_owned () , items : { let mut temp = Vec :: with_capacity (msg . items . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . items . data , msg . items . size) } ; for s in slice { temp . push (rmf_ingestor_msgs :: msg :: IngestorRequestItem :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . time . copy_to_native (& mut msg . time) ; msg . request_guid . assign (& self . request_guid) ; msg . target_guid . assign (& self . target_guid) ; msg . transporter_type . assign (& self . transporter_type) ; unsafe { rmf_ingestor_msgs__msg__IngestorRequestItem__Sequence__fini (& mut msg . items) ; rmf_ingestor_msgs__msg__IngestorRequestItem__Sequence__init (& mut msg . items , self . items . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . items . data , msg . items . size) ; for (t , s) in slice . iter_mut () . zip (& self . items) { s . copy_to_native (t) ; } } } } impl Default for IngestorRequest { fn default () -> Self { let msg_native = WrappedNativeMsg :: < IngestorRequest > :: new () ; IngestorRequest :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct IngestorRequestItem { pub type_guid : std :: string :: String , pub quantity : i32 , pub compartment_name : std :: string :: String } impl WrappedTypesupport for IngestorRequestItem { type CStruct = rmf_ingestor_msgs__msg__IngestorRequestItem ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_ingestor_msgs__msg__IngestorRequestItem () } } fn create_msg () -> * mut rmf_ingestor_msgs__msg__IngestorRequestItem { unsafe { rmf_ingestor_msgs__msg__IngestorRequestItem__create () } } fn destroy_msg (msg : * mut rmf_ingestor_msgs__msg__IngestorRequestItem) -> () { unsafe { rmf_ingestor_msgs__msg__IngestorRequestItem__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> IngestorRequestItem { IngestorRequestItem { type_guid : msg . type_guid . to_str () . to_owned () , quantity : msg . quantity , compartment_name : msg . compartment_name . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . type_guid . assign (& self . type_guid) ; msg . quantity = self . quantity ; msg . compartment_name . assign (& self . compartment_name) ; } } impl Default for IngestorRequestItem { fn default () -> Self { let msg_native = WrappedNativeMsg :: < IngestorRequestItem > :: new () ; IngestorRequestItem :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct IngestorResult { pub time : builtin_interfaces :: msg :: Time , pub request_guid : std :: string :: String , pub source_guid : std :: string :: String , pub status : u8 } impl WrappedTypesupport for IngestorResult { type CStruct = rmf_ingestor_msgs__msg__IngestorResult ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_ingestor_msgs__msg__IngestorResult () } } fn create_msg () -> * mut rmf_ingestor_msgs__msg__IngestorResult { unsafe { rmf_ingestor_msgs__msg__IngestorResult__create () } } fn destroy_msg (msg : * mut rmf_ingestor_msgs__msg__IngestorResult) -> () { unsafe { rmf_ingestor_msgs__msg__IngestorResult__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> IngestorResult { IngestorResult { time : builtin_interfaces :: msg :: Time :: from_native (& msg . time) , request_guid : msg . request_guid . to_str () . to_owned () , source_guid : msg . source_guid . to_str () . to_owned () , status : msg . status , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . time . copy_to_native (& mut msg . time) ; msg . request_guid . assign (& self . request_guid) ; msg . source_guid . assign (& self . source_guid) ; msg . status = self . status ; } } impl Default for IngestorResult { fn default () -> Self { let msg_native = WrappedNativeMsg :: < IngestorResult > :: new () ; IngestorResult :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl IngestorResult { pub const ACKNOWLEDGED : _bindgen_ty_1546 = rmf_ingestor_msgs__msg__IngestorResult__ACKNOWLEDGED ; pub const FAILED : _bindgen_ty_1548 = rmf_ingestor_msgs__msg__IngestorResult__FAILED ; pub const SUCCESS : _bindgen_ty_1547 = rmf_ingestor_msgs__msg__IngestorResult__SUCCESS ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct IngestorState { pub time : builtin_interfaces :: msg :: Time , pub guid : std :: string :: String , pub mode : i32 , pub request_guid_queue : Vec < std :: string :: String > , pub seconds_remaining : f32 } impl WrappedTypesupport for IngestorState { type CStruct = rmf_ingestor_msgs__msg__IngestorState ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_ingestor_msgs__msg__IngestorState () } } fn create_msg () -> * mut rmf_ingestor_msgs__msg__IngestorState { unsafe { rmf_ingestor_msgs__msg__IngestorState__create () } } fn destroy_msg (msg : * mut rmf_ingestor_msgs__msg__IngestorState) -> () { unsafe { rmf_ingestor_msgs__msg__IngestorState__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> IngestorState { IngestorState { time : builtin_interfaces :: msg :: Time :: from_native (& msg . time) , guid : msg . guid . to_str () . to_owned () , mode : msg . mode , request_guid_queue : msg . request_guid_queue . to_vec () , seconds_remaining : msg . seconds_remaining , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . time . copy_to_native (& mut msg . time) ; msg . guid . assign (& self . guid) ; msg . mode = self . mode ; msg . request_guid_queue . update (& self . request_guid_queue) ; msg . seconds_remaining = self . seconds_remaining ; } } impl Default for IngestorState { fn default () -> Self { let msg_native = WrappedNativeMsg :: < IngestorState > :: new () ; IngestorState :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl IngestorState { pub const BUSY : _bindgen_ty_1550 = rmf_ingestor_msgs__msg__IngestorState__BUSY ; pub const IDLE : _bindgen_ty_1549 = rmf_ingestor_msgs__msg__IngestorState__IDLE ; pub const OFFLINE : _bindgen_ty_1551 = rmf_ingestor_msgs__msg__IngestorState__OFFLINE ; } }