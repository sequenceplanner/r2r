pub mod msg { use super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct AffineImage { pub name : std :: string :: String , pub x_offset : f32 , pub y_offset : f32 , pub yaw : f32 , pub scale : f32 , pub encoding : std :: string :: String , pub data : Vec < u8 > } impl WrappedTypesupport for AffineImage { type CStruct = rmf_building_map_msgs__msg__AffineImage ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_building_map_msgs__msg__AffineImage () } } fn create_msg () -> * mut rmf_building_map_msgs__msg__AffineImage { unsafe { rmf_building_map_msgs__msg__AffineImage__create () } } fn destroy_msg (msg : * mut rmf_building_map_msgs__msg__AffineImage) -> () { unsafe { rmf_building_map_msgs__msg__AffineImage__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> AffineImage { AffineImage { name : msg . name . to_str () . to_owned () , x_offset : msg . x_offset , y_offset : msg . y_offset , yaw : msg . yaw , scale : msg . scale , encoding : msg . encoding . to_str () . to_owned () , data : msg . data . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . name . assign (& self . name) ; msg . x_offset = self . x_offset ; msg . y_offset = self . y_offset ; msg . yaw = self . yaw ; msg . scale = self . scale ; msg . encoding . assign (& self . encoding) ; msg . data . update (& self . data) ; } } impl Default for AffineImage { fn default () -> Self { let msg_native = WrappedNativeMsg :: < AffineImage > :: new () ; AffineImage :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct BuildingMap { pub name : std :: string :: String , pub levels : Vec < rmf_building_map_msgs :: msg :: Level > , pub lifts : Vec < rmf_building_map_msgs :: msg :: Lift > } impl WrappedTypesupport for BuildingMap { type CStruct = rmf_building_map_msgs__msg__BuildingMap ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_building_map_msgs__msg__BuildingMap () } } fn create_msg () -> * mut rmf_building_map_msgs__msg__BuildingMap { unsafe { rmf_building_map_msgs__msg__BuildingMap__create () } } fn destroy_msg (msg : * mut rmf_building_map_msgs__msg__BuildingMap) -> () { unsafe { rmf_building_map_msgs__msg__BuildingMap__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> BuildingMap { BuildingMap { name : msg . name . to_str () . to_owned () , levels : { let mut temp = Vec :: with_capacity (msg . levels . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . levels . data , msg . levels . size) } ; for s in slice { temp . push (rmf_building_map_msgs :: msg :: Level :: from_native (s)) ; } temp } , lifts : { let mut temp = Vec :: with_capacity (msg . lifts . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . lifts . data , msg . lifts . size) } ; for s in slice { temp . push (rmf_building_map_msgs :: msg :: Lift :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . name . assign (& self . name) ; unsafe { rmf_building_map_msgs__msg__Level__Sequence__fini (& mut msg . levels) ; rmf_building_map_msgs__msg__Level__Sequence__init (& mut msg . levels , self . levels . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . levels . data , msg . levels . size) ; for (t , s) in slice . iter_mut () . zip (& self . levels) { s . copy_to_native (t) ; } } unsafe { rmf_building_map_msgs__msg__Lift__Sequence__fini (& mut msg . lifts) ; rmf_building_map_msgs__msg__Lift__Sequence__init (& mut msg . lifts , self . lifts . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . lifts . data , msg . lifts . size) ; for (t , s) in slice . iter_mut () . zip (& self . lifts) { s . copy_to_native (t) ; } } } } impl Default for BuildingMap { fn default () -> Self { let msg_native = WrappedNativeMsg :: < BuildingMap > :: new () ; BuildingMap :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Door { pub name : std :: string :: String , pub v1_x : f32 , pub v1_y : f32 , pub v2_x : f32 , pub v2_y : f32 , pub door_type : u8 , pub motion_range : f32 , pub motion_direction : i32 } impl WrappedTypesupport for Door { type CStruct = rmf_building_map_msgs__msg__Door ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_building_map_msgs__msg__Door () } } fn create_msg () -> * mut rmf_building_map_msgs__msg__Door { unsafe { rmf_building_map_msgs__msg__Door__create () } } fn destroy_msg (msg : * mut rmf_building_map_msgs__msg__Door) -> () { unsafe { rmf_building_map_msgs__msg__Door__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Door { Door { name : msg . name . to_str () . to_owned () , v1_x : msg . v1_x , v1_y : msg . v1_y , v2_x : msg . v2_x , v2_y : msg . v2_y , door_type : msg . door_type , motion_range : msg . motion_range , motion_direction : msg . motion_direction , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . name . assign (& self . name) ; msg . v1_x = self . v1_x ; msg . v1_y = self . v1_y ; msg . v2_x = self . v2_x ; msg . v2_y = self . v2_y ; msg . door_type = self . door_type ; msg . motion_range = self . motion_range ; msg . motion_direction = self . motion_direction ; } } impl Default for Door { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Door > :: new () ; Door :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl Door { pub const DOOR_TYPE_DOUBLE_SLIDING : _bindgen_ty_1503 = rmf_building_map_msgs__msg__Door__DOOR_TYPE_DOUBLE_SLIDING ; pub const DOOR_TYPE_DOUBLE_SWING : _bindgen_ty_1507 = rmf_building_map_msgs__msg__Door__DOOR_TYPE_DOUBLE_SWING ; pub const DOOR_TYPE_DOUBLE_TELESCOPE : _bindgen_ty_1505 = rmf_building_map_msgs__msg__Door__DOOR_TYPE_DOUBLE_TELESCOPE ; pub const DOOR_TYPE_SINGLE_SLIDING : _bindgen_ty_1502 = rmf_building_map_msgs__msg__Door__DOOR_TYPE_SINGLE_SLIDING ; pub const DOOR_TYPE_SINGLE_SWING : _bindgen_ty_1506 = rmf_building_map_msgs__msg__Door__DOOR_TYPE_SINGLE_SWING ; pub const DOOR_TYPE_SINGLE_TELESCOPE : _bindgen_ty_1504 = rmf_building_map_msgs__msg__Door__DOOR_TYPE_SINGLE_TELESCOPE ; pub const DOOR_TYPE_UNDEFINED : _bindgen_ty_1501 = rmf_building_map_msgs__msg__Door__DOOR_TYPE_UNDEFINED ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Graph { pub name : std :: string :: String , pub vertices : Vec < rmf_building_map_msgs :: msg :: GraphNode > , pub edges : Vec < rmf_building_map_msgs :: msg :: GraphEdge > , pub params : Vec < rmf_building_map_msgs :: msg :: Param > } impl WrappedTypesupport for Graph { type CStruct = rmf_building_map_msgs__msg__Graph ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_building_map_msgs__msg__Graph () } } fn create_msg () -> * mut rmf_building_map_msgs__msg__Graph { unsafe { rmf_building_map_msgs__msg__Graph__create () } } fn destroy_msg (msg : * mut rmf_building_map_msgs__msg__Graph) -> () { unsafe { rmf_building_map_msgs__msg__Graph__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Graph { Graph { name : msg . name . to_str () . to_owned () , vertices : { let mut temp = Vec :: with_capacity (msg . vertices . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . vertices . data , msg . vertices . size) } ; for s in slice { temp . push (rmf_building_map_msgs :: msg :: GraphNode :: from_native (s)) ; } temp } , edges : { let mut temp = Vec :: with_capacity (msg . edges . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . edges . data , msg . edges . size) } ; for s in slice { temp . push (rmf_building_map_msgs :: msg :: GraphEdge :: from_native (s)) ; } temp } , params : { let mut temp = Vec :: with_capacity (msg . params . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . params . data , msg . params . size) } ; for s in slice { temp . push (rmf_building_map_msgs :: msg :: Param :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . name . assign (& self . name) ; unsafe { rmf_building_map_msgs__msg__GraphNode__Sequence__fini (& mut msg . vertices) ; rmf_building_map_msgs__msg__GraphNode__Sequence__init (& mut msg . vertices , self . vertices . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . vertices . data , msg . vertices . size) ; for (t , s) in slice . iter_mut () . zip (& self . vertices) { s . copy_to_native (t) ; } } unsafe { rmf_building_map_msgs__msg__GraphEdge__Sequence__fini (& mut msg . edges) ; rmf_building_map_msgs__msg__GraphEdge__Sequence__init (& mut msg . edges , self . edges . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . edges . data , msg . edges . size) ; for (t , s) in slice . iter_mut () . zip (& self . edges) { s . copy_to_native (t) ; } } unsafe { rmf_building_map_msgs__msg__Param__Sequence__fini (& mut msg . params) ; rmf_building_map_msgs__msg__Param__Sequence__init (& mut msg . params , self . params . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . params . data , msg . params . size) ; for (t , s) in slice . iter_mut () . zip (& self . params) { s . copy_to_native (t) ; } } } } impl Default for Graph { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Graph > :: new () ; Graph :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct GraphEdge { pub v1_idx : u32 , pub v2_idx : u32 , pub params : Vec < rmf_building_map_msgs :: msg :: Param > , pub edge_type : u8 } impl WrappedTypesupport for GraphEdge { type CStruct = rmf_building_map_msgs__msg__GraphEdge ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_building_map_msgs__msg__GraphEdge () } } fn create_msg () -> * mut rmf_building_map_msgs__msg__GraphEdge { unsafe { rmf_building_map_msgs__msg__GraphEdge__create () } } fn destroy_msg (msg : * mut rmf_building_map_msgs__msg__GraphEdge) -> () { unsafe { rmf_building_map_msgs__msg__GraphEdge__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> GraphEdge { GraphEdge { v1_idx : msg . v1_idx , v2_idx : msg . v2_idx , params : { let mut temp = Vec :: with_capacity (msg . params . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . params . data , msg . params . size) } ; for s in slice { temp . push (rmf_building_map_msgs :: msg :: Param :: from_native (s)) ; } temp } , edge_type : msg . edge_type , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . v1_idx = self . v1_idx ; msg . v2_idx = self . v2_idx ; unsafe { rmf_building_map_msgs__msg__Param__Sequence__fini (& mut msg . params) ; rmf_building_map_msgs__msg__Param__Sequence__init (& mut msg . params , self . params . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . params . data , msg . params . size) ; for (t , s) in slice . iter_mut () . zip (& self . params) { s . copy_to_native (t) ; } } msg . edge_type = self . edge_type ; } } impl Default for GraphEdge { fn default () -> Self { let msg_native = WrappedNativeMsg :: < GraphEdge > :: new () ; GraphEdge :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl GraphEdge { pub const EDGE_TYPE_BIDIRECTIONAL : _bindgen_ty_1513 = rmf_building_map_msgs__msg__GraphEdge__EDGE_TYPE_BIDIRECTIONAL ; pub const EDGE_TYPE_UNIDIRECTIONAL : _bindgen_ty_1514 = rmf_building_map_msgs__msg__GraphEdge__EDGE_TYPE_UNIDIRECTIONAL ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct GraphNode { pub x : f32 , pub y : f32 , pub name : std :: string :: String , pub params : Vec < rmf_building_map_msgs :: msg :: Param > } impl WrappedTypesupport for GraphNode { type CStruct = rmf_building_map_msgs__msg__GraphNode ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_building_map_msgs__msg__GraphNode () } } fn create_msg () -> * mut rmf_building_map_msgs__msg__GraphNode { unsafe { rmf_building_map_msgs__msg__GraphNode__create () } } fn destroy_msg (msg : * mut rmf_building_map_msgs__msg__GraphNode) -> () { unsafe { rmf_building_map_msgs__msg__GraphNode__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> GraphNode { GraphNode { x : msg . x , y : msg . y , name : msg . name . to_str () . to_owned () , params : { let mut temp = Vec :: with_capacity (msg . params . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . params . data , msg . params . size) } ; for s in slice { temp . push (rmf_building_map_msgs :: msg :: Param :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . x = self . x ; msg . y = self . y ; msg . name . assign (& self . name) ; unsafe { rmf_building_map_msgs__msg__Param__Sequence__fini (& mut msg . params) ; rmf_building_map_msgs__msg__Param__Sequence__init (& mut msg . params , self . params . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . params . data , msg . params . size) ; for (t , s) in slice . iter_mut () . zip (& self . params) { s . copy_to_native (t) ; } } } } impl Default for GraphNode { fn default () -> Self { let msg_native = WrappedNativeMsg :: < GraphNode > :: new () ; GraphNode :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Level { pub name : std :: string :: String , pub elevation : f32 , pub images : Vec < rmf_building_map_msgs :: msg :: AffineImage > , pub places : Vec < rmf_building_map_msgs :: msg :: Place > , pub doors : Vec < rmf_building_map_msgs :: msg :: Door > , pub nav_graphs : Vec < rmf_building_map_msgs :: msg :: Graph > , pub wall_graph : rmf_building_map_msgs :: msg :: Graph } impl WrappedTypesupport for Level { type CStruct = rmf_building_map_msgs__msg__Level ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_building_map_msgs__msg__Level () } } fn create_msg () -> * mut rmf_building_map_msgs__msg__Level { unsafe { rmf_building_map_msgs__msg__Level__create () } } fn destroy_msg (msg : * mut rmf_building_map_msgs__msg__Level) -> () { unsafe { rmf_building_map_msgs__msg__Level__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Level { Level { name : msg . name . to_str () . to_owned () , elevation : msg . elevation , images : { let mut temp = Vec :: with_capacity (msg . images . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . images . data , msg . images . size) } ; for s in slice { temp . push (rmf_building_map_msgs :: msg :: AffineImage :: from_native (s)) ; } temp } , places : { let mut temp = Vec :: with_capacity (msg . places . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . places . data , msg . places . size) } ; for s in slice { temp . push (rmf_building_map_msgs :: msg :: Place :: from_native (s)) ; } temp } , doors : { let mut temp = Vec :: with_capacity (msg . doors . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . doors . data , msg . doors . size) } ; for s in slice { temp . push (rmf_building_map_msgs :: msg :: Door :: from_native (s)) ; } temp } , nav_graphs : { let mut temp = Vec :: with_capacity (msg . nav_graphs . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . nav_graphs . data , msg . nav_graphs . size) } ; for s in slice { temp . push (rmf_building_map_msgs :: msg :: Graph :: from_native (s)) ; } temp } , wall_graph : rmf_building_map_msgs :: msg :: Graph :: from_native (& msg . wall_graph) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . name . assign (& self . name) ; msg . elevation = self . elevation ; unsafe { rmf_building_map_msgs__msg__AffineImage__Sequence__fini (& mut msg . images) ; rmf_building_map_msgs__msg__AffineImage__Sequence__init (& mut msg . images , self . images . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . images . data , msg . images . size) ; for (t , s) in slice . iter_mut () . zip (& self . images) { s . copy_to_native (t) ; } } unsafe { rmf_building_map_msgs__msg__Place__Sequence__fini (& mut msg . places) ; rmf_building_map_msgs__msg__Place__Sequence__init (& mut msg . places , self . places . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . places . data , msg . places . size) ; for (t , s) in slice . iter_mut () . zip (& self . places) { s . copy_to_native (t) ; } } unsafe { rmf_building_map_msgs__msg__Door__Sequence__fini (& mut msg . doors) ; rmf_building_map_msgs__msg__Door__Sequence__init (& mut msg . doors , self . doors . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . doors . data , msg . doors . size) ; for (t , s) in slice . iter_mut () . zip (& self . doors) { s . copy_to_native (t) ; } } unsafe { rmf_building_map_msgs__msg__Graph__Sequence__fini (& mut msg . nav_graphs) ; rmf_building_map_msgs__msg__Graph__Sequence__init (& mut msg . nav_graphs , self . nav_graphs . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . nav_graphs . data , msg . nav_graphs . size) ; for (t , s) in slice . iter_mut () . zip (& self . nav_graphs) { s . copy_to_native (t) ; } } self . wall_graph . copy_to_native (& mut msg . wall_graph) ; } } impl Default for Level { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Level > :: new () ; Level :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Lift { pub name : std :: string :: String , pub levels : Vec < std :: string :: String > , pub doors : Vec < rmf_building_map_msgs :: msg :: Door > , pub wall_graph : rmf_building_map_msgs :: msg :: Graph , pub ref_x : f32 , pub ref_y : f32 , pub ref_yaw : f32 , pub width : f32 , pub depth : f32 } impl WrappedTypesupport for Lift { type CStruct = rmf_building_map_msgs__msg__Lift ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_building_map_msgs__msg__Lift () } } fn create_msg () -> * mut rmf_building_map_msgs__msg__Lift { unsafe { rmf_building_map_msgs__msg__Lift__create () } } fn destroy_msg (msg : * mut rmf_building_map_msgs__msg__Lift) -> () { unsafe { rmf_building_map_msgs__msg__Lift__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Lift { Lift { name : msg . name . to_str () . to_owned () , levels : msg . levels . to_vec () , doors : { let mut temp = Vec :: with_capacity (msg . doors . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . doors . data , msg . doors . size) } ; for s in slice { temp . push (rmf_building_map_msgs :: msg :: Door :: from_native (s)) ; } temp } , wall_graph : rmf_building_map_msgs :: msg :: Graph :: from_native (& msg . wall_graph) , ref_x : msg . ref_x , ref_y : msg . ref_y , ref_yaw : msg . ref_yaw , width : msg . width , depth : msg . depth , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . name . assign (& self . name) ; msg . levels . update (& self . levels) ; unsafe { rmf_building_map_msgs__msg__Door__Sequence__fini (& mut msg . doors) ; rmf_building_map_msgs__msg__Door__Sequence__init (& mut msg . doors , self . doors . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . doors . data , msg . doors . size) ; for (t , s) in slice . iter_mut () . zip (& self . doors) { s . copy_to_native (t) ; } } self . wall_graph . copy_to_native (& mut msg . wall_graph) ; msg . ref_x = self . ref_x ; msg . ref_y = self . ref_y ; msg . ref_yaw = self . ref_yaw ; msg . width = self . width ; msg . depth = self . depth ; } } impl Default for Lift { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Lift > :: new () ; Lift :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Param { pub name : std :: string :: String , # [serde (rename = "type")] pub type_ : u32 , pub value_int : i32 , pub value_float : f32 , pub value_string : std :: string :: String , pub value_bool : bool } impl WrappedTypesupport for Param { type CStruct = rmf_building_map_msgs__msg__Param ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_building_map_msgs__msg__Param () } } fn create_msg () -> * mut rmf_building_map_msgs__msg__Param { unsafe { rmf_building_map_msgs__msg__Param__create () } } fn destroy_msg (msg : * mut rmf_building_map_msgs__msg__Param) -> () { unsafe { rmf_building_map_msgs__msg__Param__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Param { Param { name : msg . name . to_str () . to_owned () , type_ : msg . type_ , value_int : msg . value_int , value_float : msg . value_float , value_string : msg . value_string . to_str () . to_owned () , value_bool : msg . value_bool , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . name . assign (& self . name) ; msg . type_ = self . type_ ; msg . value_int = self . value_int ; msg . value_float = self . value_float ; msg . value_string . assign (& self . value_string) ; msg . value_bool = self . value_bool ; } } impl Default for Param { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Param > :: new () ; Param :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl Param { pub const TYPE_BOOL : _bindgen_ty_1512 = rmf_building_map_msgs__msg__Param__TYPE_BOOL ; pub const TYPE_DOUBLE : _bindgen_ty_1511 = rmf_building_map_msgs__msg__Param__TYPE_DOUBLE ; pub const TYPE_INT : _bindgen_ty_1510 = rmf_building_map_msgs__msg__Param__TYPE_INT ; pub const TYPE_STRING : _bindgen_ty_1509 = rmf_building_map_msgs__msg__Param__TYPE_STRING ; pub const TYPE_UNDEFINED : _bindgen_ty_1508 = rmf_building_map_msgs__msg__Param__TYPE_UNDEFINED ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Place { pub name : std :: string :: String , pub x : f32 , pub y : f32 , pub yaw : f32 , pub position_tolerance : f32 , pub yaw_tolerance : f32 } impl WrappedTypesupport for Place { type CStruct = rmf_building_map_msgs__msg__Place ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_building_map_msgs__msg__Place () } } fn create_msg () -> * mut rmf_building_map_msgs__msg__Place { unsafe { rmf_building_map_msgs__msg__Place__create () } } fn destroy_msg (msg : * mut rmf_building_map_msgs__msg__Place) -> () { unsafe { rmf_building_map_msgs__msg__Place__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Place { Place { name : msg . name . to_str () . to_owned () , x : msg . x , y : msg . y , yaw : msg . yaw , position_tolerance : msg . position_tolerance , yaw_tolerance : msg . yaw_tolerance , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . name . assign (& self . name) ; msg . x = self . x ; msg . y = self . y ; msg . yaw = self . yaw ; msg . position_tolerance = self . position_tolerance ; msg . yaw_tolerance = self . yaw_tolerance ; } } impl Default for Place { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Place > :: new () ; Place :: from_native (& msg_native) } } } pub mod srv { # [allow (non_snake_case)] pub mod GetBuildingMap { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__rmf_building_map_msgs__srv__GetBuildingMap () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { } impl WrappedTypesupport for Request { type CStruct = rmf_building_map_msgs__srv__GetBuildingMap_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_building_map_msgs__srv__GetBuildingMap_Request () } } fn create_msg () -> * mut rmf_building_map_msgs__srv__GetBuildingMap_Request { unsafe { rmf_building_map_msgs__srv__GetBuildingMap_Request__create () } } fn destroy_msg (msg : * mut rmf_building_map_msgs__srv__GetBuildingMap_Request) -> () { unsafe { rmf_building_map_msgs__srv__GetBuildingMap_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub building_map : rmf_building_map_msgs :: msg :: BuildingMap } impl WrappedTypesupport for Response { type CStruct = rmf_building_map_msgs__srv__GetBuildingMap_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_building_map_msgs__srv__GetBuildingMap_Response () } } fn create_msg () -> * mut rmf_building_map_msgs__srv__GetBuildingMap_Response { unsafe { rmf_building_map_msgs__srv__GetBuildingMap_Response__create () } } fn destroy_msg (msg : * mut rmf_building_map_msgs__srv__GetBuildingMap_Response) -> () { unsafe { rmf_building_map_msgs__srv__GetBuildingMap_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { building_map : rmf_building_map_msgs :: msg :: BuildingMap :: from_native (& msg . building_map) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . building_map . copy_to_native (& mut msg . building_map) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } }