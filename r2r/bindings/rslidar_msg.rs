pub mod msg { use super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct RslidarPacket { pub stamp : builtin_interfaces :: msg :: Time , pub data : Vec < u8 > } impl WrappedTypesupport for RslidarPacket { type CStruct = rslidar_msg__msg__RslidarPacket ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rslidar_msg__msg__RslidarPacket () } } fn create_msg () -> * mut rslidar_msg__msg__RslidarPacket { unsafe { rslidar_msg__msg__RslidarPacket__create () } } fn destroy_msg (msg : * mut rslidar_msg__msg__RslidarPacket) -> () { unsafe { rslidar_msg__msg__RslidarPacket__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> RslidarPacket { RslidarPacket { stamp : builtin_interfaces :: msg :: Time :: from_native (& msg . stamp) , data : msg . data . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . stamp . copy_to_native (& mut msg . stamp) ; assert_eq ! (self . data . len () , 1248usize , "Field {} is fixed size of {}!" , "data" , 1248usize) ; msg . data . copy_from_slice (& self . data [.. 1248usize]) ; } } impl Default for RslidarPacket { fn default () -> Self { let msg_native = WrappedNativeMsg :: < RslidarPacket > :: new () ; RslidarPacket :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct RslidarScan { pub header : std_msgs :: msg :: Header , pub packets : Vec < rslidar_msg :: msg :: RslidarPacket > } impl WrappedTypesupport for RslidarScan { type CStruct = rslidar_msg__msg__RslidarScan ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rslidar_msg__msg__RslidarScan () } } fn create_msg () -> * mut rslidar_msg__msg__RslidarScan { unsafe { rslidar_msg__msg__RslidarScan__create () } } fn destroy_msg (msg : * mut rslidar_msg__msg__RslidarScan) -> () { unsafe { rslidar_msg__msg__RslidarScan__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> RslidarScan { RslidarScan { header : std_msgs :: msg :: Header :: from_native (& msg . header) , packets : { let mut temp = Vec :: with_capacity (msg . packets . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . packets . data , msg . packets . size) } ; for s in slice { temp . push (rslidar_msg :: msg :: RslidarPacket :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; unsafe { rslidar_msg__msg__RslidarPacket__Sequence__fini (& mut msg . packets) ; rslidar_msg__msg__RslidarPacket__Sequence__init (& mut msg . packets , self . packets . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . packets . data , msg . packets . size) ; for (t , s) in slice . iter_mut () . zip (& self . packets) { s . copy_to_native (t) ; } } } } impl Default for RslidarScan { fn default () -> Self { let msg_native = WrappedNativeMsg :: < RslidarScan > :: new () ; RslidarScan :: from_native (& msg_native) } } }