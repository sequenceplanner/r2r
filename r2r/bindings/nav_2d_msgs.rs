pub mod msg { use super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Path2D { pub header : std_msgs :: msg :: Header , pub poses : Vec < geometry_msgs :: msg :: Pose2D > } impl WrappedTypesupport for Path2D { type CStruct = nav_2d_msgs__msg__Path2D ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__nav_2d_msgs__msg__Path2D () } } fn create_msg () -> * mut nav_2d_msgs__msg__Path2D { unsafe { nav_2d_msgs__msg__Path2D__create () } } fn destroy_msg (msg : * mut nav_2d_msgs__msg__Path2D) -> () { unsafe { nav_2d_msgs__msg__Path2D__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Path2D { Path2D { header : std_msgs :: msg :: Header :: from_native (& msg . header) , poses : { let mut temp = Vec :: with_capacity (msg . poses . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . poses . data , msg . poses . size) } ; for s in slice { temp . push (geometry_msgs :: msg :: Pose2D :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; unsafe { geometry_msgs__msg__Pose2D__Sequence__fini (& mut msg . poses) ; geometry_msgs__msg__Pose2D__Sequence__init (& mut msg . poses , self . poses . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . poses . data , msg . poses . size) ; for (t , s) in slice . iter_mut () . zip (& self . poses) { s . copy_to_native (t) ; } } } } impl Default for Path2D { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Path2D > :: new () ; Path2D :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Pose2D32 { pub x : f32 , pub y : f32 , pub theta : f32 } impl WrappedTypesupport for Pose2D32 { type CStruct = nav_2d_msgs__msg__Pose2D32 ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__nav_2d_msgs__msg__Pose2D32 () } } fn create_msg () -> * mut nav_2d_msgs__msg__Pose2D32 { unsafe { nav_2d_msgs__msg__Pose2D32__create () } } fn destroy_msg (msg : * mut nav_2d_msgs__msg__Pose2D32) -> () { unsafe { nav_2d_msgs__msg__Pose2D32__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Pose2D32 { Pose2D32 { x : msg . x , y : msg . y , theta : msg . theta , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . x = self . x ; msg . y = self . y ; msg . theta = self . theta ; } } impl Default for Pose2D32 { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Pose2D32 > :: new () ; Pose2D32 :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Pose2DStamped { pub header : std_msgs :: msg :: Header , pub pose : geometry_msgs :: msg :: Pose2D } impl WrappedTypesupport for Pose2DStamped { type CStruct = nav_2d_msgs__msg__Pose2DStamped ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__nav_2d_msgs__msg__Pose2DStamped () } } fn create_msg () -> * mut nav_2d_msgs__msg__Pose2DStamped { unsafe { nav_2d_msgs__msg__Pose2DStamped__create () } } fn destroy_msg (msg : * mut nav_2d_msgs__msg__Pose2DStamped) -> () { unsafe { nav_2d_msgs__msg__Pose2DStamped__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Pose2DStamped { Pose2DStamped { header : std_msgs :: msg :: Header :: from_native (& msg . header) , pose : geometry_msgs :: msg :: Pose2D :: from_native (& msg . pose) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; self . pose . copy_to_native (& mut msg . pose) ; } } impl Default for Pose2DStamped { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Pose2DStamped > :: new () ; Pose2DStamped :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Twist2D { pub x : f64 , pub y : f64 , pub theta : f64 } impl WrappedTypesupport for Twist2D { type CStruct = nav_2d_msgs__msg__Twist2D ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__nav_2d_msgs__msg__Twist2D () } } fn create_msg () -> * mut nav_2d_msgs__msg__Twist2D { unsafe { nav_2d_msgs__msg__Twist2D__create () } } fn destroy_msg (msg : * mut nav_2d_msgs__msg__Twist2D) -> () { unsafe { nav_2d_msgs__msg__Twist2D__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Twist2D { Twist2D { x : msg . x , y : msg . y , theta : msg . theta , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . x = self . x ; msg . y = self . y ; msg . theta = self . theta ; } } impl Default for Twist2D { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Twist2D > :: new () ; Twist2D :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Twist2D32 { pub x : f32 , pub y : f32 , pub theta : f32 } impl WrappedTypesupport for Twist2D32 { type CStruct = nav_2d_msgs__msg__Twist2D32 ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__nav_2d_msgs__msg__Twist2D32 () } } fn create_msg () -> * mut nav_2d_msgs__msg__Twist2D32 { unsafe { nav_2d_msgs__msg__Twist2D32__create () } } fn destroy_msg (msg : * mut nav_2d_msgs__msg__Twist2D32) -> () { unsafe { nav_2d_msgs__msg__Twist2D32__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Twist2D32 { Twist2D32 { x : msg . x , y : msg . y , theta : msg . theta , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . x = self . x ; msg . y = self . y ; msg . theta = self . theta ; } } impl Default for Twist2D32 { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Twist2D32 > :: new () ; Twist2D32 :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Twist2DStamped { pub header : std_msgs :: msg :: Header , pub velocity : nav_2d_msgs :: msg :: Twist2D } impl WrappedTypesupport for Twist2DStamped { type CStruct = nav_2d_msgs__msg__Twist2DStamped ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__nav_2d_msgs__msg__Twist2DStamped () } } fn create_msg () -> * mut nav_2d_msgs__msg__Twist2DStamped { unsafe { nav_2d_msgs__msg__Twist2DStamped__create () } } fn destroy_msg (msg : * mut nav_2d_msgs__msg__Twist2DStamped) -> () { unsafe { nav_2d_msgs__msg__Twist2DStamped__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Twist2DStamped { Twist2DStamped { header : std_msgs :: msg :: Header :: from_native (& msg . header) , velocity : nav_2d_msgs :: msg :: Twist2D :: from_native (& msg . velocity) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; self . velocity . copy_to_native (& mut msg . velocity) ; } } impl Default for Twist2DStamped { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Twist2DStamped > :: new () ; Twist2DStamped :: from_native (& msg_native) } } }