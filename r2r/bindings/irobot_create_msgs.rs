pub mod msg { use super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct AudioNote { pub frequency : u16 , pub max_runtime : builtin_interfaces :: msg :: Duration } impl WrappedTypesupport for AudioNote { type CStruct = irobot_create_msgs__msg__AudioNote ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__msg__AudioNote () } } fn create_msg () -> * mut irobot_create_msgs__msg__AudioNote { unsafe { irobot_create_msgs__msg__AudioNote__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__msg__AudioNote) -> () { unsafe { irobot_create_msgs__msg__AudioNote__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> AudioNote { AudioNote { frequency : msg . frequency , max_runtime : builtin_interfaces :: msg :: Duration :: from_native (& msg . max_runtime) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . frequency = self . frequency ; self . max_runtime . copy_to_native (& mut msg . max_runtime) ; } } impl Default for AudioNote { fn default () -> Self { let msg_native = WrappedNativeMsg :: < AudioNote > :: new () ; AudioNote :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct AudioNoteVector { pub header : std_msgs :: msg :: Header , pub notes : Vec < irobot_create_msgs :: msg :: AudioNote > , pub append : bool } impl WrappedTypesupport for AudioNoteVector { type CStruct = irobot_create_msgs__msg__AudioNoteVector ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__msg__AudioNoteVector () } } fn create_msg () -> * mut irobot_create_msgs__msg__AudioNoteVector { unsafe { irobot_create_msgs__msg__AudioNoteVector__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__msg__AudioNoteVector) -> () { unsafe { irobot_create_msgs__msg__AudioNoteVector__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> AudioNoteVector { AudioNoteVector { header : std_msgs :: msg :: Header :: from_native (& msg . header) , notes : { let mut temp = Vec :: with_capacity (msg . notes . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . notes . data , msg . notes . size) } ; for s in slice { temp . push (irobot_create_msgs :: msg :: AudioNote :: from_native (s)) ; } temp } , append : msg . append , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; unsafe { irobot_create_msgs__msg__AudioNote__Sequence__fini (& mut msg . notes) ; irobot_create_msgs__msg__AudioNote__Sequence__init (& mut msg . notes , self . notes . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . notes . data , msg . notes . size) ; for (t , s) in slice . iter_mut () . zip (& self . notes) { s . copy_to_native (t) ; } } msg . append = self . append ; } } impl Default for AudioNoteVector { fn default () -> Self { let msg_native = WrappedNativeMsg :: < AudioNoteVector > :: new () ; AudioNoteVector :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Button { pub header : std_msgs :: msg :: Header , pub is_pressed : bool , pub last_start_pressed_time : builtin_interfaces :: msg :: Time , pub last_pressed_duration : builtin_interfaces :: msg :: Duration } impl WrappedTypesupport for Button { type CStruct = irobot_create_msgs__msg__Button ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__msg__Button () } } fn create_msg () -> * mut irobot_create_msgs__msg__Button { unsafe { irobot_create_msgs__msg__Button__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__msg__Button) -> () { unsafe { irobot_create_msgs__msg__Button__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Button { Button { header : std_msgs :: msg :: Header :: from_native (& msg . header) , is_pressed : msg . is_pressed , last_start_pressed_time : builtin_interfaces :: msg :: Time :: from_native (& msg . last_start_pressed_time) , last_pressed_duration : builtin_interfaces :: msg :: Duration :: from_native (& msg . last_pressed_duration) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . is_pressed = self . is_pressed ; self . last_start_pressed_time . copy_to_native (& mut msg . last_start_pressed_time) ; self . last_pressed_duration . copy_to_native (& mut msg . last_pressed_duration) ; } } impl Default for Button { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Button > :: new () ; Button :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Dock { pub header : std_msgs :: msg :: Header , pub dock_visible : bool , pub is_docked : bool } impl WrappedTypesupport for Dock { type CStruct = irobot_create_msgs__msg__Dock ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__msg__Dock () } } fn create_msg () -> * mut irobot_create_msgs__msg__Dock { unsafe { irobot_create_msgs__msg__Dock__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__msg__Dock) -> () { unsafe { irobot_create_msgs__msg__Dock__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Dock { Dock { header : std_msgs :: msg :: Header :: from_native (& msg . header) , dock_visible : msg . dock_visible , is_docked : msg . is_docked , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . dock_visible = self . dock_visible ; msg . is_docked = self . is_docked ; } } impl Default for Dock { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Dock > :: new () ; Dock :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct HazardDetection { pub header : std_msgs :: msg :: Header , # [serde (rename = "type")] pub type_ : u8 } impl WrappedTypesupport for HazardDetection { type CStruct = irobot_create_msgs__msg__HazardDetection ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__msg__HazardDetection () } } fn create_msg () -> * mut irobot_create_msgs__msg__HazardDetection { unsafe { irobot_create_msgs__msg__HazardDetection__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__msg__HazardDetection) -> () { unsafe { irobot_create_msgs__msg__HazardDetection__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> HazardDetection { HazardDetection { header : std_msgs :: msg :: Header :: from_native (& msg . header) , type_ : msg . type_ , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . type_ = self . type_ ; } } impl Default for HazardDetection { fn default () -> Self { let msg_native = WrappedNativeMsg :: < HazardDetection > :: new () ; HazardDetection :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl HazardDetection { pub const BACKUP_LIMIT : _bindgen_ty_253 = irobot_create_msgs__msg__HazardDetection__BACKUP_LIMIT ; pub const BUMP : _bindgen_ty_254 = irobot_create_msgs__msg__HazardDetection__BUMP ; pub const CLIFF : _bindgen_ty_255 = irobot_create_msgs__msg__HazardDetection__CLIFF ; pub const OBJECT_PROXIMITY : _bindgen_ty_258 = irobot_create_msgs__msg__HazardDetection__OBJECT_PROXIMITY ; pub const STALL : _bindgen_ty_256 = irobot_create_msgs__msg__HazardDetection__STALL ; pub const WHEEL_DROP : _bindgen_ty_257 = irobot_create_msgs__msg__HazardDetection__WHEEL_DROP ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct HazardDetectionVector { pub header : std_msgs :: msg :: Header , pub detections : Vec < irobot_create_msgs :: msg :: HazardDetection > } impl WrappedTypesupport for HazardDetectionVector { type CStruct = irobot_create_msgs__msg__HazardDetectionVector ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__msg__HazardDetectionVector () } } fn create_msg () -> * mut irobot_create_msgs__msg__HazardDetectionVector { unsafe { irobot_create_msgs__msg__HazardDetectionVector__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__msg__HazardDetectionVector) -> () { unsafe { irobot_create_msgs__msg__HazardDetectionVector__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> HazardDetectionVector { HazardDetectionVector { header : std_msgs :: msg :: Header :: from_native (& msg . header) , detections : { let mut temp = Vec :: with_capacity (msg . detections . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . detections . data , msg . detections . size) } ; for s in slice { temp . push (irobot_create_msgs :: msg :: HazardDetection :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; unsafe { irobot_create_msgs__msg__HazardDetection__Sequence__fini (& mut msg . detections) ; irobot_create_msgs__msg__HazardDetection__Sequence__init (& mut msg . detections , self . detections . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . detections . data , msg . detections . size) ; for (t , s) in slice . iter_mut () . zip (& self . detections) { s . copy_to_native (t) ; } } } } impl Default for HazardDetectionVector { fn default () -> Self { let msg_native = WrappedNativeMsg :: < HazardDetectionVector > :: new () ; HazardDetectionVector :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct InterfaceButtons { pub header : std_msgs :: msg :: Header , pub button_1 : irobot_create_msgs :: msg :: Button , pub button_power : irobot_create_msgs :: msg :: Button , pub button_2 : irobot_create_msgs :: msg :: Button } impl WrappedTypesupport for InterfaceButtons { type CStruct = irobot_create_msgs__msg__InterfaceButtons ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__msg__InterfaceButtons () } } fn create_msg () -> * mut irobot_create_msgs__msg__InterfaceButtons { unsafe { irobot_create_msgs__msg__InterfaceButtons__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__msg__InterfaceButtons) -> () { unsafe { irobot_create_msgs__msg__InterfaceButtons__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> InterfaceButtons { InterfaceButtons { header : std_msgs :: msg :: Header :: from_native (& msg . header) , button_1 : irobot_create_msgs :: msg :: Button :: from_native (& msg . button_1) , button_power : irobot_create_msgs :: msg :: Button :: from_native (& msg . button_power) , button_2 : irobot_create_msgs :: msg :: Button :: from_native (& msg . button_2) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; self . button_1 . copy_to_native (& mut msg . button_1) ; self . button_power . copy_to_native (& mut msg . button_power) ; self . button_2 . copy_to_native (& mut msg . button_2) ; } } impl Default for InterfaceButtons { fn default () -> Self { let msg_native = WrappedNativeMsg :: < InterfaceButtons > :: new () ; InterfaceButtons :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct IrIntensity { pub header : std_msgs :: msg :: Header , pub value : i16 } impl WrappedTypesupport for IrIntensity { type CStruct = irobot_create_msgs__msg__IrIntensity ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__msg__IrIntensity () } } fn create_msg () -> * mut irobot_create_msgs__msg__IrIntensity { unsafe { irobot_create_msgs__msg__IrIntensity__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__msg__IrIntensity) -> () { unsafe { irobot_create_msgs__msg__IrIntensity__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> IrIntensity { IrIntensity { header : std_msgs :: msg :: Header :: from_native (& msg . header) , value : msg . value , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . value = self . value ; } } impl Default for IrIntensity { fn default () -> Self { let msg_native = WrappedNativeMsg :: < IrIntensity > :: new () ; IrIntensity :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct IrIntensityVector { pub header : std_msgs :: msg :: Header , pub readings : Vec < irobot_create_msgs :: msg :: IrIntensity > } impl WrappedTypesupport for IrIntensityVector { type CStruct = irobot_create_msgs__msg__IrIntensityVector ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__msg__IrIntensityVector () } } fn create_msg () -> * mut irobot_create_msgs__msg__IrIntensityVector { unsafe { irobot_create_msgs__msg__IrIntensityVector__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__msg__IrIntensityVector) -> () { unsafe { irobot_create_msgs__msg__IrIntensityVector__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> IrIntensityVector { IrIntensityVector { header : std_msgs :: msg :: Header :: from_native (& msg . header) , readings : { let mut temp = Vec :: with_capacity (msg . readings . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . readings . data , msg . readings . size) } ; for s in slice { temp . push (irobot_create_msgs :: msg :: IrIntensity :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; unsafe { irobot_create_msgs__msg__IrIntensity__Sequence__fini (& mut msg . readings) ; irobot_create_msgs__msg__IrIntensity__Sequence__init (& mut msg . readings , self . readings . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . readings . data , msg . readings . size) ; for (t , s) in slice . iter_mut () . zip (& self . readings) { s . copy_to_native (t) ; } } } } impl Default for IrIntensityVector { fn default () -> Self { let msg_native = WrappedNativeMsg :: < IrIntensityVector > :: new () ; IrIntensityVector :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct IrOpcode { pub header : std_msgs :: msg :: Header , pub opcode : u8 , pub sensor : u8 } impl WrappedTypesupport for IrOpcode { type CStruct = irobot_create_msgs__msg__IrOpcode ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__msg__IrOpcode () } } fn create_msg () -> * mut irobot_create_msgs__msg__IrOpcode { unsafe { irobot_create_msgs__msg__IrOpcode__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__msg__IrOpcode) -> () { unsafe { irobot_create_msgs__msg__IrOpcode__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> IrOpcode { IrOpcode { header : std_msgs :: msg :: Header :: from_native (& msg . header) , opcode : msg . opcode , sensor : msg . sensor , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . opcode = self . opcode ; msg . sensor = self . sensor ; } } impl Default for IrOpcode { fn default () -> Self { let msg_native = WrappedNativeMsg :: < IrOpcode > :: new () ; IrOpcode :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl IrOpcode { pub const CODE_IR_BUOY_BOTH : _bindgen_ty_263 = irobot_create_msgs__msg__IrOpcode__CODE_IR_BUOY_BOTH ; pub const CODE_IR_BUOY_GREEN : _bindgen_ty_261 = irobot_create_msgs__msg__IrOpcode__CODE_IR_BUOY_GREEN ; pub const CODE_IR_BUOY_RED : _bindgen_ty_262 = irobot_create_msgs__msg__IrOpcode__CODE_IR_BUOY_RED ; pub const CODE_IR_EVAC_BOTH_FIELD : _bindgen_ty_266 = irobot_create_msgs__msg__IrOpcode__CODE_IR_EVAC_BOTH_FIELD ; pub const CODE_IR_EVAC_GREEN_FIELD : _bindgen_ty_264 = irobot_create_msgs__msg__IrOpcode__CODE_IR_EVAC_GREEN_FIELD ; pub const CODE_IR_EVAC_RED_FIELD : _bindgen_ty_265 = irobot_create_msgs__msg__IrOpcode__CODE_IR_EVAC_RED_FIELD ; pub const CODE_IR_FORCE_FIELD : _bindgen_ty_259 = irobot_create_msgs__msg__IrOpcode__CODE_IR_FORCE_FIELD ; pub const CODE_IR_VIRTUAL_WALL : _bindgen_ty_260 = irobot_create_msgs__msg__IrOpcode__CODE_IR_VIRTUAL_WALL ; pub const SENSOR_DIRECTIONAL_FRONT : _bindgen_ty_268 = irobot_create_msgs__msg__IrOpcode__SENSOR_DIRECTIONAL_FRONT ; pub const SENSOR_OMNI : _bindgen_ty_267 = irobot_create_msgs__msg__IrOpcode__SENSOR_OMNI ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct KidnapStatus { pub header : std_msgs :: msg :: Header , pub is_kidnapped : bool } impl WrappedTypesupport for KidnapStatus { type CStruct = irobot_create_msgs__msg__KidnapStatus ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__msg__KidnapStatus () } } fn create_msg () -> * mut irobot_create_msgs__msg__KidnapStatus { unsafe { irobot_create_msgs__msg__KidnapStatus__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__msg__KidnapStatus) -> () { unsafe { irobot_create_msgs__msg__KidnapStatus__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> KidnapStatus { KidnapStatus { header : std_msgs :: msg :: Header :: from_native (& msg . header) , is_kidnapped : msg . is_kidnapped , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . is_kidnapped = self . is_kidnapped ; } } impl Default for KidnapStatus { fn default () -> Self { let msg_native = WrappedNativeMsg :: < KidnapStatus > :: new () ; KidnapStatus :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct LedColor { pub red : u8 , pub green : u8 , pub blue : u8 } impl WrappedTypesupport for LedColor { type CStruct = irobot_create_msgs__msg__LedColor ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__msg__LedColor () } } fn create_msg () -> * mut irobot_create_msgs__msg__LedColor { unsafe { irobot_create_msgs__msg__LedColor__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__msg__LedColor) -> () { unsafe { irobot_create_msgs__msg__LedColor__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> LedColor { LedColor { red : msg . red , green : msg . green , blue : msg . blue , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . red = self . red ; msg . green = self . green ; msg . blue = self . blue ; } } impl Default for LedColor { fn default () -> Self { let msg_native = WrappedNativeMsg :: < LedColor > :: new () ; LedColor :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct LightringLeds { pub header : std_msgs :: msg :: Header , pub leds : Vec < irobot_create_msgs :: msg :: LedColor > , pub override_system : bool } impl WrappedTypesupport for LightringLeds { type CStruct = irobot_create_msgs__msg__LightringLeds ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__msg__LightringLeds () } } fn create_msg () -> * mut irobot_create_msgs__msg__LightringLeds { unsafe { irobot_create_msgs__msg__LightringLeds__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__msg__LightringLeds) -> () { unsafe { irobot_create_msgs__msg__LightringLeds__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> LightringLeds { LightringLeds { header : std_msgs :: msg :: Header :: from_native (& msg . header) , leds : { let vec : Vec < _ > = msg . leds . iter () . map (| s | irobot_create_msgs :: msg :: LedColor :: from_native (s)) . collect () ; vec } , override_system : msg . override_system , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; assert_eq ! (self . leds . len () , 6usize , "Field {} is fixed size of {}!" , "leds" , 6usize) ; for (t , s) in msg . leds . iter_mut () . zip (& self . leds) { s . copy_to_native (t) ; } msg . override_system = self . override_system ; } } impl Default for LightringLeds { fn default () -> Self { let msg_native = WrappedNativeMsg :: < LightringLeds > :: new () ; LightringLeds :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Mouse { pub header : std_msgs :: msg :: Header , pub integrated_x : f32 , pub integrated_y : f32 , pub frame_id : u32 , pub last_squal : u8 } impl WrappedTypesupport for Mouse { type CStruct = irobot_create_msgs__msg__Mouse ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__msg__Mouse () } } fn create_msg () -> * mut irobot_create_msgs__msg__Mouse { unsafe { irobot_create_msgs__msg__Mouse__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__msg__Mouse) -> () { unsafe { irobot_create_msgs__msg__Mouse__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Mouse { Mouse { header : std_msgs :: msg :: Header :: from_native (& msg . header) , integrated_x : msg . integrated_x , integrated_y : msg . integrated_y , frame_id : msg . frame_id , last_squal : msg . last_squal , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . integrated_x = self . integrated_x ; msg . integrated_y = self . integrated_y ; msg . frame_id = self . frame_id ; msg . last_squal = self . last_squal ; } } impl Default for Mouse { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Mouse > :: new () ; Mouse :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct SlipStatus { pub header : std_msgs :: msg :: Header , pub is_slipping : bool } impl WrappedTypesupport for SlipStatus { type CStruct = irobot_create_msgs__msg__SlipStatus ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__msg__SlipStatus () } } fn create_msg () -> * mut irobot_create_msgs__msg__SlipStatus { unsafe { irobot_create_msgs__msg__SlipStatus__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__msg__SlipStatus) -> () { unsafe { irobot_create_msgs__msg__SlipStatus__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> SlipStatus { SlipStatus { header : std_msgs :: msg :: Header :: from_native (& msg . header) , is_slipping : msg . is_slipping , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . is_slipping = self . is_slipping ; } } impl Default for SlipStatus { fn default () -> Self { let msg_native = WrappedNativeMsg :: < SlipStatus > :: new () ; SlipStatus :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct StopStatus { pub header : std_msgs :: msg :: Header , pub is_stopped : bool } impl WrappedTypesupport for StopStatus { type CStruct = irobot_create_msgs__msg__StopStatus ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__msg__StopStatus () } } fn create_msg () -> * mut irobot_create_msgs__msg__StopStatus { unsafe { irobot_create_msgs__msg__StopStatus__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__msg__StopStatus) -> () { unsafe { irobot_create_msgs__msg__StopStatus__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> StopStatus { StopStatus { header : std_msgs :: msg :: Header :: from_native (& msg . header) , is_stopped : msg . is_stopped , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . is_stopped = self . is_stopped ; } } impl Default for StopStatus { fn default () -> Self { let msg_native = WrappedNativeMsg :: < StopStatus > :: new () ; StopStatus :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct WheelStatus { pub header : std_msgs :: msg :: Header , pub current_ma_left : i16 , pub current_ma_right : i16 , pub pwm_left : i16 , pub pwm_right : i16 , pub wheels_enabled : bool } impl WrappedTypesupport for WheelStatus { type CStruct = irobot_create_msgs__msg__WheelStatus ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__msg__WheelStatus () } } fn create_msg () -> * mut irobot_create_msgs__msg__WheelStatus { unsafe { irobot_create_msgs__msg__WheelStatus__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__msg__WheelStatus) -> () { unsafe { irobot_create_msgs__msg__WheelStatus__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> WheelStatus { WheelStatus { header : std_msgs :: msg :: Header :: from_native (& msg . header) , current_ma_left : msg . current_ma_left , current_ma_right : msg . current_ma_right , pwm_left : msg . pwm_left , pwm_right : msg . pwm_right , wheels_enabled : msg . wheels_enabled , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . current_ma_left = self . current_ma_left ; msg . current_ma_right = self . current_ma_right ; msg . pwm_left = self . pwm_left ; msg . pwm_right = self . pwm_right ; msg . wheels_enabled = self . wheels_enabled ; } } impl Default for WheelStatus { fn default () -> Self { let msg_native = WrappedNativeMsg :: < WheelStatus > :: new () ; WheelStatus :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct WheelTicks { pub header : std_msgs :: msg :: Header , pub ticks_left : i32 , pub ticks_right : i32 } impl WrappedTypesupport for WheelTicks { type CStruct = irobot_create_msgs__msg__WheelTicks ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__msg__WheelTicks () } } fn create_msg () -> * mut irobot_create_msgs__msg__WheelTicks { unsafe { irobot_create_msgs__msg__WheelTicks__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__msg__WheelTicks) -> () { unsafe { irobot_create_msgs__msg__WheelTicks__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> WheelTicks { WheelTicks { header : std_msgs :: msg :: Header :: from_native (& msg . header) , ticks_left : msg . ticks_left , ticks_right : msg . ticks_right , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . ticks_left = self . ticks_left ; msg . ticks_right = self . ticks_right ; } } impl Default for WheelTicks { fn default () -> Self { let msg_native = WrappedNativeMsg :: < WheelTicks > :: new () ; WheelTicks :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct WheelVels { pub header : std_msgs :: msg :: Header , pub velocity_left : f32 , pub velocity_right : f32 } impl WrappedTypesupport for WheelVels { type CStruct = irobot_create_msgs__msg__WheelVels ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__msg__WheelVels () } } fn create_msg () -> * mut irobot_create_msgs__msg__WheelVels { unsafe { irobot_create_msgs__msg__WheelVels__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__msg__WheelVels) -> () { unsafe { irobot_create_msgs__msg__WheelVels__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> WheelVels { WheelVels { header : std_msgs :: msg :: Header :: from_native (& msg . header) , velocity_left : msg . velocity_left , velocity_right : msg . velocity_right , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . velocity_left = self . velocity_left ; msg . velocity_right = self . velocity_right ; } } impl Default for WheelVels { fn default () -> Self { let msg_native = WrappedNativeMsg :: < WheelVels > :: new () ; WheelVels :: from_native (& msg_native) } } } pub mod srv { # [allow (non_snake_case)] pub mod EStop { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__irobot_create_msgs__srv__EStop () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub e_stop_on : bool } impl WrappedTypesupport for Request { type CStruct = irobot_create_msgs__srv__EStop_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__srv__EStop_Request () } } fn create_msg () -> * mut irobot_create_msgs__srv__EStop_Request { unsafe { irobot_create_msgs__srv__EStop_Request__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__srv__EStop_Request) -> () { unsafe { irobot_create_msgs__srv__EStop_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { e_stop_on : msg . e_stop_on , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . e_stop_on = self . e_stop_on ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool , pub message : std :: string :: String } impl WrappedTypesupport for Response { type CStruct = irobot_create_msgs__srv__EStop_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__srv__EStop_Response () } } fn create_msg () -> * mut irobot_create_msgs__srv__EStop_Response { unsafe { irobot_create_msgs__srv__EStop_Response__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__srv__EStop_Response) -> () { unsafe { irobot_create_msgs__srv__EStop_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , message : msg . message . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; msg . message . assign (& self . message) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod ResetPose { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__irobot_create_msgs__srv__ResetPose () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub pose : geometry_msgs :: msg :: Pose } impl WrappedTypesupport for Request { type CStruct = irobot_create_msgs__srv__ResetPose_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__srv__ResetPose_Request () } } fn create_msg () -> * mut irobot_create_msgs__srv__ResetPose_Request { unsafe { irobot_create_msgs__srv__ResetPose_Request__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__srv__ResetPose_Request) -> () { unsafe { irobot_create_msgs__srv__ResetPose_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { pose : geometry_msgs :: msg :: Pose :: from_native (& msg . pose) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . pose . copy_to_native (& mut msg . pose) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { } impl WrappedTypesupport for Response { type CStruct = irobot_create_msgs__srv__ResetPose_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__srv__ResetPose_Response () } } fn create_msg () -> * mut irobot_create_msgs__srv__ResetPose_Response { unsafe { irobot_create_msgs__srv__ResetPose_Response__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__srv__ResetPose_Response) -> () { unsafe { irobot_create_msgs__srv__ResetPose_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod RobotPower { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__irobot_create_msgs__srv__RobotPower () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { } impl WrappedTypesupport for Request { type CStruct = irobot_create_msgs__srv__RobotPower_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__srv__RobotPower_Request () } } fn create_msg () -> * mut irobot_create_msgs__srv__RobotPower_Request { unsafe { irobot_create_msgs__srv__RobotPower_Request__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__srv__RobotPower_Request) -> () { unsafe { irobot_create_msgs__srv__RobotPower_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool , pub message : std :: string :: String } impl WrappedTypesupport for Response { type CStruct = irobot_create_msgs__srv__RobotPower_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__srv__RobotPower_Response () } } fn create_msg () -> * mut irobot_create_msgs__srv__RobotPower_Response { unsafe { irobot_create_msgs__srv__RobotPower_Response__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__srv__RobotPower_Response) -> () { unsafe { irobot_create_msgs__srv__RobotPower_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , message : msg . message . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; msg . message . assign (& self . message) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } } pub mod action { # [allow (non_snake_case)] pub mod AudioNoteSequence { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Action () ; impl WrappedActionTypeSupport for Action { type Goal = Goal ; type Result = Result ; type Feedback = Feedback ; type FeedbackMessage = FeedbackMessage ; type SendGoal = SendGoal :: Service ; type GetResult = GetResult :: Service ; fn get_ts () -> & 'static rosidl_action_type_support_t { unsafe { & * rosidl_typesupport_c__get_action_type_support_handle__irobot_create_msgs__action__AudioNoteSequence () } } fn make_goal_request_msg (goal_id : unique_identifier_msgs :: msg :: UUID , goal : Goal) -> SendGoal :: Request { SendGoal :: Request { goal_id , goal } } fn make_goal_response_msg (accepted : bool , stamp : builtin_interfaces :: msg :: Time) -> SendGoal :: Response { SendGoal :: Response { accepted , stamp } } fn make_feedback_msg (goal_id : unique_identifier_msgs :: msg :: UUID , feedback : Feedback) -> FeedbackMessage { FeedbackMessage { goal_id , feedback } } fn make_result_request_msg (goal_id : unique_identifier_msgs :: msg :: UUID) -> GetResult :: Request { GetResult :: Request { goal_id , } } fn make_result_response_msg (status : i8 , result : Result) -> GetResult :: Response { GetResult :: Response { status , result , } } fn destructure_goal_request_msg (msg : SendGoal :: Request) -> (unique_identifier_msgs :: msg :: UUID , Goal) { (msg . goal_id , msg . goal) } fn destructure_goal_response_msg (msg : SendGoal :: Response) -> (bool , builtin_interfaces :: msg :: Time) { (msg . accepted , msg . stamp) } fn destructure_feedback_msg (msg : FeedbackMessage) -> (unique_identifier_msgs :: msg :: UUID , Feedback) { (msg . goal_id , msg . feedback) } fn destructure_result_response_msg (msg : GetResult :: Response) -> (i8 , Result) { (msg . status , msg . result) } fn destructure_result_request_msg (msg : GetResult :: Request) -> unique_identifier_msgs :: msg :: UUID { msg . goal_id } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Goal { pub iterations : i32 , pub note_sequence : irobot_create_msgs :: msg :: AudioNoteVector } impl WrappedTypesupport for Goal { type CStruct = irobot_create_msgs__action__AudioNoteSequence_Goal ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__action__AudioNoteSequence_Goal () } } fn create_msg () -> * mut irobot_create_msgs__action__AudioNoteSequence_Goal { unsafe { irobot_create_msgs__action__AudioNoteSequence_Goal__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__action__AudioNoteSequence_Goal) -> () { unsafe { irobot_create_msgs__action__AudioNoteSequence_Goal__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Goal { Goal { iterations : msg . iterations , note_sequence : irobot_create_msgs :: msg :: AudioNoteVector :: from_native (& msg . note_sequence) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . iterations = self . iterations ; self . note_sequence . copy_to_native (& mut msg . note_sequence) ; } } impl Default for Goal { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Goal > :: new () ; Goal :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl Goal { pub const INFINITE : _bindgen_ty_243 = irobot_create_msgs__action__AudioNoteSequence_Goal__INFINITE ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Result { pub complete : bool , pub iterations_played : i32 , pub runtime : builtin_interfaces :: msg :: Duration } impl WrappedTypesupport for Result { type CStruct = irobot_create_msgs__action__AudioNoteSequence_Result ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__action__AudioNoteSequence_Result () } } fn create_msg () -> * mut irobot_create_msgs__action__AudioNoteSequence_Result { unsafe { irobot_create_msgs__action__AudioNoteSequence_Result__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__action__AudioNoteSequence_Result) -> () { unsafe { irobot_create_msgs__action__AudioNoteSequence_Result__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Result { Result { complete : msg . complete , iterations_played : msg . iterations_played , runtime : builtin_interfaces :: msg :: Duration :: from_native (& msg . runtime) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . complete = self . complete ; msg . iterations_played = self . iterations_played ; self . runtime . copy_to_native (& mut msg . runtime) ; } } impl Default for Result { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Result > :: new () ; Result :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Feedback { pub iterations_played : i32 , pub current_runtime : builtin_interfaces :: msg :: Duration } impl WrappedTypesupport for Feedback { type CStruct = irobot_create_msgs__action__AudioNoteSequence_Feedback ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__action__AudioNoteSequence_Feedback () } } fn create_msg () -> * mut irobot_create_msgs__action__AudioNoteSequence_Feedback { unsafe { irobot_create_msgs__action__AudioNoteSequence_Feedback__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__action__AudioNoteSequence_Feedback) -> () { unsafe { irobot_create_msgs__action__AudioNoteSequence_Feedback__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Feedback { Feedback { iterations_played : msg . iterations_played , current_runtime : builtin_interfaces :: msg :: Duration :: from_native (& msg . current_runtime) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . iterations_played = self . iterations_played ; self . current_runtime . copy_to_native (& mut msg . current_runtime) ; } } impl Default for Feedback { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Feedback > :: new () ; Feedback :: from_native (& msg_native) } } # [allow (non_snake_case)] pub mod SendGoal { use super :: super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__irobot_create_msgs__action__AudioNoteSequence_SendGoal () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub goal_id : unique_identifier_msgs :: msg :: UUID , pub goal : irobot_create_msgs :: action :: AudioNoteSequence :: Goal } impl WrappedTypesupport for Request { type CStruct = irobot_create_msgs__action__AudioNoteSequence_SendGoal_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__action__AudioNoteSequence_SendGoal_Request () } } fn create_msg () -> * mut irobot_create_msgs__action__AudioNoteSequence_SendGoal_Request { unsafe { irobot_create_msgs__action__AudioNoteSequence_SendGoal_Request__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__action__AudioNoteSequence_SendGoal_Request) -> () { unsafe { irobot_create_msgs__action__AudioNoteSequence_SendGoal_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { goal_id : unique_identifier_msgs :: msg :: UUID :: from_native (& msg . goal_id) , goal : irobot_create_msgs :: action :: AudioNoteSequence :: Goal :: from_native (& msg . goal) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . goal_id . copy_to_native (& mut msg . goal_id) ; self . goal . copy_to_native (& mut msg . goal) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub accepted : bool , pub stamp : builtin_interfaces :: msg :: Time } impl WrappedTypesupport for Response { type CStruct = irobot_create_msgs__action__AudioNoteSequence_SendGoal_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__action__AudioNoteSequence_SendGoal_Response () } } fn create_msg () -> * mut irobot_create_msgs__action__AudioNoteSequence_SendGoal_Response { unsafe { irobot_create_msgs__action__AudioNoteSequence_SendGoal_Response__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__action__AudioNoteSequence_SendGoal_Response) -> () { unsafe { irobot_create_msgs__action__AudioNoteSequence_SendGoal_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { accepted : msg . accepted , stamp : builtin_interfaces :: msg :: Time :: from_native (& msg . stamp) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . accepted = self . accepted ; self . stamp . copy_to_native (& mut msg . stamp) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetResult { use super :: super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__irobot_create_msgs__action__AudioNoteSequence_GetResult () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub goal_id : unique_identifier_msgs :: msg :: UUID } impl WrappedTypesupport for Request { type CStruct = irobot_create_msgs__action__AudioNoteSequence_GetResult_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__action__AudioNoteSequence_GetResult_Request () } } fn create_msg () -> * mut irobot_create_msgs__action__AudioNoteSequence_GetResult_Request { unsafe { irobot_create_msgs__action__AudioNoteSequence_GetResult_Request__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__action__AudioNoteSequence_GetResult_Request) -> () { unsafe { irobot_create_msgs__action__AudioNoteSequence_GetResult_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { goal_id : unique_identifier_msgs :: msg :: UUID :: from_native (& msg . goal_id) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . goal_id . copy_to_native (& mut msg . goal_id) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub status : i8 , pub result : irobot_create_msgs :: action :: AudioNoteSequence :: Result } impl WrappedTypesupport for Response { type CStruct = irobot_create_msgs__action__AudioNoteSequence_GetResult_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__action__AudioNoteSequence_GetResult_Response () } } fn create_msg () -> * mut irobot_create_msgs__action__AudioNoteSequence_GetResult_Response { unsafe { irobot_create_msgs__action__AudioNoteSequence_GetResult_Response__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__action__AudioNoteSequence_GetResult_Response) -> () { unsafe { irobot_create_msgs__action__AudioNoteSequence_GetResult_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { status : msg . status , result : irobot_create_msgs :: action :: AudioNoteSequence :: Result :: from_native (& msg . result) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . status = self . status ; self . result . copy_to_native (& mut msg . result) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct FeedbackMessage { pub goal_id : unique_identifier_msgs :: msg :: UUID , pub feedback : irobot_create_msgs :: action :: AudioNoteSequence :: Feedback } impl WrappedTypesupport for FeedbackMessage { type CStruct = irobot_create_msgs__action__AudioNoteSequence_FeedbackMessage ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__action__AudioNoteSequence_FeedbackMessage () } } fn create_msg () -> * mut irobot_create_msgs__action__AudioNoteSequence_FeedbackMessage { unsafe { irobot_create_msgs__action__AudioNoteSequence_FeedbackMessage__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__action__AudioNoteSequence_FeedbackMessage) -> () { unsafe { irobot_create_msgs__action__AudioNoteSequence_FeedbackMessage__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> FeedbackMessage { FeedbackMessage { goal_id : unique_identifier_msgs :: msg :: UUID :: from_native (& msg . goal_id) , feedback : irobot_create_msgs :: action :: AudioNoteSequence :: Feedback :: from_native (& msg . feedback) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . goal_id . copy_to_native (& mut msg . goal_id) ; self . feedback . copy_to_native (& mut msg . feedback) ; } } impl Default for FeedbackMessage { fn default () -> Self { let msg_native = WrappedNativeMsg :: < FeedbackMessage > :: new () ; FeedbackMessage :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod DockServo { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Action () ; impl WrappedActionTypeSupport for Action { type Goal = Goal ; type Result = Result ; type Feedback = Feedback ; type FeedbackMessage = FeedbackMessage ; type SendGoal = SendGoal :: Service ; type GetResult = GetResult :: Service ; fn get_ts () -> & 'static rosidl_action_type_support_t { unsafe { & * rosidl_typesupport_c__get_action_type_support_handle__irobot_create_msgs__action__DockServo () } } fn make_goal_request_msg (goal_id : unique_identifier_msgs :: msg :: UUID , goal : Goal) -> SendGoal :: Request { SendGoal :: Request { goal_id , goal } } fn make_goal_response_msg (accepted : bool , stamp : builtin_interfaces :: msg :: Time) -> SendGoal :: Response { SendGoal :: Response { accepted , stamp } } fn make_feedback_msg (goal_id : unique_identifier_msgs :: msg :: UUID , feedback : Feedback) -> FeedbackMessage { FeedbackMessage { goal_id , feedback } } fn make_result_request_msg (goal_id : unique_identifier_msgs :: msg :: UUID) -> GetResult :: Request { GetResult :: Request { goal_id , } } fn make_result_response_msg (status : i8 , result : Result) -> GetResult :: Response { GetResult :: Response { status , result , } } fn destructure_goal_request_msg (msg : SendGoal :: Request) -> (unique_identifier_msgs :: msg :: UUID , Goal) { (msg . goal_id , msg . goal) } fn destructure_goal_response_msg (msg : SendGoal :: Response) -> (bool , builtin_interfaces :: msg :: Time) { (msg . accepted , msg . stamp) } fn destructure_feedback_msg (msg : FeedbackMessage) -> (unique_identifier_msgs :: msg :: UUID , Feedback) { (msg . goal_id , msg . feedback) } fn destructure_result_response_msg (msg : GetResult :: Response) -> (i8 , Result) { (msg . status , msg . result) } fn destructure_result_request_msg (msg : GetResult :: Request) -> unique_identifier_msgs :: msg :: UUID { msg . goal_id } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Goal { } impl WrappedTypesupport for Goal { type CStruct = irobot_create_msgs__action__DockServo_Goal ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__action__DockServo_Goal () } } fn create_msg () -> * mut irobot_create_msgs__action__DockServo_Goal { unsafe { irobot_create_msgs__action__DockServo_Goal__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__action__DockServo_Goal) -> () { unsafe { irobot_create_msgs__action__DockServo_Goal__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Goal { Goal { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Goal { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Goal > :: new () ; Goal :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Result { pub is_docked : bool } impl WrappedTypesupport for Result { type CStruct = irobot_create_msgs__action__DockServo_Result ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__action__DockServo_Result () } } fn create_msg () -> * mut irobot_create_msgs__action__DockServo_Result { unsafe { irobot_create_msgs__action__DockServo_Result__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__action__DockServo_Result) -> () { unsafe { irobot_create_msgs__action__DockServo_Result__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Result { Result { is_docked : msg . is_docked , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . is_docked = self . is_docked ; } } impl Default for Result { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Result > :: new () ; Result :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Feedback { pub sees_dock : bool } impl WrappedTypesupport for Feedback { type CStruct = irobot_create_msgs__action__DockServo_Feedback ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__action__DockServo_Feedback () } } fn create_msg () -> * mut irobot_create_msgs__action__DockServo_Feedback { unsafe { irobot_create_msgs__action__DockServo_Feedback__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__action__DockServo_Feedback) -> () { unsafe { irobot_create_msgs__action__DockServo_Feedback__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Feedback { Feedback { sees_dock : msg . sees_dock , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . sees_dock = self . sees_dock ; } } impl Default for Feedback { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Feedback > :: new () ; Feedback :: from_native (& msg_native) } } # [allow (non_snake_case)] pub mod SendGoal { use super :: super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__irobot_create_msgs__action__DockServo_SendGoal () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub goal_id : unique_identifier_msgs :: msg :: UUID , pub goal : irobot_create_msgs :: action :: DockServo :: Goal } impl WrappedTypesupport for Request { type CStruct = irobot_create_msgs__action__DockServo_SendGoal_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__action__DockServo_SendGoal_Request () } } fn create_msg () -> * mut irobot_create_msgs__action__DockServo_SendGoal_Request { unsafe { irobot_create_msgs__action__DockServo_SendGoal_Request__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__action__DockServo_SendGoal_Request) -> () { unsafe { irobot_create_msgs__action__DockServo_SendGoal_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { goal_id : unique_identifier_msgs :: msg :: UUID :: from_native (& msg . goal_id) , goal : irobot_create_msgs :: action :: DockServo :: Goal :: from_native (& msg . goal) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . goal_id . copy_to_native (& mut msg . goal_id) ; self . goal . copy_to_native (& mut msg . goal) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub accepted : bool , pub stamp : builtin_interfaces :: msg :: Time } impl WrappedTypesupport for Response { type CStruct = irobot_create_msgs__action__DockServo_SendGoal_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__action__DockServo_SendGoal_Response () } } fn create_msg () -> * mut irobot_create_msgs__action__DockServo_SendGoal_Response { unsafe { irobot_create_msgs__action__DockServo_SendGoal_Response__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__action__DockServo_SendGoal_Response) -> () { unsafe { irobot_create_msgs__action__DockServo_SendGoal_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { accepted : msg . accepted , stamp : builtin_interfaces :: msg :: Time :: from_native (& msg . stamp) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . accepted = self . accepted ; self . stamp . copy_to_native (& mut msg . stamp) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetResult { use super :: super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__irobot_create_msgs__action__DockServo_GetResult () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub goal_id : unique_identifier_msgs :: msg :: UUID } impl WrappedTypesupport for Request { type CStruct = irobot_create_msgs__action__DockServo_GetResult_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__action__DockServo_GetResult_Request () } } fn create_msg () -> * mut irobot_create_msgs__action__DockServo_GetResult_Request { unsafe { irobot_create_msgs__action__DockServo_GetResult_Request__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__action__DockServo_GetResult_Request) -> () { unsafe { irobot_create_msgs__action__DockServo_GetResult_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { goal_id : unique_identifier_msgs :: msg :: UUID :: from_native (& msg . goal_id) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . goal_id . copy_to_native (& mut msg . goal_id) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub status : i8 , pub result : irobot_create_msgs :: action :: DockServo :: Result } impl WrappedTypesupport for Response { type CStruct = irobot_create_msgs__action__DockServo_GetResult_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__action__DockServo_GetResult_Response () } } fn create_msg () -> * mut irobot_create_msgs__action__DockServo_GetResult_Response { unsafe { irobot_create_msgs__action__DockServo_GetResult_Response__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__action__DockServo_GetResult_Response) -> () { unsafe { irobot_create_msgs__action__DockServo_GetResult_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { status : msg . status , result : irobot_create_msgs :: action :: DockServo :: Result :: from_native (& msg . result) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . status = self . status ; self . result . copy_to_native (& mut msg . result) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct FeedbackMessage { pub goal_id : unique_identifier_msgs :: msg :: UUID , pub feedback : irobot_create_msgs :: action :: DockServo :: Feedback } impl WrappedTypesupport for FeedbackMessage { type CStruct = irobot_create_msgs__action__DockServo_FeedbackMessage ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__action__DockServo_FeedbackMessage () } } fn create_msg () -> * mut irobot_create_msgs__action__DockServo_FeedbackMessage { unsafe { irobot_create_msgs__action__DockServo_FeedbackMessage__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__action__DockServo_FeedbackMessage) -> () { unsafe { irobot_create_msgs__action__DockServo_FeedbackMessage__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> FeedbackMessage { FeedbackMessage { goal_id : unique_identifier_msgs :: msg :: UUID :: from_native (& msg . goal_id) , feedback : irobot_create_msgs :: action :: DockServo :: Feedback :: from_native (& msg . feedback) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . goal_id . copy_to_native (& mut msg . goal_id) ; self . feedback . copy_to_native (& mut msg . feedback) ; } } impl Default for FeedbackMessage { fn default () -> Self { let msg_native = WrappedNativeMsg :: < FeedbackMessage > :: new () ; FeedbackMessage :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod DriveArc { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Action () ; impl WrappedActionTypeSupport for Action { type Goal = Goal ; type Result = Result ; type Feedback = Feedback ; type FeedbackMessage = FeedbackMessage ; type SendGoal = SendGoal :: Service ; type GetResult = GetResult :: Service ; fn get_ts () -> & 'static rosidl_action_type_support_t { unsafe { & * rosidl_typesupport_c__get_action_type_support_handle__irobot_create_msgs__action__DriveArc () } } fn make_goal_request_msg (goal_id : unique_identifier_msgs :: msg :: UUID , goal : Goal) -> SendGoal :: Request { SendGoal :: Request { goal_id , goal } } fn make_goal_response_msg (accepted : bool , stamp : builtin_interfaces :: msg :: Time) -> SendGoal :: Response { SendGoal :: Response { accepted , stamp } } fn make_feedback_msg (goal_id : unique_identifier_msgs :: msg :: UUID , feedback : Feedback) -> FeedbackMessage { FeedbackMessage { goal_id , feedback } } fn make_result_request_msg (goal_id : unique_identifier_msgs :: msg :: UUID) -> GetResult :: Request { GetResult :: Request { goal_id , } } fn make_result_response_msg (status : i8 , result : Result) -> GetResult :: Response { GetResult :: Response { status , result , } } fn destructure_goal_request_msg (msg : SendGoal :: Request) -> (unique_identifier_msgs :: msg :: UUID , Goal) { (msg . goal_id , msg . goal) } fn destructure_goal_response_msg (msg : SendGoal :: Response) -> (bool , builtin_interfaces :: msg :: Time) { (msg . accepted , msg . stamp) } fn destructure_feedback_msg (msg : FeedbackMessage) -> (unique_identifier_msgs :: msg :: UUID , Feedback) { (msg . goal_id , msg . feedback) } fn destructure_result_response_msg (msg : GetResult :: Response) -> (i8 , Result) { (msg . status , msg . result) } fn destructure_result_request_msg (msg : GetResult :: Request) -> unique_identifier_msgs :: msg :: UUID { msg . goal_id } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Goal { pub translate_direction : i8 , pub angle : f32 , pub radius : f32 , pub max_translation_speed : f32 } impl WrappedTypesupport for Goal { type CStruct = irobot_create_msgs__action__DriveArc_Goal ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__action__DriveArc_Goal () } } fn create_msg () -> * mut irobot_create_msgs__action__DriveArc_Goal { unsafe { irobot_create_msgs__action__DriveArc_Goal__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__action__DriveArc_Goal) -> () { unsafe { irobot_create_msgs__action__DriveArc_Goal__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Goal { Goal { translate_direction : msg . translate_direction , angle : msg . angle , radius : msg . radius , max_translation_speed : msg . max_translation_speed , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . translate_direction = self . translate_direction ; msg . angle = self . angle ; msg . radius = self . radius ; msg . max_translation_speed = self . max_translation_speed ; } } impl Default for Goal { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Goal > :: new () ; Goal :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl Goal { pub const TRANSLATE_BACKWARD : _bindgen_ty_245 = irobot_create_msgs__action__DriveArc_Goal__TRANSLATE_BACKWARD ; pub const TRANSLATE_FORWARD : _bindgen_ty_244 = irobot_create_msgs__action__DriveArc_Goal__TRANSLATE_FORWARD ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Result { pub pose : geometry_msgs :: msg :: PoseStamped } impl WrappedTypesupport for Result { type CStruct = irobot_create_msgs__action__DriveArc_Result ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__action__DriveArc_Result () } } fn create_msg () -> * mut irobot_create_msgs__action__DriveArc_Result { unsafe { irobot_create_msgs__action__DriveArc_Result__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__action__DriveArc_Result) -> () { unsafe { irobot_create_msgs__action__DriveArc_Result__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Result { Result { pose : geometry_msgs :: msg :: PoseStamped :: from_native (& msg . pose) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . pose . copy_to_native (& mut msg . pose) ; } } impl Default for Result { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Result > :: new () ; Result :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Feedback { pub remaining_angle_travel : f32 } impl WrappedTypesupport for Feedback { type CStruct = irobot_create_msgs__action__DriveArc_Feedback ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__action__DriveArc_Feedback () } } fn create_msg () -> * mut irobot_create_msgs__action__DriveArc_Feedback { unsafe { irobot_create_msgs__action__DriveArc_Feedback__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__action__DriveArc_Feedback) -> () { unsafe { irobot_create_msgs__action__DriveArc_Feedback__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Feedback { Feedback { remaining_angle_travel : msg . remaining_angle_travel , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . remaining_angle_travel = self . remaining_angle_travel ; } } impl Default for Feedback { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Feedback > :: new () ; Feedback :: from_native (& msg_native) } } # [allow (non_snake_case)] pub mod SendGoal { use super :: super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__irobot_create_msgs__action__DriveArc_SendGoal () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub goal_id : unique_identifier_msgs :: msg :: UUID , pub goal : irobot_create_msgs :: action :: DriveArc :: Goal } impl WrappedTypesupport for Request { type CStruct = irobot_create_msgs__action__DriveArc_SendGoal_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__action__DriveArc_SendGoal_Request () } } fn create_msg () -> * mut irobot_create_msgs__action__DriveArc_SendGoal_Request { unsafe { irobot_create_msgs__action__DriveArc_SendGoal_Request__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__action__DriveArc_SendGoal_Request) -> () { unsafe { irobot_create_msgs__action__DriveArc_SendGoal_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { goal_id : unique_identifier_msgs :: msg :: UUID :: from_native (& msg . goal_id) , goal : irobot_create_msgs :: action :: DriveArc :: Goal :: from_native (& msg . goal) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . goal_id . copy_to_native (& mut msg . goal_id) ; self . goal . copy_to_native (& mut msg . goal) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub accepted : bool , pub stamp : builtin_interfaces :: msg :: Time } impl WrappedTypesupport for Response { type CStruct = irobot_create_msgs__action__DriveArc_SendGoal_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__action__DriveArc_SendGoal_Response () } } fn create_msg () -> * mut irobot_create_msgs__action__DriveArc_SendGoal_Response { unsafe { irobot_create_msgs__action__DriveArc_SendGoal_Response__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__action__DriveArc_SendGoal_Response) -> () { unsafe { irobot_create_msgs__action__DriveArc_SendGoal_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { accepted : msg . accepted , stamp : builtin_interfaces :: msg :: Time :: from_native (& msg . stamp) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . accepted = self . accepted ; self . stamp . copy_to_native (& mut msg . stamp) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetResult { use super :: super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__irobot_create_msgs__action__DriveArc_GetResult () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub goal_id : unique_identifier_msgs :: msg :: UUID } impl WrappedTypesupport for Request { type CStruct = irobot_create_msgs__action__DriveArc_GetResult_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__action__DriveArc_GetResult_Request () } } fn create_msg () -> * mut irobot_create_msgs__action__DriveArc_GetResult_Request { unsafe { irobot_create_msgs__action__DriveArc_GetResult_Request__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__action__DriveArc_GetResult_Request) -> () { unsafe { irobot_create_msgs__action__DriveArc_GetResult_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { goal_id : unique_identifier_msgs :: msg :: UUID :: from_native (& msg . goal_id) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . goal_id . copy_to_native (& mut msg . goal_id) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub status : i8 , pub result : irobot_create_msgs :: action :: DriveArc :: Result } impl WrappedTypesupport for Response { type CStruct = irobot_create_msgs__action__DriveArc_GetResult_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__action__DriveArc_GetResult_Response () } } fn create_msg () -> * mut irobot_create_msgs__action__DriveArc_GetResult_Response { unsafe { irobot_create_msgs__action__DriveArc_GetResult_Response__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__action__DriveArc_GetResult_Response) -> () { unsafe { irobot_create_msgs__action__DriveArc_GetResult_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { status : msg . status , result : irobot_create_msgs :: action :: DriveArc :: Result :: from_native (& msg . result) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . status = self . status ; self . result . copy_to_native (& mut msg . result) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct FeedbackMessage { pub goal_id : unique_identifier_msgs :: msg :: UUID , pub feedback : irobot_create_msgs :: action :: DriveArc :: Feedback } impl WrappedTypesupport for FeedbackMessage { type CStruct = irobot_create_msgs__action__DriveArc_FeedbackMessage ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__action__DriveArc_FeedbackMessage () } } fn create_msg () -> * mut irobot_create_msgs__action__DriveArc_FeedbackMessage { unsafe { irobot_create_msgs__action__DriveArc_FeedbackMessage__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__action__DriveArc_FeedbackMessage) -> () { unsafe { irobot_create_msgs__action__DriveArc_FeedbackMessage__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> FeedbackMessage { FeedbackMessage { goal_id : unique_identifier_msgs :: msg :: UUID :: from_native (& msg . goal_id) , feedback : irobot_create_msgs :: action :: DriveArc :: Feedback :: from_native (& msg . feedback) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . goal_id . copy_to_native (& mut msg . goal_id) ; self . feedback . copy_to_native (& mut msg . feedback) ; } } impl Default for FeedbackMessage { fn default () -> Self { let msg_native = WrappedNativeMsg :: < FeedbackMessage > :: new () ; FeedbackMessage :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod DriveDistance { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Action () ; impl WrappedActionTypeSupport for Action { type Goal = Goal ; type Result = Result ; type Feedback = Feedback ; type FeedbackMessage = FeedbackMessage ; type SendGoal = SendGoal :: Service ; type GetResult = GetResult :: Service ; fn get_ts () -> & 'static rosidl_action_type_support_t { unsafe { & * rosidl_typesupport_c__get_action_type_support_handle__irobot_create_msgs__action__DriveDistance () } } fn make_goal_request_msg (goal_id : unique_identifier_msgs :: msg :: UUID , goal : Goal) -> SendGoal :: Request { SendGoal :: Request { goal_id , goal } } fn make_goal_response_msg (accepted : bool , stamp : builtin_interfaces :: msg :: Time) -> SendGoal :: Response { SendGoal :: Response { accepted , stamp } } fn make_feedback_msg (goal_id : unique_identifier_msgs :: msg :: UUID , feedback : Feedback) -> FeedbackMessage { FeedbackMessage { goal_id , feedback } } fn make_result_request_msg (goal_id : unique_identifier_msgs :: msg :: UUID) -> GetResult :: Request { GetResult :: Request { goal_id , } } fn make_result_response_msg (status : i8 , result : Result) -> GetResult :: Response { GetResult :: Response { status , result , } } fn destructure_goal_request_msg (msg : SendGoal :: Request) -> (unique_identifier_msgs :: msg :: UUID , Goal) { (msg . goal_id , msg . goal) } fn destructure_goal_response_msg (msg : SendGoal :: Response) -> (bool , builtin_interfaces :: msg :: Time) { (msg . accepted , msg . stamp) } fn destructure_feedback_msg (msg : FeedbackMessage) -> (unique_identifier_msgs :: msg :: UUID , Feedback) { (msg . goal_id , msg . feedback) } fn destructure_result_response_msg (msg : GetResult :: Response) -> (i8 , Result) { (msg . status , msg . result) } fn destructure_result_request_msg (msg : GetResult :: Request) -> unique_identifier_msgs :: msg :: UUID { msg . goal_id } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Goal { pub distance : f32 , pub max_translation_speed : f32 } impl WrappedTypesupport for Goal { type CStruct = irobot_create_msgs__action__DriveDistance_Goal ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__action__DriveDistance_Goal () } } fn create_msg () -> * mut irobot_create_msgs__action__DriveDistance_Goal { unsafe { irobot_create_msgs__action__DriveDistance_Goal__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__action__DriveDistance_Goal) -> () { unsafe { irobot_create_msgs__action__DriveDistance_Goal__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Goal { Goal { distance : msg . distance , max_translation_speed : msg . max_translation_speed , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . distance = self . distance ; msg . max_translation_speed = self . max_translation_speed ; } } impl Default for Goal { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Goal > :: new () ; Goal :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Result { pub pose : geometry_msgs :: msg :: PoseStamped } impl WrappedTypesupport for Result { type CStruct = irobot_create_msgs__action__DriveDistance_Result ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__action__DriveDistance_Result () } } fn create_msg () -> * mut irobot_create_msgs__action__DriveDistance_Result { unsafe { irobot_create_msgs__action__DriveDistance_Result__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__action__DriveDistance_Result) -> () { unsafe { irobot_create_msgs__action__DriveDistance_Result__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Result { Result { pose : geometry_msgs :: msg :: PoseStamped :: from_native (& msg . pose) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . pose . copy_to_native (& mut msg . pose) ; } } impl Default for Result { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Result > :: new () ; Result :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Feedback { pub remaining_travel_distance : f32 } impl WrappedTypesupport for Feedback { type CStruct = irobot_create_msgs__action__DriveDistance_Feedback ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__action__DriveDistance_Feedback () } } fn create_msg () -> * mut irobot_create_msgs__action__DriveDistance_Feedback { unsafe { irobot_create_msgs__action__DriveDistance_Feedback__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__action__DriveDistance_Feedback) -> () { unsafe { irobot_create_msgs__action__DriveDistance_Feedback__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Feedback { Feedback { remaining_travel_distance : msg . remaining_travel_distance , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . remaining_travel_distance = self . remaining_travel_distance ; } } impl Default for Feedback { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Feedback > :: new () ; Feedback :: from_native (& msg_native) } } # [allow (non_snake_case)] pub mod SendGoal { use super :: super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__irobot_create_msgs__action__DriveDistance_SendGoal () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub goal_id : unique_identifier_msgs :: msg :: UUID , pub goal : irobot_create_msgs :: action :: DriveDistance :: Goal } impl WrappedTypesupport for Request { type CStruct = irobot_create_msgs__action__DriveDistance_SendGoal_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__action__DriveDistance_SendGoal_Request () } } fn create_msg () -> * mut irobot_create_msgs__action__DriveDistance_SendGoal_Request { unsafe { irobot_create_msgs__action__DriveDistance_SendGoal_Request__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__action__DriveDistance_SendGoal_Request) -> () { unsafe { irobot_create_msgs__action__DriveDistance_SendGoal_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { goal_id : unique_identifier_msgs :: msg :: UUID :: from_native (& msg . goal_id) , goal : irobot_create_msgs :: action :: DriveDistance :: Goal :: from_native (& msg . goal) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . goal_id . copy_to_native (& mut msg . goal_id) ; self . goal . copy_to_native (& mut msg . goal) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub accepted : bool , pub stamp : builtin_interfaces :: msg :: Time } impl WrappedTypesupport for Response { type CStruct = irobot_create_msgs__action__DriveDistance_SendGoal_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__action__DriveDistance_SendGoal_Response () } } fn create_msg () -> * mut irobot_create_msgs__action__DriveDistance_SendGoal_Response { unsafe { irobot_create_msgs__action__DriveDistance_SendGoal_Response__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__action__DriveDistance_SendGoal_Response) -> () { unsafe { irobot_create_msgs__action__DriveDistance_SendGoal_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { accepted : msg . accepted , stamp : builtin_interfaces :: msg :: Time :: from_native (& msg . stamp) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . accepted = self . accepted ; self . stamp . copy_to_native (& mut msg . stamp) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetResult { use super :: super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__irobot_create_msgs__action__DriveDistance_GetResult () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub goal_id : unique_identifier_msgs :: msg :: UUID } impl WrappedTypesupport for Request { type CStruct = irobot_create_msgs__action__DriveDistance_GetResult_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__action__DriveDistance_GetResult_Request () } } fn create_msg () -> * mut irobot_create_msgs__action__DriveDistance_GetResult_Request { unsafe { irobot_create_msgs__action__DriveDistance_GetResult_Request__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__action__DriveDistance_GetResult_Request) -> () { unsafe { irobot_create_msgs__action__DriveDistance_GetResult_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { goal_id : unique_identifier_msgs :: msg :: UUID :: from_native (& msg . goal_id) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . goal_id . copy_to_native (& mut msg . goal_id) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub status : i8 , pub result : irobot_create_msgs :: action :: DriveDistance :: Result } impl WrappedTypesupport for Response { type CStruct = irobot_create_msgs__action__DriveDistance_GetResult_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__action__DriveDistance_GetResult_Response () } } fn create_msg () -> * mut irobot_create_msgs__action__DriveDistance_GetResult_Response { unsafe { irobot_create_msgs__action__DriveDistance_GetResult_Response__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__action__DriveDistance_GetResult_Response) -> () { unsafe { irobot_create_msgs__action__DriveDistance_GetResult_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { status : msg . status , result : irobot_create_msgs :: action :: DriveDistance :: Result :: from_native (& msg . result) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . status = self . status ; self . result . copy_to_native (& mut msg . result) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct FeedbackMessage { pub goal_id : unique_identifier_msgs :: msg :: UUID , pub feedback : irobot_create_msgs :: action :: DriveDistance :: Feedback } impl WrappedTypesupport for FeedbackMessage { type CStruct = irobot_create_msgs__action__DriveDistance_FeedbackMessage ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__action__DriveDistance_FeedbackMessage () } } fn create_msg () -> * mut irobot_create_msgs__action__DriveDistance_FeedbackMessage { unsafe { irobot_create_msgs__action__DriveDistance_FeedbackMessage__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__action__DriveDistance_FeedbackMessage) -> () { unsafe { irobot_create_msgs__action__DriveDistance_FeedbackMessage__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> FeedbackMessage { FeedbackMessage { goal_id : unique_identifier_msgs :: msg :: UUID :: from_native (& msg . goal_id) , feedback : irobot_create_msgs :: action :: DriveDistance :: Feedback :: from_native (& msg . feedback) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . goal_id . copy_to_native (& mut msg . goal_id) ; self . feedback . copy_to_native (& mut msg . feedback) ; } } impl Default for FeedbackMessage { fn default () -> Self { let msg_native = WrappedNativeMsg :: < FeedbackMessage > :: new () ; FeedbackMessage :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod LedAnimation { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Action () ; impl WrappedActionTypeSupport for Action { type Goal = Goal ; type Result = Result ; type Feedback = Feedback ; type FeedbackMessage = FeedbackMessage ; type SendGoal = SendGoal :: Service ; type GetResult = GetResult :: Service ; fn get_ts () -> & 'static rosidl_action_type_support_t { unsafe { & * rosidl_typesupport_c__get_action_type_support_handle__irobot_create_msgs__action__LedAnimation () } } fn make_goal_request_msg (goal_id : unique_identifier_msgs :: msg :: UUID , goal : Goal) -> SendGoal :: Request { SendGoal :: Request { goal_id , goal } } fn make_goal_response_msg (accepted : bool , stamp : builtin_interfaces :: msg :: Time) -> SendGoal :: Response { SendGoal :: Response { accepted , stamp } } fn make_feedback_msg (goal_id : unique_identifier_msgs :: msg :: UUID , feedback : Feedback) -> FeedbackMessage { FeedbackMessage { goal_id , feedback } } fn make_result_request_msg (goal_id : unique_identifier_msgs :: msg :: UUID) -> GetResult :: Request { GetResult :: Request { goal_id , } } fn make_result_response_msg (status : i8 , result : Result) -> GetResult :: Response { GetResult :: Response { status , result , } } fn destructure_goal_request_msg (msg : SendGoal :: Request) -> (unique_identifier_msgs :: msg :: UUID , Goal) { (msg . goal_id , msg . goal) } fn destructure_goal_response_msg (msg : SendGoal :: Response) -> (bool , builtin_interfaces :: msg :: Time) { (msg . accepted , msg . stamp) } fn destructure_feedback_msg (msg : FeedbackMessage) -> (unique_identifier_msgs :: msg :: UUID , Feedback) { (msg . goal_id , msg . feedback) } fn destructure_result_response_msg (msg : GetResult :: Response) -> (i8 , Result) { (msg . status , msg . result) } fn destructure_result_request_msg (msg : GetResult :: Request) -> unique_identifier_msgs :: msg :: UUID { msg . goal_id } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Goal { pub animation_type : i8 , pub lightring : irobot_create_msgs :: msg :: LightringLeds , pub max_runtime : builtin_interfaces :: msg :: Duration } impl WrappedTypesupport for Goal { type CStruct = irobot_create_msgs__action__LedAnimation_Goal ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__action__LedAnimation_Goal () } } fn create_msg () -> * mut irobot_create_msgs__action__LedAnimation_Goal { unsafe { irobot_create_msgs__action__LedAnimation_Goal__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__action__LedAnimation_Goal) -> () { unsafe { irobot_create_msgs__action__LedAnimation_Goal__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Goal { Goal { animation_type : msg . animation_type , lightring : irobot_create_msgs :: msg :: LightringLeds :: from_native (& msg . lightring) , max_runtime : builtin_interfaces :: msg :: Duration :: from_native (& msg . max_runtime) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . animation_type = self . animation_type ; self . lightring . copy_to_native (& mut msg . lightring) ; self . max_runtime . copy_to_native (& mut msg . max_runtime) ; } } impl Default for Goal { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Goal > :: new () ; Goal :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl Goal { pub const BLINK_LIGHTS : _bindgen_ty_246 = irobot_create_msgs__action__LedAnimation_Goal__BLINK_LIGHTS ; pub const SPIN_LIGHTS : _bindgen_ty_247 = irobot_create_msgs__action__LedAnimation_Goal__SPIN_LIGHTS ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Result { pub runtime : builtin_interfaces :: msg :: Duration } impl WrappedTypesupport for Result { type CStruct = irobot_create_msgs__action__LedAnimation_Result ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__action__LedAnimation_Result () } } fn create_msg () -> * mut irobot_create_msgs__action__LedAnimation_Result { unsafe { irobot_create_msgs__action__LedAnimation_Result__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__action__LedAnimation_Result) -> () { unsafe { irobot_create_msgs__action__LedAnimation_Result__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Result { Result { runtime : builtin_interfaces :: msg :: Duration :: from_native (& msg . runtime) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . runtime . copy_to_native (& mut msg . runtime) ; } } impl Default for Result { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Result > :: new () ; Result :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Feedback { pub remaining_runtime : builtin_interfaces :: msg :: Duration } impl WrappedTypesupport for Feedback { type CStruct = irobot_create_msgs__action__LedAnimation_Feedback ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__action__LedAnimation_Feedback () } } fn create_msg () -> * mut irobot_create_msgs__action__LedAnimation_Feedback { unsafe { irobot_create_msgs__action__LedAnimation_Feedback__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__action__LedAnimation_Feedback) -> () { unsafe { irobot_create_msgs__action__LedAnimation_Feedback__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Feedback { Feedback { remaining_runtime : builtin_interfaces :: msg :: Duration :: from_native (& msg . remaining_runtime) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . remaining_runtime . copy_to_native (& mut msg . remaining_runtime) ; } } impl Default for Feedback { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Feedback > :: new () ; Feedback :: from_native (& msg_native) } } # [allow (non_snake_case)] pub mod SendGoal { use super :: super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__irobot_create_msgs__action__LedAnimation_SendGoal () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub goal_id : unique_identifier_msgs :: msg :: UUID , pub goal : irobot_create_msgs :: action :: LedAnimation :: Goal } impl WrappedTypesupport for Request { type CStruct = irobot_create_msgs__action__LedAnimation_SendGoal_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__action__LedAnimation_SendGoal_Request () } } fn create_msg () -> * mut irobot_create_msgs__action__LedAnimation_SendGoal_Request { unsafe { irobot_create_msgs__action__LedAnimation_SendGoal_Request__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__action__LedAnimation_SendGoal_Request) -> () { unsafe { irobot_create_msgs__action__LedAnimation_SendGoal_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { goal_id : unique_identifier_msgs :: msg :: UUID :: from_native (& msg . goal_id) , goal : irobot_create_msgs :: action :: LedAnimation :: Goal :: from_native (& msg . goal) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . goal_id . copy_to_native (& mut msg . goal_id) ; self . goal . copy_to_native (& mut msg . goal) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub accepted : bool , pub stamp : builtin_interfaces :: msg :: Time } impl WrappedTypesupport for Response { type CStruct = irobot_create_msgs__action__LedAnimation_SendGoal_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__action__LedAnimation_SendGoal_Response () } } fn create_msg () -> * mut irobot_create_msgs__action__LedAnimation_SendGoal_Response { unsafe { irobot_create_msgs__action__LedAnimation_SendGoal_Response__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__action__LedAnimation_SendGoal_Response) -> () { unsafe { irobot_create_msgs__action__LedAnimation_SendGoal_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { accepted : msg . accepted , stamp : builtin_interfaces :: msg :: Time :: from_native (& msg . stamp) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . accepted = self . accepted ; self . stamp . copy_to_native (& mut msg . stamp) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetResult { use super :: super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__irobot_create_msgs__action__LedAnimation_GetResult () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub goal_id : unique_identifier_msgs :: msg :: UUID } impl WrappedTypesupport for Request { type CStruct = irobot_create_msgs__action__LedAnimation_GetResult_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__action__LedAnimation_GetResult_Request () } } fn create_msg () -> * mut irobot_create_msgs__action__LedAnimation_GetResult_Request { unsafe { irobot_create_msgs__action__LedAnimation_GetResult_Request__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__action__LedAnimation_GetResult_Request) -> () { unsafe { irobot_create_msgs__action__LedAnimation_GetResult_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { goal_id : unique_identifier_msgs :: msg :: UUID :: from_native (& msg . goal_id) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . goal_id . copy_to_native (& mut msg . goal_id) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub status : i8 , pub result : irobot_create_msgs :: action :: LedAnimation :: Result } impl WrappedTypesupport for Response { type CStruct = irobot_create_msgs__action__LedAnimation_GetResult_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__action__LedAnimation_GetResult_Response () } } fn create_msg () -> * mut irobot_create_msgs__action__LedAnimation_GetResult_Response { unsafe { irobot_create_msgs__action__LedAnimation_GetResult_Response__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__action__LedAnimation_GetResult_Response) -> () { unsafe { irobot_create_msgs__action__LedAnimation_GetResult_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { status : msg . status , result : irobot_create_msgs :: action :: LedAnimation :: Result :: from_native (& msg . result) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . status = self . status ; self . result . copy_to_native (& mut msg . result) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct FeedbackMessage { pub goal_id : unique_identifier_msgs :: msg :: UUID , pub feedback : irobot_create_msgs :: action :: LedAnimation :: Feedback } impl WrappedTypesupport for FeedbackMessage { type CStruct = irobot_create_msgs__action__LedAnimation_FeedbackMessage ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__action__LedAnimation_FeedbackMessage () } } fn create_msg () -> * mut irobot_create_msgs__action__LedAnimation_FeedbackMessage { unsafe { irobot_create_msgs__action__LedAnimation_FeedbackMessage__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__action__LedAnimation_FeedbackMessage) -> () { unsafe { irobot_create_msgs__action__LedAnimation_FeedbackMessage__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> FeedbackMessage { FeedbackMessage { goal_id : unique_identifier_msgs :: msg :: UUID :: from_native (& msg . goal_id) , feedback : irobot_create_msgs :: action :: LedAnimation :: Feedback :: from_native (& msg . feedback) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . goal_id . copy_to_native (& mut msg . goal_id) ; self . feedback . copy_to_native (& mut msg . feedback) ; } } impl Default for FeedbackMessage { fn default () -> Self { let msg_native = WrappedNativeMsg :: < FeedbackMessage > :: new () ; FeedbackMessage :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod NavigateToPosition { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Action () ; impl WrappedActionTypeSupport for Action { type Goal = Goal ; type Result = Result ; type Feedback = Feedback ; type FeedbackMessage = FeedbackMessage ; type SendGoal = SendGoal :: Service ; type GetResult = GetResult :: Service ; fn get_ts () -> & 'static rosidl_action_type_support_t { unsafe { & * rosidl_typesupport_c__get_action_type_support_handle__irobot_create_msgs__action__NavigateToPosition () } } fn make_goal_request_msg (goal_id : unique_identifier_msgs :: msg :: UUID , goal : Goal) -> SendGoal :: Request { SendGoal :: Request { goal_id , goal } } fn make_goal_response_msg (accepted : bool , stamp : builtin_interfaces :: msg :: Time) -> SendGoal :: Response { SendGoal :: Response { accepted , stamp } } fn make_feedback_msg (goal_id : unique_identifier_msgs :: msg :: UUID , feedback : Feedback) -> FeedbackMessage { FeedbackMessage { goal_id , feedback } } fn make_result_request_msg (goal_id : unique_identifier_msgs :: msg :: UUID) -> GetResult :: Request { GetResult :: Request { goal_id , } } fn make_result_response_msg (status : i8 , result : Result) -> GetResult :: Response { GetResult :: Response { status , result , } } fn destructure_goal_request_msg (msg : SendGoal :: Request) -> (unique_identifier_msgs :: msg :: UUID , Goal) { (msg . goal_id , msg . goal) } fn destructure_goal_response_msg (msg : SendGoal :: Response) -> (bool , builtin_interfaces :: msg :: Time) { (msg . accepted , msg . stamp) } fn destructure_feedback_msg (msg : FeedbackMessage) -> (unique_identifier_msgs :: msg :: UUID , Feedback) { (msg . goal_id , msg . feedback) } fn destructure_result_response_msg (msg : GetResult :: Response) -> (i8 , Result) { (msg . status , msg . result) } fn destructure_result_request_msg (msg : GetResult :: Request) -> unique_identifier_msgs :: msg :: UUID { msg . goal_id } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Goal { pub goal_pose : geometry_msgs :: msg :: PoseStamped , pub achieve_goal_heading : bool , pub max_translation_speed : f32 , pub max_rotation_speed : f32 } impl WrappedTypesupport for Goal { type CStruct = irobot_create_msgs__action__NavigateToPosition_Goal ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__action__NavigateToPosition_Goal () } } fn create_msg () -> * mut irobot_create_msgs__action__NavigateToPosition_Goal { unsafe { irobot_create_msgs__action__NavigateToPosition_Goal__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__action__NavigateToPosition_Goal) -> () { unsafe { irobot_create_msgs__action__NavigateToPosition_Goal__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Goal { Goal { goal_pose : geometry_msgs :: msg :: PoseStamped :: from_native (& msg . goal_pose) , achieve_goal_heading : msg . achieve_goal_heading , max_translation_speed : msg . max_translation_speed , max_rotation_speed : msg . max_rotation_speed , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . goal_pose . copy_to_native (& mut msg . goal_pose) ; msg . achieve_goal_heading = self . achieve_goal_heading ; msg . max_translation_speed = self . max_translation_speed ; msg . max_rotation_speed = self . max_rotation_speed ; } } impl Default for Goal { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Goal > :: new () ; Goal :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Result { pub pose : geometry_msgs :: msg :: PoseStamped } impl WrappedTypesupport for Result { type CStruct = irobot_create_msgs__action__NavigateToPosition_Result ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__action__NavigateToPosition_Result () } } fn create_msg () -> * mut irobot_create_msgs__action__NavigateToPosition_Result { unsafe { irobot_create_msgs__action__NavigateToPosition_Result__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__action__NavigateToPosition_Result) -> () { unsafe { irobot_create_msgs__action__NavigateToPosition_Result__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Result { Result { pose : geometry_msgs :: msg :: PoseStamped :: from_native (& msg . pose) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . pose . copy_to_native (& mut msg . pose) ; } } impl Default for Result { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Result > :: new () ; Result :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Feedback { pub navigate_state : i8 , pub remaining_angle_travel : f32 , pub remaining_travel_distance : f32 } impl WrappedTypesupport for Feedback { type CStruct = irobot_create_msgs__action__NavigateToPosition_Feedback ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__action__NavigateToPosition_Feedback () } } fn create_msg () -> * mut irobot_create_msgs__action__NavigateToPosition_Feedback { unsafe { irobot_create_msgs__action__NavigateToPosition_Feedback__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__action__NavigateToPosition_Feedback) -> () { unsafe { irobot_create_msgs__action__NavigateToPosition_Feedback__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Feedback { Feedback { navigate_state : msg . navigate_state , remaining_angle_travel : msg . remaining_angle_travel , remaining_travel_distance : msg . remaining_travel_distance , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . navigate_state = self . navigate_state ; msg . remaining_angle_travel = self . remaining_angle_travel ; msg . remaining_travel_distance = self . remaining_travel_distance ; } } impl Default for Feedback { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Feedback > :: new () ; Feedback :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl Feedback { pub const DRIVING_TO_GOAL_POSITION : _bindgen_ty_249 = irobot_create_msgs__action__NavigateToPosition_Feedback__DRIVING_TO_GOAL_POSITION ; pub const ROTATING_TO_GOAL_ORIENTATION : _bindgen_ty_250 = irobot_create_msgs__action__NavigateToPosition_Feedback__ROTATING_TO_GOAL_ORIENTATION ; pub const ROTATING_TO_GOAL_POSITION : _bindgen_ty_248 = irobot_create_msgs__action__NavigateToPosition_Feedback__ROTATING_TO_GOAL_POSITION ; } # [allow (non_snake_case)] pub mod SendGoal { use super :: super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__irobot_create_msgs__action__NavigateToPosition_SendGoal () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub goal_id : unique_identifier_msgs :: msg :: UUID , pub goal : irobot_create_msgs :: action :: NavigateToPosition :: Goal } impl WrappedTypesupport for Request { type CStruct = irobot_create_msgs__action__NavigateToPosition_SendGoal_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__action__NavigateToPosition_SendGoal_Request () } } fn create_msg () -> * mut irobot_create_msgs__action__NavigateToPosition_SendGoal_Request { unsafe { irobot_create_msgs__action__NavigateToPosition_SendGoal_Request__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__action__NavigateToPosition_SendGoal_Request) -> () { unsafe { irobot_create_msgs__action__NavigateToPosition_SendGoal_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { goal_id : unique_identifier_msgs :: msg :: UUID :: from_native (& msg . goal_id) , goal : irobot_create_msgs :: action :: NavigateToPosition :: Goal :: from_native (& msg . goal) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . goal_id . copy_to_native (& mut msg . goal_id) ; self . goal . copy_to_native (& mut msg . goal) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub accepted : bool , pub stamp : builtin_interfaces :: msg :: Time } impl WrappedTypesupport for Response { type CStruct = irobot_create_msgs__action__NavigateToPosition_SendGoal_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__action__NavigateToPosition_SendGoal_Response () } } fn create_msg () -> * mut irobot_create_msgs__action__NavigateToPosition_SendGoal_Response { unsafe { irobot_create_msgs__action__NavigateToPosition_SendGoal_Response__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__action__NavigateToPosition_SendGoal_Response) -> () { unsafe { irobot_create_msgs__action__NavigateToPosition_SendGoal_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { accepted : msg . accepted , stamp : builtin_interfaces :: msg :: Time :: from_native (& msg . stamp) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . accepted = self . accepted ; self . stamp . copy_to_native (& mut msg . stamp) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetResult { use super :: super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__irobot_create_msgs__action__NavigateToPosition_GetResult () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub goal_id : unique_identifier_msgs :: msg :: UUID } impl WrappedTypesupport for Request { type CStruct = irobot_create_msgs__action__NavigateToPosition_GetResult_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__action__NavigateToPosition_GetResult_Request () } } fn create_msg () -> * mut irobot_create_msgs__action__NavigateToPosition_GetResult_Request { unsafe { irobot_create_msgs__action__NavigateToPosition_GetResult_Request__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__action__NavigateToPosition_GetResult_Request) -> () { unsafe { irobot_create_msgs__action__NavigateToPosition_GetResult_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { goal_id : unique_identifier_msgs :: msg :: UUID :: from_native (& msg . goal_id) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . goal_id . copy_to_native (& mut msg . goal_id) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub status : i8 , pub result : irobot_create_msgs :: action :: NavigateToPosition :: Result } impl WrappedTypesupport for Response { type CStruct = irobot_create_msgs__action__NavigateToPosition_GetResult_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__action__NavigateToPosition_GetResult_Response () } } fn create_msg () -> * mut irobot_create_msgs__action__NavigateToPosition_GetResult_Response { unsafe { irobot_create_msgs__action__NavigateToPosition_GetResult_Response__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__action__NavigateToPosition_GetResult_Response) -> () { unsafe { irobot_create_msgs__action__NavigateToPosition_GetResult_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { status : msg . status , result : irobot_create_msgs :: action :: NavigateToPosition :: Result :: from_native (& msg . result) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . status = self . status ; self . result . copy_to_native (& mut msg . result) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct FeedbackMessage { pub goal_id : unique_identifier_msgs :: msg :: UUID , pub feedback : irobot_create_msgs :: action :: NavigateToPosition :: Feedback } impl WrappedTypesupport for FeedbackMessage { type CStruct = irobot_create_msgs__action__NavigateToPosition_FeedbackMessage ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__action__NavigateToPosition_FeedbackMessage () } } fn create_msg () -> * mut irobot_create_msgs__action__NavigateToPosition_FeedbackMessage { unsafe { irobot_create_msgs__action__NavigateToPosition_FeedbackMessage__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__action__NavigateToPosition_FeedbackMessage) -> () { unsafe { irobot_create_msgs__action__NavigateToPosition_FeedbackMessage__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> FeedbackMessage { FeedbackMessage { goal_id : unique_identifier_msgs :: msg :: UUID :: from_native (& msg . goal_id) , feedback : irobot_create_msgs :: action :: NavigateToPosition :: Feedback :: from_native (& msg . feedback) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . goal_id . copy_to_native (& mut msg . goal_id) ; self . feedback . copy_to_native (& mut msg . feedback) ; } } impl Default for FeedbackMessage { fn default () -> Self { let msg_native = WrappedNativeMsg :: < FeedbackMessage > :: new () ; FeedbackMessage :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod RotateAngle { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Action () ; impl WrappedActionTypeSupport for Action { type Goal = Goal ; type Result = Result ; type Feedback = Feedback ; type FeedbackMessage = FeedbackMessage ; type SendGoal = SendGoal :: Service ; type GetResult = GetResult :: Service ; fn get_ts () -> & 'static rosidl_action_type_support_t { unsafe { & * rosidl_typesupport_c__get_action_type_support_handle__irobot_create_msgs__action__RotateAngle () } } fn make_goal_request_msg (goal_id : unique_identifier_msgs :: msg :: UUID , goal : Goal) -> SendGoal :: Request { SendGoal :: Request { goal_id , goal } } fn make_goal_response_msg (accepted : bool , stamp : builtin_interfaces :: msg :: Time) -> SendGoal :: Response { SendGoal :: Response { accepted , stamp } } fn make_feedback_msg (goal_id : unique_identifier_msgs :: msg :: UUID , feedback : Feedback) -> FeedbackMessage { FeedbackMessage { goal_id , feedback } } fn make_result_request_msg (goal_id : unique_identifier_msgs :: msg :: UUID) -> GetResult :: Request { GetResult :: Request { goal_id , } } fn make_result_response_msg (status : i8 , result : Result) -> GetResult :: Response { GetResult :: Response { status , result , } } fn destructure_goal_request_msg (msg : SendGoal :: Request) -> (unique_identifier_msgs :: msg :: UUID , Goal) { (msg . goal_id , msg . goal) } fn destructure_goal_response_msg (msg : SendGoal :: Response) -> (bool , builtin_interfaces :: msg :: Time) { (msg . accepted , msg . stamp) } fn destructure_feedback_msg (msg : FeedbackMessage) -> (unique_identifier_msgs :: msg :: UUID , Feedback) { (msg . goal_id , msg . feedback) } fn destructure_result_response_msg (msg : GetResult :: Response) -> (i8 , Result) { (msg . status , msg . result) } fn destructure_result_request_msg (msg : GetResult :: Request) -> unique_identifier_msgs :: msg :: UUID { msg . goal_id } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Goal { pub angle : f32 , pub max_rotation_speed : f32 } impl WrappedTypesupport for Goal { type CStruct = irobot_create_msgs__action__RotateAngle_Goal ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__action__RotateAngle_Goal () } } fn create_msg () -> * mut irobot_create_msgs__action__RotateAngle_Goal { unsafe { irobot_create_msgs__action__RotateAngle_Goal__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__action__RotateAngle_Goal) -> () { unsafe { irobot_create_msgs__action__RotateAngle_Goal__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Goal { Goal { angle : msg . angle , max_rotation_speed : msg . max_rotation_speed , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . angle = self . angle ; msg . max_rotation_speed = self . max_rotation_speed ; } } impl Default for Goal { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Goal > :: new () ; Goal :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Result { pub pose : geometry_msgs :: msg :: PoseStamped } impl WrappedTypesupport for Result { type CStruct = irobot_create_msgs__action__RotateAngle_Result ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__action__RotateAngle_Result () } } fn create_msg () -> * mut irobot_create_msgs__action__RotateAngle_Result { unsafe { irobot_create_msgs__action__RotateAngle_Result__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__action__RotateAngle_Result) -> () { unsafe { irobot_create_msgs__action__RotateAngle_Result__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Result { Result { pose : geometry_msgs :: msg :: PoseStamped :: from_native (& msg . pose) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . pose . copy_to_native (& mut msg . pose) ; } } impl Default for Result { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Result > :: new () ; Result :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Feedback { pub remaining_angle_travel : f32 } impl WrappedTypesupport for Feedback { type CStruct = irobot_create_msgs__action__RotateAngle_Feedback ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__action__RotateAngle_Feedback () } } fn create_msg () -> * mut irobot_create_msgs__action__RotateAngle_Feedback { unsafe { irobot_create_msgs__action__RotateAngle_Feedback__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__action__RotateAngle_Feedback) -> () { unsafe { irobot_create_msgs__action__RotateAngle_Feedback__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Feedback { Feedback { remaining_angle_travel : msg . remaining_angle_travel , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . remaining_angle_travel = self . remaining_angle_travel ; } } impl Default for Feedback { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Feedback > :: new () ; Feedback :: from_native (& msg_native) } } # [allow (non_snake_case)] pub mod SendGoal { use super :: super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__irobot_create_msgs__action__RotateAngle_SendGoal () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub goal_id : unique_identifier_msgs :: msg :: UUID , pub goal : irobot_create_msgs :: action :: RotateAngle :: Goal } impl WrappedTypesupport for Request { type CStruct = irobot_create_msgs__action__RotateAngle_SendGoal_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__action__RotateAngle_SendGoal_Request () } } fn create_msg () -> * mut irobot_create_msgs__action__RotateAngle_SendGoal_Request { unsafe { irobot_create_msgs__action__RotateAngle_SendGoal_Request__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__action__RotateAngle_SendGoal_Request) -> () { unsafe { irobot_create_msgs__action__RotateAngle_SendGoal_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { goal_id : unique_identifier_msgs :: msg :: UUID :: from_native (& msg . goal_id) , goal : irobot_create_msgs :: action :: RotateAngle :: Goal :: from_native (& msg . goal) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . goal_id . copy_to_native (& mut msg . goal_id) ; self . goal . copy_to_native (& mut msg . goal) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub accepted : bool , pub stamp : builtin_interfaces :: msg :: Time } impl WrappedTypesupport for Response { type CStruct = irobot_create_msgs__action__RotateAngle_SendGoal_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__action__RotateAngle_SendGoal_Response () } } fn create_msg () -> * mut irobot_create_msgs__action__RotateAngle_SendGoal_Response { unsafe { irobot_create_msgs__action__RotateAngle_SendGoal_Response__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__action__RotateAngle_SendGoal_Response) -> () { unsafe { irobot_create_msgs__action__RotateAngle_SendGoal_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { accepted : msg . accepted , stamp : builtin_interfaces :: msg :: Time :: from_native (& msg . stamp) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . accepted = self . accepted ; self . stamp . copy_to_native (& mut msg . stamp) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetResult { use super :: super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__irobot_create_msgs__action__RotateAngle_GetResult () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub goal_id : unique_identifier_msgs :: msg :: UUID } impl WrappedTypesupport for Request { type CStruct = irobot_create_msgs__action__RotateAngle_GetResult_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__action__RotateAngle_GetResult_Request () } } fn create_msg () -> * mut irobot_create_msgs__action__RotateAngle_GetResult_Request { unsafe { irobot_create_msgs__action__RotateAngle_GetResult_Request__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__action__RotateAngle_GetResult_Request) -> () { unsafe { irobot_create_msgs__action__RotateAngle_GetResult_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { goal_id : unique_identifier_msgs :: msg :: UUID :: from_native (& msg . goal_id) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . goal_id . copy_to_native (& mut msg . goal_id) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub status : i8 , pub result : irobot_create_msgs :: action :: RotateAngle :: Result } impl WrappedTypesupport for Response { type CStruct = irobot_create_msgs__action__RotateAngle_GetResult_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__action__RotateAngle_GetResult_Response () } } fn create_msg () -> * mut irobot_create_msgs__action__RotateAngle_GetResult_Response { unsafe { irobot_create_msgs__action__RotateAngle_GetResult_Response__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__action__RotateAngle_GetResult_Response) -> () { unsafe { irobot_create_msgs__action__RotateAngle_GetResult_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { status : msg . status , result : irobot_create_msgs :: action :: RotateAngle :: Result :: from_native (& msg . result) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . status = self . status ; self . result . copy_to_native (& mut msg . result) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct FeedbackMessage { pub goal_id : unique_identifier_msgs :: msg :: UUID , pub feedback : irobot_create_msgs :: action :: RotateAngle :: Feedback } impl WrappedTypesupport for FeedbackMessage { type CStruct = irobot_create_msgs__action__RotateAngle_FeedbackMessage ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__action__RotateAngle_FeedbackMessage () } } fn create_msg () -> * mut irobot_create_msgs__action__RotateAngle_FeedbackMessage { unsafe { irobot_create_msgs__action__RotateAngle_FeedbackMessage__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__action__RotateAngle_FeedbackMessage) -> () { unsafe { irobot_create_msgs__action__RotateAngle_FeedbackMessage__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> FeedbackMessage { FeedbackMessage { goal_id : unique_identifier_msgs :: msg :: UUID :: from_native (& msg . goal_id) , feedback : irobot_create_msgs :: action :: RotateAngle :: Feedback :: from_native (& msg . feedback) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . goal_id . copy_to_native (& mut msg . goal_id) ; self . feedback . copy_to_native (& mut msg . feedback) ; } } impl Default for FeedbackMessage { fn default () -> Self { let msg_native = WrappedNativeMsg :: < FeedbackMessage > :: new () ; FeedbackMessage :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod Undock { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Action () ; impl WrappedActionTypeSupport for Action { type Goal = Goal ; type Result = Result ; type Feedback = Feedback ; type FeedbackMessage = FeedbackMessage ; type SendGoal = SendGoal :: Service ; type GetResult = GetResult :: Service ; fn get_ts () -> & 'static rosidl_action_type_support_t { unsafe { & * rosidl_typesupport_c__get_action_type_support_handle__irobot_create_msgs__action__Undock () } } fn make_goal_request_msg (goal_id : unique_identifier_msgs :: msg :: UUID , goal : Goal) -> SendGoal :: Request { SendGoal :: Request { goal_id , goal } } fn make_goal_response_msg (accepted : bool , stamp : builtin_interfaces :: msg :: Time) -> SendGoal :: Response { SendGoal :: Response { accepted , stamp } } fn make_feedback_msg (goal_id : unique_identifier_msgs :: msg :: UUID , feedback : Feedback) -> FeedbackMessage { FeedbackMessage { goal_id , feedback } } fn make_result_request_msg (goal_id : unique_identifier_msgs :: msg :: UUID) -> GetResult :: Request { GetResult :: Request { goal_id , } } fn make_result_response_msg (status : i8 , result : Result) -> GetResult :: Response { GetResult :: Response { status , result , } } fn destructure_goal_request_msg (msg : SendGoal :: Request) -> (unique_identifier_msgs :: msg :: UUID , Goal) { (msg . goal_id , msg . goal) } fn destructure_goal_response_msg (msg : SendGoal :: Response) -> (bool , builtin_interfaces :: msg :: Time) { (msg . accepted , msg . stamp) } fn destructure_feedback_msg (msg : FeedbackMessage) -> (unique_identifier_msgs :: msg :: UUID , Feedback) { (msg . goal_id , msg . feedback) } fn destructure_result_response_msg (msg : GetResult :: Response) -> (i8 , Result) { (msg . status , msg . result) } fn destructure_result_request_msg (msg : GetResult :: Request) -> unique_identifier_msgs :: msg :: UUID { msg . goal_id } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Goal { } impl WrappedTypesupport for Goal { type CStruct = irobot_create_msgs__action__Undock_Goal ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__action__Undock_Goal () } } fn create_msg () -> * mut irobot_create_msgs__action__Undock_Goal { unsafe { irobot_create_msgs__action__Undock_Goal__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__action__Undock_Goal) -> () { unsafe { irobot_create_msgs__action__Undock_Goal__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Goal { Goal { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Goal { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Goal > :: new () ; Goal :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Result { pub is_docked : bool } impl WrappedTypesupport for Result { type CStruct = irobot_create_msgs__action__Undock_Result ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__action__Undock_Result () } } fn create_msg () -> * mut irobot_create_msgs__action__Undock_Result { unsafe { irobot_create_msgs__action__Undock_Result__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__action__Undock_Result) -> () { unsafe { irobot_create_msgs__action__Undock_Result__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Result { Result { is_docked : msg . is_docked , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . is_docked = self . is_docked ; } } impl Default for Result { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Result > :: new () ; Result :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Feedback { } impl WrappedTypesupport for Feedback { type CStruct = irobot_create_msgs__action__Undock_Feedback ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__action__Undock_Feedback () } } fn create_msg () -> * mut irobot_create_msgs__action__Undock_Feedback { unsafe { irobot_create_msgs__action__Undock_Feedback__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__action__Undock_Feedback) -> () { unsafe { irobot_create_msgs__action__Undock_Feedback__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Feedback { Feedback { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Feedback { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Feedback > :: new () ; Feedback :: from_native (& msg_native) } } # [allow (non_snake_case)] pub mod SendGoal { use super :: super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__irobot_create_msgs__action__Undock_SendGoal () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub goal_id : unique_identifier_msgs :: msg :: UUID , pub goal : irobot_create_msgs :: action :: Undock :: Goal } impl WrappedTypesupport for Request { type CStruct = irobot_create_msgs__action__Undock_SendGoal_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__action__Undock_SendGoal_Request () } } fn create_msg () -> * mut irobot_create_msgs__action__Undock_SendGoal_Request { unsafe { irobot_create_msgs__action__Undock_SendGoal_Request__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__action__Undock_SendGoal_Request) -> () { unsafe { irobot_create_msgs__action__Undock_SendGoal_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { goal_id : unique_identifier_msgs :: msg :: UUID :: from_native (& msg . goal_id) , goal : irobot_create_msgs :: action :: Undock :: Goal :: from_native (& msg . goal) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . goal_id . copy_to_native (& mut msg . goal_id) ; self . goal . copy_to_native (& mut msg . goal) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub accepted : bool , pub stamp : builtin_interfaces :: msg :: Time } impl WrappedTypesupport for Response { type CStruct = irobot_create_msgs__action__Undock_SendGoal_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__action__Undock_SendGoal_Response () } } fn create_msg () -> * mut irobot_create_msgs__action__Undock_SendGoal_Response { unsafe { irobot_create_msgs__action__Undock_SendGoal_Response__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__action__Undock_SendGoal_Response) -> () { unsafe { irobot_create_msgs__action__Undock_SendGoal_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { accepted : msg . accepted , stamp : builtin_interfaces :: msg :: Time :: from_native (& msg . stamp) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . accepted = self . accepted ; self . stamp . copy_to_native (& mut msg . stamp) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetResult { use super :: super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__irobot_create_msgs__action__Undock_GetResult () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub goal_id : unique_identifier_msgs :: msg :: UUID } impl WrappedTypesupport for Request { type CStruct = irobot_create_msgs__action__Undock_GetResult_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__action__Undock_GetResult_Request () } } fn create_msg () -> * mut irobot_create_msgs__action__Undock_GetResult_Request { unsafe { irobot_create_msgs__action__Undock_GetResult_Request__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__action__Undock_GetResult_Request) -> () { unsafe { irobot_create_msgs__action__Undock_GetResult_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { goal_id : unique_identifier_msgs :: msg :: UUID :: from_native (& msg . goal_id) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . goal_id . copy_to_native (& mut msg . goal_id) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub status : i8 , pub result : irobot_create_msgs :: action :: Undock :: Result } impl WrappedTypesupport for Response { type CStruct = irobot_create_msgs__action__Undock_GetResult_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__action__Undock_GetResult_Response () } } fn create_msg () -> * mut irobot_create_msgs__action__Undock_GetResult_Response { unsafe { irobot_create_msgs__action__Undock_GetResult_Response__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__action__Undock_GetResult_Response) -> () { unsafe { irobot_create_msgs__action__Undock_GetResult_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { status : msg . status , result : irobot_create_msgs :: action :: Undock :: Result :: from_native (& msg . result) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . status = self . status ; self . result . copy_to_native (& mut msg . result) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct FeedbackMessage { pub goal_id : unique_identifier_msgs :: msg :: UUID , pub feedback : irobot_create_msgs :: action :: Undock :: Feedback } impl WrappedTypesupport for FeedbackMessage { type CStruct = irobot_create_msgs__action__Undock_FeedbackMessage ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__action__Undock_FeedbackMessage () } } fn create_msg () -> * mut irobot_create_msgs__action__Undock_FeedbackMessage { unsafe { irobot_create_msgs__action__Undock_FeedbackMessage__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__action__Undock_FeedbackMessage) -> () { unsafe { irobot_create_msgs__action__Undock_FeedbackMessage__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> FeedbackMessage { FeedbackMessage { goal_id : unique_identifier_msgs :: msg :: UUID :: from_native (& msg . goal_id) , feedback : irobot_create_msgs :: action :: Undock :: Feedback :: from_native (& msg . feedback) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . goal_id . copy_to_native (& mut msg . goal_id) ; self . feedback . copy_to_native (& mut msg . feedback) ; } } impl Default for FeedbackMessage { fn default () -> Self { let msg_native = WrappedNativeMsg :: < FeedbackMessage > :: new () ; FeedbackMessage :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod WallFollow { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Action () ; impl WrappedActionTypeSupport for Action { type Goal = Goal ; type Result = Result ; type Feedback = Feedback ; type FeedbackMessage = FeedbackMessage ; type SendGoal = SendGoal :: Service ; type GetResult = GetResult :: Service ; fn get_ts () -> & 'static rosidl_action_type_support_t { unsafe { & * rosidl_typesupport_c__get_action_type_support_handle__irobot_create_msgs__action__WallFollow () } } fn make_goal_request_msg (goal_id : unique_identifier_msgs :: msg :: UUID , goal : Goal) -> SendGoal :: Request { SendGoal :: Request { goal_id , goal } } fn make_goal_response_msg (accepted : bool , stamp : builtin_interfaces :: msg :: Time) -> SendGoal :: Response { SendGoal :: Response { accepted , stamp } } fn make_feedback_msg (goal_id : unique_identifier_msgs :: msg :: UUID , feedback : Feedback) -> FeedbackMessage { FeedbackMessage { goal_id , feedback } } fn make_result_request_msg (goal_id : unique_identifier_msgs :: msg :: UUID) -> GetResult :: Request { GetResult :: Request { goal_id , } } fn make_result_response_msg (status : i8 , result : Result) -> GetResult :: Response { GetResult :: Response { status , result , } } fn destructure_goal_request_msg (msg : SendGoal :: Request) -> (unique_identifier_msgs :: msg :: UUID , Goal) { (msg . goal_id , msg . goal) } fn destructure_goal_response_msg (msg : SendGoal :: Response) -> (bool , builtin_interfaces :: msg :: Time) { (msg . accepted , msg . stamp) } fn destructure_feedback_msg (msg : FeedbackMessage) -> (unique_identifier_msgs :: msg :: UUID , Feedback) { (msg . goal_id , msg . feedback) } fn destructure_result_response_msg (msg : GetResult :: Response) -> (i8 , Result) { (msg . status , msg . result) } fn destructure_result_request_msg (msg : GetResult :: Request) -> unique_identifier_msgs :: msg :: UUID { msg . goal_id } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Goal { pub follow_side : i8 , pub max_runtime : builtin_interfaces :: msg :: Duration } impl WrappedTypesupport for Goal { type CStruct = irobot_create_msgs__action__WallFollow_Goal ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__action__WallFollow_Goal () } } fn create_msg () -> * mut irobot_create_msgs__action__WallFollow_Goal { unsafe { irobot_create_msgs__action__WallFollow_Goal__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__action__WallFollow_Goal) -> () { unsafe { irobot_create_msgs__action__WallFollow_Goal__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Goal { Goal { follow_side : msg . follow_side , max_runtime : builtin_interfaces :: msg :: Duration :: from_native (& msg . max_runtime) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . follow_side = self . follow_side ; self . max_runtime . copy_to_native (& mut msg . max_runtime) ; } } impl Default for Goal { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Goal > :: new () ; Goal :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl Goal { pub const FOLLOW_LEFT : _bindgen_ty_252 = irobot_create_msgs__action__WallFollow_Goal__FOLLOW_LEFT ; pub const FOLLOW_RIGHT : _bindgen_ty_251 = irobot_create_msgs__action__WallFollow_Goal__FOLLOW_RIGHT ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Result { pub runtime : builtin_interfaces :: msg :: Duration } impl WrappedTypesupport for Result { type CStruct = irobot_create_msgs__action__WallFollow_Result ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__action__WallFollow_Result () } } fn create_msg () -> * mut irobot_create_msgs__action__WallFollow_Result { unsafe { irobot_create_msgs__action__WallFollow_Result__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__action__WallFollow_Result) -> () { unsafe { irobot_create_msgs__action__WallFollow_Result__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Result { Result { runtime : builtin_interfaces :: msg :: Duration :: from_native (& msg . runtime) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . runtime . copy_to_native (& mut msg . runtime) ; } } impl Default for Result { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Result > :: new () ; Result :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Feedback { pub engaged : bool } impl WrappedTypesupport for Feedback { type CStruct = irobot_create_msgs__action__WallFollow_Feedback ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__action__WallFollow_Feedback () } } fn create_msg () -> * mut irobot_create_msgs__action__WallFollow_Feedback { unsafe { irobot_create_msgs__action__WallFollow_Feedback__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__action__WallFollow_Feedback) -> () { unsafe { irobot_create_msgs__action__WallFollow_Feedback__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Feedback { Feedback { engaged : msg . engaged , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . engaged = self . engaged ; } } impl Default for Feedback { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Feedback > :: new () ; Feedback :: from_native (& msg_native) } } # [allow (non_snake_case)] pub mod SendGoal { use super :: super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__irobot_create_msgs__action__WallFollow_SendGoal () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub goal_id : unique_identifier_msgs :: msg :: UUID , pub goal : irobot_create_msgs :: action :: WallFollow :: Goal } impl WrappedTypesupport for Request { type CStruct = irobot_create_msgs__action__WallFollow_SendGoal_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__action__WallFollow_SendGoal_Request () } } fn create_msg () -> * mut irobot_create_msgs__action__WallFollow_SendGoal_Request { unsafe { irobot_create_msgs__action__WallFollow_SendGoal_Request__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__action__WallFollow_SendGoal_Request) -> () { unsafe { irobot_create_msgs__action__WallFollow_SendGoal_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { goal_id : unique_identifier_msgs :: msg :: UUID :: from_native (& msg . goal_id) , goal : irobot_create_msgs :: action :: WallFollow :: Goal :: from_native (& msg . goal) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . goal_id . copy_to_native (& mut msg . goal_id) ; self . goal . copy_to_native (& mut msg . goal) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub accepted : bool , pub stamp : builtin_interfaces :: msg :: Time } impl WrappedTypesupport for Response { type CStruct = irobot_create_msgs__action__WallFollow_SendGoal_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__action__WallFollow_SendGoal_Response () } } fn create_msg () -> * mut irobot_create_msgs__action__WallFollow_SendGoal_Response { unsafe { irobot_create_msgs__action__WallFollow_SendGoal_Response__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__action__WallFollow_SendGoal_Response) -> () { unsafe { irobot_create_msgs__action__WallFollow_SendGoal_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { accepted : msg . accepted , stamp : builtin_interfaces :: msg :: Time :: from_native (& msg . stamp) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . accepted = self . accepted ; self . stamp . copy_to_native (& mut msg . stamp) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetResult { use super :: super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__irobot_create_msgs__action__WallFollow_GetResult () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub goal_id : unique_identifier_msgs :: msg :: UUID } impl WrappedTypesupport for Request { type CStruct = irobot_create_msgs__action__WallFollow_GetResult_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__action__WallFollow_GetResult_Request () } } fn create_msg () -> * mut irobot_create_msgs__action__WallFollow_GetResult_Request { unsafe { irobot_create_msgs__action__WallFollow_GetResult_Request__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__action__WallFollow_GetResult_Request) -> () { unsafe { irobot_create_msgs__action__WallFollow_GetResult_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { goal_id : unique_identifier_msgs :: msg :: UUID :: from_native (& msg . goal_id) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . goal_id . copy_to_native (& mut msg . goal_id) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub status : i8 , pub result : irobot_create_msgs :: action :: WallFollow :: Result } impl WrappedTypesupport for Response { type CStruct = irobot_create_msgs__action__WallFollow_GetResult_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__action__WallFollow_GetResult_Response () } } fn create_msg () -> * mut irobot_create_msgs__action__WallFollow_GetResult_Response { unsafe { irobot_create_msgs__action__WallFollow_GetResult_Response__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__action__WallFollow_GetResult_Response) -> () { unsafe { irobot_create_msgs__action__WallFollow_GetResult_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { status : msg . status , result : irobot_create_msgs :: action :: WallFollow :: Result :: from_native (& msg . result) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . status = self . status ; self . result . copy_to_native (& mut msg . result) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct FeedbackMessage { pub goal_id : unique_identifier_msgs :: msg :: UUID , pub feedback : irobot_create_msgs :: action :: WallFollow :: Feedback } impl WrappedTypesupport for FeedbackMessage { type CStruct = irobot_create_msgs__action__WallFollow_FeedbackMessage ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__irobot_create_msgs__action__WallFollow_FeedbackMessage () } } fn create_msg () -> * mut irobot_create_msgs__action__WallFollow_FeedbackMessage { unsafe { irobot_create_msgs__action__WallFollow_FeedbackMessage__create () } } fn destroy_msg (msg : * mut irobot_create_msgs__action__WallFollow_FeedbackMessage) -> () { unsafe { irobot_create_msgs__action__WallFollow_FeedbackMessage__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> FeedbackMessage { FeedbackMessage { goal_id : unique_identifier_msgs :: msg :: UUID :: from_native (& msg . goal_id) , feedback : irobot_create_msgs :: action :: WallFollow :: Feedback :: from_native (& msg . feedback) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . goal_id . copy_to_native (& mut msg . goal_id) ; self . feedback . copy_to_native (& mut msg . feedback) ; } } impl Default for FeedbackMessage { fn default () -> Self { let msg_native = WrappedNativeMsg :: < FeedbackMessage > :: new () ; FeedbackMessage :: from_native (& msg_native) } } } }