pub mod msg { use super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ChestLed { pub color : std_msgs :: msg :: ColorRGBA } impl WrappedTypesupport for ChestLed { type CStruct = nao_command_msgs__msg__ChestLed ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__nao_command_msgs__msg__ChestLed () } } fn create_msg () -> * mut nao_command_msgs__msg__ChestLed { unsafe { nao_command_msgs__msg__ChestLed__create () } } fn destroy_msg (msg : * mut nao_command_msgs__msg__ChestLed) -> () { unsafe { nao_command_msgs__msg__ChestLed__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ChestLed { ChestLed { color : std_msgs :: msg :: ColorRGBA :: from_native (& msg . color) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . color . copy_to_native (& mut msg . color) ; } } impl Default for ChestLed { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ChestLed > :: new () ; ChestLed :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct HeadLeds { pub intensities : Vec < f32 > } impl WrappedTypesupport for HeadLeds { type CStruct = nao_command_msgs__msg__HeadLeds ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__nao_command_msgs__msg__HeadLeds () } } fn create_msg () -> * mut nao_command_msgs__msg__HeadLeds { unsafe { nao_command_msgs__msg__HeadLeds__create () } } fn destroy_msg (msg : * mut nao_command_msgs__msg__HeadLeds) -> () { unsafe { nao_command_msgs__msg__HeadLeds__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> HeadLeds { HeadLeds { intensities : msg . intensities . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { assert_eq ! (self . intensities . len () , 12usize , "Field {} is fixed size of {}!" , "intensities" , 12usize) ; msg . intensities . copy_from_slice (& self . intensities [.. 12usize]) ; } } impl Default for HeadLeds { fn default () -> Self { let msg_native = WrappedNativeMsg :: < HeadLeds > :: new () ; HeadLeds :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl HeadLeds { pub const B0 : _bindgen_ty_974 = nao_command_msgs__msg__HeadLeds__B0 ; pub const B1 : _bindgen_ty_975 = nao_command_msgs__msg__HeadLeds__B1 ; pub const B10 : _bindgen_ty_984 = nao_command_msgs__msg__HeadLeds__B10 ; pub const B11 : _bindgen_ty_985 = nao_command_msgs__msg__HeadLeds__B11 ; pub const B2 : _bindgen_ty_976 = nao_command_msgs__msg__HeadLeds__B2 ; pub const B3 : _bindgen_ty_977 = nao_command_msgs__msg__HeadLeds__B3 ; pub const B4 : _bindgen_ty_978 = nao_command_msgs__msg__HeadLeds__B4 ; pub const B5 : _bindgen_ty_979 = nao_command_msgs__msg__HeadLeds__B5 ; pub const B6 : _bindgen_ty_980 = nao_command_msgs__msg__HeadLeds__B6 ; pub const B7 : _bindgen_ty_981 = nao_command_msgs__msg__HeadLeds__B7 ; pub const B8 : _bindgen_ty_982 = nao_command_msgs__msg__HeadLeds__B8 ; pub const B9 : _bindgen_ty_983 = nao_command_msgs__msg__HeadLeds__B9 ; pub const NUM_LEDS : _bindgen_ty_986 = nao_command_msgs__msg__HeadLeds__NUM_LEDS ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct JointIndexes { } impl WrappedTypesupport for JointIndexes { type CStruct = nao_command_msgs__msg__JointIndexes ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__nao_command_msgs__msg__JointIndexes () } } fn create_msg () -> * mut nao_command_msgs__msg__JointIndexes { unsafe { nao_command_msgs__msg__JointIndexes__create () } } fn destroy_msg (msg : * mut nao_command_msgs__msg__JointIndexes) -> () { unsafe { nao_command_msgs__msg__JointIndexes__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> JointIndexes { JointIndexes { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for JointIndexes { fn default () -> Self { let msg_native = WrappedNativeMsg :: < JointIndexes > :: new () ; JointIndexes :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl JointIndexes { pub const HEADPITCH : _bindgen_ty_988 = nao_command_msgs__msg__JointIndexes__HEADPITCH ; pub const HEADYAW : _bindgen_ty_987 = nao_command_msgs__msg__JointIndexes__HEADYAW ; pub const LANKLEPITCH : _bindgen_ty_998 = nao_command_msgs__msg__JointIndexes__LANKLEPITCH ; pub const LANKLEROLL : _bindgen_ty_999 = nao_command_msgs__msg__JointIndexes__LANKLEROLL ; pub const LELBOWROLL : _bindgen_ty_992 = nao_command_msgs__msg__JointIndexes__LELBOWROLL ; pub const LELBOWYAW : _bindgen_ty_991 = nao_command_msgs__msg__JointIndexes__LELBOWYAW ; pub const LHAND : _bindgen_ty_1010 = nao_command_msgs__msg__JointIndexes__LHAND ; pub const LHIPPITCH : _bindgen_ty_996 = nao_command_msgs__msg__JointIndexes__LHIPPITCH ; pub const LHIPROLL : _bindgen_ty_995 = nao_command_msgs__msg__JointIndexes__LHIPROLL ; pub const LHIPYAWPITCH : _bindgen_ty_994 = nao_command_msgs__msg__JointIndexes__LHIPYAWPITCH ; pub const LKNEEPITCH : _bindgen_ty_997 = nao_command_msgs__msg__JointIndexes__LKNEEPITCH ; pub const LSHOULDERPITCH : _bindgen_ty_989 = nao_command_msgs__msg__JointIndexes__LSHOULDERPITCH ; pub const LSHOULDERROLL : _bindgen_ty_990 = nao_command_msgs__msg__JointIndexes__LSHOULDERROLL ; pub const LWRISTYAW : _bindgen_ty_993 = nao_command_msgs__msg__JointIndexes__LWRISTYAW ; pub const NUMJOINTS : _bindgen_ty_1012 = nao_command_msgs__msg__JointIndexes__NUMJOINTS ; pub const RANKLEPITCH : _bindgen_ty_1003 = nao_command_msgs__msg__JointIndexes__RANKLEPITCH ; pub const RANKLEROLL : _bindgen_ty_1004 = nao_command_msgs__msg__JointIndexes__RANKLEROLL ; pub const RELBOWROLL : _bindgen_ty_1008 = nao_command_msgs__msg__JointIndexes__RELBOWROLL ; pub const RELBOWYAW : _bindgen_ty_1007 = nao_command_msgs__msg__JointIndexes__RELBOWYAW ; pub const RHAND : _bindgen_ty_1011 = nao_command_msgs__msg__JointIndexes__RHAND ; pub const RHIPPITCH : _bindgen_ty_1001 = nao_command_msgs__msg__JointIndexes__RHIPPITCH ; pub const RHIPROLL : _bindgen_ty_1000 = nao_command_msgs__msg__JointIndexes__RHIPROLL ; pub const RKNEEPITCH : _bindgen_ty_1002 = nao_command_msgs__msg__JointIndexes__RKNEEPITCH ; pub const RSHOULDERPITCH : _bindgen_ty_1005 = nao_command_msgs__msg__JointIndexes__RSHOULDERPITCH ; pub const RSHOULDERROLL : _bindgen_ty_1006 = nao_command_msgs__msg__JointIndexes__RSHOULDERROLL ; pub const RWRISTYAW : _bindgen_ty_1009 = nao_command_msgs__msg__JointIndexes__RWRISTYAW ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct JointPositions { pub indexes : Vec < u8 > , pub positions : Vec < f32 > } impl WrappedTypesupport for JointPositions { type CStruct = nao_command_msgs__msg__JointPositions ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__nao_command_msgs__msg__JointPositions () } } fn create_msg () -> * mut nao_command_msgs__msg__JointPositions { unsafe { nao_command_msgs__msg__JointPositions__create () } } fn destroy_msg (msg : * mut nao_command_msgs__msg__JointPositions) -> () { unsafe { nao_command_msgs__msg__JointPositions__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> JointPositions { JointPositions { indexes : msg . indexes . to_vec () , positions : msg . positions . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . indexes . update (& self . indexes) ; msg . positions . update (& self . positions) ; } } impl Default for JointPositions { fn default () -> Self { let msg_native = WrappedNativeMsg :: < JointPositions > :: new () ; JointPositions :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct JointStiffnesses { pub indexes : Vec < u8 > , pub stiffnesses : Vec < f32 > } impl WrappedTypesupport for JointStiffnesses { type CStruct = nao_command_msgs__msg__JointStiffnesses ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__nao_command_msgs__msg__JointStiffnesses () } } fn create_msg () -> * mut nao_command_msgs__msg__JointStiffnesses { unsafe { nao_command_msgs__msg__JointStiffnesses__create () } } fn destroy_msg (msg : * mut nao_command_msgs__msg__JointStiffnesses) -> () { unsafe { nao_command_msgs__msg__JointStiffnesses__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> JointStiffnesses { JointStiffnesses { indexes : msg . indexes . to_vec () , stiffnesses : msg . stiffnesses . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . indexes . update (& self . indexes) ; msg . stiffnesses . update (& self . stiffnesses) ; } } impl Default for JointStiffnesses { fn default () -> Self { let msg_native = WrappedNativeMsg :: < JointStiffnesses > :: new () ; JointStiffnesses :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct LeftEarLeds { pub intensities : Vec < f32 > } impl WrappedTypesupport for LeftEarLeds { type CStruct = nao_command_msgs__msg__LeftEarLeds ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__nao_command_msgs__msg__LeftEarLeds () } } fn create_msg () -> * mut nao_command_msgs__msg__LeftEarLeds { unsafe { nao_command_msgs__msg__LeftEarLeds__create () } } fn destroy_msg (msg : * mut nao_command_msgs__msg__LeftEarLeds) -> () { unsafe { nao_command_msgs__msg__LeftEarLeds__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> LeftEarLeds { LeftEarLeds { intensities : msg . intensities . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { assert_eq ! (self . intensities . len () , 10usize , "Field {} is fixed size of {}!" , "intensities" , 10usize) ; msg . intensities . copy_from_slice (& self . intensities [.. 10usize]) ; } } impl Default for LeftEarLeds { fn default () -> Self { let msg_native = WrappedNativeMsg :: < LeftEarLeds > :: new () ; LeftEarLeds :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl LeftEarLeds { pub const L0 : _bindgen_ty_1013 = nao_command_msgs__msg__LeftEarLeds__L0 ; pub const L1 : _bindgen_ty_1014 = nao_command_msgs__msg__LeftEarLeds__L1 ; pub const L2 : _bindgen_ty_1015 = nao_command_msgs__msg__LeftEarLeds__L2 ; pub const L3 : _bindgen_ty_1016 = nao_command_msgs__msg__LeftEarLeds__L3 ; pub const L4 : _bindgen_ty_1017 = nao_command_msgs__msg__LeftEarLeds__L4 ; pub const L5 : _bindgen_ty_1018 = nao_command_msgs__msg__LeftEarLeds__L5 ; pub const L6 : _bindgen_ty_1019 = nao_command_msgs__msg__LeftEarLeds__L6 ; pub const L7 : _bindgen_ty_1020 = nao_command_msgs__msg__LeftEarLeds__L7 ; pub const L8 : _bindgen_ty_1021 = nao_command_msgs__msg__LeftEarLeds__L8 ; pub const L9 : _bindgen_ty_1022 = nao_command_msgs__msg__LeftEarLeds__L9 ; pub const NUM_LEDS : _bindgen_ty_1023 = nao_command_msgs__msg__LeftEarLeds__NUM_LEDS ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct LeftEyeLeds { pub colors : Vec < std_msgs :: msg :: ColorRGBA > } impl WrappedTypesupport for LeftEyeLeds { type CStruct = nao_command_msgs__msg__LeftEyeLeds ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__nao_command_msgs__msg__LeftEyeLeds () } } fn create_msg () -> * mut nao_command_msgs__msg__LeftEyeLeds { unsafe { nao_command_msgs__msg__LeftEyeLeds__create () } } fn destroy_msg (msg : * mut nao_command_msgs__msg__LeftEyeLeds) -> () { unsafe { nao_command_msgs__msg__LeftEyeLeds__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> LeftEyeLeds { LeftEyeLeds { colors : { let vec : Vec < _ > = msg . colors . iter () . map (| s | std_msgs :: msg :: ColorRGBA :: from_native (s)) . collect () ; vec } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { assert_eq ! (self . colors . len () , 8usize , "Field {} is fixed size of {}!" , "colors" , 8usize) ; for (t , s) in msg . colors . iter_mut () . zip (& self . colors) { s . copy_to_native (t) ; } } } impl Default for LeftEyeLeds { fn default () -> Self { let msg_native = WrappedNativeMsg :: < LeftEyeLeds > :: new () ; LeftEyeLeds :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl LeftEyeLeds { pub const L0 : _bindgen_ty_1024 = nao_command_msgs__msg__LeftEyeLeds__L0 ; pub const L1 : _bindgen_ty_1025 = nao_command_msgs__msg__LeftEyeLeds__L1 ; pub const L2 : _bindgen_ty_1026 = nao_command_msgs__msg__LeftEyeLeds__L2 ; pub const L3 : _bindgen_ty_1027 = nao_command_msgs__msg__LeftEyeLeds__L3 ; pub const L4 : _bindgen_ty_1028 = nao_command_msgs__msg__LeftEyeLeds__L4 ; pub const L5 : _bindgen_ty_1029 = nao_command_msgs__msg__LeftEyeLeds__L5 ; pub const L6 : _bindgen_ty_1030 = nao_command_msgs__msg__LeftEyeLeds__L6 ; pub const L7 : _bindgen_ty_1031 = nao_command_msgs__msg__LeftEyeLeds__L7 ; pub const NUM_LEDS : _bindgen_ty_1032 = nao_command_msgs__msg__LeftEyeLeds__NUM_LEDS ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct LeftFootLed { pub color : std_msgs :: msg :: ColorRGBA } impl WrappedTypesupport for LeftFootLed { type CStruct = nao_command_msgs__msg__LeftFootLed ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__nao_command_msgs__msg__LeftFootLed () } } fn create_msg () -> * mut nao_command_msgs__msg__LeftFootLed { unsafe { nao_command_msgs__msg__LeftFootLed__create () } } fn destroy_msg (msg : * mut nao_command_msgs__msg__LeftFootLed) -> () { unsafe { nao_command_msgs__msg__LeftFootLed__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> LeftFootLed { LeftFootLed { color : std_msgs :: msg :: ColorRGBA :: from_native (& msg . color) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . color . copy_to_native (& mut msg . color) ; } } impl Default for LeftFootLed { fn default () -> Self { let msg_native = WrappedNativeMsg :: < LeftFootLed > :: new () ; LeftFootLed :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct RightEarLeds { pub intensities : Vec < f32 > } impl WrappedTypesupport for RightEarLeds { type CStruct = nao_command_msgs__msg__RightEarLeds ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__nao_command_msgs__msg__RightEarLeds () } } fn create_msg () -> * mut nao_command_msgs__msg__RightEarLeds { unsafe { nao_command_msgs__msg__RightEarLeds__create () } } fn destroy_msg (msg : * mut nao_command_msgs__msg__RightEarLeds) -> () { unsafe { nao_command_msgs__msg__RightEarLeds__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> RightEarLeds { RightEarLeds { intensities : msg . intensities . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { assert_eq ! (self . intensities . len () , 10usize , "Field {} is fixed size of {}!" , "intensities" , 10usize) ; msg . intensities . copy_from_slice (& self . intensities [.. 10usize]) ; } } impl Default for RightEarLeds { fn default () -> Self { let msg_native = WrappedNativeMsg :: < RightEarLeds > :: new () ; RightEarLeds :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl RightEarLeds { pub const NUM_LEDS : _bindgen_ty_1043 = nao_command_msgs__msg__RightEarLeds__NUM_LEDS ; pub const R0 : _bindgen_ty_1033 = nao_command_msgs__msg__RightEarLeds__R0 ; pub const R1 : _bindgen_ty_1034 = nao_command_msgs__msg__RightEarLeds__R1 ; pub const R2 : _bindgen_ty_1035 = nao_command_msgs__msg__RightEarLeds__R2 ; pub const R3 : _bindgen_ty_1036 = nao_command_msgs__msg__RightEarLeds__R3 ; pub const R4 : _bindgen_ty_1037 = nao_command_msgs__msg__RightEarLeds__R4 ; pub const R5 : _bindgen_ty_1038 = nao_command_msgs__msg__RightEarLeds__R5 ; pub const R6 : _bindgen_ty_1039 = nao_command_msgs__msg__RightEarLeds__R6 ; pub const R7 : _bindgen_ty_1040 = nao_command_msgs__msg__RightEarLeds__R7 ; pub const R8 : _bindgen_ty_1041 = nao_command_msgs__msg__RightEarLeds__R8 ; pub const R9 : _bindgen_ty_1042 = nao_command_msgs__msg__RightEarLeds__R9 ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct RightEyeLeds { pub colors : Vec < std_msgs :: msg :: ColorRGBA > } impl WrappedTypesupport for RightEyeLeds { type CStruct = nao_command_msgs__msg__RightEyeLeds ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__nao_command_msgs__msg__RightEyeLeds () } } fn create_msg () -> * mut nao_command_msgs__msg__RightEyeLeds { unsafe { nao_command_msgs__msg__RightEyeLeds__create () } } fn destroy_msg (msg : * mut nao_command_msgs__msg__RightEyeLeds) -> () { unsafe { nao_command_msgs__msg__RightEyeLeds__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> RightEyeLeds { RightEyeLeds { colors : { let vec : Vec < _ > = msg . colors . iter () . map (| s | std_msgs :: msg :: ColorRGBA :: from_native (s)) . collect () ; vec } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { assert_eq ! (self . colors . len () , 8usize , "Field {} is fixed size of {}!" , "colors" , 8usize) ; for (t , s) in msg . colors . iter_mut () . zip (& self . colors) { s . copy_to_native (t) ; } } } impl Default for RightEyeLeds { fn default () -> Self { let msg_native = WrappedNativeMsg :: < RightEyeLeds > :: new () ; RightEyeLeds :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl RightEyeLeds { pub const NUM_LEDS : _bindgen_ty_1052 = nao_command_msgs__msg__RightEyeLeds__NUM_LEDS ; pub const R0 : _bindgen_ty_1044 = nao_command_msgs__msg__RightEyeLeds__R0 ; pub const R1 : _bindgen_ty_1045 = nao_command_msgs__msg__RightEyeLeds__R1 ; pub const R2 : _bindgen_ty_1046 = nao_command_msgs__msg__RightEyeLeds__R2 ; pub const R3 : _bindgen_ty_1047 = nao_command_msgs__msg__RightEyeLeds__R3 ; pub const R4 : _bindgen_ty_1048 = nao_command_msgs__msg__RightEyeLeds__R4 ; pub const R5 : _bindgen_ty_1049 = nao_command_msgs__msg__RightEyeLeds__R5 ; pub const R6 : _bindgen_ty_1050 = nao_command_msgs__msg__RightEyeLeds__R6 ; pub const R7 : _bindgen_ty_1051 = nao_command_msgs__msg__RightEyeLeds__R7 ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct RightFootLed { pub color : std_msgs :: msg :: ColorRGBA } impl WrappedTypesupport for RightFootLed { type CStruct = nao_command_msgs__msg__RightFootLed ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__nao_command_msgs__msg__RightFootLed () } } fn create_msg () -> * mut nao_command_msgs__msg__RightFootLed { unsafe { nao_command_msgs__msg__RightFootLed__create () } } fn destroy_msg (msg : * mut nao_command_msgs__msg__RightFootLed) -> () { unsafe { nao_command_msgs__msg__RightFootLed__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> RightFootLed { RightFootLed { color : std_msgs :: msg :: ColorRGBA :: from_native (& msg . color) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . color . copy_to_native (& mut msg . color) ; } } impl Default for RightFootLed { fn default () -> Self { let msg_native = WrappedNativeMsg :: < RightFootLed > :: new () ; RightFootLed :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct SonarUsage { pub left : bool , pub right : bool } impl WrappedTypesupport for SonarUsage { type CStruct = nao_command_msgs__msg__SonarUsage ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__nao_command_msgs__msg__SonarUsage () } } fn create_msg () -> * mut nao_command_msgs__msg__SonarUsage { unsafe { nao_command_msgs__msg__SonarUsage__create () } } fn destroy_msg (msg : * mut nao_command_msgs__msg__SonarUsage) -> () { unsafe { nao_command_msgs__msg__SonarUsage__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> SonarUsage { SonarUsage { left : msg . left , right : msg . right , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . left = self . left ; msg . right = self . right ; } } impl Default for SonarUsage { fn default () -> Self { let msg_native = WrappedNativeMsg :: < SonarUsage > :: new () ; SonarUsage :: from_native (& msg_native) } } }