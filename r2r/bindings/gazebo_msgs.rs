pub mod msg { use super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ContactState { pub info : std :: string :: String , pub collision1_name : std :: string :: String , pub collision2_name : std :: string :: String , pub wrenches : Vec < geometry_msgs :: msg :: Wrench > , pub total_wrench : geometry_msgs :: msg :: Wrench , pub contact_positions : Vec < geometry_msgs :: msg :: Vector3 > , pub contact_normals : Vec < geometry_msgs :: msg :: Vector3 > , pub depths : Vec < f64 > } impl WrappedTypesupport for ContactState { type CStruct = gazebo_msgs__msg__ContactState ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__gazebo_msgs__msg__ContactState () } } fn create_msg () -> * mut gazebo_msgs__msg__ContactState { unsafe { gazebo_msgs__msg__ContactState__create () } } fn destroy_msg (msg : * mut gazebo_msgs__msg__ContactState) -> () { unsafe { gazebo_msgs__msg__ContactState__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ContactState { ContactState { info : msg . info . to_str () . to_owned () , collision1_name : msg . collision1_name . to_str () . to_owned () , collision2_name : msg . collision2_name . to_str () . to_owned () , wrenches : { let mut temp = Vec :: with_capacity (msg . wrenches . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . wrenches . data , msg . wrenches . size) } ; for s in slice { temp . push (geometry_msgs :: msg :: Wrench :: from_native (s)) ; } temp } , total_wrench : geometry_msgs :: msg :: Wrench :: from_native (& msg . total_wrench) , contact_positions : { let mut temp = Vec :: with_capacity (msg . contact_positions . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . contact_positions . data , msg . contact_positions . size) } ; for s in slice { temp . push (geometry_msgs :: msg :: Vector3 :: from_native (s)) ; } temp } , contact_normals : { let mut temp = Vec :: with_capacity (msg . contact_normals . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . contact_normals . data , msg . contact_normals . size) } ; for s in slice { temp . push (geometry_msgs :: msg :: Vector3 :: from_native (s)) ; } temp } , depths : msg . depths . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . info . assign (& self . info) ; msg . collision1_name . assign (& self . collision1_name) ; msg . collision2_name . assign (& self . collision2_name) ; unsafe { geometry_msgs__msg__Wrench__Sequence__fini (& mut msg . wrenches) ; geometry_msgs__msg__Wrench__Sequence__init (& mut msg . wrenches , self . wrenches . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . wrenches . data , msg . wrenches . size) ; for (t , s) in slice . iter_mut () . zip (& self . wrenches) { s . copy_to_native (t) ; } } self . total_wrench . copy_to_native (& mut msg . total_wrench) ; unsafe { geometry_msgs__msg__Vector3__Sequence__fini (& mut msg . contact_positions) ; geometry_msgs__msg__Vector3__Sequence__init (& mut msg . contact_positions , self . contact_positions . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . contact_positions . data , msg . contact_positions . size) ; for (t , s) in slice . iter_mut () . zip (& self . contact_positions) { s . copy_to_native (t) ; } } unsafe { geometry_msgs__msg__Vector3__Sequence__fini (& mut msg . contact_normals) ; geometry_msgs__msg__Vector3__Sequence__init (& mut msg . contact_normals , self . contact_normals . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . contact_normals . data , msg . contact_normals . size) ; for (t , s) in slice . iter_mut () . zip (& self . contact_normals) { s . copy_to_native (t) ; } } msg . depths . update (& self . depths) ; } } impl Default for ContactState { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ContactState > :: new () ; ContactState :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ContactsState { pub header : std_msgs :: msg :: Header , pub states : Vec < gazebo_msgs :: msg :: ContactState > } impl WrappedTypesupport for ContactsState { type CStruct = gazebo_msgs__msg__ContactsState ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__gazebo_msgs__msg__ContactsState () } } fn create_msg () -> * mut gazebo_msgs__msg__ContactsState { unsafe { gazebo_msgs__msg__ContactsState__create () } } fn destroy_msg (msg : * mut gazebo_msgs__msg__ContactsState) -> () { unsafe { gazebo_msgs__msg__ContactsState__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ContactsState { ContactsState { header : std_msgs :: msg :: Header :: from_native (& msg . header) , states : { let mut temp = Vec :: with_capacity (msg . states . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . states . data , msg . states . size) } ; for s in slice { temp . push (gazebo_msgs :: msg :: ContactState :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; unsafe { gazebo_msgs__msg__ContactState__Sequence__fini (& mut msg . states) ; gazebo_msgs__msg__ContactState__Sequence__init (& mut msg . states , self . states . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . states . data , msg . states . size) ; for (t , s) in slice . iter_mut () . zip (& self . states) { s . copy_to_native (t) ; } } } } impl Default for ContactsState { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ContactsState > :: new () ; ContactsState :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct EntityState { pub name : std :: string :: String , pub pose : geometry_msgs :: msg :: Pose , pub twist : geometry_msgs :: msg :: Twist , pub reference_frame : std :: string :: String } impl WrappedTypesupport for EntityState { type CStruct = gazebo_msgs__msg__EntityState ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__gazebo_msgs__msg__EntityState () } } fn create_msg () -> * mut gazebo_msgs__msg__EntityState { unsafe { gazebo_msgs__msg__EntityState__create () } } fn destroy_msg (msg : * mut gazebo_msgs__msg__EntityState) -> () { unsafe { gazebo_msgs__msg__EntityState__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> EntityState { EntityState { name : msg . name . to_str () . to_owned () , pose : geometry_msgs :: msg :: Pose :: from_native (& msg . pose) , twist : geometry_msgs :: msg :: Twist :: from_native (& msg . twist) , reference_frame : msg . reference_frame . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . name . assign (& self . name) ; self . pose . copy_to_native (& mut msg . pose) ; self . twist . copy_to_native (& mut msg . twist) ; msg . reference_frame . assign (& self . reference_frame) ; } } impl Default for EntityState { fn default () -> Self { let msg_native = WrappedNativeMsg :: < EntityState > :: new () ; EntityState :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct LinkState { pub link_name : std :: string :: String , pub pose : geometry_msgs :: msg :: Pose , pub twist : geometry_msgs :: msg :: Twist , pub reference_frame : std :: string :: String } impl WrappedTypesupport for LinkState { type CStruct = gazebo_msgs__msg__LinkState ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__gazebo_msgs__msg__LinkState () } } fn create_msg () -> * mut gazebo_msgs__msg__LinkState { unsafe { gazebo_msgs__msg__LinkState__create () } } fn destroy_msg (msg : * mut gazebo_msgs__msg__LinkState) -> () { unsafe { gazebo_msgs__msg__LinkState__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> LinkState { LinkState { link_name : msg . link_name . to_str () . to_owned () , pose : geometry_msgs :: msg :: Pose :: from_native (& msg . pose) , twist : geometry_msgs :: msg :: Twist :: from_native (& msg . twist) , reference_frame : msg . reference_frame . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . link_name . assign (& self . link_name) ; self . pose . copy_to_native (& mut msg . pose) ; self . twist . copy_to_native (& mut msg . twist) ; msg . reference_frame . assign (& self . reference_frame) ; } } impl Default for LinkState { fn default () -> Self { let msg_native = WrappedNativeMsg :: < LinkState > :: new () ; LinkState :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct LinkStates { pub name : Vec < std :: string :: String > , pub pose : Vec < geometry_msgs :: msg :: Pose > , pub twist : Vec < geometry_msgs :: msg :: Twist > } impl WrappedTypesupport for LinkStates { type CStruct = gazebo_msgs__msg__LinkStates ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__gazebo_msgs__msg__LinkStates () } } fn create_msg () -> * mut gazebo_msgs__msg__LinkStates { unsafe { gazebo_msgs__msg__LinkStates__create () } } fn destroy_msg (msg : * mut gazebo_msgs__msg__LinkStates) -> () { unsafe { gazebo_msgs__msg__LinkStates__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> LinkStates { LinkStates { name : msg . name . to_vec () , pose : { let mut temp = Vec :: with_capacity (msg . pose . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . pose . data , msg . pose . size) } ; for s in slice { temp . push (geometry_msgs :: msg :: Pose :: from_native (s)) ; } temp } , twist : { let mut temp = Vec :: with_capacity (msg . twist . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . twist . data , msg . twist . size) } ; for s in slice { temp . push (geometry_msgs :: msg :: Twist :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . name . update (& self . name) ; unsafe { geometry_msgs__msg__Pose__Sequence__fini (& mut msg . pose) ; geometry_msgs__msg__Pose__Sequence__init (& mut msg . pose , self . pose . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . pose . data , msg . pose . size) ; for (t , s) in slice . iter_mut () . zip (& self . pose) { s . copy_to_native (t) ; } } unsafe { geometry_msgs__msg__Twist__Sequence__fini (& mut msg . twist) ; geometry_msgs__msg__Twist__Sequence__init (& mut msg . twist , self . twist . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . twist . data , msg . twist . size) ; for (t , s) in slice . iter_mut () . zip (& self . twist) { s . copy_to_native (t) ; } } } } impl Default for LinkStates { fn default () -> Self { let msg_native = WrappedNativeMsg :: < LinkStates > :: new () ; LinkStates :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ModelState { pub model_name : std :: string :: String , pub pose : geometry_msgs :: msg :: Pose , pub twist : geometry_msgs :: msg :: Twist , pub reference_frame : std :: string :: String } impl WrappedTypesupport for ModelState { type CStruct = gazebo_msgs__msg__ModelState ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__gazebo_msgs__msg__ModelState () } } fn create_msg () -> * mut gazebo_msgs__msg__ModelState { unsafe { gazebo_msgs__msg__ModelState__create () } } fn destroy_msg (msg : * mut gazebo_msgs__msg__ModelState) -> () { unsafe { gazebo_msgs__msg__ModelState__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ModelState { ModelState { model_name : msg . model_name . to_str () . to_owned () , pose : geometry_msgs :: msg :: Pose :: from_native (& msg . pose) , twist : geometry_msgs :: msg :: Twist :: from_native (& msg . twist) , reference_frame : msg . reference_frame . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . model_name . assign (& self . model_name) ; self . pose . copy_to_native (& mut msg . pose) ; self . twist . copy_to_native (& mut msg . twist) ; msg . reference_frame . assign (& self . reference_frame) ; } } impl Default for ModelState { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ModelState > :: new () ; ModelState :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ModelStates { pub name : Vec < std :: string :: String > , pub pose : Vec < geometry_msgs :: msg :: Pose > , pub twist : Vec < geometry_msgs :: msg :: Twist > } impl WrappedTypesupport for ModelStates { type CStruct = gazebo_msgs__msg__ModelStates ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__gazebo_msgs__msg__ModelStates () } } fn create_msg () -> * mut gazebo_msgs__msg__ModelStates { unsafe { gazebo_msgs__msg__ModelStates__create () } } fn destroy_msg (msg : * mut gazebo_msgs__msg__ModelStates) -> () { unsafe { gazebo_msgs__msg__ModelStates__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ModelStates { ModelStates { name : msg . name . to_vec () , pose : { let mut temp = Vec :: with_capacity (msg . pose . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . pose . data , msg . pose . size) } ; for s in slice { temp . push (geometry_msgs :: msg :: Pose :: from_native (s)) ; } temp } , twist : { let mut temp = Vec :: with_capacity (msg . twist . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . twist . data , msg . twist . size) } ; for s in slice { temp . push (geometry_msgs :: msg :: Twist :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . name . update (& self . name) ; unsafe { geometry_msgs__msg__Pose__Sequence__fini (& mut msg . pose) ; geometry_msgs__msg__Pose__Sequence__init (& mut msg . pose , self . pose . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . pose . data , msg . pose . size) ; for (t , s) in slice . iter_mut () . zip (& self . pose) { s . copy_to_native (t) ; } } unsafe { geometry_msgs__msg__Twist__Sequence__fini (& mut msg . twist) ; geometry_msgs__msg__Twist__Sequence__init (& mut msg . twist , self . twist . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . twist . data , msg . twist . size) ; for (t , s) in slice . iter_mut () . zip (& self . twist) { s . copy_to_native (t) ; } } } } impl Default for ModelStates { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ModelStates > :: new () ; ModelStates :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ODEJointProperties { pub damping : Vec < f64 > , pub hi_stop : Vec < f64 > , pub lo_stop : Vec < f64 > , pub erp : Vec < f64 > , pub cfm : Vec < f64 > , pub stop_erp : Vec < f64 > , pub stop_cfm : Vec < f64 > , pub fudge_factor : Vec < f64 > , pub fmax : Vec < f64 > , pub vel : Vec < f64 > } impl WrappedTypesupport for ODEJointProperties { type CStruct = gazebo_msgs__msg__ODEJointProperties ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__gazebo_msgs__msg__ODEJointProperties () } } fn create_msg () -> * mut gazebo_msgs__msg__ODEJointProperties { unsafe { gazebo_msgs__msg__ODEJointProperties__create () } } fn destroy_msg (msg : * mut gazebo_msgs__msg__ODEJointProperties) -> () { unsafe { gazebo_msgs__msg__ODEJointProperties__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ODEJointProperties { ODEJointProperties { damping : msg . damping . to_vec () , hi_stop : msg . hi_stop . to_vec () , lo_stop : msg . lo_stop . to_vec () , erp : msg . erp . to_vec () , cfm : msg . cfm . to_vec () , stop_erp : msg . stop_erp . to_vec () , stop_cfm : msg . stop_cfm . to_vec () , fudge_factor : msg . fudge_factor . to_vec () , fmax : msg . fmax . to_vec () , vel : msg . vel . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . damping . update (& self . damping) ; msg . hi_stop . update (& self . hi_stop) ; msg . lo_stop . update (& self . lo_stop) ; msg . erp . update (& self . erp) ; msg . cfm . update (& self . cfm) ; msg . stop_erp . update (& self . stop_erp) ; msg . stop_cfm . update (& self . stop_cfm) ; msg . fudge_factor . update (& self . fudge_factor) ; msg . fmax . update (& self . fmax) ; msg . vel . update (& self . vel) ; } } impl Default for ODEJointProperties { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ODEJointProperties > :: new () ; ODEJointProperties :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ODEPhysics { pub auto_disable_bodies : bool , pub sor_pgs_precon_iters : u32 , pub sor_pgs_iters : u32 , pub sor_pgs_w : f64 , pub sor_pgs_rms_error_tol : f64 , pub contact_surface_layer : f64 , pub contact_max_correcting_vel : f64 , pub cfm : f64 , pub erp : f64 , pub max_contacts : u32 } impl WrappedTypesupport for ODEPhysics { type CStruct = gazebo_msgs__msg__ODEPhysics ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__gazebo_msgs__msg__ODEPhysics () } } fn create_msg () -> * mut gazebo_msgs__msg__ODEPhysics { unsafe { gazebo_msgs__msg__ODEPhysics__create () } } fn destroy_msg (msg : * mut gazebo_msgs__msg__ODEPhysics) -> () { unsafe { gazebo_msgs__msg__ODEPhysics__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ODEPhysics { ODEPhysics { auto_disable_bodies : msg . auto_disable_bodies , sor_pgs_precon_iters : msg . sor_pgs_precon_iters , sor_pgs_iters : msg . sor_pgs_iters , sor_pgs_w : msg . sor_pgs_w , sor_pgs_rms_error_tol : msg . sor_pgs_rms_error_tol , contact_surface_layer : msg . contact_surface_layer , contact_max_correcting_vel : msg . contact_max_correcting_vel , cfm : msg . cfm , erp : msg . erp , max_contacts : msg . max_contacts , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . auto_disable_bodies = self . auto_disable_bodies ; msg . sor_pgs_precon_iters = self . sor_pgs_precon_iters ; msg . sor_pgs_iters = self . sor_pgs_iters ; msg . sor_pgs_w = self . sor_pgs_w ; msg . sor_pgs_rms_error_tol = self . sor_pgs_rms_error_tol ; msg . contact_surface_layer = self . contact_surface_layer ; msg . contact_max_correcting_vel = self . contact_max_correcting_vel ; msg . cfm = self . cfm ; msg . erp = self . erp ; msg . max_contacts = self . max_contacts ; } } impl Default for ODEPhysics { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ODEPhysics > :: new () ; ODEPhysics :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct PerformanceMetrics { pub header : std_msgs :: msg :: Header , pub real_time_factor : f64 , pub sensors : Vec < gazebo_msgs :: msg :: SensorPerformanceMetric > } impl WrappedTypesupport for PerformanceMetrics { type CStruct = gazebo_msgs__msg__PerformanceMetrics ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__gazebo_msgs__msg__PerformanceMetrics () } } fn create_msg () -> * mut gazebo_msgs__msg__PerformanceMetrics { unsafe { gazebo_msgs__msg__PerformanceMetrics__create () } } fn destroy_msg (msg : * mut gazebo_msgs__msg__PerformanceMetrics) -> () { unsafe { gazebo_msgs__msg__PerformanceMetrics__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> PerformanceMetrics { PerformanceMetrics { header : std_msgs :: msg :: Header :: from_native (& msg . header) , real_time_factor : msg . real_time_factor , sensors : { let mut temp = Vec :: with_capacity (msg . sensors . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . sensors . data , msg . sensors . size) } ; for s in slice { temp . push (gazebo_msgs :: msg :: SensorPerformanceMetric :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . real_time_factor = self . real_time_factor ; unsafe { gazebo_msgs__msg__SensorPerformanceMetric__Sequence__fini (& mut msg . sensors) ; gazebo_msgs__msg__SensorPerformanceMetric__Sequence__init (& mut msg . sensors , self . sensors . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . sensors . data , msg . sensors . size) ; for (t , s) in slice . iter_mut () . zip (& self . sensors) { s . copy_to_native (t) ; } } } } impl Default for PerformanceMetrics { fn default () -> Self { let msg_native = WrappedNativeMsg :: < PerformanceMetrics > :: new () ; PerformanceMetrics :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct SensorPerformanceMetric { pub name : std :: string :: String , pub sim_update_rate : f64 , pub real_update_rate : f64 , pub fps : f64 } impl WrappedTypesupport for SensorPerformanceMetric { type CStruct = gazebo_msgs__msg__SensorPerformanceMetric ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__gazebo_msgs__msg__SensorPerformanceMetric () } } fn create_msg () -> * mut gazebo_msgs__msg__SensorPerformanceMetric { unsafe { gazebo_msgs__msg__SensorPerformanceMetric__create () } } fn destroy_msg (msg : * mut gazebo_msgs__msg__SensorPerformanceMetric) -> () { unsafe { gazebo_msgs__msg__SensorPerformanceMetric__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> SensorPerformanceMetric { SensorPerformanceMetric { name : msg . name . to_str () . to_owned () , sim_update_rate : msg . sim_update_rate , real_update_rate : msg . real_update_rate , fps : msg . fps , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . name . assign (& self . name) ; msg . sim_update_rate = self . sim_update_rate ; msg . real_update_rate = self . real_update_rate ; msg . fps = self . fps ; } } impl Default for SensorPerformanceMetric { fn default () -> Self { let msg_native = WrappedNativeMsg :: < SensorPerformanceMetric > :: new () ; SensorPerformanceMetric :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct WorldState { pub header : std_msgs :: msg :: Header , pub name : Vec < std :: string :: String > , pub pose : Vec < geometry_msgs :: msg :: Pose > , pub twist : Vec < geometry_msgs :: msg :: Twist > , pub wrench : Vec < geometry_msgs :: msg :: Wrench > } impl WrappedTypesupport for WorldState { type CStruct = gazebo_msgs__msg__WorldState ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__gazebo_msgs__msg__WorldState () } } fn create_msg () -> * mut gazebo_msgs__msg__WorldState { unsafe { gazebo_msgs__msg__WorldState__create () } } fn destroy_msg (msg : * mut gazebo_msgs__msg__WorldState) -> () { unsafe { gazebo_msgs__msg__WorldState__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> WorldState { WorldState { header : std_msgs :: msg :: Header :: from_native (& msg . header) , name : msg . name . to_vec () , pose : { let mut temp = Vec :: with_capacity (msg . pose . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . pose . data , msg . pose . size) } ; for s in slice { temp . push (geometry_msgs :: msg :: Pose :: from_native (s)) ; } temp } , twist : { let mut temp = Vec :: with_capacity (msg . twist . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . twist . data , msg . twist . size) } ; for s in slice { temp . push (geometry_msgs :: msg :: Twist :: from_native (s)) ; } temp } , wrench : { let mut temp = Vec :: with_capacity (msg . wrench . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . wrench . data , msg . wrench . size) } ; for s in slice { temp . push (geometry_msgs :: msg :: Wrench :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . name . update (& self . name) ; unsafe { geometry_msgs__msg__Pose__Sequence__fini (& mut msg . pose) ; geometry_msgs__msg__Pose__Sequence__init (& mut msg . pose , self . pose . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . pose . data , msg . pose . size) ; for (t , s) in slice . iter_mut () . zip (& self . pose) { s . copy_to_native (t) ; } } unsafe { geometry_msgs__msg__Twist__Sequence__fini (& mut msg . twist) ; geometry_msgs__msg__Twist__Sequence__init (& mut msg . twist , self . twist . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . twist . data , msg . twist . size) ; for (t , s) in slice . iter_mut () . zip (& self . twist) { s . copy_to_native (t) ; } } unsafe { geometry_msgs__msg__Wrench__Sequence__fini (& mut msg . wrench) ; geometry_msgs__msg__Wrench__Sequence__init (& mut msg . wrench , self . wrench . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . wrench . data , msg . wrench . size) ; for (t , s) in slice . iter_mut () . zip (& self . wrench) { s . copy_to_native (t) ; } } } } impl Default for WorldState { fn default () -> Self { let msg_native = WrappedNativeMsg :: < WorldState > :: new () ; WorldState :: from_native (& msg_native) } } } pub mod srv { # [allow (non_snake_case)] pub mod ApplyBodyWrench { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__gazebo_msgs__srv__ApplyBodyWrench () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub body_name : std :: string :: String , pub reference_frame : std :: string :: String , pub reference_point : geometry_msgs :: msg :: Point , pub wrench : geometry_msgs :: msg :: Wrench , pub start_time : builtin_interfaces :: msg :: Time , pub duration : builtin_interfaces :: msg :: Duration } impl WrappedTypesupport for Request { type CStruct = gazebo_msgs__srv__ApplyBodyWrench_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__gazebo_msgs__srv__ApplyBodyWrench_Request () } } fn create_msg () -> * mut gazebo_msgs__srv__ApplyBodyWrench_Request { unsafe { gazebo_msgs__srv__ApplyBodyWrench_Request__create () } } fn destroy_msg (msg : * mut gazebo_msgs__srv__ApplyBodyWrench_Request) -> () { unsafe { gazebo_msgs__srv__ApplyBodyWrench_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { body_name : msg . body_name . to_str () . to_owned () , reference_frame : msg . reference_frame . to_str () . to_owned () , reference_point : geometry_msgs :: msg :: Point :: from_native (& msg . reference_point) , wrench : geometry_msgs :: msg :: Wrench :: from_native (& msg . wrench) , start_time : builtin_interfaces :: msg :: Time :: from_native (& msg . start_time) , duration : builtin_interfaces :: msg :: Duration :: from_native (& msg . duration) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . body_name . assign (& self . body_name) ; msg . reference_frame . assign (& self . reference_frame) ; self . reference_point . copy_to_native (& mut msg . reference_point) ; self . wrench . copy_to_native (& mut msg . wrench) ; self . start_time . copy_to_native (& mut msg . start_time) ; self . duration . copy_to_native (& mut msg . duration) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool , pub status_message : std :: string :: String } impl WrappedTypesupport for Response { type CStruct = gazebo_msgs__srv__ApplyBodyWrench_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__gazebo_msgs__srv__ApplyBodyWrench_Response () } } fn create_msg () -> * mut gazebo_msgs__srv__ApplyBodyWrench_Response { unsafe { gazebo_msgs__srv__ApplyBodyWrench_Response__create () } } fn destroy_msg (msg : * mut gazebo_msgs__srv__ApplyBodyWrench_Response) -> () { unsafe { gazebo_msgs__srv__ApplyBodyWrench_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , status_message : msg . status_message . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; msg . status_message . assign (& self . status_message) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod ApplyJointEffort { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__gazebo_msgs__srv__ApplyJointEffort () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub joint_name : std :: string :: String , pub effort : f64 , pub start_time : builtin_interfaces :: msg :: Time , pub duration : builtin_interfaces :: msg :: Duration } impl WrappedTypesupport for Request { type CStruct = gazebo_msgs__srv__ApplyJointEffort_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__gazebo_msgs__srv__ApplyJointEffort_Request () } } fn create_msg () -> * mut gazebo_msgs__srv__ApplyJointEffort_Request { unsafe { gazebo_msgs__srv__ApplyJointEffort_Request__create () } } fn destroy_msg (msg : * mut gazebo_msgs__srv__ApplyJointEffort_Request) -> () { unsafe { gazebo_msgs__srv__ApplyJointEffort_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { joint_name : msg . joint_name . to_str () . to_owned () , effort : msg . effort , start_time : builtin_interfaces :: msg :: Time :: from_native (& msg . start_time) , duration : builtin_interfaces :: msg :: Duration :: from_native (& msg . duration) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . joint_name . assign (& self . joint_name) ; msg . effort = self . effort ; self . start_time . copy_to_native (& mut msg . start_time) ; self . duration . copy_to_native (& mut msg . duration) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool , pub status_message : std :: string :: String } impl WrappedTypesupport for Response { type CStruct = gazebo_msgs__srv__ApplyJointEffort_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__gazebo_msgs__srv__ApplyJointEffort_Response () } } fn create_msg () -> * mut gazebo_msgs__srv__ApplyJointEffort_Response { unsafe { gazebo_msgs__srv__ApplyJointEffort_Response__create () } } fn destroy_msg (msg : * mut gazebo_msgs__srv__ApplyJointEffort_Response) -> () { unsafe { gazebo_msgs__srv__ApplyJointEffort_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , status_message : msg . status_message . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; msg . status_message . assign (& self . status_message) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod ApplyLinkWrench { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__gazebo_msgs__srv__ApplyLinkWrench () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub link_name : std :: string :: String , pub reference_frame : std :: string :: String , pub reference_point : geometry_msgs :: msg :: Point , pub wrench : geometry_msgs :: msg :: Wrench , pub start_time : builtin_interfaces :: msg :: Time , pub duration : builtin_interfaces :: msg :: Duration } impl WrappedTypesupport for Request { type CStruct = gazebo_msgs__srv__ApplyLinkWrench_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__gazebo_msgs__srv__ApplyLinkWrench_Request () } } fn create_msg () -> * mut gazebo_msgs__srv__ApplyLinkWrench_Request { unsafe { gazebo_msgs__srv__ApplyLinkWrench_Request__create () } } fn destroy_msg (msg : * mut gazebo_msgs__srv__ApplyLinkWrench_Request) -> () { unsafe { gazebo_msgs__srv__ApplyLinkWrench_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { link_name : msg . link_name . to_str () . to_owned () , reference_frame : msg . reference_frame . to_str () . to_owned () , reference_point : geometry_msgs :: msg :: Point :: from_native (& msg . reference_point) , wrench : geometry_msgs :: msg :: Wrench :: from_native (& msg . wrench) , start_time : builtin_interfaces :: msg :: Time :: from_native (& msg . start_time) , duration : builtin_interfaces :: msg :: Duration :: from_native (& msg . duration) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . link_name . assign (& self . link_name) ; msg . reference_frame . assign (& self . reference_frame) ; self . reference_point . copy_to_native (& mut msg . reference_point) ; self . wrench . copy_to_native (& mut msg . wrench) ; self . start_time . copy_to_native (& mut msg . start_time) ; self . duration . copy_to_native (& mut msg . duration) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool , pub status_message : std :: string :: String } impl WrappedTypesupport for Response { type CStruct = gazebo_msgs__srv__ApplyLinkWrench_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__gazebo_msgs__srv__ApplyLinkWrench_Response () } } fn create_msg () -> * mut gazebo_msgs__srv__ApplyLinkWrench_Response { unsafe { gazebo_msgs__srv__ApplyLinkWrench_Response__create () } } fn destroy_msg (msg : * mut gazebo_msgs__srv__ApplyLinkWrench_Response) -> () { unsafe { gazebo_msgs__srv__ApplyLinkWrench_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , status_message : msg . status_message . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; msg . status_message . assign (& self . status_message) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod BodyRequest { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__gazebo_msgs__srv__BodyRequest () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub body_name : std :: string :: String } impl WrappedTypesupport for Request { type CStruct = gazebo_msgs__srv__BodyRequest_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__gazebo_msgs__srv__BodyRequest_Request () } } fn create_msg () -> * mut gazebo_msgs__srv__BodyRequest_Request { unsafe { gazebo_msgs__srv__BodyRequest_Request__create () } } fn destroy_msg (msg : * mut gazebo_msgs__srv__BodyRequest_Request) -> () { unsafe { gazebo_msgs__srv__BodyRequest_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { body_name : msg . body_name . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . body_name . assign (& self . body_name) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { } impl WrappedTypesupport for Response { type CStruct = gazebo_msgs__srv__BodyRequest_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__gazebo_msgs__srv__BodyRequest_Response () } } fn create_msg () -> * mut gazebo_msgs__srv__BodyRequest_Response { unsafe { gazebo_msgs__srv__BodyRequest_Response__create () } } fn destroy_msg (msg : * mut gazebo_msgs__srv__BodyRequest_Response) -> () { unsafe { gazebo_msgs__srv__BodyRequest_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod DeleteEntity { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__gazebo_msgs__srv__DeleteEntity () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub name : std :: string :: String } impl WrappedTypesupport for Request { type CStruct = gazebo_msgs__srv__DeleteEntity_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__gazebo_msgs__srv__DeleteEntity_Request () } } fn create_msg () -> * mut gazebo_msgs__srv__DeleteEntity_Request { unsafe { gazebo_msgs__srv__DeleteEntity_Request__create () } } fn destroy_msg (msg : * mut gazebo_msgs__srv__DeleteEntity_Request) -> () { unsafe { gazebo_msgs__srv__DeleteEntity_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { name : msg . name . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . name . assign (& self . name) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool , pub status_message : std :: string :: String } impl WrappedTypesupport for Response { type CStruct = gazebo_msgs__srv__DeleteEntity_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__gazebo_msgs__srv__DeleteEntity_Response () } } fn create_msg () -> * mut gazebo_msgs__srv__DeleteEntity_Response { unsafe { gazebo_msgs__srv__DeleteEntity_Response__create () } } fn destroy_msg (msg : * mut gazebo_msgs__srv__DeleteEntity_Response) -> () { unsafe { gazebo_msgs__srv__DeleteEntity_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , status_message : msg . status_message . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; msg . status_message . assign (& self . status_message) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod DeleteLight { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__gazebo_msgs__srv__DeleteLight () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub light_name : std :: string :: String } impl WrappedTypesupport for Request { type CStruct = gazebo_msgs__srv__DeleteLight_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__gazebo_msgs__srv__DeleteLight_Request () } } fn create_msg () -> * mut gazebo_msgs__srv__DeleteLight_Request { unsafe { gazebo_msgs__srv__DeleteLight_Request__create () } } fn destroy_msg (msg : * mut gazebo_msgs__srv__DeleteLight_Request) -> () { unsafe { gazebo_msgs__srv__DeleteLight_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { light_name : msg . light_name . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . light_name . assign (& self . light_name) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool , pub status_message : std :: string :: String } impl WrappedTypesupport for Response { type CStruct = gazebo_msgs__srv__DeleteLight_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__gazebo_msgs__srv__DeleteLight_Response () } } fn create_msg () -> * mut gazebo_msgs__srv__DeleteLight_Response { unsafe { gazebo_msgs__srv__DeleteLight_Response__create () } } fn destroy_msg (msg : * mut gazebo_msgs__srv__DeleteLight_Response) -> () { unsafe { gazebo_msgs__srv__DeleteLight_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , status_message : msg . status_message . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; msg . status_message . assign (& self . status_message) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod DeleteModel { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__gazebo_msgs__srv__DeleteModel () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub model_name : std :: string :: String } impl WrappedTypesupport for Request { type CStruct = gazebo_msgs__srv__DeleteModel_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__gazebo_msgs__srv__DeleteModel_Request () } } fn create_msg () -> * mut gazebo_msgs__srv__DeleteModel_Request { unsafe { gazebo_msgs__srv__DeleteModel_Request__create () } } fn destroy_msg (msg : * mut gazebo_msgs__srv__DeleteModel_Request) -> () { unsafe { gazebo_msgs__srv__DeleteModel_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { model_name : msg . model_name . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . model_name . assign (& self . model_name) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool , pub status_message : std :: string :: String } impl WrappedTypesupport for Response { type CStruct = gazebo_msgs__srv__DeleteModel_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__gazebo_msgs__srv__DeleteModel_Response () } } fn create_msg () -> * mut gazebo_msgs__srv__DeleteModel_Response { unsafe { gazebo_msgs__srv__DeleteModel_Response__create () } } fn destroy_msg (msg : * mut gazebo_msgs__srv__DeleteModel_Response) -> () { unsafe { gazebo_msgs__srv__DeleteModel_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , status_message : msg . status_message . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; msg . status_message . assign (& self . status_message) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetEntityState { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__gazebo_msgs__srv__GetEntityState () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub name : std :: string :: String , pub reference_frame : std :: string :: String } impl WrappedTypesupport for Request { type CStruct = gazebo_msgs__srv__GetEntityState_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__gazebo_msgs__srv__GetEntityState_Request () } } fn create_msg () -> * mut gazebo_msgs__srv__GetEntityState_Request { unsafe { gazebo_msgs__srv__GetEntityState_Request__create () } } fn destroy_msg (msg : * mut gazebo_msgs__srv__GetEntityState_Request) -> () { unsafe { gazebo_msgs__srv__GetEntityState_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { name : msg . name . to_str () . to_owned () , reference_frame : msg . reference_frame . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . name . assign (& self . name) ; msg . reference_frame . assign (& self . reference_frame) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub header : std_msgs :: msg :: Header , pub state : gazebo_msgs :: msg :: EntityState , pub success : bool } impl WrappedTypesupport for Response { type CStruct = gazebo_msgs__srv__GetEntityState_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__gazebo_msgs__srv__GetEntityState_Response () } } fn create_msg () -> * mut gazebo_msgs__srv__GetEntityState_Response { unsafe { gazebo_msgs__srv__GetEntityState_Response__create () } } fn destroy_msg (msg : * mut gazebo_msgs__srv__GetEntityState_Response) -> () { unsafe { gazebo_msgs__srv__GetEntityState_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { header : std_msgs :: msg :: Header :: from_native (& msg . header) , state : gazebo_msgs :: msg :: EntityState :: from_native (& msg . state) , success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; self . state . copy_to_native (& mut msg . state) ; msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetJointProperties { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__gazebo_msgs__srv__GetJointProperties () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub joint_name : std :: string :: String } impl WrappedTypesupport for Request { type CStruct = gazebo_msgs__srv__GetJointProperties_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__gazebo_msgs__srv__GetJointProperties_Request () } } fn create_msg () -> * mut gazebo_msgs__srv__GetJointProperties_Request { unsafe { gazebo_msgs__srv__GetJointProperties_Request__create () } } fn destroy_msg (msg : * mut gazebo_msgs__srv__GetJointProperties_Request) -> () { unsafe { gazebo_msgs__srv__GetJointProperties_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { joint_name : msg . joint_name . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . joint_name . assign (& self . joint_name) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { # [serde (rename = "type")] pub type_ : u8 , pub damping : Vec < f64 > , pub position : Vec < f64 > , pub rate : Vec < f64 > , pub success : bool , pub status_message : std :: string :: String } impl WrappedTypesupport for Response { type CStruct = gazebo_msgs__srv__GetJointProperties_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__gazebo_msgs__srv__GetJointProperties_Response () } } fn create_msg () -> * mut gazebo_msgs__srv__GetJointProperties_Response { unsafe { gazebo_msgs__srv__GetJointProperties_Response__create () } } fn destroy_msg (msg : * mut gazebo_msgs__srv__GetJointProperties_Response) -> () { unsafe { gazebo_msgs__srv__GetJointProperties_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { type_ : msg . type_ , damping : msg . damping . to_vec () , position : msg . position . to_vec () , rate : msg . rate . to_vec () , success : msg . success , status_message : msg . status_message . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . type_ = self . type_ ; msg . damping . update (& self . damping) ; msg . position . update (& self . position) ; msg . rate . update (& self . rate) ; msg . success = self . success ; msg . status_message . assign (& self . status_message) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl Response { pub const BALL : _bindgen_ty_223 = gazebo_msgs__srv__GetJointProperties_Response__BALL ; pub const CONTINUOUS : _bindgen_ty_220 = gazebo_msgs__srv__GetJointProperties_Response__CONTINUOUS ; pub const FIXED : _bindgen_ty_222 = gazebo_msgs__srv__GetJointProperties_Response__FIXED ; pub const PRISMATIC : _bindgen_ty_221 = gazebo_msgs__srv__GetJointProperties_Response__PRISMATIC ; pub const REVOLUTE : _bindgen_ty_219 = gazebo_msgs__srv__GetJointProperties_Response__REVOLUTE ; pub const UNIVERSAL : _bindgen_ty_224 = gazebo_msgs__srv__GetJointProperties_Response__UNIVERSAL ; } } # [allow (non_snake_case)] pub mod GetLightProperties { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__gazebo_msgs__srv__GetLightProperties () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub light_name : std :: string :: String } impl WrappedTypesupport for Request { type CStruct = gazebo_msgs__srv__GetLightProperties_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__gazebo_msgs__srv__GetLightProperties_Request () } } fn create_msg () -> * mut gazebo_msgs__srv__GetLightProperties_Request { unsafe { gazebo_msgs__srv__GetLightProperties_Request__create () } } fn destroy_msg (msg : * mut gazebo_msgs__srv__GetLightProperties_Request) -> () { unsafe { gazebo_msgs__srv__GetLightProperties_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { light_name : msg . light_name . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . light_name . assign (& self . light_name) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub diffuse : std_msgs :: msg :: ColorRGBA , pub attenuation_constant : f64 , pub attenuation_linear : f64 , pub attenuation_quadratic : f64 , pub success : bool , pub status_message : std :: string :: String } impl WrappedTypesupport for Response { type CStruct = gazebo_msgs__srv__GetLightProperties_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__gazebo_msgs__srv__GetLightProperties_Response () } } fn create_msg () -> * mut gazebo_msgs__srv__GetLightProperties_Response { unsafe { gazebo_msgs__srv__GetLightProperties_Response__create () } } fn destroy_msg (msg : * mut gazebo_msgs__srv__GetLightProperties_Response) -> () { unsafe { gazebo_msgs__srv__GetLightProperties_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { diffuse : std_msgs :: msg :: ColorRGBA :: from_native (& msg . diffuse) , attenuation_constant : msg . attenuation_constant , attenuation_linear : msg . attenuation_linear , attenuation_quadratic : msg . attenuation_quadratic , success : msg . success , status_message : msg . status_message . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . diffuse . copy_to_native (& mut msg . diffuse) ; msg . attenuation_constant = self . attenuation_constant ; msg . attenuation_linear = self . attenuation_linear ; msg . attenuation_quadratic = self . attenuation_quadratic ; msg . success = self . success ; msg . status_message . assign (& self . status_message) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetLinkProperties { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__gazebo_msgs__srv__GetLinkProperties () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub link_name : std :: string :: String } impl WrappedTypesupport for Request { type CStruct = gazebo_msgs__srv__GetLinkProperties_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__gazebo_msgs__srv__GetLinkProperties_Request () } } fn create_msg () -> * mut gazebo_msgs__srv__GetLinkProperties_Request { unsafe { gazebo_msgs__srv__GetLinkProperties_Request__create () } } fn destroy_msg (msg : * mut gazebo_msgs__srv__GetLinkProperties_Request) -> () { unsafe { gazebo_msgs__srv__GetLinkProperties_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { link_name : msg . link_name . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . link_name . assign (& self . link_name) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub com : geometry_msgs :: msg :: Pose , pub gravity_mode : bool , pub mass : f64 , pub ixx : f64 , pub ixy : f64 , pub ixz : f64 , pub iyy : f64 , pub iyz : f64 , pub izz : f64 , pub success : bool , pub status_message : std :: string :: String } impl WrappedTypesupport for Response { type CStruct = gazebo_msgs__srv__GetLinkProperties_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__gazebo_msgs__srv__GetLinkProperties_Response () } } fn create_msg () -> * mut gazebo_msgs__srv__GetLinkProperties_Response { unsafe { gazebo_msgs__srv__GetLinkProperties_Response__create () } } fn destroy_msg (msg : * mut gazebo_msgs__srv__GetLinkProperties_Response) -> () { unsafe { gazebo_msgs__srv__GetLinkProperties_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { com : geometry_msgs :: msg :: Pose :: from_native (& msg . com) , gravity_mode : msg . gravity_mode , mass : msg . mass , ixx : msg . ixx , ixy : msg . ixy , ixz : msg . ixz , iyy : msg . iyy , iyz : msg . iyz , izz : msg . izz , success : msg . success , status_message : msg . status_message . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . com . copy_to_native (& mut msg . com) ; msg . gravity_mode = self . gravity_mode ; msg . mass = self . mass ; msg . ixx = self . ixx ; msg . ixy = self . ixy ; msg . ixz = self . ixz ; msg . iyy = self . iyy ; msg . iyz = self . iyz ; msg . izz = self . izz ; msg . success = self . success ; msg . status_message . assign (& self . status_message) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetLinkState { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__gazebo_msgs__srv__GetLinkState () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub link_name : std :: string :: String , pub reference_frame : std :: string :: String } impl WrappedTypesupport for Request { type CStruct = gazebo_msgs__srv__GetLinkState_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__gazebo_msgs__srv__GetLinkState_Request () } } fn create_msg () -> * mut gazebo_msgs__srv__GetLinkState_Request { unsafe { gazebo_msgs__srv__GetLinkState_Request__create () } } fn destroy_msg (msg : * mut gazebo_msgs__srv__GetLinkState_Request) -> () { unsafe { gazebo_msgs__srv__GetLinkState_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { link_name : msg . link_name . to_str () . to_owned () , reference_frame : msg . reference_frame . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . link_name . assign (& self . link_name) ; msg . reference_frame . assign (& self . reference_frame) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub link_state : gazebo_msgs :: msg :: LinkState , pub success : bool , pub status_message : std :: string :: String } impl WrappedTypesupport for Response { type CStruct = gazebo_msgs__srv__GetLinkState_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__gazebo_msgs__srv__GetLinkState_Response () } } fn create_msg () -> * mut gazebo_msgs__srv__GetLinkState_Response { unsafe { gazebo_msgs__srv__GetLinkState_Response__create () } } fn destroy_msg (msg : * mut gazebo_msgs__srv__GetLinkState_Response) -> () { unsafe { gazebo_msgs__srv__GetLinkState_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { link_state : gazebo_msgs :: msg :: LinkState :: from_native (& msg . link_state) , success : msg . success , status_message : msg . status_message . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . link_state . copy_to_native (& mut msg . link_state) ; msg . success = self . success ; msg . status_message . assign (& self . status_message) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetModelList { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__gazebo_msgs__srv__GetModelList () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { } impl WrappedTypesupport for Request { type CStruct = gazebo_msgs__srv__GetModelList_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__gazebo_msgs__srv__GetModelList_Request () } } fn create_msg () -> * mut gazebo_msgs__srv__GetModelList_Request { unsafe { gazebo_msgs__srv__GetModelList_Request__create () } } fn destroy_msg (msg : * mut gazebo_msgs__srv__GetModelList_Request) -> () { unsafe { gazebo_msgs__srv__GetModelList_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub header : std_msgs :: msg :: Header , pub model_names : Vec < std :: string :: String > , pub success : bool } impl WrappedTypesupport for Response { type CStruct = gazebo_msgs__srv__GetModelList_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__gazebo_msgs__srv__GetModelList_Response () } } fn create_msg () -> * mut gazebo_msgs__srv__GetModelList_Response { unsafe { gazebo_msgs__srv__GetModelList_Response__create () } } fn destroy_msg (msg : * mut gazebo_msgs__srv__GetModelList_Response) -> () { unsafe { gazebo_msgs__srv__GetModelList_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { header : std_msgs :: msg :: Header :: from_native (& msg . header) , model_names : msg . model_names . to_vec () , success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . model_names . update (& self . model_names) ; msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetModelProperties { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__gazebo_msgs__srv__GetModelProperties () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub model_name : std :: string :: String } impl WrappedTypesupport for Request { type CStruct = gazebo_msgs__srv__GetModelProperties_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__gazebo_msgs__srv__GetModelProperties_Request () } } fn create_msg () -> * mut gazebo_msgs__srv__GetModelProperties_Request { unsafe { gazebo_msgs__srv__GetModelProperties_Request__create () } } fn destroy_msg (msg : * mut gazebo_msgs__srv__GetModelProperties_Request) -> () { unsafe { gazebo_msgs__srv__GetModelProperties_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { model_name : msg . model_name . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . model_name . assign (& self . model_name) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub parent_model_name : std :: string :: String , pub canonical_body_name : std :: string :: String , pub body_names : Vec < std :: string :: String > , pub geom_names : Vec < std :: string :: String > , pub joint_names : Vec < std :: string :: String > , pub child_model_names : Vec < std :: string :: String > , pub is_static : bool , pub success : bool , pub status_message : std :: string :: String } impl WrappedTypesupport for Response { type CStruct = gazebo_msgs__srv__GetModelProperties_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__gazebo_msgs__srv__GetModelProperties_Response () } } fn create_msg () -> * mut gazebo_msgs__srv__GetModelProperties_Response { unsafe { gazebo_msgs__srv__GetModelProperties_Response__create () } } fn destroy_msg (msg : * mut gazebo_msgs__srv__GetModelProperties_Response) -> () { unsafe { gazebo_msgs__srv__GetModelProperties_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { parent_model_name : msg . parent_model_name . to_str () . to_owned () , canonical_body_name : msg . canonical_body_name . to_str () . to_owned () , body_names : msg . body_names . to_vec () , geom_names : msg . geom_names . to_vec () , joint_names : msg . joint_names . to_vec () , child_model_names : msg . child_model_names . to_vec () , is_static : msg . is_static , success : msg . success , status_message : msg . status_message . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . parent_model_name . assign (& self . parent_model_name) ; msg . canonical_body_name . assign (& self . canonical_body_name) ; msg . body_names . update (& self . body_names) ; msg . geom_names . update (& self . geom_names) ; msg . joint_names . update (& self . joint_names) ; msg . child_model_names . update (& self . child_model_names) ; msg . is_static = self . is_static ; msg . success = self . success ; msg . status_message . assign (& self . status_message) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetModelState { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__gazebo_msgs__srv__GetModelState () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub model_name : std :: string :: String , pub relative_entity_name : std :: string :: String } impl WrappedTypesupport for Request { type CStruct = gazebo_msgs__srv__GetModelState_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__gazebo_msgs__srv__GetModelState_Request () } } fn create_msg () -> * mut gazebo_msgs__srv__GetModelState_Request { unsafe { gazebo_msgs__srv__GetModelState_Request__create () } } fn destroy_msg (msg : * mut gazebo_msgs__srv__GetModelState_Request) -> () { unsafe { gazebo_msgs__srv__GetModelState_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { model_name : msg . model_name . to_str () . to_owned () , relative_entity_name : msg . relative_entity_name . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . model_name . assign (& self . model_name) ; msg . relative_entity_name . assign (& self . relative_entity_name) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub header : std_msgs :: msg :: Header , pub pose : geometry_msgs :: msg :: Pose , pub twist : geometry_msgs :: msg :: Twist , pub success : bool , pub status_message : std :: string :: String } impl WrappedTypesupport for Response { type CStruct = gazebo_msgs__srv__GetModelState_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__gazebo_msgs__srv__GetModelState_Response () } } fn create_msg () -> * mut gazebo_msgs__srv__GetModelState_Response { unsafe { gazebo_msgs__srv__GetModelState_Response__create () } } fn destroy_msg (msg : * mut gazebo_msgs__srv__GetModelState_Response) -> () { unsafe { gazebo_msgs__srv__GetModelState_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { header : std_msgs :: msg :: Header :: from_native (& msg . header) , pose : geometry_msgs :: msg :: Pose :: from_native (& msg . pose) , twist : geometry_msgs :: msg :: Twist :: from_native (& msg . twist) , success : msg . success , status_message : msg . status_message . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; self . pose . copy_to_native (& mut msg . pose) ; self . twist . copy_to_native (& mut msg . twist) ; msg . success = self . success ; msg . status_message . assign (& self . status_message) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetPhysicsProperties { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__gazebo_msgs__srv__GetPhysicsProperties () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { } impl WrappedTypesupport for Request { type CStruct = gazebo_msgs__srv__GetPhysicsProperties_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__gazebo_msgs__srv__GetPhysicsProperties_Request () } } fn create_msg () -> * mut gazebo_msgs__srv__GetPhysicsProperties_Request { unsafe { gazebo_msgs__srv__GetPhysicsProperties_Request__create () } } fn destroy_msg (msg : * mut gazebo_msgs__srv__GetPhysicsProperties_Request) -> () { unsafe { gazebo_msgs__srv__GetPhysicsProperties_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub time_step : f64 , pub pause : bool , pub max_update_rate : f64 , pub gravity : geometry_msgs :: msg :: Vector3 , pub ode_config : gazebo_msgs :: msg :: ODEPhysics , pub success : bool , pub status_message : std :: string :: String } impl WrappedTypesupport for Response { type CStruct = gazebo_msgs__srv__GetPhysicsProperties_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__gazebo_msgs__srv__GetPhysicsProperties_Response () } } fn create_msg () -> * mut gazebo_msgs__srv__GetPhysicsProperties_Response { unsafe { gazebo_msgs__srv__GetPhysicsProperties_Response__create () } } fn destroy_msg (msg : * mut gazebo_msgs__srv__GetPhysicsProperties_Response) -> () { unsafe { gazebo_msgs__srv__GetPhysicsProperties_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { time_step : msg . time_step , pause : msg . pause , max_update_rate : msg . max_update_rate , gravity : geometry_msgs :: msg :: Vector3 :: from_native (& msg . gravity) , ode_config : gazebo_msgs :: msg :: ODEPhysics :: from_native (& msg . ode_config) , success : msg . success , status_message : msg . status_message . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . time_step = self . time_step ; msg . pause = self . pause ; msg . max_update_rate = self . max_update_rate ; self . gravity . copy_to_native (& mut msg . gravity) ; self . ode_config . copy_to_native (& mut msg . ode_config) ; msg . success = self . success ; msg . status_message . assign (& self . status_message) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetWorldProperties { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__gazebo_msgs__srv__GetWorldProperties () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { } impl WrappedTypesupport for Request { type CStruct = gazebo_msgs__srv__GetWorldProperties_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__gazebo_msgs__srv__GetWorldProperties_Request () } } fn create_msg () -> * mut gazebo_msgs__srv__GetWorldProperties_Request { unsafe { gazebo_msgs__srv__GetWorldProperties_Request__create () } } fn destroy_msg (msg : * mut gazebo_msgs__srv__GetWorldProperties_Request) -> () { unsafe { gazebo_msgs__srv__GetWorldProperties_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub sim_time : f64 , pub model_names : Vec < std :: string :: String > , pub rendering_enabled : bool , pub success : bool , pub status_message : std :: string :: String } impl WrappedTypesupport for Response { type CStruct = gazebo_msgs__srv__GetWorldProperties_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__gazebo_msgs__srv__GetWorldProperties_Response () } } fn create_msg () -> * mut gazebo_msgs__srv__GetWorldProperties_Response { unsafe { gazebo_msgs__srv__GetWorldProperties_Response__create () } } fn destroy_msg (msg : * mut gazebo_msgs__srv__GetWorldProperties_Response) -> () { unsafe { gazebo_msgs__srv__GetWorldProperties_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { sim_time : msg . sim_time , model_names : msg . model_names . to_vec () , rendering_enabled : msg . rendering_enabled , success : msg . success , status_message : msg . status_message . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . sim_time = self . sim_time ; msg . model_names . update (& self . model_names) ; msg . rendering_enabled = self . rendering_enabled ; msg . success = self . success ; msg . status_message . assign (& self . status_message) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod JointRequest { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__gazebo_msgs__srv__JointRequest () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub joint_name : std :: string :: String } impl WrappedTypesupport for Request { type CStruct = gazebo_msgs__srv__JointRequest_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__gazebo_msgs__srv__JointRequest_Request () } } fn create_msg () -> * mut gazebo_msgs__srv__JointRequest_Request { unsafe { gazebo_msgs__srv__JointRequest_Request__create () } } fn destroy_msg (msg : * mut gazebo_msgs__srv__JointRequest_Request) -> () { unsafe { gazebo_msgs__srv__JointRequest_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { joint_name : msg . joint_name . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . joint_name . assign (& self . joint_name) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { } impl WrappedTypesupport for Response { type CStruct = gazebo_msgs__srv__JointRequest_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__gazebo_msgs__srv__JointRequest_Response () } } fn create_msg () -> * mut gazebo_msgs__srv__JointRequest_Response { unsafe { gazebo_msgs__srv__JointRequest_Response__create () } } fn destroy_msg (msg : * mut gazebo_msgs__srv__JointRequest_Response) -> () { unsafe { gazebo_msgs__srv__JointRequest_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod LinkRequest { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__gazebo_msgs__srv__LinkRequest () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub link_name : std :: string :: String } impl WrappedTypesupport for Request { type CStruct = gazebo_msgs__srv__LinkRequest_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__gazebo_msgs__srv__LinkRequest_Request () } } fn create_msg () -> * mut gazebo_msgs__srv__LinkRequest_Request { unsafe { gazebo_msgs__srv__LinkRequest_Request__create () } } fn destroy_msg (msg : * mut gazebo_msgs__srv__LinkRequest_Request) -> () { unsafe { gazebo_msgs__srv__LinkRequest_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { link_name : msg . link_name . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . link_name . assign (& self . link_name) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { } impl WrappedTypesupport for Response { type CStruct = gazebo_msgs__srv__LinkRequest_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__gazebo_msgs__srv__LinkRequest_Response () } } fn create_msg () -> * mut gazebo_msgs__srv__LinkRequest_Response { unsafe { gazebo_msgs__srv__LinkRequest_Response__create () } } fn destroy_msg (msg : * mut gazebo_msgs__srv__LinkRequest_Response) -> () { unsafe { gazebo_msgs__srv__LinkRequest_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod SetEntityState { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__gazebo_msgs__srv__SetEntityState () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub state : gazebo_msgs :: msg :: EntityState } impl WrappedTypesupport for Request { type CStruct = gazebo_msgs__srv__SetEntityState_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__gazebo_msgs__srv__SetEntityState_Request () } } fn create_msg () -> * mut gazebo_msgs__srv__SetEntityState_Request { unsafe { gazebo_msgs__srv__SetEntityState_Request__create () } } fn destroy_msg (msg : * mut gazebo_msgs__srv__SetEntityState_Request) -> () { unsafe { gazebo_msgs__srv__SetEntityState_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { state : gazebo_msgs :: msg :: EntityState :: from_native (& msg . state) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . state . copy_to_native (& mut msg . state) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool } impl WrappedTypesupport for Response { type CStruct = gazebo_msgs__srv__SetEntityState_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__gazebo_msgs__srv__SetEntityState_Response () } } fn create_msg () -> * mut gazebo_msgs__srv__SetEntityState_Response { unsafe { gazebo_msgs__srv__SetEntityState_Response__create () } } fn destroy_msg (msg : * mut gazebo_msgs__srv__SetEntityState_Response) -> () { unsafe { gazebo_msgs__srv__SetEntityState_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod SetJointProperties { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__gazebo_msgs__srv__SetJointProperties () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub joint_name : std :: string :: String , pub ode_joint_config : gazebo_msgs :: msg :: ODEJointProperties } impl WrappedTypesupport for Request { type CStruct = gazebo_msgs__srv__SetJointProperties_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__gazebo_msgs__srv__SetJointProperties_Request () } } fn create_msg () -> * mut gazebo_msgs__srv__SetJointProperties_Request { unsafe { gazebo_msgs__srv__SetJointProperties_Request__create () } } fn destroy_msg (msg : * mut gazebo_msgs__srv__SetJointProperties_Request) -> () { unsafe { gazebo_msgs__srv__SetJointProperties_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { joint_name : msg . joint_name . to_str () . to_owned () , ode_joint_config : gazebo_msgs :: msg :: ODEJointProperties :: from_native (& msg . ode_joint_config) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . joint_name . assign (& self . joint_name) ; self . ode_joint_config . copy_to_native (& mut msg . ode_joint_config) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool , pub status_message : std :: string :: String } impl WrappedTypesupport for Response { type CStruct = gazebo_msgs__srv__SetJointProperties_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__gazebo_msgs__srv__SetJointProperties_Response () } } fn create_msg () -> * mut gazebo_msgs__srv__SetJointProperties_Response { unsafe { gazebo_msgs__srv__SetJointProperties_Response__create () } } fn destroy_msg (msg : * mut gazebo_msgs__srv__SetJointProperties_Response) -> () { unsafe { gazebo_msgs__srv__SetJointProperties_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , status_message : msg . status_message . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; msg . status_message . assign (& self . status_message) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod SetJointTrajectory { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__gazebo_msgs__srv__SetJointTrajectory () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub model_name : std :: string :: String , pub joint_trajectory : trajectory_msgs :: msg :: JointTrajectory , pub model_pose : geometry_msgs :: msg :: Pose , pub set_model_pose : bool , pub disable_physics_updates : bool } impl WrappedTypesupport for Request { type CStruct = gazebo_msgs__srv__SetJointTrajectory_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__gazebo_msgs__srv__SetJointTrajectory_Request () } } fn create_msg () -> * mut gazebo_msgs__srv__SetJointTrajectory_Request { unsafe { gazebo_msgs__srv__SetJointTrajectory_Request__create () } } fn destroy_msg (msg : * mut gazebo_msgs__srv__SetJointTrajectory_Request) -> () { unsafe { gazebo_msgs__srv__SetJointTrajectory_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { model_name : msg . model_name . to_str () . to_owned () , joint_trajectory : trajectory_msgs :: msg :: JointTrajectory :: from_native (& msg . joint_trajectory) , model_pose : geometry_msgs :: msg :: Pose :: from_native (& msg . model_pose) , set_model_pose : msg . set_model_pose , disable_physics_updates : msg . disable_physics_updates , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . model_name . assign (& self . model_name) ; self . joint_trajectory . copy_to_native (& mut msg . joint_trajectory) ; self . model_pose . copy_to_native (& mut msg . model_pose) ; msg . set_model_pose = self . set_model_pose ; msg . disable_physics_updates = self . disable_physics_updates ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool , pub status_message : std :: string :: String } impl WrappedTypesupport for Response { type CStruct = gazebo_msgs__srv__SetJointTrajectory_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__gazebo_msgs__srv__SetJointTrajectory_Response () } } fn create_msg () -> * mut gazebo_msgs__srv__SetJointTrajectory_Response { unsafe { gazebo_msgs__srv__SetJointTrajectory_Response__create () } } fn destroy_msg (msg : * mut gazebo_msgs__srv__SetJointTrajectory_Response) -> () { unsafe { gazebo_msgs__srv__SetJointTrajectory_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , status_message : msg . status_message . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; msg . status_message . assign (& self . status_message) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod SetLightProperties { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__gazebo_msgs__srv__SetLightProperties () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub light_name : std :: string :: String , pub diffuse : std_msgs :: msg :: ColorRGBA , pub attenuation_constant : f64 , pub attenuation_linear : f64 , pub attenuation_quadratic : f64 } impl WrappedTypesupport for Request { type CStruct = gazebo_msgs__srv__SetLightProperties_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__gazebo_msgs__srv__SetLightProperties_Request () } } fn create_msg () -> * mut gazebo_msgs__srv__SetLightProperties_Request { unsafe { gazebo_msgs__srv__SetLightProperties_Request__create () } } fn destroy_msg (msg : * mut gazebo_msgs__srv__SetLightProperties_Request) -> () { unsafe { gazebo_msgs__srv__SetLightProperties_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { light_name : msg . light_name . to_str () . to_owned () , diffuse : std_msgs :: msg :: ColorRGBA :: from_native (& msg . diffuse) , attenuation_constant : msg . attenuation_constant , attenuation_linear : msg . attenuation_linear , attenuation_quadratic : msg . attenuation_quadratic , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . light_name . assign (& self . light_name) ; self . diffuse . copy_to_native (& mut msg . diffuse) ; msg . attenuation_constant = self . attenuation_constant ; msg . attenuation_linear = self . attenuation_linear ; msg . attenuation_quadratic = self . attenuation_quadratic ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool , pub status_message : std :: string :: String } impl WrappedTypesupport for Response { type CStruct = gazebo_msgs__srv__SetLightProperties_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__gazebo_msgs__srv__SetLightProperties_Response () } } fn create_msg () -> * mut gazebo_msgs__srv__SetLightProperties_Response { unsafe { gazebo_msgs__srv__SetLightProperties_Response__create () } } fn destroy_msg (msg : * mut gazebo_msgs__srv__SetLightProperties_Response) -> () { unsafe { gazebo_msgs__srv__SetLightProperties_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , status_message : msg . status_message . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; msg . status_message . assign (& self . status_message) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod SetLinkProperties { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__gazebo_msgs__srv__SetLinkProperties () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub link_name : std :: string :: String , pub com : geometry_msgs :: msg :: Pose , pub gravity_mode : bool , pub mass : f64 , pub ixx : f64 , pub ixy : f64 , pub ixz : f64 , pub iyy : f64 , pub iyz : f64 , pub izz : f64 } impl WrappedTypesupport for Request { type CStruct = gazebo_msgs__srv__SetLinkProperties_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__gazebo_msgs__srv__SetLinkProperties_Request () } } fn create_msg () -> * mut gazebo_msgs__srv__SetLinkProperties_Request { unsafe { gazebo_msgs__srv__SetLinkProperties_Request__create () } } fn destroy_msg (msg : * mut gazebo_msgs__srv__SetLinkProperties_Request) -> () { unsafe { gazebo_msgs__srv__SetLinkProperties_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { link_name : msg . link_name . to_str () . to_owned () , com : geometry_msgs :: msg :: Pose :: from_native (& msg . com) , gravity_mode : msg . gravity_mode , mass : msg . mass , ixx : msg . ixx , ixy : msg . ixy , ixz : msg . ixz , iyy : msg . iyy , iyz : msg . iyz , izz : msg . izz , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . link_name . assign (& self . link_name) ; self . com . copy_to_native (& mut msg . com) ; msg . gravity_mode = self . gravity_mode ; msg . mass = self . mass ; msg . ixx = self . ixx ; msg . ixy = self . ixy ; msg . ixz = self . ixz ; msg . iyy = self . iyy ; msg . iyz = self . iyz ; msg . izz = self . izz ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool , pub status_message : std :: string :: String } impl WrappedTypesupport for Response { type CStruct = gazebo_msgs__srv__SetLinkProperties_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__gazebo_msgs__srv__SetLinkProperties_Response () } } fn create_msg () -> * mut gazebo_msgs__srv__SetLinkProperties_Response { unsafe { gazebo_msgs__srv__SetLinkProperties_Response__create () } } fn destroy_msg (msg : * mut gazebo_msgs__srv__SetLinkProperties_Response) -> () { unsafe { gazebo_msgs__srv__SetLinkProperties_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , status_message : msg . status_message . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; msg . status_message . assign (& self . status_message) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod SetLinkState { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__gazebo_msgs__srv__SetLinkState () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub link_state : gazebo_msgs :: msg :: LinkState } impl WrappedTypesupport for Request { type CStruct = gazebo_msgs__srv__SetLinkState_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__gazebo_msgs__srv__SetLinkState_Request () } } fn create_msg () -> * mut gazebo_msgs__srv__SetLinkState_Request { unsafe { gazebo_msgs__srv__SetLinkState_Request__create () } } fn destroy_msg (msg : * mut gazebo_msgs__srv__SetLinkState_Request) -> () { unsafe { gazebo_msgs__srv__SetLinkState_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { link_state : gazebo_msgs :: msg :: LinkState :: from_native (& msg . link_state) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . link_state . copy_to_native (& mut msg . link_state) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool , pub status_message : std :: string :: String } impl WrappedTypesupport for Response { type CStruct = gazebo_msgs__srv__SetLinkState_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__gazebo_msgs__srv__SetLinkState_Response () } } fn create_msg () -> * mut gazebo_msgs__srv__SetLinkState_Response { unsafe { gazebo_msgs__srv__SetLinkState_Response__create () } } fn destroy_msg (msg : * mut gazebo_msgs__srv__SetLinkState_Response) -> () { unsafe { gazebo_msgs__srv__SetLinkState_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , status_message : msg . status_message . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; msg . status_message . assign (& self . status_message) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod SetModelConfiguration { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__gazebo_msgs__srv__SetModelConfiguration () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub model_name : std :: string :: String , pub urdf_param_name : std :: string :: String , pub joint_names : Vec < std :: string :: String > , pub joint_positions : Vec < f64 > } impl WrappedTypesupport for Request { type CStruct = gazebo_msgs__srv__SetModelConfiguration_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__gazebo_msgs__srv__SetModelConfiguration_Request () } } fn create_msg () -> * mut gazebo_msgs__srv__SetModelConfiguration_Request { unsafe { gazebo_msgs__srv__SetModelConfiguration_Request__create () } } fn destroy_msg (msg : * mut gazebo_msgs__srv__SetModelConfiguration_Request) -> () { unsafe { gazebo_msgs__srv__SetModelConfiguration_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { model_name : msg . model_name . to_str () . to_owned () , urdf_param_name : msg . urdf_param_name . to_str () . to_owned () , joint_names : msg . joint_names . to_vec () , joint_positions : msg . joint_positions . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . model_name . assign (& self . model_name) ; msg . urdf_param_name . assign (& self . urdf_param_name) ; msg . joint_names . update (& self . joint_names) ; msg . joint_positions . update (& self . joint_positions) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool , pub status_message : std :: string :: String } impl WrappedTypesupport for Response { type CStruct = gazebo_msgs__srv__SetModelConfiguration_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__gazebo_msgs__srv__SetModelConfiguration_Response () } } fn create_msg () -> * mut gazebo_msgs__srv__SetModelConfiguration_Response { unsafe { gazebo_msgs__srv__SetModelConfiguration_Response__create () } } fn destroy_msg (msg : * mut gazebo_msgs__srv__SetModelConfiguration_Response) -> () { unsafe { gazebo_msgs__srv__SetModelConfiguration_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , status_message : msg . status_message . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; msg . status_message . assign (& self . status_message) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod SetModelState { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__gazebo_msgs__srv__SetModelState () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub model_state : gazebo_msgs :: msg :: ModelState } impl WrappedTypesupport for Request { type CStruct = gazebo_msgs__srv__SetModelState_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__gazebo_msgs__srv__SetModelState_Request () } } fn create_msg () -> * mut gazebo_msgs__srv__SetModelState_Request { unsafe { gazebo_msgs__srv__SetModelState_Request__create () } } fn destroy_msg (msg : * mut gazebo_msgs__srv__SetModelState_Request) -> () { unsafe { gazebo_msgs__srv__SetModelState_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { model_state : gazebo_msgs :: msg :: ModelState :: from_native (& msg . model_state) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . model_state . copy_to_native (& mut msg . model_state) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool , pub status_message : std :: string :: String } impl WrappedTypesupport for Response { type CStruct = gazebo_msgs__srv__SetModelState_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__gazebo_msgs__srv__SetModelState_Response () } } fn create_msg () -> * mut gazebo_msgs__srv__SetModelState_Response { unsafe { gazebo_msgs__srv__SetModelState_Response__create () } } fn destroy_msg (msg : * mut gazebo_msgs__srv__SetModelState_Response) -> () { unsafe { gazebo_msgs__srv__SetModelState_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , status_message : msg . status_message . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; msg . status_message . assign (& self . status_message) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod SetPhysicsProperties { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__gazebo_msgs__srv__SetPhysicsProperties () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub time_step : f64 , pub max_update_rate : f64 , pub gravity : geometry_msgs :: msg :: Vector3 , pub ode_config : gazebo_msgs :: msg :: ODEPhysics } impl WrappedTypesupport for Request { type CStruct = gazebo_msgs__srv__SetPhysicsProperties_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__gazebo_msgs__srv__SetPhysicsProperties_Request () } } fn create_msg () -> * mut gazebo_msgs__srv__SetPhysicsProperties_Request { unsafe { gazebo_msgs__srv__SetPhysicsProperties_Request__create () } } fn destroy_msg (msg : * mut gazebo_msgs__srv__SetPhysicsProperties_Request) -> () { unsafe { gazebo_msgs__srv__SetPhysicsProperties_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { time_step : msg . time_step , max_update_rate : msg . max_update_rate , gravity : geometry_msgs :: msg :: Vector3 :: from_native (& msg . gravity) , ode_config : gazebo_msgs :: msg :: ODEPhysics :: from_native (& msg . ode_config) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . time_step = self . time_step ; msg . max_update_rate = self . max_update_rate ; self . gravity . copy_to_native (& mut msg . gravity) ; self . ode_config . copy_to_native (& mut msg . ode_config) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool , pub status_message : std :: string :: String } impl WrappedTypesupport for Response { type CStruct = gazebo_msgs__srv__SetPhysicsProperties_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__gazebo_msgs__srv__SetPhysicsProperties_Response () } } fn create_msg () -> * mut gazebo_msgs__srv__SetPhysicsProperties_Response { unsafe { gazebo_msgs__srv__SetPhysicsProperties_Response__create () } } fn destroy_msg (msg : * mut gazebo_msgs__srv__SetPhysicsProperties_Response) -> () { unsafe { gazebo_msgs__srv__SetPhysicsProperties_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , status_message : msg . status_message . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; msg . status_message . assign (& self . status_message) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod SpawnEntity { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__gazebo_msgs__srv__SpawnEntity () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub name : std :: string :: String , pub xml : std :: string :: String , pub robot_namespace : std :: string :: String , pub initial_pose : geometry_msgs :: msg :: Pose , pub reference_frame : std :: string :: String } impl WrappedTypesupport for Request { type CStruct = gazebo_msgs__srv__SpawnEntity_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__gazebo_msgs__srv__SpawnEntity_Request () } } fn create_msg () -> * mut gazebo_msgs__srv__SpawnEntity_Request { unsafe { gazebo_msgs__srv__SpawnEntity_Request__create () } } fn destroy_msg (msg : * mut gazebo_msgs__srv__SpawnEntity_Request) -> () { unsafe { gazebo_msgs__srv__SpawnEntity_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { name : msg . name . to_str () . to_owned () , xml : msg . xml . to_str () . to_owned () , robot_namespace : msg . robot_namespace . to_str () . to_owned () , initial_pose : geometry_msgs :: msg :: Pose :: from_native (& msg . initial_pose) , reference_frame : msg . reference_frame . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . name . assign (& self . name) ; msg . xml . assign (& self . xml) ; msg . robot_namespace . assign (& self . robot_namespace) ; self . initial_pose . copy_to_native (& mut msg . initial_pose) ; msg . reference_frame . assign (& self . reference_frame) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool , pub status_message : std :: string :: String } impl WrappedTypesupport for Response { type CStruct = gazebo_msgs__srv__SpawnEntity_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__gazebo_msgs__srv__SpawnEntity_Response () } } fn create_msg () -> * mut gazebo_msgs__srv__SpawnEntity_Response { unsafe { gazebo_msgs__srv__SpawnEntity_Response__create () } } fn destroy_msg (msg : * mut gazebo_msgs__srv__SpawnEntity_Response) -> () { unsafe { gazebo_msgs__srv__SpawnEntity_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , status_message : msg . status_message . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; msg . status_message . assign (& self . status_message) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod SpawnModel { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__gazebo_msgs__srv__SpawnModel () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub model_name : std :: string :: String , pub model_xml : std :: string :: String , pub robot_namespace : std :: string :: String , pub initial_pose : geometry_msgs :: msg :: Pose , pub reference_frame : std :: string :: String } impl WrappedTypesupport for Request { type CStruct = gazebo_msgs__srv__SpawnModel_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__gazebo_msgs__srv__SpawnModel_Request () } } fn create_msg () -> * mut gazebo_msgs__srv__SpawnModel_Request { unsafe { gazebo_msgs__srv__SpawnModel_Request__create () } } fn destroy_msg (msg : * mut gazebo_msgs__srv__SpawnModel_Request) -> () { unsafe { gazebo_msgs__srv__SpawnModel_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { model_name : msg . model_name . to_str () . to_owned () , model_xml : msg . model_xml . to_str () . to_owned () , robot_namespace : msg . robot_namespace . to_str () . to_owned () , initial_pose : geometry_msgs :: msg :: Pose :: from_native (& msg . initial_pose) , reference_frame : msg . reference_frame . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . model_name . assign (& self . model_name) ; msg . model_xml . assign (& self . model_xml) ; msg . robot_namespace . assign (& self . robot_namespace) ; self . initial_pose . copy_to_native (& mut msg . initial_pose) ; msg . reference_frame . assign (& self . reference_frame) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool , pub status_message : std :: string :: String } impl WrappedTypesupport for Response { type CStruct = gazebo_msgs__srv__SpawnModel_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__gazebo_msgs__srv__SpawnModel_Response () } } fn create_msg () -> * mut gazebo_msgs__srv__SpawnModel_Response { unsafe { gazebo_msgs__srv__SpawnModel_Response__create () } } fn destroy_msg (msg : * mut gazebo_msgs__srv__SpawnModel_Response) -> () { unsafe { gazebo_msgs__srv__SpawnModel_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , status_message : msg . status_message . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; msg . status_message . assign (& self . status_message) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } }