pub mod srv { # [allow (non_snake_case)] pub mod NestedUint8ArrayTestService { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__rclpy_message_converter_msgs__srv__NestedUint8ArrayTestService () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub input : rclpy_message_converter_msgs :: msg :: NestedUint8ArrayTestMessage } impl WrappedTypesupport for Request { type CStruct = rclpy_message_converter_msgs__srv__NestedUint8ArrayTestService_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rclpy_message_converter_msgs__srv__NestedUint8ArrayTestService_Request () } } fn create_msg () -> * mut rclpy_message_converter_msgs__srv__NestedUint8ArrayTestService_Request { unsafe { rclpy_message_converter_msgs__srv__NestedUint8ArrayTestService_Request__create () } } fn destroy_msg (msg : * mut rclpy_message_converter_msgs__srv__NestedUint8ArrayTestService_Request) -> () { unsafe { rclpy_message_converter_msgs__srv__NestedUint8ArrayTestService_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { input : rclpy_message_converter_msgs :: msg :: NestedUint8ArrayTestMessage :: from_native (& msg . input) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . input . copy_to_native (& mut msg . input) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub output : rclpy_message_converter_msgs :: msg :: NestedUint8ArrayTestMessage } impl WrappedTypesupport for Response { type CStruct = rclpy_message_converter_msgs__srv__NestedUint8ArrayTestService_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rclpy_message_converter_msgs__srv__NestedUint8ArrayTestService_Response () } } fn create_msg () -> * mut rclpy_message_converter_msgs__srv__NestedUint8ArrayTestService_Response { unsafe { rclpy_message_converter_msgs__srv__NestedUint8ArrayTestService_Response__create () } } fn destroy_msg (msg : * mut rclpy_message_converter_msgs__srv__NestedUint8ArrayTestService_Response) -> () { unsafe { rclpy_message_converter_msgs__srv__NestedUint8ArrayTestService_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { output : rclpy_message_converter_msgs :: msg :: NestedUint8ArrayTestMessage :: from_native (& msg . output) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . output . copy_to_native (& mut msg . output) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } } pub mod msg { use super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct NestedUint8ArrayTestMessage { pub arrays : Vec < rclpy_message_converter_msgs :: msg :: Uint8ArrayTestMessage > } impl WrappedTypesupport for NestedUint8ArrayTestMessage { type CStruct = rclpy_message_converter_msgs__msg__NestedUint8ArrayTestMessage ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rclpy_message_converter_msgs__msg__NestedUint8ArrayTestMessage () } } fn create_msg () -> * mut rclpy_message_converter_msgs__msg__NestedUint8ArrayTestMessage { unsafe { rclpy_message_converter_msgs__msg__NestedUint8ArrayTestMessage__create () } } fn destroy_msg (msg : * mut rclpy_message_converter_msgs__msg__NestedUint8ArrayTestMessage) -> () { unsafe { rclpy_message_converter_msgs__msg__NestedUint8ArrayTestMessage__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> NestedUint8ArrayTestMessage { NestedUint8ArrayTestMessage { arrays : { let mut temp = Vec :: with_capacity (msg . arrays . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . arrays . data , msg . arrays . size) } ; for s in slice { temp . push (rclpy_message_converter_msgs :: msg :: Uint8ArrayTestMessage :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { unsafe { rclpy_message_converter_msgs__msg__Uint8ArrayTestMessage__Sequence__fini (& mut msg . arrays) ; rclpy_message_converter_msgs__msg__Uint8ArrayTestMessage__Sequence__init (& mut msg . arrays , self . arrays . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . arrays . data , msg . arrays . size) ; for (t , s) in slice . iter_mut () . zip (& self . arrays) { s . copy_to_native (t) ; } } } } impl Default for NestedUint8ArrayTestMessage { fn default () -> Self { let msg_native = WrappedNativeMsg :: < NestedUint8ArrayTestMessage > :: new () ; NestedUint8ArrayTestMessage :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct TestArray { pub data : Vec < f64 > } impl WrappedTypesupport for TestArray { type CStruct = rclpy_message_converter_msgs__msg__TestArray ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rclpy_message_converter_msgs__msg__TestArray () } } fn create_msg () -> * mut rclpy_message_converter_msgs__msg__TestArray { unsafe { rclpy_message_converter_msgs__msg__TestArray__create () } } fn destroy_msg (msg : * mut rclpy_message_converter_msgs__msg__TestArray) -> () { unsafe { rclpy_message_converter_msgs__msg__TestArray__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> TestArray { TestArray { data : msg . data . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . data . update (& self . data) ; } } impl Default for TestArray { fn default () -> Self { let msg_native = WrappedNativeMsg :: < TestArray > :: new () ; TestArray :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Uint8Array3TestMessage { pub data : Vec < u8 > } impl WrappedTypesupport for Uint8Array3TestMessage { type CStruct = rclpy_message_converter_msgs__msg__Uint8Array3TestMessage ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rclpy_message_converter_msgs__msg__Uint8Array3TestMessage () } } fn create_msg () -> * mut rclpy_message_converter_msgs__msg__Uint8Array3TestMessage { unsafe { rclpy_message_converter_msgs__msg__Uint8Array3TestMessage__create () } } fn destroy_msg (msg : * mut rclpy_message_converter_msgs__msg__Uint8Array3TestMessage) -> () { unsafe { rclpy_message_converter_msgs__msg__Uint8Array3TestMessage__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Uint8Array3TestMessage { Uint8Array3TestMessage { data : msg . data . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { assert_eq ! (self . data . len () , 3usize , "Field {} is fixed size of {}!" , "data" , 3usize) ; msg . data . copy_from_slice (& self . data [.. 3usize]) ; } } impl Default for Uint8Array3TestMessage { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Uint8Array3TestMessage > :: new () ; Uint8Array3TestMessage :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Uint8ArrayTestMessage { pub data : Vec < u8 > } impl WrappedTypesupport for Uint8ArrayTestMessage { type CStruct = rclpy_message_converter_msgs__msg__Uint8ArrayTestMessage ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rclpy_message_converter_msgs__msg__Uint8ArrayTestMessage () } } fn create_msg () -> * mut rclpy_message_converter_msgs__msg__Uint8ArrayTestMessage { unsafe { rclpy_message_converter_msgs__msg__Uint8ArrayTestMessage__create () } } fn destroy_msg (msg : * mut rclpy_message_converter_msgs__msg__Uint8ArrayTestMessage) -> () { unsafe { rclpy_message_converter_msgs__msg__Uint8ArrayTestMessage__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Uint8ArrayTestMessage { Uint8ArrayTestMessage { data : msg . data . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . data . update (& self . data) ; } } impl Default for Uint8ArrayTestMessage { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Uint8ArrayTestMessage > :: new () ; Uint8ArrayTestMessage :: from_native (& msg_native) } } }