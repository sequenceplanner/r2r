pub mod srv { # [allow (non_snake_case)] pub mod AddToLog { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__ur_dashboard_msgs__srv__AddToLog () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub message : std :: string :: String } impl WrappedTypesupport for Request { type CStruct = ur_dashboard_msgs__srv__AddToLog_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ur_dashboard_msgs__srv__AddToLog_Request () } } fn create_msg () -> * mut ur_dashboard_msgs__srv__AddToLog_Request { unsafe { ur_dashboard_msgs__srv__AddToLog_Request__create () } } fn destroy_msg (msg : * mut ur_dashboard_msgs__srv__AddToLog_Request) -> () { unsafe { ur_dashboard_msgs__srv__AddToLog_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { message : msg . message . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . message . assign (& self . message) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub answer : std :: string :: String , pub success : bool } impl WrappedTypesupport for Response { type CStruct = ur_dashboard_msgs__srv__AddToLog_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ur_dashboard_msgs__srv__AddToLog_Response () } } fn create_msg () -> * mut ur_dashboard_msgs__srv__AddToLog_Response { unsafe { ur_dashboard_msgs__srv__AddToLog_Response__create () } } fn destroy_msg (msg : * mut ur_dashboard_msgs__srv__AddToLog_Response) -> () { unsafe { ur_dashboard_msgs__srv__AddToLog_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { answer : msg . answer . to_str () . to_owned () , success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . answer . assign (& self . answer) ; msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetLoadedProgram { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__ur_dashboard_msgs__srv__GetLoadedProgram () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { } impl WrappedTypesupport for Request { type CStruct = ur_dashboard_msgs__srv__GetLoadedProgram_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ur_dashboard_msgs__srv__GetLoadedProgram_Request () } } fn create_msg () -> * mut ur_dashboard_msgs__srv__GetLoadedProgram_Request { unsafe { ur_dashboard_msgs__srv__GetLoadedProgram_Request__create () } } fn destroy_msg (msg : * mut ur_dashboard_msgs__srv__GetLoadedProgram_Request) -> () { unsafe { ur_dashboard_msgs__srv__GetLoadedProgram_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub answer : std :: string :: String , pub program_name : std :: string :: String , pub success : bool } impl WrappedTypesupport for Response { type CStruct = ur_dashboard_msgs__srv__GetLoadedProgram_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ur_dashboard_msgs__srv__GetLoadedProgram_Response () } } fn create_msg () -> * mut ur_dashboard_msgs__srv__GetLoadedProgram_Response { unsafe { ur_dashboard_msgs__srv__GetLoadedProgram_Response__create () } } fn destroy_msg (msg : * mut ur_dashboard_msgs__srv__GetLoadedProgram_Response) -> () { unsafe { ur_dashboard_msgs__srv__GetLoadedProgram_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { answer : msg . answer . to_str () . to_owned () , program_name : msg . program_name . to_str () . to_owned () , success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . answer . assign (& self . answer) ; msg . program_name . assign (& self . program_name) ; msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetProgramState { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__ur_dashboard_msgs__srv__GetProgramState () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { } impl WrappedTypesupport for Request { type CStruct = ur_dashboard_msgs__srv__GetProgramState_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ur_dashboard_msgs__srv__GetProgramState_Request () } } fn create_msg () -> * mut ur_dashboard_msgs__srv__GetProgramState_Request { unsafe { ur_dashboard_msgs__srv__GetProgramState_Request__create () } } fn destroy_msg (msg : * mut ur_dashboard_msgs__srv__GetProgramState_Request) -> () { unsafe { ur_dashboard_msgs__srv__GetProgramState_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub state : ur_dashboard_msgs :: msg :: ProgramState , pub program_name : std :: string :: String , pub answer : std :: string :: String , pub success : bool } impl WrappedTypesupport for Response { type CStruct = ur_dashboard_msgs__srv__GetProgramState_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ur_dashboard_msgs__srv__GetProgramState_Response () } } fn create_msg () -> * mut ur_dashboard_msgs__srv__GetProgramState_Response { unsafe { ur_dashboard_msgs__srv__GetProgramState_Response__create () } } fn destroy_msg (msg : * mut ur_dashboard_msgs__srv__GetProgramState_Response) -> () { unsafe { ur_dashboard_msgs__srv__GetProgramState_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { state : ur_dashboard_msgs :: msg :: ProgramState :: from_native (& msg . state) , program_name : msg . program_name . to_str () . to_owned () , answer : msg . answer . to_str () . to_owned () , success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . state . copy_to_native (& mut msg . state) ; msg . program_name . assign (& self . program_name) ; msg . answer . assign (& self . answer) ; msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetRobotMode { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__ur_dashboard_msgs__srv__GetRobotMode () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { } impl WrappedTypesupport for Request { type CStruct = ur_dashboard_msgs__srv__GetRobotMode_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ur_dashboard_msgs__srv__GetRobotMode_Request () } } fn create_msg () -> * mut ur_dashboard_msgs__srv__GetRobotMode_Request { unsafe { ur_dashboard_msgs__srv__GetRobotMode_Request__create () } } fn destroy_msg (msg : * mut ur_dashboard_msgs__srv__GetRobotMode_Request) -> () { unsafe { ur_dashboard_msgs__srv__GetRobotMode_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub robot_mode : ur_dashboard_msgs :: msg :: RobotMode , pub answer : std :: string :: String , pub success : bool } impl WrappedTypesupport for Response { type CStruct = ur_dashboard_msgs__srv__GetRobotMode_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ur_dashboard_msgs__srv__GetRobotMode_Response () } } fn create_msg () -> * mut ur_dashboard_msgs__srv__GetRobotMode_Response { unsafe { ur_dashboard_msgs__srv__GetRobotMode_Response__create () } } fn destroy_msg (msg : * mut ur_dashboard_msgs__srv__GetRobotMode_Response) -> () { unsafe { ur_dashboard_msgs__srv__GetRobotMode_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { robot_mode : ur_dashboard_msgs :: msg :: RobotMode :: from_native (& msg . robot_mode) , answer : msg . answer . to_str () . to_owned () , success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . robot_mode . copy_to_native (& mut msg . robot_mode) ; msg . answer . assign (& self . answer) ; msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetSafetyMode { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__ur_dashboard_msgs__srv__GetSafetyMode () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { } impl WrappedTypesupport for Request { type CStruct = ur_dashboard_msgs__srv__GetSafetyMode_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ur_dashboard_msgs__srv__GetSafetyMode_Request () } } fn create_msg () -> * mut ur_dashboard_msgs__srv__GetSafetyMode_Request { unsafe { ur_dashboard_msgs__srv__GetSafetyMode_Request__create () } } fn destroy_msg (msg : * mut ur_dashboard_msgs__srv__GetSafetyMode_Request) -> () { unsafe { ur_dashboard_msgs__srv__GetSafetyMode_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub safety_mode : ur_dashboard_msgs :: msg :: SafetyMode , pub answer : std :: string :: String , pub success : bool } impl WrappedTypesupport for Response { type CStruct = ur_dashboard_msgs__srv__GetSafetyMode_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ur_dashboard_msgs__srv__GetSafetyMode_Response () } } fn create_msg () -> * mut ur_dashboard_msgs__srv__GetSafetyMode_Response { unsafe { ur_dashboard_msgs__srv__GetSafetyMode_Response__create () } } fn destroy_msg (msg : * mut ur_dashboard_msgs__srv__GetSafetyMode_Response) -> () { unsafe { ur_dashboard_msgs__srv__GetSafetyMode_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { safety_mode : ur_dashboard_msgs :: msg :: SafetyMode :: from_native (& msg . safety_mode) , answer : msg . answer . to_str () . to_owned () , success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . safety_mode . copy_to_native (& mut msg . safety_mode) ; msg . answer . assign (& self . answer) ; msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod IsProgramRunning { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__ur_dashboard_msgs__srv__IsProgramRunning () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { } impl WrappedTypesupport for Request { type CStruct = ur_dashboard_msgs__srv__IsProgramRunning_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ur_dashboard_msgs__srv__IsProgramRunning_Request () } } fn create_msg () -> * mut ur_dashboard_msgs__srv__IsProgramRunning_Request { unsafe { ur_dashboard_msgs__srv__IsProgramRunning_Request__create () } } fn destroy_msg (msg : * mut ur_dashboard_msgs__srv__IsProgramRunning_Request) -> () { unsafe { ur_dashboard_msgs__srv__IsProgramRunning_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub answer : std :: string :: String , pub program_running : bool , pub success : bool } impl WrappedTypesupport for Response { type CStruct = ur_dashboard_msgs__srv__IsProgramRunning_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ur_dashboard_msgs__srv__IsProgramRunning_Response () } } fn create_msg () -> * mut ur_dashboard_msgs__srv__IsProgramRunning_Response { unsafe { ur_dashboard_msgs__srv__IsProgramRunning_Response__create () } } fn destroy_msg (msg : * mut ur_dashboard_msgs__srv__IsProgramRunning_Response) -> () { unsafe { ur_dashboard_msgs__srv__IsProgramRunning_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { answer : msg . answer . to_str () . to_owned () , program_running : msg . program_running , success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . answer . assign (& self . answer) ; msg . program_running = self . program_running ; msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod IsProgramSaved { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__ur_dashboard_msgs__srv__IsProgramSaved () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { } impl WrappedTypesupport for Request { type CStruct = ur_dashboard_msgs__srv__IsProgramSaved_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ur_dashboard_msgs__srv__IsProgramSaved_Request () } } fn create_msg () -> * mut ur_dashboard_msgs__srv__IsProgramSaved_Request { unsafe { ur_dashboard_msgs__srv__IsProgramSaved_Request__create () } } fn destroy_msg (msg : * mut ur_dashboard_msgs__srv__IsProgramSaved_Request) -> () { unsafe { ur_dashboard_msgs__srv__IsProgramSaved_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub answer : std :: string :: String , pub program_name : std :: string :: String , pub program_saved : bool , pub success : bool } impl WrappedTypesupport for Response { type CStruct = ur_dashboard_msgs__srv__IsProgramSaved_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ur_dashboard_msgs__srv__IsProgramSaved_Response () } } fn create_msg () -> * mut ur_dashboard_msgs__srv__IsProgramSaved_Response { unsafe { ur_dashboard_msgs__srv__IsProgramSaved_Response__create () } } fn destroy_msg (msg : * mut ur_dashboard_msgs__srv__IsProgramSaved_Response) -> () { unsafe { ur_dashboard_msgs__srv__IsProgramSaved_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { answer : msg . answer . to_str () . to_owned () , program_name : msg . program_name . to_str () . to_owned () , program_saved : msg . program_saved , success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . answer . assign (& self . answer) ; msg . program_name . assign (& self . program_name) ; msg . program_saved = self . program_saved ; msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod Load { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__ur_dashboard_msgs__srv__Load () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub filename : std :: string :: String } impl WrappedTypesupport for Request { type CStruct = ur_dashboard_msgs__srv__Load_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ur_dashboard_msgs__srv__Load_Request () } } fn create_msg () -> * mut ur_dashboard_msgs__srv__Load_Request { unsafe { ur_dashboard_msgs__srv__Load_Request__create () } } fn destroy_msg (msg : * mut ur_dashboard_msgs__srv__Load_Request) -> () { unsafe { ur_dashboard_msgs__srv__Load_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { filename : msg . filename . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . filename . assign (& self . filename) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub answer : std :: string :: String , pub success : bool } impl WrappedTypesupport for Response { type CStruct = ur_dashboard_msgs__srv__Load_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ur_dashboard_msgs__srv__Load_Response () } } fn create_msg () -> * mut ur_dashboard_msgs__srv__Load_Response { unsafe { ur_dashboard_msgs__srv__Load_Response__create () } } fn destroy_msg (msg : * mut ur_dashboard_msgs__srv__Load_Response) -> () { unsafe { ur_dashboard_msgs__srv__Load_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { answer : msg . answer . to_str () . to_owned () , success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . answer . assign (& self . answer) ; msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod Popup { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__ur_dashboard_msgs__srv__Popup () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub message : std :: string :: String } impl WrappedTypesupport for Request { type CStruct = ur_dashboard_msgs__srv__Popup_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ur_dashboard_msgs__srv__Popup_Request () } } fn create_msg () -> * mut ur_dashboard_msgs__srv__Popup_Request { unsafe { ur_dashboard_msgs__srv__Popup_Request__create () } } fn destroy_msg (msg : * mut ur_dashboard_msgs__srv__Popup_Request) -> () { unsafe { ur_dashboard_msgs__srv__Popup_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { message : msg . message . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . message . assign (& self . message) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub answer : std :: string :: String , pub success : bool } impl WrappedTypesupport for Response { type CStruct = ur_dashboard_msgs__srv__Popup_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ur_dashboard_msgs__srv__Popup_Response () } } fn create_msg () -> * mut ur_dashboard_msgs__srv__Popup_Response { unsafe { ur_dashboard_msgs__srv__Popup_Response__create () } } fn destroy_msg (msg : * mut ur_dashboard_msgs__srv__Popup_Response) -> () { unsafe { ur_dashboard_msgs__srv__Popup_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { answer : msg . answer . to_str () . to_owned () , success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . answer . assign (& self . answer) ; msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod RawRequest { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__ur_dashboard_msgs__srv__RawRequest () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub query : std :: string :: String } impl WrappedTypesupport for Request { type CStruct = ur_dashboard_msgs__srv__RawRequest_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ur_dashboard_msgs__srv__RawRequest_Request () } } fn create_msg () -> * mut ur_dashboard_msgs__srv__RawRequest_Request { unsafe { ur_dashboard_msgs__srv__RawRequest_Request__create () } } fn destroy_msg (msg : * mut ur_dashboard_msgs__srv__RawRequest_Request) -> () { unsafe { ur_dashboard_msgs__srv__RawRequest_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { query : msg . query . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . query . assign (& self . query) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub answer : std :: string :: String } impl WrappedTypesupport for Response { type CStruct = ur_dashboard_msgs__srv__RawRequest_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ur_dashboard_msgs__srv__RawRequest_Response () } } fn create_msg () -> * mut ur_dashboard_msgs__srv__RawRequest_Response { unsafe { ur_dashboard_msgs__srv__RawRequest_Response__create () } } fn destroy_msg (msg : * mut ur_dashboard_msgs__srv__RawRequest_Response) -> () { unsafe { ur_dashboard_msgs__srv__RawRequest_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { answer : msg . answer . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . answer . assign (& self . answer) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } } pub mod action { # [allow (non_snake_case)] pub mod SetMode { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Action () ; impl WrappedActionTypeSupport for Action { type Goal = Goal ; type Result = Result ; type Feedback = Feedback ; type FeedbackMessage = FeedbackMessage ; type SendGoal = SendGoal :: Service ; type GetResult = GetResult :: Service ; fn get_ts () -> & 'static rosidl_action_type_support_t { unsafe { & * rosidl_typesupport_c__get_action_type_support_handle__ur_dashboard_msgs__action__SetMode () } } fn make_goal_request_msg (goal_id : unique_identifier_msgs :: msg :: UUID , goal : Goal) -> SendGoal :: Request { SendGoal :: Request { goal_id , goal } } fn make_goal_response_msg (accepted : bool , stamp : builtin_interfaces :: msg :: Time) -> SendGoal :: Response { SendGoal :: Response { accepted , stamp } } fn make_feedback_msg (goal_id : unique_identifier_msgs :: msg :: UUID , feedback : Feedback) -> FeedbackMessage { FeedbackMessage { goal_id , feedback } } fn make_result_request_msg (goal_id : unique_identifier_msgs :: msg :: UUID) -> GetResult :: Request { GetResult :: Request { goal_id , } } fn make_result_response_msg (status : i8 , result : Result) -> GetResult :: Response { GetResult :: Response { status , result , } } fn destructure_goal_request_msg (msg : SendGoal :: Request) -> (unique_identifier_msgs :: msg :: UUID , Goal) { (msg . goal_id , msg . goal) } fn destructure_goal_response_msg (msg : SendGoal :: Response) -> (bool , builtin_interfaces :: msg :: Time) { (msg . accepted , msg . stamp) } fn destructure_feedback_msg (msg : FeedbackMessage) -> (unique_identifier_msgs :: msg :: UUID , Feedback) { (msg . goal_id , msg . feedback) } fn destructure_result_response_msg (msg : GetResult :: Response) -> (i8 , Result) { (msg . status , msg . result) } fn destructure_result_request_msg (msg : GetResult :: Request) -> unique_identifier_msgs :: msg :: UUID { msg . goal_id } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Goal { pub target_robot_mode : i8 , pub stop_program : bool , pub play_program : bool } impl WrappedTypesupport for Goal { type CStruct = ur_dashboard_msgs__action__SetMode_Goal ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ur_dashboard_msgs__action__SetMode_Goal () } } fn create_msg () -> * mut ur_dashboard_msgs__action__SetMode_Goal { unsafe { ur_dashboard_msgs__action__SetMode_Goal__create () } } fn destroy_msg (msg : * mut ur_dashboard_msgs__action__SetMode_Goal) -> () { unsafe { ur_dashboard_msgs__action__SetMode_Goal__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Goal { Goal { target_robot_mode : msg . target_robot_mode , stop_program : msg . stop_program , play_program : msg . play_program , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . target_robot_mode = self . target_robot_mode ; msg . stop_program = self . stop_program ; msg . play_program = self . play_program ; } } impl Default for Goal { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Goal > :: new () ; Goal :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Result { pub success : bool , pub message : std :: string :: String } impl WrappedTypesupport for Result { type CStruct = ur_dashboard_msgs__action__SetMode_Result ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ur_dashboard_msgs__action__SetMode_Result () } } fn create_msg () -> * mut ur_dashboard_msgs__action__SetMode_Result { unsafe { ur_dashboard_msgs__action__SetMode_Result__create () } } fn destroy_msg (msg : * mut ur_dashboard_msgs__action__SetMode_Result) -> () { unsafe { ur_dashboard_msgs__action__SetMode_Result__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Result { Result { success : msg . success , message : msg . message . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; msg . message . assign (& self . message) ; } } impl Default for Result { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Result > :: new () ; Result :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Feedback { pub current_robot_mode : i8 , pub current_safety_mode : i8 } impl WrappedTypesupport for Feedback { type CStruct = ur_dashboard_msgs__action__SetMode_Feedback ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ur_dashboard_msgs__action__SetMode_Feedback () } } fn create_msg () -> * mut ur_dashboard_msgs__action__SetMode_Feedback { unsafe { ur_dashboard_msgs__action__SetMode_Feedback__create () } } fn destroy_msg (msg : * mut ur_dashboard_msgs__action__SetMode_Feedback) -> () { unsafe { ur_dashboard_msgs__action__SetMode_Feedback__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Feedback { Feedback { current_robot_mode : msg . current_robot_mode , current_safety_mode : msg . current_safety_mode , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . current_robot_mode = self . current_robot_mode ; msg . current_safety_mode = self . current_safety_mode ; } } impl Default for Feedback { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Feedback > :: new () ; Feedback :: from_native (& msg_native) } } # [allow (non_snake_case)] pub mod SendGoal { use super :: super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__ur_dashboard_msgs__action__SetMode_SendGoal () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub goal_id : unique_identifier_msgs :: msg :: UUID , pub goal : ur_dashboard_msgs :: action :: SetMode :: Goal } impl WrappedTypesupport for Request { type CStruct = ur_dashboard_msgs__action__SetMode_SendGoal_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ur_dashboard_msgs__action__SetMode_SendGoal_Request () } } fn create_msg () -> * mut ur_dashboard_msgs__action__SetMode_SendGoal_Request { unsafe { ur_dashboard_msgs__action__SetMode_SendGoal_Request__create () } } fn destroy_msg (msg : * mut ur_dashboard_msgs__action__SetMode_SendGoal_Request) -> () { unsafe { ur_dashboard_msgs__action__SetMode_SendGoal_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { goal_id : unique_identifier_msgs :: msg :: UUID :: from_native (& msg . goal_id) , goal : ur_dashboard_msgs :: action :: SetMode :: Goal :: from_native (& msg . goal) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . goal_id . copy_to_native (& mut msg . goal_id) ; self . goal . copy_to_native (& mut msg . goal) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub accepted : bool , pub stamp : builtin_interfaces :: msg :: Time } impl WrappedTypesupport for Response { type CStruct = ur_dashboard_msgs__action__SetMode_SendGoal_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ur_dashboard_msgs__action__SetMode_SendGoal_Response () } } fn create_msg () -> * mut ur_dashboard_msgs__action__SetMode_SendGoal_Response { unsafe { ur_dashboard_msgs__action__SetMode_SendGoal_Response__create () } } fn destroy_msg (msg : * mut ur_dashboard_msgs__action__SetMode_SendGoal_Response) -> () { unsafe { ur_dashboard_msgs__action__SetMode_SendGoal_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { accepted : msg . accepted , stamp : builtin_interfaces :: msg :: Time :: from_native (& msg . stamp) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . accepted = self . accepted ; self . stamp . copy_to_native (& mut msg . stamp) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetResult { use super :: super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__ur_dashboard_msgs__action__SetMode_GetResult () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub goal_id : unique_identifier_msgs :: msg :: UUID } impl WrappedTypesupport for Request { type CStruct = ur_dashboard_msgs__action__SetMode_GetResult_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ur_dashboard_msgs__action__SetMode_GetResult_Request () } } fn create_msg () -> * mut ur_dashboard_msgs__action__SetMode_GetResult_Request { unsafe { ur_dashboard_msgs__action__SetMode_GetResult_Request__create () } } fn destroy_msg (msg : * mut ur_dashboard_msgs__action__SetMode_GetResult_Request) -> () { unsafe { ur_dashboard_msgs__action__SetMode_GetResult_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { goal_id : unique_identifier_msgs :: msg :: UUID :: from_native (& msg . goal_id) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . goal_id . copy_to_native (& mut msg . goal_id) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub status : i8 , pub result : ur_dashboard_msgs :: action :: SetMode :: Result } impl WrappedTypesupport for Response { type CStruct = ur_dashboard_msgs__action__SetMode_GetResult_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ur_dashboard_msgs__action__SetMode_GetResult_Response () } } fn create_msg () -> * mut ur_dashboard_msgs__action__SetMode_GetResult_Response { unsafe { ur_dashboard_msgs__action__SetMode_GetResult_Response__create () } } fn destroy_msg (msg : * mut ur_dashboard_msgs__action__SetMode_GetResult_Response) -> () { unsafe { ur_dashboard_msgs__action__SetMode_GetResult_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { status : msg . status , result : ur_dashboard_msgs :: action :: SetMode :: Result :: from_native (& msg . result) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . status = self . status ; self . result . copy_to_native (& mut msg . result) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct FeedbackMessage { pub goal_id : unique_identifier_msgs :: msg :: UUID , pub feedback : ur_dashboard_msgs :: action :: SetMode :: Feedback } impl WrappedTypesupport for FeedbackMessage { type CStruct = ur_dashboard_msgs__action__SetMode_FeedbackMessage ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ur_dashboard_msgs__action__SetMode_FeedbackMessage () } } fn create_msg () -> * mut ur_dashboard_msgs__action__SetMode_FeedbackMessage { unsafe { ur_dashboard_msgs__action__SetMode_FeedbackMessage__create () } } fn destroy_msg (msg : * mut ur_dashboard_msgs__action__SetMode_FeedbackMessage) -> () { unsafe { ur_dashboard_msgs__action__SetMode_FeedbackMessage__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> FeedbackMessage { FeedbackMessage { goal_id : unique_identifier_msgs :: msg :: UUID :: from_native (& msg . goal_id) , feedback : ur_dashboard_msgs :: action :: SetMode :: Feedback :: from_native (& msg . feedback) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . goal_id . copy_to_native (& mut msg . goal_id) ; self . feedback . copy_to_native (& mut msg . feedback) ; } } impl Default for FeedbackMessage { fn default () -> Self { let msg_native = WrappedNativeMsg :: < FeedbackMessage > :: new () ; FeedbackMessage :: from_native (& msg_native) } } } } pub mod msg { use super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ProgramState { pub state : std :: string :: String } impl WrappedTypesupport for ProgramState { type CStruct = ur_dashboard_msgs__msg__ProgramState ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ur_dashboard_msgs__msg__ProgramState () } } fn create_msg () -> * mut ur_dashboard_msgs__msg__ProgramState { unsafe { ur_dashboard_msgs__msg__ProgramState__create () } } fn destroy_msg (msg : * mut ur_dashboard_msgs__msg__ProgramState) -> () { unsafe { ur_dashboard_msgs__msg__ProgramState__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ProgramState { ProgramState { state : msg . state . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . state . assign (& self . state) ; } } impl Default for ProgramState { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ProgramState > :: new () ; ProgramState :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl ProgramState { pub const PAUSED : & [u8 ; 7usize] = ur_dashboard_msgs__msg__ProgramState__PAUSED ; pub const PLAYING : & [u8 ; 8usize] = ur_dashboard_msgs__msg__ProgramState__PLAYING ; pub const STOPPED : & [u8 ; 8usize] = ur_dashboard_msgs__msg__ProgramState__STOPPED ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct RobotMode { pub mode : i8 } impl WrappedTypesupport for RobotMode { type CStruct = ur_dashboard_msgs__msg__RobotMode ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ur_dashboard_msgs__msg__RobotMode () } } fn create_msg () -> * mut ur_dashboard_msgs__msg__RobotMode { unsafe { ur_dashboard_msgs__msg__RobotMode__create () } } fn destroy_msg (msg : * mut ur_dashboard_msgs__msg__RobotMode) -> () { unsafe { ur_dashboard_msgs__msg__RobotMode__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> RobotMode { RobotMode { mode : msg . mode , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . mode = self . mode ; } } impl Default for RobotMode { fn default () -> Self { let msg_native = WrappedNativeMsg :: < RobotMode > :: new () ; RobotMode :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl RobotMode { pub const BACKDRIVE : _bindgen_ty_2493 = ur_dashboard_msgs__msg__RobotMode__BACKDRIVE ; pub const BOOTING : _bindgen_ty_2489 = ur_dashboard_msgs__msg__RobotMode__BOOTING ; pub const CONFIRM_SAFETY : _bindgen_ty_2488 = ur_dashboard_msgs__msg__RobotMode__CONFIRM_SAFETY ; pub const DISCONNECTED : _bindgen_ty_2487 = ur_dashboard_msgs__msg__RobotMode__DISCONNECTED ; pub const IDLE : _bindgen_ty_2492 = ur_dashboard_msgs__msg__RobotMode__IDLE ; pub const NO_CONTROLLER : _bindgen_ty_2486 = ur_dashboard_msgs__msg__RobotMode__NO_CONTROLLER ; pub const POWER_OFF : _bindgen_ty_2490 = ur_dashboard_msgs__msg__RobotMode__POWER_OFF ; pub const POWER_ON : _bindgen_ty_2491 = ur_dashboard_msgs__msg__RobotMode__POWER_ON ; pub const RUNNING : _bindgen_ty_2494 = ur_dashboard_msgs__msg__RobotMode__RUNNING ; pub const UPDATING_FIRMWARE : _bindgen_ty_2495 = ur_dashboard_msgs__msg__RobotMode__UPDATING_FIRMWARE ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct SafetyMode { pub mode : u8 } impl WrappedTypesupport for SafetyMode { type CStruct = ur_dashboard_msgs__msg__SafetyMode ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ur_dashboard_msgs__msg__SafetyMode () } } fn create_msg () -> * mut ur_dashboard_msgs__msg__SafetyMode { unsafe { ur_dashboard_msgs__msg__SafetyMode__create () } } fn destroy_msg (msg : * mut ur_dashboard_msgs__msg__SafetyMode) -> () { unsafe { ur_dashboard_msgs__msg__SafetyMode__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> SafetyMode { SafetyMode { mode : msg . mode , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . mode = self . mode ; } } impl Default for SafetyMode { fn default () -> Self { let msg_native = WrappedNativeMsg :: < SafetyMode > :: new () ; SafetyMode :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl SafetyMode { pub const AUTOMATIC_MODE_SAFEGUARD_STOP : _bindgen_ty_2507 = ur_dashboard_msgs__msg__SafetyMode__AUTOMATIC_MODE_SAFEGUARD_STOP ; pub const FAULT : _bindgen_ty_2504 = ur_dashboard_msgs__msg__SafetyMode__FAULT ; pub const NORMAL : _bindgen_ty_2496 = ur_dashboard_msgs__msg__SafetyMode__NORMAL ; pub const PROTECTIVE_STOP : _bindgen_ty_2498 = ur_dashboard_msgs__msg__SafetyMode__PROTECTIVE_STOP ; pub const RECOVERY : _bindgen_ty_2499 = ur_dashboard_msgs__msg__SafetyMode__RECOVERY ; pub const REDUCED : _bindgen_ty_2497 = ur_dashboard_msgs__msg__SafetyMode__REDUCED ; pub const ROBOT_EMERGENCY_STOP : _bindgen_ty_2502 = ur_dashboard_msgs__msg__SafetyMode__ROBOT_EMERGENCY_STOP ; pub const SAFEGUARD_STOP : _bindgen_ty_2500 = ur_dashboard_msgs__msg__SafetyMode__SAFEGUARD_STOP ; pub const SYSTEM_EMERGENCY_STOP : _bindgen_ty_2501 = ur_dashboard_msgs__msg__SafetyMode__SYSTEM_EMERGENCY_STOP ; pub const SYSTEM_THREE_POSITION_ENABLING_STOP : _bindgen_ty_2508 = ur_dashboard_msgs__msg__SafetyMode__SYSTEM_THREE_POSITION_ENABLING_STOP ; pub const UNDEFINED_SAFETY_MODE : _bindgen_ty_2506 = ur_dashboard_msgs__msg__SafetyMode__UNDEFINED_SAFETY_MODE ; pub const VALIDATE_JOINT_ID : _bindgen_ty_2505 = ur_dashboard_msgs__msg__SafetyMode__VALIDATE_JOINT_ID ; pub const VIOLATION : _bindgen_ty_2503 = ur_dashboard_msgs__msg__SafetyMode__VIOLATION ; } }