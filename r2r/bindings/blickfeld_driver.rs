pub mod srv { # [allow (non_snake_case)] pub mod ImuStaticTransformation { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__blickfeld_driver__srv__ImuStaticTransformation () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { } impl WrappedTypesupport for Request { type CStruct = blickfeld_driver__srv__ImuStaticTransformation_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__blickfeld_driver__srv__ImuStaticTransformation_Request () } } fn create_msg () -> * mut blickfeld_driver__srv__ImuStaticTransformation_Request { unsafe { blickfeld_driver__srv__ImuStaticTransformation_Request__create () } } fn destroy_msg (msg : * mut blickfeld_driver__srv__ImuStaticTransformation_Request) -> () { unsafe { blickfeld_driver__srv__ImuStaticTransformation_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub imu_transformation : geometry_msgs :: msg :: TransformStamped } impl WrappedTypesupport for Response { type CStruct = blickfeld_driver__srv__ImuStaticTransformation_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__blickfeld_driver__srv__ImuStaticTransformation_Response () } } fn create_msg () -> * mut blickfeld_driver__srv__ImuStaticTransformation_Response { unsafe { blickfeld_driver__srv__ImuStaticTransformation_Response__create () } } fn destroy_msg (msg : * mut blickfeld_driver__srv__ImuStaticTransformation_Response) -> () { unsafe { blickfeld_driver__srv__ImuStaticTransformation_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { imu_transformation : geometry_msgs :: msg :: TransformStamped :: from_native (& msg . imu_transformation) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . imu_transformation . copy_to_native (& mut msg . imu_transformation) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod SetScanPattern { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__blickfeld_driver__srv__SetScanPattern () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub fov_horizontal : f32 , pub fov_vertical : f32 , pub angle_spacing : f32 , pub scanlines_up : u16 , pub scanlines_down : u16 , pub frame_mode : std :: string :: String , pub pulse_type : std :: string :: String } impl WrappedTypesupport for Request { type CStruct = blickfeld_driver__srv__SetScanPattern_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__blickfeld_driver__srv__SetScanPattern_Request () } } fn create_msg () -> * mut blickfeld_driver__srv__SetScanPattern_Request { unsafe { blickfeld_driver__srv__SetScanPattern_Request__create () } } fn destroy_msg (msg : * mut blickfeld_driver__srv__SetScanPattern_Request) -> () { unsafe { blickfeld_driver__srv__SetScanPattern_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { fov_horizontal : msg . fov_horizontal , fov_vertical : msg . fov_vertical , angle_spacing : msg . angle_spacing , scanlines_up : msg . scanlines_up , scanlines_down : msg . scanlines_down , frame_mode : msg . frame_mode . to_str () . to_owned () , pulse_type : msg . pulse_type . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . fov_horizontal = self . fov_horizontal ; msg . fov_vertical = self . fov_vertical ; msg . angle_spacing = self . angle_spacing ; msg . scanlines_up = self . scanlines_up ; msg . scanlines_down = self . scanlines_down ; msg . frame_mode . assign (& self . frame_mode) ; msg . pulse_type . assign (& self . pulse_type) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl Request { pub const COMBINE_UP_DOWN : & [u8 ; 16usize] = blickfeld_driver__srv__SetScanPattern_Request__COMBINE_UP_DOWN ; pub const EQUI_HORIZONTAL_ANGLE : & [u8 ; 22usize] = blickfeld_driver__srv__SetScanPattern_Request__EQUI_HORIZONTAL_ANGLE ; pub const INTERLEAVE : & [u8 ; 11usize] = blickfeld_driver__srv__SetScanPattern_Request__INTERLEAVE ; pub const ONLY_DOWN : & [u8 ; 10usize] = blickfeld_driver__srv__SetScanPattern_Request__ONLY_DOWN ; pub const ONLY_UP : & [u8 ; 8usize] = blickfeld_driver__srv__SetScanPattern_Request__ONLY_UP ; pub const SEPARATE : & [u8 ; 9usize] = blickfeld_driver__srv__SetScanPattern_Request__SEPARATE ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool , pub message : std :: string :: String } impl WrappedTypesupport for Response { type CStruct = blickfeld_driver__srv__SetScanPattern_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__blickfeld_driver__srv__SetScanPattern_Response () } } fn create_msg () -> * mut blickfeld_driver__srv__SetScanPattern_Response { unsafe { blickfeld_driver__srv__SetScanPattern_Response__create () } } fn destroy_msg (msg : * mut blickfeld_driver__srv__SetScanPattern_Response) -> () { unsafe { blickfeld_driver__srv__SetScanPattern_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , message : msg . message . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; msg . message . assign (& self . message) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } }