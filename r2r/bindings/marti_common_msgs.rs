pub mod msg { use super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct BoolStamped { pub header : std_msgs :: msg :: Header , pub value : bool } impl WrappedTypesupport for BoolStamped { type CStruct = marti_common_msgs__msg__BoolStamped ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__marti_common_msgs__msg__BoolStamped () } } fn create_msg () -> * mut marti_common_msgs__msg__BoolStamped { unsafe { marti_common_msgs__msg__BoolStamped__create () } } fn destroy_msg (msg : * mut marti_common_msgs__msg__BoolStamped) -> () { unsafe { marti_common_msgs__msg__BoolStamped__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> BoolStamped { BoolStamped { header : std_msgs :: msg :: Header :: from_native (& msg . header) , value : msg . value , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . value = self . value ; } } impl Default for BoolStamped { fn default () -> Self { let msg_native = WrappedNativeMsg :: < BoolStamped > :: new () ; BoolStamped :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ByteArrayStamped { pub header : std_msgs :: msg :: Header , pub value : Vec < u8 > } impl WrappedTypesupport for ByteArrayStamped { type CStruct = marti_common_msgs__msg__ByteArrayStamped ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__marti_common_msgs__msg__ByteArrayStamped () } } fn create_msg () -> * mut marti_common_msgs__msg__ByteArrayStamped { unsafe { marti_common_msgs__msg__ByteArrayStamped__create () } } fn destroy_msg (msg : * mut marti_common_msgs__msg__ByteArrayStamped) -> () { unsafe { marti_common_msgs__msg__ByteArrayStamped__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ByteArrayStamped { ByteArrayStamped { header : std_msgs :: msg :: Header :: from_native (& msg . header) , value : msg . value . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . value . update (& self . value) ; } } impl Default for ByteArrayStamped { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ByteArrayStamped > :: new () ; ByteArrayStamped :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct DurationStamped { pub header : std_msgs :: msg :: Header , pub value : builtin_interfaces :: msg :: Duration } impl WrappedTypesupport for DurationStamped { type CStruct = marti_common_msgs__msg__DurationStamped ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__marti_common_msgs__msg__DurationStamped () } } fn create_msg () -> * mut marti_common_msgs__msg__DurationStamped { unsafe { marti_common_msgs__msg__DurationStamped__create () } } fn destroy_msg (msg : * mut marti_common_msgs__msg__DurationStamped) -> () { unsafe { marti_common_msgs__msg__DurationStamped__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> DurationStamped { DurationStamped { header : std_msgs :: msg :: Header :: from_native (& msg . header) , value : builtin_interfaces :: msg :: Duration :: from_native (& msg . value) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; self . value . copy_to_native (& mut msg . value) ; } } impl Default for DurationStamped { fn default () -> Self { let msg_native = WrappedNativeMsg :: < DurationStamped > :: new () ; DurationStamped :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Float32Stamped { pub header : std_msgs :: msg :: Header , pub value : f32 } impl WrappedTypesupport for Float32Stamped { type CStruct = marti_common_msgs__msg__Float32Stamped ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__marti_common_msgs__msg__Float32Stamped () } } fn create_msg () -> * mut marti_common_msgs__msg__Float32Stamped { unsafe { marti_common_msgs__msg__Float32Stamped__create () } } fn destroy_msg (msg : * mut marti_common_msgs__msg__Float32Stamped) -> () { unsafe { marti_common_msgs__msg__Float32Stamped__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Float32Stamped { Float32Stamped { header : std_msgs :: msg :: Header :: from_native (& msg . header) , value : msg . value , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . value = self . value ; } } impl Default for Float32Stamped { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Float32Stamped > :: new () ; Float32Stamped :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Float64Stamped { pub header : std_msgs :: msg :: Header , pub value : f64 } impl WrappedTypesupport for Float64Stamped { type CStruct = marti_common_msgs__msg__Float64Stamped ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__marti_common_msgs__msg__Float64Stamped () } } fn create_msg () -> * mut marti_common_msgs__msg__Float64Stamped { unsafe { marti_common_msgs__msg__Float64Stamped__create () } } fn destroy_msg (msg : * mut marti_common_msgs__msg__Float64Stamped) -> () { unsafe { marti_common_msgs__msg__Float64Stamped__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Float64Stamped { Float64Stamped { header : std_msgs :: msg :: Header :: from_native (& msg . header) , value : msg . value , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . value = self . value ; } } impl Default for Float64Stamped { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Float64Stamped > :: new () ; Float64Stamped :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct HealthStatus { pub header : std_msgs :: msg :: Header , pub status : i8 , pub message : std :: string :: String } impl WrappedTypesupport for HealthStatus { type CStruct = marti_common_msgs__msg__HealthStatus ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__marti_common_msgs__msg__HealthStatus () } } fn create_msg () -> * mut marti_common_msgs__msg__HealthStatus { unsafe { marti_common_msgs__msg__HealthStatus__create () } } fn destroy_msg (msg : * mut marti_common_msgs__msg__HealthStatus) -> () { unsafe { marti_common_msgs__msg__HealthStatus__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> HealthStatus { HealthStatus { header : std_msgs :: msg :: Header :: from_native (& msg . header) , status : msg . status , message : msg . message . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . status = self . status ; msg . message . assign (& self . message) ; } } impl Default for HealthStatus { fn default () -> Self { let msg_native = WrappedNativeMsg :: < HealthStatus > :: new () ; HealthStatus :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl HealthStatus { pub const ERROR : _bindgen_ty_438 = marti_common_msgs__msg__HealthStatus__ERROR ; pub const OK : _bindgen_ty_436 = marti_common_msgs__msg__HealthStatus__OK ; pub const STALE : _bindgen_ty_439 = marti_common_msgs__msg__HealthStatus__STALE ; pub const WARN : _bindgen_ty_437 = marti_common_msgs__msg__HealthStatus__WARN ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Int16Stamped { pub header : std_msgs :: msg :: Header , pub value : i16 } impl WrappedTypesupport for Int16Stamped { type CStruct = marti_common_msgs__msg__Int16Stamped ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__marti_common_msgs__msg__Int16Stamped () } } fn create_msg () -> * mut marti_common_msgs__msg__Int16Stamped { unsafe { marti_common_msgs__msg__Int16Stamped__create () } } fn destroy_msg (msg : * mut marti_common_msgs__msg__Int16Stamped) -> () { unsafe { marti_common_msgs__msg__Int16Stamped__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Int16Stamped { Int16Stamped { header : std_msgs :: msg :: Header :: from_native (& msg . header) , value : msg . value , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . value = self . value ; } } impl Default for Int16Stamped { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Int16Stamped > :: new () ; Int16Stamped :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Int32Stamped { pub header : std_msgs :: msg :: Header , pub value : i32 } impl WrappedTypesupport for Int32Stamped { type CStruct = marti_common_msgs__msg__Int32Stamped ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__marti_common_msgs__msg__Int32Stamped () } } fn create_msg () -> * mut marti_common_msgs__msg__Int32Stamped { unsafe { marti_common_msgs__msg__Int32Stamped__create () } } fn destroy_msg (msg : * mut marti_common_msgs__msg__Int32Stamped) -> () { unsafe { marti_common_msgs__msg__Int32Stamped__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Int32Stamped { Int32Stamped { header : std_msgs :: msg :: Header :: from_native (& msg . header) , value : msg . value , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . value = self . value ; } } impl Default for Int32Stamped { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Int32Stamped > :: new () ; Int32Stamped :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Int64Stamped { pub header : std_msgs :: msg :: Header , pub value : i64 } impl WrappedTypesupport for Int64Stamped { type CStruct = marti_common_msgs__msg__Int64Stamped ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__marti_common_msgs__msg__Int64Stamped () } } fn create_msg () -> * mut marti_common_msgs__msg__Int64Stamped { unsafe { marti_common_msgs__msg__Int64Stamped__create () } } fn destroy_msg (msg : * mut marti_common_msgs__msg__Int64Stamped) -> () { unsafe { marti_common_msgs__msg__Int64Stamped__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Int64Stamped { Int64Stamped { header : std_msgs :: msg :: Header :: from_native (& msg . header) , value : msg . value , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . value = self . value ; } } impl Default for Int64Stamped { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Int64Stamped > :: new () ; Int64Stamped :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Int8Stamped { pub header : std_msgs :: msg :: Header , pub value : i8 } impl WrappedTypesupport for Int8Stamped { type CStruct = marti_common_msgs__msg__Int8Stamped ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__marti_common_msgs__msg__Int8Stamped () } } fn create_msg () -> * mut marti_common_msgs__msg__Int8Stamped { unsafe { marti_common_msgs__msg__Int8Stamped__create () } } fn destroy_msg (msg : * mut marti_common_msgs__msg__Int8Stamped) -> () { unsafe { marti_common_msgs__msg__Int8Stamped__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Int8Stamped { Int8Stamped { header : std_msgs :: msg :: Header :: from_native (& msg . header) , value : msg . value , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . value = self . value ; } } impl Default for Int8Stamped { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Int8Stamped > :: new () ; Int8Stamped :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct KeyValue { pub key : std :: string :: String , pub value : std :: string :: String } impl WrappedTypesupport for KeyValue { type CStruct = marti_common_msgs__msg__KeyValue ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__marti_common_msgs__msg__KeyValue () } } fn create_msg () -> * mut marti_common_msgs__msg__KeyValue { unsafe { marti_common_msgs__msg__KeyValue__create () } } fn destroy_msg (msg : * mut marti_common_msgs__msg__KeyValue) -> () { unsafe { marti_common_msgs__msg__KeyValue__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> KeyValue { KeyValue { key : msg . key . to_str () . to_owned () , value : msg . value . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . key . assign (& self . key) ; msg . value . assign (& self . value) ; } } impl Default for KeyValue { fn default () -> Self { let msg_native = WrappedNativeMsg :: < KeyValue > :: new () ; KeyValue :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct KeyValueArray { pub header : std_msgs :: msg :: Header , pub items : Vec < marti_common_msgs :: msg :: KeyValue > } impl WrappedTypesupport for KeyValueArray { type CStruct = marti_common_msgs__msg__KeyValueArray ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__marti_common_msgs__msg__KeyValueArray () } } fn create_msg () -> * mut marti_common_msgs__msg__KeyValueArray { unsafe { marti_common_msgs__msg__KeyValueArray__create () } } fn destroy_msg (msg : * mut marti_common_msgs__msg__KeyValueArray) -> () { unsafe { marti_common_msgs__msg__KeyValueArray__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> KeyValueArray { KeyValueArray { header : std_msgs :: msg :: Header :: from_native (& msg . header) , items : { let mut temp = Vec :: with_capacity (msg . items . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . items . data , msg . items . size) } ; for s in slice { temp . push (marti_common_msgs :: msg :: KeyValue :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; unsafe { marti_common_msgs__msg__KeyValue__Sequence__fini (& mut msg . items) ; marti_common_msgs__msg__KeyValue__Sequence__init (& mut msg . items , self . items . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . items . data , msg . items . size) ; for (t , s) in slice . iter_mut () . zip (& self . items) { s . copy_to_native (t) ; } } } } impl Default for KeyValueArray { fn default () -> Self { let msg_native = WrappedNativeMsg :: < KeyValueArray > :: new () ; KeyValueArray :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Matrix3x3Stamped { pub header : std_msgs :: msg :: Header , pub matrix : Vec < f64 > } impl WrappedTypesupport for Matrix3x3Stamped { type CStruct = marti_common_msgs__msg__Matrix3x3Stamped ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__marti_common_msgs__msg__Matrix3x3Stamped () } } fn create_msg () -> * mut marti_common_msgs__msg__Matrix3x3Stamped { unsafe { marti_common_msgs__msg__Matrix3x3Stamped__create () } } fn destroy_msg (msg : * mut marti_common_msgs__msg__Matrix3x3Stamped) -> () { unsafe { marti_common_msgs__msg__Matrix3x3Stamped__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Matrix3x3Stamped { Matrix3x3Stamped { header : std_msgs :: msg :: Header :: from_native (& msg . header) , matrix : msg . matrix . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; assert_eq ! (self . matrix . len () , 9usize , "Field {} is fixed size of {}!" , "matrix" , 9usize) ; msg . matrix . copy_from_slice (& self . matrix [.. 9usize]) ; } } impl Default for Matrix3x3Stamped { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Matrix3x3Stamped > :: new () ; Matrix3x3Stamped :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ServiceHeader { pub stamp : builtin_interfaces :: msg :: Time , pub sequence : u32 , pub sender : std :: string :: String , pub result : bool } impl WrappedTypesupport for ServiceHeader { type CStruct = marti_common_msgs__msg__ServiceHeader ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__marti_common_msgs__msg__ServiceHeader () } } fn create_msg () -> * mut marti_common_msgs__msg__ServiceHeader { unsafe { marti_common_msgs__msg__ServiceHeader__create () } } fn destroy_msg (msg : * mut marti_common_msgs__msg__ServiceHeader) -> () { unsafe { marti_common_msgs__msg__ServiceHeader__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ServiceHeader { ServiceHeader { stamp : builtin_interfaces :: msg :: Time :: from_native (& msg . stamp) , sequence : msg . sequence , sender : msg . sender . to_str () . to_owned () , result : msg . result , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . stamp . copy_to_native (& mut msg . stamp) ; msg . sequence = self . sequence ; msg . sender . assign (& self . sender) ; msg . result = self . result ; } } impl Default for ServiceHeader { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ServiceHeader > :: new () ; ServiceHeader :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct StringArrayStamped { pub header : std_msgs :: msg :: Header , pub strings : Vec < std :: string :: String > } impl WrappedTypesupport for StringArrayStamped { type CStruct = marti_common_msgs__msg__StringArrayStamped ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__marti_common_msgs__msg__StringArrayStamped () } } fn create_msg () -> * mut marti_common_msgs__msg__StringArrayStamped { unsafe { marti_common_msgs__msg__StringArrayStamped__create () } } fn destroy_msg (msg : * mut marti_common_msgs__msg__StringArrayStamped) -> () { unsafe { marti_common_msgs__msg__StringArrayStamped__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> StringArrayStamped { StringArrayStamped { header : std_msgs :: msg :: Header :: from_native (& msg . header) , strings : msg . strings . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . strings . update (& self . strings) ; } } impl Default for StringArrayStamped { fn default () -> Self { let msg_native = WrappedNativeMsg :: < StringArrayStamped > :: new () ; StringArrayStamped :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct StringStamped { pub header : std_msgs :: msg :: Header , pub value : std :: string :: String } impl WrappedTypesupport for StringStamped { type CStruct = marti_common_msgs__msg__StringStamped ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__marti_common_msgs__msg__StringStamped () } } fn create_msg () -> * mut marti_common_msgs__msg__StringStamped { unsafe { marti_common_msgs__msg__StringStamped__create () } } fn destroy_msg (msg : * mut marti_common_msgs__msg__StringStamped) -> () { unsafe { marti_common_msgs__msg__StringStamped__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> StringStamped { StringStamped { header : std_msgs :: msg :: Header :: from_native (& msg . header) , value : msg . value . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . value . assign (& self . value) ; } } impl Default for StringStamped { fn default () -> Self { let msg_native = WrappedNativeMsg :: < StringStamped > :: new () ; StringStamped :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct TimeStamped { pub header : std_msgs :: msg :: Header , pub value : builtin_interfaces :: msg :: Time } impl WrappedTypesupport for TimeStamped { type CStruct = marti_common_msgs__msg__TimeStamped ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__marti_common_msgs__msg__TimeStamped () } } fn create_msg () -> * mut marti_common_msgs__msg__TimeStamped { unsafe { marti_common_msgs__msg__TimeStamped__create () } } fn destroy_msg (msg : * mut marti_common_msgs__msg__TimeStamped) -> () { unsafe { marti_common_msgs__msg__TimeStamped__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> TimeStamped { TimeStamped { header : std_msgs :: msg :: Header :: from_native (& msg . header) , value : builtin_interfaces :: msg :: Time :: from_native (& msg . value) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; self . value . copy_to_native (& mut msg . value) ; } } impl Default for TimeStamped { fn default () -> Self { let msg_native = WrappedNativeMsg :: < TimeStamped > :: new () ; TimeStamped :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct UInt16Stamped { pub header : std_msgs :: msg :: Header , pub value : u16 } impl WrappedTypesupport for UInt16Stamped { type CStruct = marti_common_msgs__msg__UInt16Stamped ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__marti_common_msgs__msg__UInt16Stamped () } } fn create_msg () -> * mut marti_common_msgs__msg__UInt16Stamped { unsafe { marti_common_msgs__msg__UInt16Stamped__create () } } fn destroy_msg (msg : * mut marti_common_msgs__msg__UInt16Stamped) -> () { unsafe { marti_common_msgs__msg__UInt16Stamped__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> UInt16Stamped { UInt16Stamped { header : std_msgs :: msg :: Header :: from_native (& msg . header) , value : msg . value , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . value = self . value ; } } impl Default for UInt16Stamped { fn default () -> Self { let msg_native = WrappedNativeMsg :: < UInt16Stamped > :: new () ; UInt16Stamped :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct UInt32Stamped { pub header : std_msgs :: msg :: Header , pub value : u32 } impl WrappedTypesupport for UInt32Stamped { type CStruct = marti_common_msgs__msg__UInt32Stamped ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__marti_common_msgs__msg__UInt32Stamped () } } fn create_msg () -> * mut marti_common_msgs__msg__UInt32Stamped { unsafe { marti_common_msgs__msg__UInt32Stamped__create () } } fn destroy_msg (msg : * mut marti_common_msgs__msg__UInt32Stamped) -> () { unsafe { marti_common_msgs__msg__UInt32Stamped__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> UInt32Stamped { UInt32Stamped { header : std_msgs :: msg :: Header :: from_native (& msg . header) , value : msg . value , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . value = self . value ; } } impl Default for UInt32Stamped { fn default () -> Self { let msg_native = WrappedNativeMsg :: < UInt32Stamped > :: new () ; UInt32Stamped :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct UInt64Stamped { pub header : std_msgs :: msg :: Header , pub value : u64 } impl WrappedTypesupport for UInt64Stamped { type CStruct = marti_common_msgs__msg__UInt64Stamped ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__marti_common_msgs__msg__UInt64Stamped () } } fn create_msg () -> * mut marti_common_msgs__msg__UInt64Stamped { unsafe { marti_common_msgs__msg__UInt64Stamped__create () } } fn destroy_msg (msg : * mut marti_common_msgs__msg__UInt64Stamped) -> () { unsafe { marti_common_msgs__msg__UInt64Stamped__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> UInt64Stamped { UInt64Stamped { header : std_msgs :: msg :: Header :: from_native (& msg . header) , value : msg . value , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . value = self . value ; } } impl Default for UInt64Stamped { fn default () -> Self { let msg_native = WrappedNativeMsg :: < UInt64Stamped > :: new () ; UInt64Stamped :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct UInt8Stamped { pub header : std_msgs :: msg :: Header , pub value : u8 } impl WrappedTypesupport for UInt8Stamped { type CStruct = marti_common_msgs__msg__UInt8Stamped ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__marti_common_msgs__msg__UInt8Stamped () } } fn create_msg () -> * mut marti_common_msgs__msg__UInt8Stamped { unsafe { marti_common_msgs__msg__UInt8Stamped__create () } } fn destroy_msg (msg : * mut marti_common_msgs__msg__UInt8Stamped) -> () { unsafe { marti_common_msgs__msg__UInt8Stamped__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> UInt8Stamped { UInt8Stamped { header : std_msgs :: msg :: Header :: from_native (& msg . header) , value : msg . value , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . value = self . value ; } } impl Default for UInt8Stamped { fn default () -> Self { let msg_native = WrappedNativeMsg :: < UInt8Stamped > :: new () ; UInt8Stamped :: from_native (& msg_native) } } }