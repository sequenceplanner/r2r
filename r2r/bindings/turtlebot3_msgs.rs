pub mod srv { # [allow (non_snake_case)] pub mod Dqn { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__turtlebot3_msgs__srv__Dqn () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub action : u8 , pub init : bool } impl WrappedTypesupport for Request { type CStruct = turtlebot3_msgs__srv__Dqn_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__turtlebot3_msgs__srv__Dqn_Request () } } fn create_msg () -> * mut turtlebot3_msgs__srv__Dqn_Request { unsafe { turtlebot3_msgs__srv__Dqn_Request__create () } } fn destroy_msg (msg : * mut turtlebot3_msgs__srv__Dqn_Request) -> () { unsafe { turtlebot3_msgs__srv__Dqn_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { action : msg . action , init : msg . init , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . action = self . action ; msg . init = self . init ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub state : Vec < f32 > , pub reward : f32 , pub done : bool } impl WrappedTypesupport for Response { type CStruct = turtlebot3_msgs__srv__Dqn_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__turtlebot3_msgs__srv__Dqn_Response () } } fn create_msg () -> * mut turtlebot3_msgs__srv__Dqn_Response { unsafe { turtlebot3_msgs__srv__Dqn_Response__create () } } fn destroy_msg (msg : * mut turtlebot3_msgs__srv__Dqn_Response) -> () { unsafe { turtlebot3_msgs__srv__Dqn_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { state : msg . state . to_vec () , reward : msg . reward , done : msg . done , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . state . update (& self . state) ; msg . reward = self . reward ; msg . done = self . done ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod Sound { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__turtlebot3_msgs__srv__Sound () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub value : u8 } impl WrappedTypesupport for Request { type CStruct = turtlebot3_msgs__srv__Sound_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__turtlebot3_msgs__srv__Sound_Request () } } fn create_msg () -> * mut turtlebot3_msgs__srv__Sound_Request { unsafe { turtlebot3_msgs__srv__Sound_Request__create () } } fn destroy_msg (msg : * mut turtlebot3_msgs__srv__Sound_Request) -> () { unsafe { turtlebot3_msgs__srv__Sound_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { value : msg . value , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . value = self . value ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool , pub message : std :: string :: String } impl WrappedTypesupport for Response { type CStruct = turtlebot3_msgs__srv__Sound_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__turtlebot3_msgs__srv__Sound_Response () } } fn create_msg () -> * mut turtlebot3_msgs__srv__Sound_Response { unsafe { turtlebot3_msgs__srv__Sound_Response__create () } } fn destroy_msg (msg : * mut turtlebot3_msgs__srv__Sound_Response) -> () { unsafe { turtlebot3_msgs__srv__Sound_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , message : msg . message . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; msg . message . assign (& self . message) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } } pub mod action { # [allow (non_snake_case)] pub mod Patrol { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Action () ; impl WrappedActionTypeSupport for Action { type Goal = Goal ; type Result = Result ; type Feedback = Feedback ; type FeedbackMessage = FeedbackMessage ; type SendGoal = SendGoal :: Service ; type GetResult = GetResult :: Service ; fn get_ts () -> & 'static rosidl_action_type_support_t { unsafe { & * rosidl_typesupport_c__get_action_type_support_handle__turtlebot3_msgs__action__Patrol () } } fn make_goal_request_msg (goal_id : unique_identifier_msgs :: msg :: UUID , goal : Goal) -> SendGoal :: Request { SendGoal :: Request { goal_id , goal } } fn make_goal_response_msg (accepted : bool , stamp : builtin_interfaces :: msg :: Time) -> SendGoal :: Response { SendGoal :: Response { accepted , stamp } } fn make_feedback_msg (goal_id : unique_identifier_msgs :: msg :: UUID , feedback : Feedback) -> FeedbackMessage { FeedbackMessage { goal_id , feedback } } fn make_result_request_msg (goal_id : unique_identifier_msgs :: msg :: UUID) -> GetResult :: Request { GetResult :: Request { goal_id , } } fn make_result_response_msg (status : i8 , result : Result) -> GetResult :: Response { GetResult :: Response { status , result , } } fn destructure_goal_request_msg (msg : SendGoal :: Request) -> (unique_identifier_msgs :: msg :: UUID , Goal) { (msg . goal_id , msg . goal) } fn destructure_goal_response_msg (msg : SendGoal :: Response) -> (bool , builtin_interfaces :: msg :: Time) { (msg . accepted , msg . stamp) } fn destructure_feedback_msg (msg : FeedbackMessage) -> (unique_identifier_msgs :: msg :: UUID , Feedback) { (msg . goal_id , msg . feedback) } fn destructure_result_response_msg (msg : GetResult :: Response) -> (i8 , Result) { (msg . status , msg . result) } fn destructure_result_request_msg (msg : GetResult :: Request) -> unique_identifier_msgs :: msg :: UUID { msg . goal_id } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Goal { pub radius : f32 } impl WrappedTypesupport for Goal { type CStruct = turtlebot3_msgs__action__Patrol_Goal ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__turtlebot3_msgs__action__Patrol_Goal () } } fn create_msg () -> * mut turtlebot3_msgs__action__Patrol_Goal { unsafe { turtlebot3_msgs__action__Patrol_Goal__create () } } fn destroy_msg (msg : * mut turtlebot3_msgs__action__Patrol_Goal) -> () { unsafe { turtlebot3_msgs__action__Patrol_Goal__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Goal { Goal { radius : msg . radius , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . radius = self . radius ; } } impl Default for Goal { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Goal > :: new () ; Goal :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Result { pub success : bool } impl WrappedTypesupport for Result { type CStruct = turtlebot3_msgs__action__Patrol_Result ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__turtlebot3_msgs__action__Patrol_Result () } } fn create_msg () -> * mut turtlebot3_msgs__action__Patrol_Result { unsafe { turtlebot3_msgs__action__Patrol_Result__create () } } fn destroy_msg (msg : * mut turtlebot3_msgs__action__Patrol_Result) -> () { unsafe { turtlebot3_msgs__action__Patrol_Result__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Result { Result { success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; } } impl Default for Result { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Result > :: new () ; Result :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Feedback { pub left_time : f32 } impl WrappedTypesupport for Feedback { type CStruct = turtlebot3_msgs__action__Patrol_Feedback ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__turtlebot3_msgs__action__Patrol_Feedback () } } fn create_msg () -> * mut turtlebot3_msgs__action__Patrol_Feedback { unsafe { turtlebot3_msgs__action__Patrol_Feedback__create () } } fn destroy_msg (msg : * mut turtlebot3_msgs__action__Patrol_Feedback) -> () { unsafe { turtlebot3_msgs__action__Patrol_Feedback__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Feedback { Feedback { left_time : msg . left_time , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . left_time = self . left_time ; } } impl Default for Feedback { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Feedback > :: new () ; Feedback :: from_native (& msg_native) } } # [allow (non_snake_case)] pub mod SendGoal { use super :: super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__turtlebot3_msgs__action__Patrol_SendGoal () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub goal_id : unique_identifier_msgs :: msg :: UUID , pub goal : turtlebot3_msgs :: action :: Patrol :: Goal } impl WrappedTypesupport for Request { type CStruct = turtlebot3_msgs__action__Patrol_SendGoal_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__turtlebot3_msgs__action__Patrol_SendGoal_Request () } } fn create_msg () -> * mut turtlebot3_msgs__action__Patrol_SendGoal_Request { unsafe { turtlebot3_msgs__action__Patrol_SendGoal_Request__create () } } fn destroy_msg (msg : * mut turtlebot3_msgs__action__Patrol_SendGoal_Request) -> () { unsafe { turtlebot3_msgs__action__Patrol_SendGoal_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { goal_id : unique_identifier_msgs :: msg :: UUID :: from_native (& msg . goal_id) , goal : turtlebot3_msgs :: action :: Patrol :: Goal :: from_native (& msg . goal) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . goal_id . copy_to_native (& mut msg . goal_id) ; self . goal . copy_to_native (& mut msg . goal) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub accepted : bool , pub stamp : builtin_interfaces :: msg :: Time } impl WrappedTypesupport for Response { type CStruct = turtlebot3_msgs__action__Patrol_SendGoal_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__turtlebot3_msgs__action__Patrol_SendGoal_Response () } } fn create_msg () -> * mut turtlebot3_msgs__action__Patrol_SendGoal_Response { unsafe { turtlebot3_msgs__action__Patrol_SendGoal_Response__create () } } fn destroy_msg (msg : * mut turtlebot3_msgs__action__Patrol_SendGoal_Response) -> () { unsafe { turtlebot3_msgs__action__Patrol_SendGoal_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { accepted : msg . accepted , stamp : builtin_interfaces :: msg :: Time :: from_native (& msg . stamp) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . accepted = self . accepted ; self . stamp . copy_to_native (& mut msg . stamp) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetResult { use super :: super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__turtlebot3_msgs__action__Patrol_GetResult () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub goal_id : unique_identifier_msgs :: msg :: UUID } impl WrappedTypesupport for Request { type CStruct = turtlebot3_msgs__action__Patrol_GetResult_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__turtlebot3_msgs__action__Patrol_GetResult_Request () } } fn create_msg () -> * mut turtlebot3_msgs__action__Patrol_GetResult_Request { unsafe { turtlebot3_msgs__action__Patrol_GetResult_Request__create () } } fn destroy_msg (msg : * mut turtlebot3_msgs__action__Patrol_GetResult_Request) -> () { unsafe { turtlebot3_msgs__action__Patrol_GetResult_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { goal_id : unique_identifier_msgs :: msg :: UUID :: from_native (& msg . goal_id) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . goal_id . copy_to_native (& mut msg . goal_id) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub status : i8 , pub result : turtlebot3_msgs :: action :: Patrol :: Result } impl WrappedTypesupport for Response { type CStruct = turtlebot3_msgs__action__Patrol_GetResult_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__turtlebot3_msgs__action__Patrol_GetResult_Response () } } fn create_msg () -> * mut turtlebot3_msgs__action__Patrol_GetResult_Response { unsafe { turtlebot3_msgs__action__Patrol_GetResult_Response__create () } } fn destroy_msg (msg : * mut turtlebot3_msgs__action__Patrol_GetResult_Response) -> () { unsafe { turtlebot3_msgs__action__Patrol_GetResult_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { status : msg . status , result : turtlebot3_msgs :: action :: Patrol :: Result :: from_native (& msg . result) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . status = self . status ; self . result . copy_to_native (& mut msg . result) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct FeedbackMessage { pub goal_id : unique_identifier_msgs :: msg :: UUID , pub feedback : turtlebot3_msgs :: action :: Patrol :: Feedback } impl WrappedTypesupport for FeedbackMessage { type CStruct = turtlebot3_msgs__action__Patrol_FeedbackMessage ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__turtlebot3_msgs__action__Patrol_FeedbackMessage () } } fn create_msg () -> * mut turtlebot3_msgs__action__Patrol_FeedbackMessage { unsafe { turtlebot3_msgs__action__Patrol_FeedbackMessage__create () } } fn destroy_msg (msg : * mut turtlebot3_msgs__action__Patrol_FeedbackMessage) -> () { unsafe { turtlebot3_msgs__action__Patrol_FeedbackMessage__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> FeedbackMessage { FeedbackMessage { goal_id : unique_identifier_msgs :: msg :: UUID :: from_native (& msg . goal_id) , feedback : turtlebot3_msgs :: action :: Patrol :: Feedback :: from_native (& msg . feedback) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . goal_id . copy_to_native (& mut msg . goal_id) ; self . feedback . copy_to_native (& mut msg . feedback) ; } } impl Default for FeedbackMessage { fn default () -> Self { let msg_native = WrappedNativeMsg :: < FeedbackMessage > :: new () ; FeedbackMessage :: from_native (& msg_native) } } } } pub mod msg { use super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct SensorState { pub header : std_msgs :: msg :: Header , pub bumper : u8 , pub cliff : f32 , pub sonar : f32 , pub illumination : f32 , pub led : u8 , pub button : u8 , pub torque : bool , pub left_encoder : i32 , pub right_encoder : i32 , pub battery : f32 } impl WrappedTypesupport for SensorState { type CStruct = turtlebot3_msgs__msg__SensorState ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__turtlebot3_msgs__msg__SensorState () } } fn create_msg () -> * mut turtlebot3_msgs__msg__SensorState { unsafe { turtlebot3_msgs__msg__SensorState__create () } } fn destroy_msg (msg : * mut turtlebot3_msgs__msg__SensorState) -> () { unsafe { turtlebot3_msgs__msg__SensorState__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> SensorState { SensorState { header : std_msgs :: msg :: Header :: from_native (& msg . header) , bumper : msg . bumper , cliff : msg . cliff , sonar : msg . sonar , illumination : msg . illumination , led : msg . led , button : msg . button , torque : msg . torque , left_encoder : msg . left_encoder , right_encoder : msg . right_encoder , battery : msg . battery , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . bumper = self . bumper ; msg . cliff = self . cliff ; msg . sonar = self . sonar ; msg . illumination = self . illumination ; msg . led = self . led ; msg . button = self . button ; msg . torque = self . torque ; msg . left_encoder = self . left_encoder ; msg . right_encoder = self . right_encoder ; msg . battery = self . battery ; } } impl Default for SensorState { fn default () -> Self { let msg_native = WrappedNativeMsg :: < SensorState > :: new () ; SensorState :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl SensorState { pub const BUMPER_BACKWARD : _bindgen_ty_1732 = turtlebot3_msgs__msg__SensorState__BUMPER_BACKWARD ; pub const BUMPER_FORWARD : _bindgen_ty_1731 = turtlebot3_msgs__msg__SensorState__BUMPER_FORWARD ; pub const BUTTON0 : _bindgen_ty_1736 = turtlebot3_msgs__msg__SensorState__BUTTON0 ; pub const BUTTON1 : _bindgen_ty_1737 = turtlebot3_msgs__msg__SensorState__BUTTON1 ; pub const CLIFF : _bindgen_ty_1733 = turtlebot3_msgs__msg__SensorState__CLIFF ; pub const ERROR_LEFT_MOTOR : _bindgen_ty_1738 = turtlebot3_msgs__msg__SensorState__ERROR_LEFT_MOTOR ; pub const ERROR_RIGHT_MOTOR : _bindgen_ty_1739 = turtlebot3_msgs__msg__SensorState__ERROR_RIGHT_MOTOR ; pub const ILLUMINATION : _bindgen_ty_1735 = turtlebot3_msgs__msg__SensorState__ILLUMINATION ; pub const SONAR : _bindgen_ty_1734 = turtlebot3_msgs__msg__SensorState__SONAR ; pub const TORQUE_OFF : _bindgen_ty_1741 = turtlebot3_msgs__msg__SensorState__TORQUE_OFF ; pub const TORQUE_ON : _bindgen_ty_1740 = turtlebot3_msgs__msg__SensorState__TORQUE_ON ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Sound { pub value : u8 } impl WrappedTypesupport for Sound { type CStruct = turtlebot3_msgs__msg__Sound ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__turtlebot3_msgs__msg__Sound () } } fn create_msg () -> * mut turtlebot3_msgs__msg__Sound { unsafe { turtlebot3_msgs__msg__Sound__create () } } fn destroy_msg (msg : * mut turtlebot3_msgs__msg__Sound) -> () { unsafe { turtlebot3_msgs__msg__Sound__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Sound { Sound { value : msg . value , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . value = self . value ; } } impl Default for Sound { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Sound > :: new () ; Sound :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl Sound { pub const BUTTON1 : _bindgen_ty_1746 = turtlebot3_msgs__msg__Sound__BUTTON1 ; pub const BUTTON2 : _bindgen_ty_1747 = turtlebot3_msgs__msg__Sound__BUTTON2 ; pub const ERROR : _bindgen_ty_1745 = turtlebot3_msgs__msg__Sound__ERROR ; pub const LOW_BATTERY : _bindgen_ty_1744 = turtlebot3_msgs__msg__Sound__LOW_BATTERY ; pub const OFF : _bindgen_ty_1742 = turtlebot3_msgs__msg__Sound__OFF ; pub const ON : _bindgen_ty_1743 = turtlebot3_msgs__msg__Sound__ON ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct VersionInfo { pub hardware : std :: string :: String , pub firmware : std :: string :: String , pub software : std :: string :: String } impl WrappedTypesupport for VersionInfo { type CStruct = turtlebot3_msgs__msg__VersionInfo ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__turtlebot3_msgs__msg__VersionInfo () } } fn create_msg () -> * mut turtlebot3_msgs__msg__VersionInfo { unsafe { turtlebot3_msgs__msg__VersionInfo__create () } } fn destroy_msg (msg : * mut turtlebot3_msgs__msg__VersionInfo) -> () { unsafe { turtlebot3_msgs__msg__VersionInfo__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> VersionInfo { VersionInfo { hardware : msg . hardware . to_str () . to_owned () , firmware : msg . firmware . to_str () . to_owned () , software : msg . software . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . hardware . assign (& self . hardware) ; msg . firmware . assign (& self . firmware) ; msg . software . assign (& self . software) ; } } impl Default for VersionInfo { fn default () -> Self { let msg_native = WrappedNativeMsg :: < VersionInfo > :: new () ; VersionInfo :: from_native (& msg_native) } } }