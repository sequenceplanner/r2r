pub mod msg { use super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ArrowMarker { pub pose : geometry_msgs :: msg :: Pose , pub length : f64 , pub shaft_diameter : f64 , pub head_diameter : f64 , pub head_length : f64 , pub color : foxglove_msgs :: msg :: Color } impl WrappedTypesupport for ArrowMarker { type CStruct = foxglove_msgs__msg__ArrowMarker ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__foxglove_msgs__msg__ArrowMarker () } } fn create_msg () -> * mut foxglove_msgs__msg__ArrowMarker { unsafe { foxglove_msgs__msg__ArrowMarker__create () } } fn destroy_msg (msg : * mut foxglove_msgs__msg__ArrowMarker) -> () { unsafe { foxglove_msgs__msg__ArrowMarker__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ArrowMarker { ArrowMarker { pose : geometry_msgs :: msg :: Pose :: from_native (& msg . pose) , length : msg . length , shaft_diameter : msg . shaft_diameter , head_diameter : msg . head_diameter , head_length : msg . head_length , color : foxglove_msgs :: msg :: Color :: from_native (& msg . color) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . pose . copy_to_native (& mut msg . pose) ; msg . length = self . length ; msg . shaft_diameter = self . shaft_diameter ; msg . head_diameter = self . head_diameter ; msg . head_length = self . head_length ; self . color . copy_to_native (& mut msg . color) ; } } impl Default for ArrowMarker { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ArrowMarker > :: new () ; ArrowMarker :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ArrowPrimitive { pub pose : geometry_msgs :: msg :: Pose , pub shaft_length : f64 , pub shaft_diameter : f64 , pub head_length : f64 , pub head_diameter : f64 , pub color : foxglove_msgs :: msg :: Color } impl WrappedTypesupport for ArrowPrimitive { type CStruct = foxglove_msgs__msg__ArrowPrimitive ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__foxglove_msgs__msg__ArrowPrimitive () } } fn create_msg () -> * mut foxglove_msgs__msg__ArrowPrimitive { unsafe { foxglove_msgs__msg__ArrowPrimitive__create () } } fn destroy_msg (msg : * mut foxglove_msgs__msg__ArrowPrimitive) -> () { unsafe { foxglove_msgs__msg__ArrowPrimitive__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ArrowPrimitive { ArrowPrimitive { pose : geometry_msgs :: msg :: Pose :: from_native (& msg . pose) , shaft_length : msg . shaft_length , shaft_diameter : msg . shaft_diameter , head_length : msg . head_length , head_diameter : msg . head_diameter , color : foxglove_msgs :: msg :: Color :: from_native (& msg . color) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . pose . copy_to_native (& mut msg . pose) ; msg . shaft_length = self . shaft_length ; msg . shaft_diameter = self . shaft_diameter ; msg . head_length = self . head_length ; msg . head_diameter = self . head_diameter ; self . color . copy_to_native (& mut msg . color) ; } } impl Default for ArrowPrimitive { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ArrowPrimitive > :: new () ; ArrowPrimitive :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct CameraCalibration { pub timestamp : builtin_interfaces :: msg :: Time , pub frame_id : std :: string :: String , pub width : u32 , pub height : u32 , pub distortion_model : std :: string :: String , pub d : Vec < f64 > , pub k : Vec < f64 > , pub r : Vec < f64 > , pub p : Vec < f64 > } impl WrappedTypesupport for CameraCalibration { type CStruct = foxglove_msgs__msg__CameraCalibration ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__foxglove_msgs__msg__CameraCalibration () } } fn create_msg () -> * mut foxglove_msgs__msg__CameraCalibration { unsafe { foxglove_msgs__msg__CameraCalibration__create () } } fn destroy_msg (msg : * mut foxglove_msgs__msg__CameraCalibration) -> () { unsafe { foxglove_msgs__msg__CameraCalibration__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> CameraCalibration { CameraCalibration { timestamp : builtin_interfaces :: msg :: Time :: from_native (& msg . timestamp) , frame_id : msg . frame_id . to_str () . to_owned () , width : msg . width , height : msg . height , distortion_model : msg . distortion_model . to_str () . to_owned () , d : msg . d . to_vec () , k : msg . k . to_vec () , r : msg . r . to_vec () , p : msg . p . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . timestamp . copy_to_native (& mut msg . timestamp) ; msg . frame_id . assign (& self . frame_id) ; msg . width = self . width ; msg . height = self . height ; msg . distortion_model . assign (& self . distortion_model) ; msg . d . update (& self . d) ; assert_eq ! (self . k . len () , 9usize , "Field {} is fixed size of {}!" , "k" , 9usize) ; msg . k . copy_from_slice (& self . k [.. 9usize]) ; assert_eq ! (self . r . len () , 9usize , "Field {} is fixed size of {}!" , "r" , 9usize) ; msg . r . copy_from_slice (& self . r [.. 9usize]) ; assert_eq ! (self . p . len () , 12usize , "Field {} is fixed size of {}!" , "p" , 12usize) ; msg . p . copy_from_slice (& self . p [.. 12usize]) ; } } impl Default for CameraCalibration { fn default () -> Self { let msg_native = WrappedNativeMsg :: < CameraCalibration > :: new () ; CameraCalibration :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct CircleAnnotation { pub timestamp : builtin_interfaces :: msg :: Time , pub position : foxglove_msgs :: msg :: Point2 , pub diameter : f64 , pub thickness : f64 , pub fill_color : foxglove_msgs :: msg :: Color , pub outline_color : foxglove_msgs :: msg :: Color } impl WrappedTypesupport for CircleAnnotation { type CStruct = foxglove_msgs__msg__CircleAnnotation ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__foxglove_msgs__msg__CircleAnnotation () } } fn create_msg () -> * mut foxglove_msgs__msg__CircleAnnotation { unsafe { foxglove_msgs__msg__CircleAnnotation__create () } } fn destroy_msg (msg : * mut foxglove_msgs__msg__CircleAnnotation) -> () { unsafe { foxglove_msgs__msg__CircleAnnotation__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> CircleAnnotation { CircleAnnotation { timestamp : builtin_interfaces :: msg :: Time :: from_native (& msg . timestamp) , position : foxglove_msgs :: msg :: Point2 :: from_native (& msg . position) , diameter : msg . diameter , thickness : msg . thickness , fill_color : foxglove_msgs :: msg :: Color :: from_native (& msg . fill_color) , outline_color : foxglove_msgs :: msg :: Color :: from_native (& msg . outline_color) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . timestamp . copy_to_native (& mut msg . timestamp) ; self . position . copy_to_native (& mut msg . position) ; msg . diameter = self . diameter ; msg . thickness = self . thickness ; self . fill_color . copy_to_native (& mut msg . fill_color) ; self . outline_color . copy_to_native (& mut msg . outline_color) ; } } impl Default for CircleAnnotation { fn default () -> Self { let msg_native = WrappedNativeMsg :: < CircleAnnotation > :: new () ; CircleAnnotation :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Color { pub r : f64 , pub g : f64 , pub b : f64 , pub a : f64 } impl WrappedTypesupport for Color { type CStruct = foxglove_msgs__msg__Color ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__foxglove_msgs__msg__Color () } } fn create_msg () -> * mut foxglove_msgs__msg__Color { unsafe { foxglove_msgs__msg__Color__create () } } fn destroy_msg (msg : * mut foxglove_msgs__msg__Color) -> () { unsafe { foxglove_msgs__msg__Color__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Color { Color { r : msg . r , g : msg . g , b : msg . b , a : msg . a , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . r = self . r ; msg . g = self . g ; msg . b = self . b ; msg . a = self . a ; } } impl Default for Color { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Color > :: new () ; Color :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct CompressedImage { pub timestamp : builtin_interfaces :: msg :: Time , pub frame_id : std :: string :: String , pub data : Vec < u8 > , pub format : std :: string :: String } impl WrappedTypesupport for CompressedImage { type CStruct = foxglove_msgs__msg__CompressedImage ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__foxglove_msgs__msg__CompressedImage () } } fn create_msg () -> * mut foxglove_msgs__msg__CompressedImage { unsafe { foxglove_msgs__msg__CompressedImage__create () } } fn destroy_msg (msg : * mut foxglove_msgs__msg__CompressedImage) -> () { unsafe { foxglove_msgs__msg__CompressedImage__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> CompressedImage { CompressedImage { timestamp : builtin_interfaces :: msg :: Time :: from_native (& msg . timestamp) , frame_id : msg . frame_id . to_str () . to_owned () , data : msg . data . to_vec () , format : msg . format . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . timestamp . copy_to_native (& mut msg . timestamp) ; msg . frame_id . assign (& self . frame_id) ; msg . data . update (& self . data) ; msg . format . assign (& self . format) ; } } impl Default for CompressedImage { fn default () -> Self { let msg_native = WrappedNativeMsg :: < CompressedImage > :: new () ; CompressedImage :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ConeAttributes { pub pose : geometry_msgs :: msg :: Pose , pub size : geometry_msgs :: msg :: Vector3 , pub bottom_scale : f64 , pub top_scale : f64 , pub color : foxglove_msgs :: msg :: Color } impl WrappedTypesupport for ConeAttributes { type CStruct = foxglove_msgs__msg__ConeAttributes ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__foxglove_msgs__msg__ConeAttributes () } } fn create_msg () -> * mut foxglove_msgs__msg__ConeAttributes { unsafe { foxglove_msgs__msg__ConeAttributes__create () } } fn destroy_msg (msg : * mut foxglove_msgs__msg__ConeAttributes) -> () { unsafe { foxglove_msgs__msg__ConeAttributes__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ConeAttributes { ConeAttributes { pose : geometry_msgs :: msg :: Pose :: from_native (& msg . pose) , size : geometry_msgs :: msg :: Vector3 :: from_native (& msg . size) , bottom_scale : msg . bottom_scale , top_scale : msg . top_scale , color : foxglove_msgs :: msg :: Color :: from_native (& msg . color) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . pose . copy_to_native (& mut msg . pose) ; self . size . copy_to_native (& mut msg . size) ; msg . bottom_scale = self . bottom_scale ; msg . top_scale = self . top_scale ; self . color . copy_to_native (& mut msg . color) ; } } impl Default for ConeAttributes { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ConeAttributes > :: new () ; ConeAttributes :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ConeListMarker { pub timestamp : builtin_interfaces :: msg :: Time , pub frame_id : std :: string :: String , pub id : std :: string :: String , pub lifetime : builtin_interfaces :: msg :: Duration , pub frame_locked : bool , pub metadata : Vec < foxglove_msgs :: msg :: KeyValuePair > , pub attributes : Vec < foxglove_msgs :: msg :: ConeAttributes > } impl WrappedTypesupport for ConeListMarker { type CStruct = foxglove_msgs__msg__ConeListMarker ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__foxglove_msgs__msg__ConeListMarker () } } fn create_msg () -> * mut foxglove_msgs__msg__ConeListMarker { unsafe { foxglove_msgs__msg__ConeListMarker__create () } } fn destroy_msg (msg : * mut foxglove_msgs__msg__ConeListMarker) -> () { unsafe { foxglove_msgs__msg__ConeListMarker__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ConeListMarker { ConeListMarker { timestamp : builtin_interfaces :: msg :: Time :: from_native (& msg . timestamp) , frame_id : msg . frame_id . to_str () . to_owned () , id : msg . id . to_str () . to_owned () , lifetime : builtin_interfaces :: msg :: Duration :: from_native (& msg . lifetime) , frame_locked : msg . frame_locked , metadata : { let mut temp = Vec :: with_capacity (msg . metadata . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . metadata . data , msg . metadata . size) } ; for s in slice { temp . push (foxglove_msgs :: msg :: KeyValuePair :: from_native (s)) ; } temp } , attributes : { let mut temp = Vec :: with_capacity (msg . attributes . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . attributes . data , msg . attributes . size) } ; for s in slice { temp . push (foxglove_msgs :: msg :: ConeAttributes :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . timestamp . copy_to_native (& mut msg . timestamp) ; msg . frame_id . assign (& self . frame_id) ; msg . id . assign (& self . id) ; self . lifetime . copy_to_native (& mut msg . lifetime) ; msg . frame_locked = self . frame_locked ; unsafe { foxglove_msgs__msg__KeyValuePair__Sequence__fini (& mut msg . metadata) ; foxglove_msgs__msg__KeyValuePair__Sequence__init (& mut msg . metadata , self . metadata . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . metadata . data , msg . metadata . size) ; for (t , s) in slice . iter_mut () . zip (& self . metadata) { s . copy_to_native (t) ; } } unsafe { foxglove_msgs__msg__ConeAttributes__Sequence__fini (& mut msg . attributes) ; foxglove_msgs__msg__ConeAttributes__Sequence__init (& mut msg . attributes , self . attributes . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . attributes . data , msg . attributes . size) ; for (t , s) in slice . iter_mut () . zip (& self . attributes) { s . copy_to_native (t) ; } } } } impl Default for ConeListMarker { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ConeListMarker > :: new () ; ConeListMarker :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ConeMarker { pub pose : geometry_msgs :: msg :: Pose , pub size : geometry_msgs :: msg :: Vector3 , pub bottom_scale : f64 , pub top_scale : f64 , pub color : foxglove_msgs :: msg :: Color } impl WrappedTypesupport for ConeMarker { type CStruct = foxglove_msgs__msg__ConeMarker ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__foxglove_msgs__msg__ConeMarker () } } fn create_msg () -> * mut foxglove_msgs__msg__ConeMarker { unsafe { foxglove_msgs__msg__ConeMarker__create () } } fn destroy_msg (msg : * mut foxglove_msgs__msg__ConeMarker) -> () { unsafe { foxglove_msgs__msg__ConeMarker__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ConeMarker { ConeMarker { pose : geometry_msgs :: msg :: Pose :: from_native (& msg . pose) , size : geometry_msgs :: msg :: Vector3 :: from_native (& msg . size) , bottom_scale : msg . bottom_scale , top_scale : msg . top_scale , color : foxglove_msgs :: msg :: Color :: from_native (& msg . color) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . pose . copy_to_native (& mut msg . pose) ; self . size . copy_to_native (& mut msg . size) ; msg . bottom_scale = self . bottom_scale ; msg . top_scale = self . top_scale ; self . color . copy_to_native (& mut msg . color) ; } } impl Default for ConeMarker { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ConeMarker > :: new () ; ConeMarker :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ConePrimitive { pub pose : geometry_msgs :: msg :: Pose , pub size : geometry_msgs :: msg :: Vector3 , pub bottom_scale : f64 , pub top_scale : f64 , pub color : foxglove_msgs :: msg :: Color } impl WrappedTypesupport for ConePrimitive { type CStruct = foxglove_msgs__msg__ConePrimitive ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__foxglove_msgs__msg__ConePrimitive () } } fn create_msg () -> * mut foxglove_msgs__msg__ConePrimitive { unsafe { foxglove_msgs__msg__ConePrimitive__create () } } fn destroy_msg (msg : * mut foxglove_msgs__msg__ConePrimitive) -> () { unsafe { foxglove_msgs__msg__ConePrimitive__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ConePrimitive { ConePrimitive { pose : geometry_msgs :: msg :: Pose :: from_native (& msg . pose) , size : geometry_msgs :: msg :: Vector3 :: from_native (& msg . size) , bottom_scale : msg . bottom_scale , top_scale : msg . top_scale , color : foxglove_msgs :: msg :: Color :: from_native (& msg . color) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . pose . copy_to_native (& mut msg . pose) ; self . size . copy_to_native (& mut msg . size) ; msg . bottom_scale = self . bottom_scale ; msg . top_scale = self . top_scale ; self . color . copy_to_native (& mut msg . color) ; } } impl Default for ConePrimitive { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ConePrimitive > :: new () ; ConePrimitive :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct CubeAttributes { pub pose : geometry_msgs :: msg :: Pose , pub size : geometry_msgs :: msg :: Vector3 , pub color : foxglove_msgs :: msg :: Color } impl WrappedTypesupport for CubeAttributes { type CStruct = foxglove_msgs__msg__CubeAttributes ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__foxglove_msgs__msg__CubeAttributes () } } fn create_msg () -> * mut foxglove_msgs__msg__CubeAttributes { unsafe { foxglove_msgs__msg__CubeAttributes__create () } } fn destroy_msg (msg : * mut foxglove_msgs__msg__CubeAttributes) -> () { unsafe { foxglove_msgs__msg__CubeAttributes__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> CubeAttributes { CubeAttributes { pose : geometry_msgs :: msg :: Pose :: from_native (& msg . pose) , size : geometry_msgs :: msg :: Vector3 :: from_native (& msg . size) , color : foxglove_msgs :: msg :: Color :: from_native (& msg . color) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . pose . copy_to_native (& mut msg . pose) ; self . size . copy_to_native (& mut msg . size) ; self . color . copy_to_native (& mut msg . color) ; } } impl Default for CubeAttributes { fn default () -> Self { let msg_native = WrappedNativeMsg :: < CubeAttributes > :: new () ; CubeAttributes :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct CubeListMarker { pub timestamp : builtin_interfaces :: msg :: Time , pub frame_id : std :: string :: String , pub id : std :: string :: String , pub lifetime : builtin_interfaces :: msg :: Duration , pub frame_locked : bool , pub metadata : Vec < foxglove_msgs :: msg :: KeyValuePair > , pub attributes : Vec < foxglove_msgs :: msg :: CubeAttributes > } impl WrappedTypesupport for CubeListMarker { type CStruct = foxglove_msgs__msg__CubeListMarker ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__foxglove_msgs__msg__CubeListMarker () } } fn create_msg () -> * mut foxglove_msgs__msg__CubeListMarker { unsafe { foxglove_msgs__msg__CubeListMarker__create () } } fn destroy_msg (msg : * mut foxglove_msgs__msg__CubeListMarker) -> () { unsafe { foxglove_msgs__msg__CubeListMarker__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> CubeListMarker { CubeListMarker { timestamp : builtin_interfaces :: msg :: Time :: from_native (& msg . timestamp) , frame_id : msg . frame_id . to_str () . to_owned () , id : msg . id . to_str () . to_owned () , lifetime : builtin_interfaces :: msg :: Duration :: from_native (& msg . lifetime) , frame_locked : msg . frame_locked , metadata : { let mut temp = Vec :: with_capacity (msg . metadata . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . metadata . data , msg . metadata . size) } ; for s in slice { temp . push (foxglove_msgs :: msg :: KeyValuePair :: from_native (s)) ; } temp } , attributes : { let mut temp = Vec :: with_capacity (msg . attributes . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . attributes . data , msg . attributes . size) } ; for s in slice { temp . push (foxglove_msgs :: msg :: CubeAttributes :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . timestamp . copy_to_native (& mut msg . timestamp) ; msg . frame_id . assign (& self . frame_id) ; msg . id . assign (& self . id) ; self . lifetime . copy_to_native (& mut msg . lifetime) ; msg . frame_locked = self . frame_locked ; unsafe { foxglove_msgs__msg__KeyValuePair__Sequence__fini (& mut msg . metadata) ; foxglove_msgs__msg__KeyValuePair__Sequence__init (& mut msg . metadata , self . metadata . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . metadata . data , msg . metadata . size) ; for (t , s) in slice . iter_mut () . zip (& self . metadata) { s . copy_to_native (t) ; } } unsafe { foxglove_msgs__msg__CubeAttributes__Sequence__fini (& mut msg . attributes) ; foxglove_msgs__msg__CubeAttributes__Sequence__init (& mut msg . attributes , self . attributes . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . attributes . data , msg . attributes . size) ; for (t , s) in slice . iter_mut () . zip (& self . attributes) { s . copy_to_native (t) ; } } } } impl Default for CubeListMarker { fn default () -> Self { let msg_native = WrappedNativeMsg :: < CubeListMarker > :: new () ; CubeListMarker :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct CubeMarker { pub pose : geometry_msgs :: msg :: Pose , pub size : geometry_msgs :: msg :: Vector3 , pub color : foxglove_msgs :: msg :: Color } impl WrappedTypesupport for CubeMarker { type CStruct = foxglove_msgs__msg__CubeMarker ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__foxglove_msgs__msg__CubeMarker () } } fn create_msg () -> * mut foxglove_msgs__msg__CubeMarker { unsafe { foxglove_msgs__msg__CubeMarker__create () } } fn destroy_msg (msg : * mut foxglove_msgs__msg__CubeMarker) -> () { unsafe { foxglove_msgs__msg__CubeMarker__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> CubeMarker { CubeMarker { pose : geometry_msgs :: msg :: Pose :: from_native (& msg . pose) , size : geometry_msgs :: msg :: Vector3 :: from_native (& msg . size) , color : foxglove_msgs :: msg :: Color :: from_native (& msg . color) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . pose . copy_to_native (& mut msg . pose) ; self . size . copy_to_native (& mut msg . size) ; self . color . copy_to_native (& mut msg . color) ; } } impl Default for CubeMarker { fn default () -> Self { let msg_native = WrappedNativeMsg :: < CubeMarker > :: new () ; CubeMarker :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct CubePrimitive { pub pose : geometry_msgs :: msg :: Pose , pub size : geometry_msgs :: msg :: Vector3 , pub color : foxglove_msgs :: msg :: Color } impl WrappedTypesupport for CubePrimitive { type CStruct = foxglove_msgs__msg__CubePrimitive ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__foxglove_msgs__msg__CubePrimitive () } } fn create_msg () -> * mut foxglove_msgs__msg__CubePrimitive { unsafe { foxglove_msgs__msg__CubePrimitive__create () } } fn destroy_msg (msg : * mut foxglove_msgs__msg__CubePrimitive) -> () { unsafe { foxglove_msgs__msg__CubePrimitive__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> CubePrimitive { CubePrimitive { pose : geometry_msgs :: msg :: Pose :: from_native (& msg . pose) , size : geometry_msgs :: msg :: Vector3 :: from_native (& msg . size) , color : foxglove_msgs :: msg :: Color :: from_native (& msg . color) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . pose . copy_to_native (& mut msg . pose) ; self . size . copy_to_native (& mut msg . size) ; self . color . copy_to_native (& mut msg . color) ; } } impl Default for CubePrimitive { fn default () -> Self { let msg_native = WrappedNativeMsg :: < CubePrimitive > :: new () ; CubePrimitive :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct CylinderMarker { pub timestamp : builtin_interfaces :: msg :: Time , pub frame_id : std :: string :: String , pub id : std :: string :: String , pub lifetime : builtin_interfaces :: msg :: Duration , pub frame_locked : bool , pub metadata : Vec < foxglove_msgs :: msg :: KeyValuePair > , pub pose : geometry_msgs :: msg :: Pose , pub bottom_radius : f64 , pub top_radius : f64 , pub height : f64 , pub color : foxglove_msgs :: msg :: Color } impl WrappedTypesupport for CylinderMarker { type CStruct = foxglove_msgs__msg__CylinderMarker ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__foxglove_msgs__msg__CylinderMarker () } } fn create_msg () -> * mut foxglove_msgs__msg__CylinderMarker { unsafe { foxglove_msgs__msg__CylinderMarker__create () } } fn destroy_msg (msg : * mut foxglove_msgs__msg__CylinderMarker) -> () { unsafe { foxglove_msgs__msg__CylinderMarker__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> CylinderMarker { CylinderMarker { timestamp : builtin_interfaces :: msg :: Time :: from_native (& msg . timestamp) , frame_id : msg . frame_id . to_str () . to_owned () , id : msg . id . to_str () . to_owned () , lifetime : builtin_interfaces :: msg :: Duration :: from_native (& msg . lifetime) , frame_locked : msg . frame_locked , metadata : { let mut temp = Vec :: with_capacity (msg . metadata . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . metadata . data , msg . metadata . size) } ; for s in slice { temp . push (foxglove_msgs :: msg :: KeyValuePair :: from_native (s)) ; } temp } , pose : geometry_msgs :: msg :: Pose :: from_native (& msg . pose) , bottom_radius : msg . bottom_radius , top_radius : msg . top_radius , height : msg . height , color : foxglove_msgs :: msg :: Color :: from_native (& msg . color) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . timestamp . copy_to_native (& mut msg . timestamp) ; msg . frame_id . assign (& self . frame_id) ; msg . id . assign (& self . id) ; self . lifetime . copy_to_native (& mut msg . lifetime) ; msg . frame_locked = self . frame_locked ; unsafe { foxglove_msgs__msg__KeyValuePair__Sequence__fini (& mut msg . metadata) ; foxglove_msgs__msg__KeyValuePair__Sequence__init (& mut msg . metadata , self . metadata . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . metadata . data , msg . metadata . size) ; for (t , s) in slice . iter_mut () . zip (& self . metadata) { s . copy_to_native (t) ; } } self . pose . copy_to_native (& mut msg . pose) ; msg . bottom_radius = self . bottom_radius ; msg . top_radius = self . top_radius ; msg . height = self . height ; self . color . copy_to_native (& mut msg . color) ; } } impl Default for CylinderMarker { fn default () -> Self { let msg_native = WrappedNativeMsg :: < CylinderMarker > :: new () ; CylinderMarker :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct CylinderPrimitive { pub pose : geometry_msgs :: msg :: Pose , pub size : geometry_msgs :: msg :: Vector3 , pub bottom_scale : f64 , pub top_scale : f64 , pub color : foxglove_msgs :: msg :: Color } impl WrappedTypesupport for CylinderPrimitive { type CStruct = foxglove_msgs__msg__CylinderPrimitive ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__foxglove_msgs__msg__CylinderPrimitive () } } fn create_msg () -> * mut foxglove_msgs__msg__CylinderPrimitive { unsafe { foxglove_msgs__msg__CylinderPrimitive__create () } } fn destroy_msg (msg : * mut foxglove_msgs__msg__CylinderPrimitive) -> () { unsafe { foxglove_msgs__msg__CylinderPrimitive__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> CylinderPrimitive { CylinderPrimitive { pose : geometry_msgs :: msg :: Pose :: from_native (& msg . pose) , size : geometry_msgs :: msg :: Vector3 :: from_native (& msg . size) , bottom_scale : msg . bottom_scale , top_scale : msg . top_scale , color : foxglove_msgs :: msg :: Color :: from_native (& msg . color) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . pose . copy_to_native (& mut msg . pose) ; self . size . copy_to_native (& mut msg . size) ; msg . bottom_scale = self . bottom_scale ; msg . top_scale = self . top_scale ; self . color . copy_to_native (& mut msg . color) ; } } impl Default for CylinderPrimitive { fn default () -> Self { let msg_native = WrappedNativeMsg :: < CylinderPrimitive > :: new () ; CylinderPrimitive :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct FrameTransform { pub timestamp : builtin_interfaces :: msg :: Time , pub parent_frame_id : std :: string :: String , pub child_frame_id : std :: string :: String , pub translation : geometry_msgs :: msg :: Vector3 , pub rotation : geometry_msgs :: msg :: Quaternion } impl WrappedTypesupport for FrameTransform { type CStruct = foxglove_msgs__msg__FrameTransform ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__foxglove_msgs__msg__FrameTransform () } } fn create_msg () -> * mut foxglove_msgs__msg__FrameTransform { unsafe { foxglove_msgs__msg__FrameTransform__create () } } fn destroy_msg (msg : * mut foxglove_msgs__msg__FrameTransform) -> () { unsafe { foxglove_msgs__msg__FrameTransform__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> FrameTransform { FrameTransform { timestamp : builtin_interfaces :: msg :: Time :: from_native (& msg . timestamp) , parent_frame_id : msg . parent_frame_id . to_str () . to_owned () , child_frame_id : msg . child_frame_id . to_str () . to_owned () , translation : geometry_msgs :: msg :: Vector3 :: from_native (& msg . translation) , rotation : geometry_msgs :: msg :: Quaternion :: from_native (& msg . rotation) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . timestamp . copy_to_native (& mut msg . timestamp) ; msg . parent_frame_id . assign (& self . parent_frame_id) ; msg . child_frame_id . assign (& self . child_frame_id) ; self . translation . copy_to_native (& mut msg . translation) ; self . rotation . copy_to_native (& mut msg . rotation) ; } } impl Default for FrameTransform { fn default () -> Self { let msg_native = WrappedNativeMsg :: < FrameTransform > :: new () ; FrameTransform :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct GeoJSON { pub geojson : std :: string :: String } impl WrappedTypesupport for GeoJSON { type CStruct = foxglove_msgs__msg__GeoJSON ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__foxglove_msgs__msg__GeoJSON () } } fn create_msg () -> * mut foxglove_msgs__msg__GeoJSON { unsafe { foxglove_msgs__msg__GeoJSON__create () } } fn destroy_msg (msg : * mut foxglove_msgs__msg__GeoJSON) -> () { unsafe { foxglove_msgs__msg__GeoJSON__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> GeoJSON { GeoJSON { geojson : msg . geojson . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . geojson . assign (& self . geojson) ; } } impl Default for GeoJSON { fn default () -> Self { let msg_native = WrappedNativeMsg :: < GeoJSON > :: new () ; GeoJSON :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Grid { pub timestamp : builtin_interfaces :: msg :: Time , pub frame_id : std :: string :: String , pub pose : geometry_msgs :: msg :: Pose , pub column_count : u32 , pub cell_size : foxglove_msgs :: msg :: Vector2 , pub row_stride : u32 , pub cell_stride : u32 , pub fields : Vec < foxglove_msgs :: msg :: PackedElementField > , pub data : Vec < u8 > } impl WrappedTypesupport for Grid { type CStruct = foxglove_msgs__msg__Grid ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__foxglove_msgs__msg__Grid () } } fn create_msg () -> * mut foxglove_msgs__msg__Grid { unsafe { foxglove_msgs__msg__Grid__create () } } fn destroy_msg (msg : * mut foxglove_msgs__msg__Grid) -> () { unsafe { foxglove_msgs__msg__Grid__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Grid { Grid { timestamp : builtin_interfaces :: msg :: Time :: from_native (& msg . timestamp) , frame_id : msg . frame_id . to_str () . to_owned () , pose : geometry_msgs :: msg :: Pose :: from_native (& msg . pose) , column_count : msg . column_count , cell_size : foxglove_msgs :: msg :: Vector2 :: from_native (& msg . cell_size) , row_stride : msg . row_stride , cell_stride : msg . cell_stride , fields : { let mut temp = Vec :: with_capacity (msg . fields . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . fields . data , msg . fields . size) } ; for s in slice { temp . push (foxglove_msgs :: msg :: PackedElementField :: from_native (s)) ; } temp } , data : msg . data . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . timestamp . copy_to_native (& mut msg . timestamp) ; msg . frame_id . assign (& self . frame_id) ; self . pose . copy_to_native (& mut msg . pose) ; msg . column_count = self . column_count ; self . cell_size . copy_to_native (& mut msg . cell_size) ; msg . row_stride = self . row_stride ; msg . cell_stride = self . cell_stride ; unsafe { foxglove_msgs__msg__PackedElementField__Sequence__fini (& mut msg . fields) ; foxglove_msgs__msg__PackedElementField__Sequence__init (& mut msg . fields , self . fields . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . fields . data , msg . fields . size) ; for (t , s) in slice . iter_mut () . zip (& self . fields) { s . copy_to_native (t) ; } } msg . data . update (& self . data) ; } } impl Default for Grid { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Grid > :: new () ; Grid :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ImageAnnotations { pub circles : Vec < foxglove_msgs :: msg :: CircleAnnotation > , pub points : Vec < foxglove_msgs :: msg :: PointsAnnotation > } impl WrappedTypesupport for ImageAnnotations { type CStruct = foxglove_msgs__msg__ImageAnnotations ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__foxglove_msgs__msg__ImageAnnotations () } } fn create_msg () -> * mut foxglove_msgs__msg__ImageAnnotations { unsafe { foxglove_msgs__msg__ImageAnnotations__create () } } fn destroy_msg (msg : * mut foxglove_msgs__msg__ImageAnnotations) -> () { unsafe { foxglove_msgs__msg__ImageAnnotations__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ImageAnnotations { ImageAnnotations { circles : { let mut temp = Vec :: with_capacity (msg . circles . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . circles . data , msg . circles . size) } ; for s in slice { temp . push (foxglove_msgs :: msg :: CircleAnnotation :: from_native (s)) ; } temp } , points : { let mut temp = Vec :: with_capacity (msg . points . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . points . data , msg . points . size) } ; for s in slice { temp . push (foxglove_msgs :: msg :: PointsAnnotation :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { unsafe { foxglove_msgs__msg__CircleAnnotation__Sequence__fini (& mut msg . circles) ; foxglove_msgs__msg__CircleAnnotation__Sequence__init (& mut msg . circles , self . circles . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . circles . data , msg . circles . size) ; for (t , s) in slice . iter_mut () . zip (& self . circles) { s . copy_to_native (t) ; } } unsafe { foxglove_msgs__msg__PointsAnnotation__Sequence__fini (& mut msg . points) ; foxglove_msgs__msg__PointsAnnotation__Sequence__init (& mut msg . points , self . points . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . points . data , msg . points . size) ; for (t , s) in slice . iter_mut () . zip (& self . points) { s . copy_to_native (t) ; } } } } impl Default for ImageAnnotations { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ImageAnnotations > :: new () ; ImageAnnotations :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ImageMarkerArray { pub markers : Vec < visualization_msgs :: msg :: ImageMarker > } impl WrappedTypesupport for ImageMarkerArray { type CStruct = foxglove_msgs__msg__ImageMarkerArray ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__foxglove_msgs__msg__ImageMarkerArray () } } fn create_msg () -> * mut foxglove_msgs__msg__ImageMarkerArray { unsafe { foxglove_msgs__msg__ImageMarkerArray__create () } } fn destroy_msg (msg : * mut foxglove_msgs__msg__ImageMarkerArray) -> () { unsafe { foxglove_msgs__msg__ImageMarkerArray__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ImageMarkerArray { ImageMarkerArray { markers : { let mut temp = Vec :: with_capacity (msg . markers . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . markers . data , msg . markers . size) } ; for s in slice { temp . push (visualization_msgs :: msg :: ImageMarker :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { unsafe { visualization_msgs__msg__ImageMarker__Sequence__fini (& mut msg . markers) ; visualization_msgs__msg__ImageMarker__Sequence__init (& mut msg . markers , self . markers . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . markers . data , msg . markers . size) ; for (t , s) in slice . iter_mut () . zip (& self . markers) { s . copy_to_native (t) ; } } } } impl Default for ImageMarkerArray { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ImageMarkerArray > :: new () ; ImageMarkerArray :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct KeyValuePair { pub key : std :: string :: String , pub value : std :: string :: String } impl WrappedTypesupport for KeyValuePair { type CStruct = foxglove_msgs__msg__KeyValuePair ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__foxglove_msgs__msg__KeyValuePair () } } fn create_msg () -> * mut foxglove_msgs__msg__KeyValuePair { unsafe { foxglove_msgs__msg__KeyValuePair__create () } } fn destroy_msg (msg : * mut foxglove_msgs__msg__KeyValuePair) -> () { unsafe { foxglove_msgs__msg__KeyValuePair__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> KeyValuePair { KeyValuePair { key : msg . key . to_str () . to_owned () , value : msg . value . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . key . assign (& self . key) ; msg . value . assign (& self . value) ; } } impl Default for KeyValuePair { fn default () -> Self { let msg_native = WrappedNativeMsg :: < KeyValuePair > :: new () ; KeyValuePair :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct LaserScan { pub timestamp : builtin_interfaces :: msg :: Time , pub frame_id : std :: string :: String , pub pose : geometry_msgs :: msg :: Pose , pub start_angle : f64 , pub end_angle : f64 , pub ranges : Vec < f64 > , pub intensities : Vec < f64 > } impl WrappedTypesupport for LaserScan { type CStruct = foxglove_msgs__msg__LaserScan ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__foxglove_msgs__msg__LaserScan () } } fn create_msg () -> * mut foxglove_msgs__msg__LaserScan { unsafe { foxglove_msgs__msg__LaserScan__create () } } fn destroy_msg (msg : * mut foxglove_msgs__msg__LaserScan) -> () { unsafe { foxglove_msgs__msg__LaserScan__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> LaserScan { LaserScan { timestamp : builtin_interfaces :: msg :: Time :: from_native (& msg . timestamp) , frame_id : msg . frame_id . to_str () . to_owned () , pose : geometry_msgs :: msg :: Pose :: from_native (& msg . pose) , start_angle : msg . start_angle , end_angle : msg . end_angle , ranges : msg . ranges . to_vec () , intensities : msg . intensities . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . timestamp . copy_to_native (& mut msg . timestamp) ; msg . frame_id . assign (& self . frame_id) ; self . pose . copy_to_native (& mut msg . pose) ; msg . start_angle = self . start_angle ; msg . end_angle = self . end_angle ; msg . ranges . update (& self . ranges) ; msg . intensities . update (& self . intensities) ; } } impl Default for LaserScan { fn default () -> Self { let msg_native = WrappedNativeMsg :: < LaserScan > :: new () ; LaserScan :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct LineMarker { # [serde (rename = "type")] pub type_ : u8 , pub pose : geometry_msgs :: msg :: Pose , pub thickness : f64 , pub scale_invariant : bool , pub points : Vec < geometry_msgs :: msg :: Point > , pub color : foxglove_msgs :: msg :: Color , pub colors : Vec < foxglove_msgs :: msg :: Color > , pub indices : Vec < u32 > } impl WrappedTypesupport for LineMarker { type CStruct = foxglove_msgs__msg__LineMarker ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__foxglove_msgs__msg__LineMarker () } } fn create_msg () -> * mut foxglove_msgs__msg__LineMarker { unsafe { foxglove_msgs__msg__LineMarker__create () } } fn destroy_msg (msg : * mut foxglove_msgs__msg__LineMarker) -> () { unsafe { foxglove_msgs__msg__LineMarker__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> LineMarker { LineMarker { type_ : msg . type_ , pose : geometry_msgs :: msg :: Pose :: from_native (& msg . pose) , thickness : msg . thickness , scale_invariant : msg . scale_invariant , points : { let mut temp = Vec :: with_capacity (msg . points . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . points . data , msg . points . size) } ; for s in slice { temp . push (geometry_msgs :: msg :: Point :: from_native (s)) ; } temp } , color : foxglove_msgs :: msg :: Color :: from_native (& msg . color) , colors : { let mut temp = Vec :: with_capacity (msg . colors . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . colors . data , msg . colors . size) } ; for s in slice { temp . push (foxglove_msgs :: msg :: Color :: from_native (s)) ; } temp } , indices : msg . indices . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . type_ = self . type_ ; self . pose . copy_to_native (& mut msg . pose) ; msg . thickness = self . thickness ; msg . scale_invariant = self . scale_invariant ; unsafe { geometry_msgs__msg__Point__Sequence__fini (& mut msg . points) ; geometry_msgs__msg__Point__Sequence__init (& mut msg . points , self . points . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . points . data , msg . points . size) ; for (t , s) in slice . iter_mut () . zip (& self . points) { s . copy_to_native (t) ; } } self . color . copy_to_native (& mut msg . color) ; unsafe { foxglove_msgs__msg__Color__Sequence__fini (& mut msg . colors) ; foxglove_msgs__msg__Color__Sequence__init (& mut msg . colors , self . colors . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . colors . data , msg . colors . size) ; for (t , s) in slice . iter_mut () . zip (& self . colors) { s . copy_to_native (t) ; } } msg . indices . update (& self . indices) ; } } impl Default for LineMarker { fn default () -> Self { let msg_native = WrappedNativeMsg :: < LineMarker > :: new () ; LineMarker :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl LineMarker { pub const LINE_LIST : _bindgen_ty_199 = foxglove_msgs__msg__LineMarker__LINE_LIST ; pub const LINE_LOOP : _bindgen_ty_198 = foxglove_msgs__msg__LineMarker__LINE_LOOP ; pub const LINE_STRIP : _bindgen_ty_197 = foxglove_msgs__msg__LineMarker__LINE_STRIP ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct LinePrimitive { # [serde (rename = "type")] pub type_ : u8 , pub pose : geometry_msgs :: msg :: Pose , pub thickness : f64 , pub scale_invariant : bool , pub points : Vec < geometry_msgs :: msg :: Point > , pub color : foxglove_msgs :: msg :: Color , pub colors : Vec < foxglove_msgs :: msg :: Color > , pub indices : Vec < u32 > } impl WrappedTypesupport for LinePrimitive { type CStruct = foxglove_msgs__msg__LinePrimitive ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__foxglove_msgs__msg__LinePrimitive () } } fn create_msg () -> * mut foxglove_msgs__msg__LinePrimitive { unsafe { foxglove_msgs__msg__LinePrimitive__create () } } fn destroy_msg (msg : * mut foxglove_msgs__msg__LinePrimitive) -> () { unsafe { foxglove_msgs__msg__LinePrimitive__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> LinePrimitive { LinePrimitive { type_ : msg . type_ , pose : geometry_msgs :: msg :: Pose :: from_native (& msg . pose) , thickness : msg . thickness , scale_invariant : msg . scale_invariant , points : { let mut temp = Vec :: with_capacity (msg . points . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . points . data , msg . points . size) } ; for s in slice { temp . push (geometry_msgs :: msg :: Point :: from_native (s)) ; } temp } , color : foxglove_msgs :: msg :: Color :: from_native (& msg . color) , colors : { let mut temp = Vec :: with_capacity (msg . colors . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . colors . data , msg . colors . size) } ; for s in slice { temp . push (foxglove_msgs :: msg :: Color :: from_native (s)) ; } temp } , indices : msg . indices . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . type_ = self . type_ ; self . pose . copy_to_native (& mut msg . pose) ; msg . thickness = self . thickness ; msg . scale_invariant = self . scale_invariant ; unsafe { geometry_msgs__msg__Point__Sequence__fini (& mut msg . points) ; geometry_msgs__msg__Point__Sequence__init (& mut msg . points , self . points . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . points . data , msg . points . size) ; for (t , s) in slice . iter_mut () . zip (& self . points) { s . copy_to_native (t) ; } } self . color . copy_to_native (& mut msg . color) ; unsafe { foxglove_msgs__msg__Color__Sequence__fini (& mut msg . colors) ; foxglove_msgs__msg__Color__Sequence__init (& mut msg . colors , self . colors . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . colors . data , msg . colors . size) ; for (t , s) in slice . iter_mut () . zip (& self . colors) { s . copy_to_native (t) ; } } msg . indices . update (& self . indices) ; } } impl Default for LinePrimitive { fn default () -> Self { let msg_native = WrappedNativeMsg :: < LinePrimitive > :: new () ; LinePrimitive :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl LinePrimitive { pub const LINE_LIST : _bindgen_ty_202 = foxglove_msgs__msg__LinePrimitive__LINE_LIST ; pub const LINE_LOOP : _bindgen_ty_201 = foxglove_msgs__msg__LinePrimitive__LINE_LOOP ; pub const LINE_STRIP : _bindgen_ty_200 = foxglove_msgs__msg__LinePrimitive__LINE_STRIP ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct LocationFix { pub latitude : f64 , pub longitude : f64 , pub altitude : f64 , pub position_covariance : Vec < f64 > , pub position_covariance_type : u8 } impl WrappedTypesupport for LocationFix { type CStruct = foxglove_msgs__msg__LocationFix ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__foxglove_msgs__msg__LocationFix () } } fn create_msg () -> * mut foxglove_msgs__msg__LocationFix { unsafe { foxglove_msgs__msg__LocationFix__create () } } fn destroy_msg (msg : * mut foxglove_msgs__msg__LocationFix) -> () { unsafe { foxglove_msgs__msg__LocationFix__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> LocationFix { LocationFix { latitude : msg . latitude , longitude : msg . longitude , altitude : msg . altitude , position_covariance : msg . position_covariance . to_vec () , position_covariance_type : msg . position_covariance_type , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . latitude = self . latitude ; msg . longitude = self . longitude ; msg . altitude = self . altitude ; assert_eq ! (self . position_covariance . len () , 9usize , "Field {} is fixed size of {}!" , "position_covariance" , 9usize) ; msg . position_covariance . copy_from_slice (& self . position_covariance [.. 9usize]) ; msg . position_covariance_type = self . position_covariance_type ; } } impl Default for LocationFix { fn default () -> Self { let msg_native = WrappedNativeMsg :: < LocationFix > :: new () ; LocationFix :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl LocationFix { pub const APPROXIMATED : _bindgen_ty_204 = foxglove_msgs__msg__LocationFix__APPROXIMATED ; pub const DIAGONAL_KNOWN : _bindgen_ty_205 = foxglove_msgs__msg__LocationFix__DIAGONAL_KNOWN ; pub const KNOWN : _bindgen_ty_206 = foxglove_msgs__msg__LocationFix__KNOWN ; pub const UNKNOWN : _bindgen_ty_203 = foxglove_msgs__msg__LocationFix__UNKNOWN ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Log { pub timestamp : builtin_interfaces :: msg :: Time , pub level : u8 , pub message : std :: string :: String , pub name : std :: string :: String , pub file : std :: string :: String , pub line : u32 } impl WrappedTypesupport for Log { type CStruct = foxglove_msgs__msg__Log ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__foxglove_msgs__msg__Log () } } fn create_msg () -> * mut foxglove_msgs__msg__Log { unsafe { foxglove_msgs__msg__Log__create () } } fn destroy_msg (msg : * mut foxglove_msgs__msg__Log) -> () { unsafe { foxglove_msgs__msg__Log__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Log { Log { timestamp : builtin_interfaces :: msg :: Time :: from_native (& msg . timestamp) , level : msg . level , message : msg . message . to_str () . to_owned () , name : msg . name . to_str () . to_owned () , file : msg . file . to_str () . to_owned () , line : msg . line , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . timestamp . copy_to_native (& mut msg . timestamp) ; msg . level = self . level ; msg . message . assign (& self . message) ; msg . name . assign (& self . name) ; msg . file . assign (& self . file) ; msg . line = self . line ; } } impl Default for Log { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Log > :: new () ; Log :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl Log { pub const DEBUG : _bindgen_ty_208 = foxglove_msgs__msg__Log__DEBUG ; pub const ERROR : _bindgen_ty_211 = foxglove_msgs__msg__Log__ERROR ; pub const FATAL : _bindgen_ty_212 = foxglove_msgs__msg__Log__FATAL ; pub const INFO : _bindgen_ty_209 = foxglove_msgs__msg__Log__INFO ; pub const UNKNOWN : _bindgen_ty_207 = foxglove_msgs__msg__Log__UNKNOWN ; pub const WARNING : _bindgen_ty_210 = foxglove_msgs__msg__Log__WARNING ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct MarkerDeletion { pub timestamp : builtin_interfaces :: msg :: Time , # [serde (rename = "type")] pub type_ : u8 , pub id : std :: string :: String } impl WrappedTypesupport for MarkerDeletion { type CStruct = foxglove_msgs__msg__MarkerDeletion ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__foxglove_msgs__msg__MarkerDeletion () } } fn create_msg () -> * mut foxglove_msgs__msg__MarkerDeletion { unsafe { foxglove_msgs__msg__MarkerDeletion__create () } } fn destroy_msg (msg : * mut foxglove_msgs__msg__MarkerDeletion) -> () { unsafe { foxglove_msgs__msg__MarkerDeletion__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> MarkerDeletion { MarkerDeletion { timestamp : builtin_interfaces :: msg :: Time :: from_native (& msg . timestamp) , type_ : msg . type_ , id : msg . id . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . timestamp . copy_to_native (& mut msg . timestamp) ; msg . type_ = self . type_ ; msg . id . assign (& self . id) ; } } impl Default for MarkerDeletion { fn default () -> Self { let msg_native = WrappedNativeMsg :: < MarkerDeletion > :: new () ; MarkerDeletion :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl MarkerDeletion { pub const ALL : _bindgen_ty_214 = foxglove_msgs__msg__MarkerDeletion__ALL ; pub const MATCHING_ID : _bindgen_ty_213 = foxglove_msgs__msg__MarkerDeletion__MATCHING_ID ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Markers { pub deletions : Vec < foxglove_msgs :: msg :: MarkerDeletion > , pub arrows : Vec < foxglove_msgs :: msg :: ArrowMarker > , pub cubes : Vec < foxglove_msgs :: msg :: CubeListMarker > , pub spheres : Vec < foxglove_msgs :: msg :: SphereListMarker > , pub cones : Vec < foxglove_msgs :: msg :: ConeListMarker > , pub lines : Vec < foxglove_msgs :: msg :: LineMarker > , pub triangles : Vec < foxglove_msgs :: msg :: TriangleListMarker > , pub texts : Vec < foxglove_msgs :: msg :: TextMarker > , pub models : Vec < foxglove_msgs :: msg :: ModelMarker > } impl WrappedTypesupport for Markers { type CStruct = foxglove_msgs__msg__Markers ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__foxglove_msgs__msg__Markers () } } fn create_msg () -> * mut foxglove_msgs__msg__Markers { unsafe { foxglove_msgs__msg__Markers__create () } } fn destroy_msg (msg : * mut foxglove_msgs__msg__Markers) -> () { unsafe { foxglove_msgs__msg__Markers__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Markers { Markers { deletions : { let mut temp = Vec :: with_capacity (msg . deletions . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . deletions . data , msg . deletions . size) } ; for s in slice { temp . push (foxglove_msgs :: msg :: MarkerDeletion :: from_native (s)) ; } temp } , arrows : { let mut temp = Vec :: with_capacity (msg . arrows . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . arrows . data , msg . arrows . size) } ; for s in slice { temp . push (foxglove_msgs :: msg :: ArrowMarker :: from_native (s)) ; } temp } , cubes : { let mut temp = Vec :: with_capacity (msg . cubes . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . cubes . data , msg . cubes . size) } ; for s in slice { temp . push (foxglove_msgs :: msg :: CubeListMarker :: from_native (s)) ; } temp } , spheres : { let mut temp = Vec :: with_capacity (msg . spheres . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . spheres . data , msg . spheres . size) } ; for s in slice { temp . push (foxglove_msgs :: msg :: SphereListMarker :: from_native (s)) ; } temp } , cones : { let mut temp = Vec :: with_capacity (msg . cones . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . cones . data , msg . cones . size) } ; for s in slice { temp . push (foxglove_msgs :: msg :: ConeListMarker :: from_native (s)) ; } temp } , lines : { let mut temp = Vec :: with_capacity (msg . lines . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . lines . data , msg . lines . size) } ; for s in slice { temp . push (foxglove_msgs :: msg :: LineMarker :: from_native (s)) ; } temp } , triangles : { let mut temp = Vec :: with_capacity (msg . triangles . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . triangles . data , msg . triangles . size) } ; for s in slice { temp . push (foxglove_msgs :: msg :: TriangleListMarker :: from_native (s)) ; } temp } , texts : { let mut temp = Vec :: with_capacity (msg . texts . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . texts . data , msg . texts . size) } ; for s in slice { temp . push (foxglove_msgs :: msg :: TextMarker :: from_native (s)) ; } temp } , models : { let mut temp = Vec :: with_capacity (msg . models . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . models . data , msg . models . size) } ; for s in slice { temp . push (foxglove_msgs :: msg :: ModelMarker :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { unsafe { foxglove_msgs__msg__MarkerDeletion__Sequence__fini (& mut msg . deletions) ; foxglove_msgs__msg__MarkerDeletion__Sequence__init (& mut msg . deletions , self . deletions . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . deletions . data , msg . deletions . size) ; for (t , s) in slice . iter_mut () . zip (& self . deletions) { s . copy_to_native (t) ; } } unsafe { foxglove_msgs__msg__ArrowMarker__Sequence__fini (& mut msg . arrows) ; foxglove_msgs__msg__ArrowMarker__Sequence__init (& mut msg . arrows , self . arrows . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . arrows . data , msg . arrows . size) ; for (t , s) in slice . iter_mut () . zip (& self . arrows) { s . copy_to_native (t) ; } } unsafe { foxglove_msgs__msg__CubeListMarker__Sequence__fini (& mut msg . cubes) ; foxglove_msgs__msg__CubeListMarker__Sequence__init (& mut msg . cubes , self . cubes . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . cubes . data , msg . cubes . size) ; for (t , s) in slice . iter_mut () . zip (& self . cubes) { s . copy_to_native (t) ; } } unsafe { foxglove_msgs__msg__SphereListMarker__Sequence__fini (& mut msg . spheres) ; foxglove_msgs__msg__SphereListMarker__Sequence__init (& mut msg . spheres , self . spheres . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . spheres . data , msg . spheres . size) ; for (t , s) in slice . iter_mut () . zip (& self . spheres) { s . copy_to_native (t) ; } } unsafe { foxglove_msgs__msg__ConeListMarker__Sequence__fini (& mut msg . cones) ; foxglove_msgs__msg__ConeListMarker__Sequence__init (& mut msg . cones , self . cones . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . cones . data , msg . cones . size) ; for (t , s) in slice . iter_mut () . zip (& self . cones) { s . copy_to_native (t) ; } } unsafe { foxglove_msgs__msg__LineMarker__Sequence__fini (& mut msg . lines) ; foxglove_msgs__msg__LineMarker__Sequence__init (& mut msg . lines , self . lines . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . lines . data , msg . lines . size) ; for (t , s) in slice . iter_mut () . zip (& self . lines) { s . copy_to_native (t) ; } } unsafe { foxglove_msgs__msg__TriangleListMarker__Sequence__fini (& mut msg . triangles) ; foxglove_msgs__msg__TriangleListMarker__Sequence__init (& mut msg . triangles , self . triangles . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . triangles . data , msg . triangles . size) ; for (t , s) in slice . iter_mut () . zip (& self . triangles) { s . copy_to_native (t) ; } } unsafe { foxglove_msgs__msg__TextMarker__Sequence__fini (& mut msg . texts) ; foxglove_msgs__msg__TextMarker__Sequence__init (& mut msg . texts , self . texts . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . texts . data , msg . texts . size) ; for (t , s) in slice . iter_mut () . zip (& self . texts) { s . copy_to_native (t) ; } } unsafe { foxglove_msgs__msg__ModelMarker__Sequence__fini (& mut msg . models) ; foxglove_msgs__msg__ModelMarker__Sequence__init (& mut msg . models , self . models . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . models . data , msg . models . size) ; for (t , s) in slice . iter_mut () . zip (& self . models) { s . copy_to_native (t) ; } } } } impl Default for Markers { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Markers > :: new () ; Markers :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ModelMarker { pub pose : geometry_msgs :: msg :: Pose , pub scale : geometry_msgs :: msg :: Vector3 , pub color : foxglove_msgs :: msg :: Color , pub use_embedded_materials : bool , pub url : std :: string :: String , pub mime_type : std :: string :: String , pub data : Vec < u8 > } impl WrappedTypesupport for ModelMarker { type CStruct = foxglove_msgs__msg__ModelMarker ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__foxglove_msgs__msg__ModelMarker () } } fn create_msg () -> * mut foxglove_msgs__msg__ModelMarker { unsafe { foxglove_msgs__msg__ModelMarker__create () } } fn destroy_msg (msg : * mut foxglove_msgs__msg__ModelMarker) -> () { unsafe { foxglove_msgs__msg__ModelMarker__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ModelMarker { ModelMarker { pose : geometry_msgs :: msg :: Pose :: from_native (& msg . pose) , scale : geometry_msgs :: msg :: Vector3 :: from_native (& msg . scale) , color : foxglove_msgs :: msg :: Color :: from_native (& msg . color) , use_embedded_materials : msg . use_embedded_materials , url : msg . url . to_str () . to_owned () , mime_type : msg . mime_type . to_str () . to_owned () , data : msg . data . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . pose . copy_to_native (& mut msg . pose) ; self . scale . copy_to_native (& mut msg . scale) ; self . color . copy_to_native (& mut msg . color) ; msg . use_embedded_materials = self . use_embedded_materials ; msg . url . assign (& self . url) ; msg . mime_type . assign (& self . mime_type) ; msg . data . update (& self . data) ; } } impl Default for ModelMarker { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ModelMarker > :: new () ; ModelMarker :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ModelPrimitive { pub pose : geometry_msgs :: msg :: Pose , pub scale : geometry_msgs :: msg :: Vector3 , pub color : foxglove_msgs :: msg :: Color , pub override_color : bool , pub url : std :: string :: String , pub media_type : std :: string :: String , pub data : Vec < u8 > } impl WrappedTypesupport for ModelPrimitive { type CStruct = foxglove_msgs__msg__ModelPrimitive ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__foxglove_msgs__msg__ModelPrimitive () } } fn create_msg () -> * mut foxglove_msgs__msg__ModelPrimitive { unsafe { foxglove_msgs__msg__ModelPrimitive__create () } } fn destroy_msg (msg : * mut foxglove_msgs__msg__ModelPrimitive) -> () { unsafe { foxglove_msgs__msg__ModelPrimitive__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ModelPrimitive { ModelPrimitive { pose : geometry_msgs :: msg :: Pose :: from_native (& msg . pose) , scale : geometry_msgs :: msg :: Vector3 :: from_native (& msg . scale) , color : foxglove_msgs :: msg :: Color :: from_native (& msg . color) , override_color : msg . override_color , url : msg . url . to_str () . to_owned () , media_type : msg . media_type . to_str () . to_owned () , data : msg . data . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . pose . copy_to_native (& mut msg . pose) ; self . scale . copy_to_native (& mut msg . scale) ; self . color . copy_to_native (& mut msg . color) ; msg . override_color = self . override_color ; msg . url . assign (& self . url) ; msg . media_type . assign (& self . media_type) ; msg . data . update (& self . data) ; } } impl Default for ModelPrimitive { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ModelPrimitive > :: new () ; ModelPrimitive :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct PackedElementField { pub name : std :: string :: String , pub offset : u32 , # [serde (rename = "type")] pub type_ : u8 } impl WrappedTypesupport for PackedElementField { type CStruct = foxglove_msgs__msg__PackedElementField ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__foxglove_msgs__msg__PackedElementField () } } fn create_msg () -> * mut foxglove_msgs__msg__PackedElementField { unsafe { foxglove_msgs__msg__PackedElementField__create () } } fn destroy_msg (msg : * mut foxglove_msgs__msg__PackedElementField) -> () { unsafe { foxglove_msgs__msg__PackedElementField__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> PackedElementField { PackedElementField { name : msg . name . to_str () . to_owned () , offset : msg . offset , type_ : msg . type_ , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . name . assign (& self . name) ; msg . offset = self . offset ; msg . type_ = self . type_ ; } } impl Default for PackedElementField { fn default () -> Self { let msg_native = WrappedNativeMsg :: < PackedElementField > :: new () ; PackedElementField :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl PackedElementField { pub const FLOAT32 : _bindgen_ty_183 = foxglove_msgs__msg__PackedElementField__FLOAT32 ; pub const FLOAT64 : _bindgen_ty_184 = foxglove_msgs__msg__PackedElementField__FLOAT64 ; pub const INT16 : _bindgen_ty_180 = foxglove_msgs__msg__PackedElementField__INT16 ; pub const INT32 : _bindgen_ty_182 = foxglove_msgs__msg__PackedElementField__INT32 ; pub const INT8 : _bindgen_ty_178 = foxglove_msgs__msg__PackedElementField__INT8 ; pub const UINT16 : _bindgen_ty_179 = foxglove_msgs__msg__PackedElementField__UINT16 ; pub const UINT32 : _bindgen_ty_181 = foxglove_msgs__msg__PackedElementField__UINT32 ; pub const UINT8 : _bindgen_ty_177 = foxglove_msgs__msg__PackedElementField__UINT8 ; pub const UNKNOWN : _bindgen_ty_176 = foxglove_msgs__msg__PackedElementField__UNKNOWN ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Point2 { pub x : f64 , pub y : f64 } impl WrappedTypesupport for Point2 { type CStruct = foxglove_msgs__msg__Point2 ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__foxglove_msgs__msg__Point2 () } } fn create_msg () -> * mut foxglove_msgs__msg__Point2 { unsafe { foxglove_msgs__msg__Point2__create () } } fn destroy_msg (msg : * mut foxglove_msgs__msg__Point2) -> () { unsafe { foxglove_msgs__msg__Point2__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Point2 { Point2 { x : msg . x , y : msg . y , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . x = self . x ; msg . y = self . y ; } } impl Default for Point2 { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Point2 > :: new () ; Point2 :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct PointCloud { pub timestamp : builtin_interfaces :: msg :: Time , pub frame_id : std :: string :: String , pub pose : geometry_msgs :: msg :: Pose , pub point_stride : u32 , pub fields : Vec < foxglove_msgs :: msg :: PackedElementField > , pub data : Vec < u8 > } impl WrappedTypesupport for PointCloud { type CStruct = foxglove_msgs__msg__PointCloud ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__foxglove_msgs__msg__PointCloud () } } fn create_msg () -> * mut foxglove_msgs__msg__PointCloud { unsafe { foxglove_msgs__msg__PointCloud__create () } } fn destroy_msg (msg : * mut foxglove_msgs__msg__PointCloud) -> () { unsafe { foxglove_msgs__msg__PointCloud__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> PointCloud { PointCloud { timestamp : builtin_interfaces :: msg :: Time :: from_native (& msg . timestamp) , frame_id : msg . frame_id . to_str () . to_owned () , pose : geometry_msgs :: msg :: Pose :: from_native (& msg . pose) , point_stride : msg . point_stride , fields : { let mut temp = Vec :: with_capacity (msg . fields . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . fields . data , msg . fields . size) } ; for s in slice { temp . push (foxglove_msgs :: msg :: PackedElementField :: from_native (s)) ; } temp } , data : msg . data . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . timestamp . copy_to_native (& mut msg . timestamp) ; msg . frame_id . assign (& self . frame_id) ; self . pose . copy_to_native (& mut msg . pose) ; msg . point_stride = self . point_stride ; unsafe { foxglove_msgs__msg__PackedElementField__Sequence__fini (& mut msg . fields) ; foxglove_msgs__msg__PackedElementField__Sequence__init (& mut msg . fields , self . fields . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . fields . data , msg . fields . size) ; for (t , s) in slice . iter_mut () . zip (& self . fields) { s . copy_to_native (t) ; } } msg . data . update (& self . data) ; } } impl Default for PointCloud { fn default () -> Self { let msg_native = WrappedNativeMsg :: < PointCloud > :: new () ; PointCloud :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct PointsAnnotation { pub timestamp : builtin_interfaces :: msg :: Time , # [serde (rename = "type")] pub type_ : u8 , pub points : Vec < foxglove_msgs :: msg :: Point2 > , pub outline_color : foxglove_msgs :: msg :: Color , pub outline_colors : Vec < foxglove_msgs :: msg :: Color > , pub fill_color : foxglove_msgs :: msg :: Color , pub thickness : f64 } impl WrappedTypesupport for PointsAnnotation { type CStruct = foxglove_msgs__msg__PointsAnnotation ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__foxglove_msgs__msg__PointsAnnotation () } } fn create_msg () -> * mut foxglove_msgs__msg__PointsAnnotation { unsafe { foxglove_msgs__msg__PointsAnnotation__create () } } fn destroy_msg (msg : * mut foxglove_msgs__msg__PointsAnnotation) -> () { unsafe { foxglove_msgs__msg__PointsAnnotation__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> PointsAnnotation { PointsAnnotation { timestamp : builtin_interfaces :: msg :: Time :: from_native (& msg . timestamp) , type_ : msg . type_ , points : { let mut temp = Vec :: with_capacity (msg . points . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . points . data , msg . points . size) } ; for s in slice { temp . push (foxglove_msgs :: msg :: Point2 :: from_native (s)) ; } temp } , outline_color : foxglove_msgs :: msg :: Color :: from_native (& msg . outline_color) , outline_colors : { let mut temp = Vec :: with_capacity (msg . outline_colors . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . outline_colors . data , msg . outline_colors . size) } ; for s in slice { temp . push (foxglove_msgs :: msg :: Color :: from_native (s)) ; } temp } , fill_color : foxglove_msgs :: msg :: Color :: from_native (& msg . fill_color) , thickness : msg . thickness , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . timestamp . copy_to_native (& mut msg . timestamp) ; msg . type_ = self . type_ ; unsafe { foxglove_msgs__msg__Point2__Sequence__fini (& mut msg . points) ; foxglove_msgs__msg__Point2__Sequence__init (& mut msg . points , self . points . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . points . data , msg . points . size) ; for (t , s) in slice . iter_mut () . zip (& self . points) { s . copy_to_native (t) ; } } self . outline_color . copy_to_native (& mut msg . outline_color) ; unsafe { foxglove_msgs__msg__Color__Sequence__fini (& mut msg . outline_colors) ; foxglove_msgs__msg__Color__Sequence__init (& mut msg . outline_colors , self . outline_colors . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . outline_colors . data , msg . outline_colors . size) ; for (t , s) in slice . iter_mut () . zip (& self . outline_colors) { s . copy_to_native (t) ; } } self . fill_color . copy_to_native (& mut msg . fill_color) ; msg . thickness = self . thickness ; } } impl Default for PointsAnnotation { fn default () -> Self { let msg_native = WrappedNativeMsg :: < PointsAnnotation > :: new () ; PointsAnnotation :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl PointsAnnotation { pub const LINE_LIST : _bindgen_ty_189 = foxglove_msgs__msg__PointsAnnotation__LINE_LIST ; pub const LINE_LOOP : _bindgen_ty_187 = foxglove_msgs__msg__PointsAnnotation__LINE_LOOP ; pub const LINE_STRIP : _bindgen_ty_188 = foxglove_msgs__msg__PointsAnnotation__LINE_STRIP ; pub const POINTS : _bindgen_ty_186 = foxglove_msgs__msg__PointsAnnotation__POINTS ; pub const UNKNOWN : _bindgen_ty_185 = foxglove_msgs__msg__PointsAnnotation__UNKNOWN ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct PoseInFrame { pub timestamp : builtin_interfaces :: msg :: Time , pub frame_id : std :: string :: String , pub pose : geometry_msgs :: msg :: Pose } impl WrappedTypesupport for PoseInFrame { type CStruct = foxglove_msgs__msg__PoseInFrame ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__foxglove_msgs__msg__PoseInFrame () } } fn create_msg () -> * mut foxglove_msgs__msg__PoseInFrame { unsafe { foxglove_msgs__msg__PoseInFrame__create () } } fn destroy_msg (msg : * mut foxglove_msgs__msg__PoseInFrame) -> () { unsafe { foxglove_msgs__msg__PoseInFrame__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> PoseInFrame { PoseInFrame { timestamp : builtin_interfaces :: msg :: Time :: from_native (& msg . timestamp) , frame_id : msg . frame_id . to_str () . to_owned () , pose : geometry_msgs :: msg :: Pose :: from_native (& msg . pose) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . timestamp . copy_to_native (& mut msg . timestamp) ; msg . frame_id . assign (& self . frame_id) ; self . pose . copy_to_native (& mut msg . pose) ; } } impl Default for PoseInFrame { fn default () -> Self { let msg_native = WrappedNativeMsg :: < PoseInFrame > :: new () ; PoseInFrame :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct PosesInFrame { pub timestamp : builtin_interfaces :: msg :: Time , pub frame_id : std :: string :: String , pub poses : Vec < geometry_msgs :: msg :: Pose > } impl WrappedTypesupport for PosesInFrame { type CStruct = foxglove_msgs__msg__PosesInFrame ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__foxglove_msgs__msg__PosesInFrame () } } fn create_msg () -> * mut foxglove_msgs__msg__PosesInFrame { unsafe { foxglove_msgs__msg__PosesInFrame__create () } } fn destroy_msg (msg : * mut foxglove_msgs__msg__PosesInFrame) -> () { unsafe { foxglove_msgs__msg__PosesInFrame__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> PosesInFrame { PosesInFrame { timestamp : builtin_interfaces :: msg :: Time :: from_native (& msg . timestamp) , frame_id : msg . frame_id . to_str () . to_owned () , poses : { let mut temp = Vec :: with_capacity (msg . poses . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . poses . data , msg . poses . size) } ; for s in slice { temp . push (geometry_msgs :: msg :: Pose :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . timestamp . copy_to_native (& mut msg . timestamp) ; msg . frame_id . assign (& self . frame_id) ; unsafe { geometry_msgs__msg__Pose__Sequence__fini (& mut msg . poses) ; geometry_msgs__msg__Pose__Sequence__init (& mut msg . poses , self . poses . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . poses . data , msg . poses . size) ; for (t , s) in slice . iter_mut () . zip (& self . poses) { s . copy_to_native (t) ; } } } } impl Default for PosesInFrame { fn default () -> Self { let msg_native = WrappedNativeMsg :: < PosesInFrame > :: new () ; PosesInFrame :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct PrimitiveDeletion { pub timestamp : builtin_interfaces :: msg :: Time , # [serde (rename = "type")] pub type_ : u8 , pub id : std :: string :: String } impl WrappedTypesupport for PrimitiveDeletion { type CStruct = foxglove_msgs__msg__PrimitiveDeletion ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__foxglove_msgs__msg__PrimitiveDeletion () } } fn create_msg () -> * mut foxglove_msgs__msg__PrimitiveDeletion { unsafe { foxglove_msgs__msg__PrimitiveDeletion__create () } } fn destroy_msg (msg : * mut foxglove_msgs__msg__PrimitiveDeletion) -> () { unsafe { foxglove_msgs__msg__PrimitiveDeletion__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> PrimitiveDeletion { PrimitiveDeletion { timestamp : builtin_interfaces :: msg :: Time :: from_native (& msg . timestamp) , type_ : msg . type_ , id : msg . id . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . timestamp . copy_to_native (& mut msg . timestamp) ; msg . type_ = self . type_ ; msg . id . assign (& self . id) ; } } impl Default for PrimitiveDeletion { fn default () -> Self { let msg_native = WrappedNativeMsg :: < PrimitiveDeletion > :: new () ; PrimitiveDeletion :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl PrimitiveDeletion { pub const ALL : _bindgen_ty_216 = foxglove_msgs__msg__PrimitiveDeletion__ALL ; pub const MATCHING_ID : _bindgen_ty_215 = foxglove_msgs__msg__PrimitiveDeletion__MATCHING_ID ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct RawImage { pub timestamp : builtin_interfaces :: msg :: Time , pub frame_id : std :: string :: String , pub width : u32 , pub height : u32 , pub encoding : std :: string :: String , pub step : u32 , pub data : Vec < u8 > } impl WrappedTypesupport for RawImage { type CStruct = foxglove_msgs__msg__RawImage ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__foxglove_msgs__msg__RawImage () } } fn create_msg () -> * mut foxglove_msgs__msg__RawImage { unsafe { foxglove_msgs__msg__RawImage__create () } } fn destroy_msg (msg : * mut foxglove_msgs__msg__RawImage) -> () { unsafe { foxglove_msgs__msg__RawImage__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> RawImage { RawImage { timestamp : builtin_interfaces :: msg :: Time :: from_native (& msg . timestamp) , frame_id : msg . frame_id . to_str () . to_owned () , width : msg . width , height : msg . height , encoding : msg . encoding . to_str () . to_owned () , step : msg . step , data : msg . data . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . timestamp . copy_to_native (& mut msg . timestamp) ; msg . frame_id . assign (& self . frame_id) ; msg . width = self . width ; msg . height = self . height ; msg . encoding . assign (& self . encoding) ; msg . step = self . step ; msg . data . update (& self . data) ; } } impl Default for RawImage { fn default () -> Self { let msg_native = WrappedNativeMsg :: < RawImage > :: new () ; RawImage :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct SceneEntities { pub deletions : Vec < foxglove_msgs :: msg :: SceneEntityDeletion > , pub entities : Vec < foxglove_msgs :: msg :: SceneEntity > } impl WrappedTypesupport for SceneEntities { type CStruct = foxglove_msgs__msg__SceneEntities ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__foxglove_msgs__msg__SceneEntities () } } fn create_msg () -> * mut foxglove_msgs__msg__SceneEntities { unsafe { foxglove_msgs__msg__SceneEntities__create () } } fn destroy_msg (msg : * mut foxglove_msgs__msg__SceneEntities) -> () { unsafe { foxglove_msgs__msg__SceneEntities__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> SceneEntities { SceneEntities { deletions : { let mut temp = Vec :: with_capacity (msg . deletions . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . deletions . data , msg . deletions . size) } ; for s in slice { temp . push (foxglove_msgs :: msg :: SceneEntityDeletion :: from_native (s)) ; } temp } , entities : { let mut temp = Vec :: with_capacity (msg . entities . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . entities . data , msg . entities . size) } ; for s in slice { temp . push (foxglove_msgs :: msg :: SceneEntity :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { unsafe { foxglove_msgs__msg__SceneEntityDeletion__Sequence__fini (& mut msg . deletions) ; foxglove_msgs__msg__SceneEntityDeletion__Sequence__init (& mut msg . deletions , self . deletions . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . deletions . data , msg . deletions . size) ; for (t , s) in slice . iter_mut () . zip (& self . deletions) { s . copy_to_native (t) ; } } unsafe { foxglove_msgs__msg__SceneEntity__Sequence__fini (& mut msg . entities) ; foxglove_msgs__msg__SceneEntity__Sequence__init (& mut msg . entities , self . entities . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . entities . data , msg . entities . size) ; for (t , s) in slice . iter_mut () . zip (& self . entities) { s . copy_to_native (t) ; } } } } impl Default for SceneEntities { fn default () -> Self { let msg_native = WrappedNativeMsg :: < SceneEntities > :: new () ; SceneEntities :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct SceneEntity { pub timestamp : builtin_interfaces :: msg :: Time , pub frame_id : std :: string :: String , pub id : std :: string :: String , pub lifetime : builtin_interfaces :: msg :: Duration , pub frame_locked : bool , pub metadata : Vec < foxglove_msgs :: msg :: KeyValuePair > , pub arrows : Vec < foxglove_msgs :: msg :: ArrowPrimitive > , pub cubes : Vec < foxglove_msgs :: msg :: CubePrimitive > , pub spheres : Vec < foxglove_msgs :: msg :: SpherePrimitive > , pub cylinders : Vec < foxglove_msgs :: msg :: CylinderPrimitive > , pub lines : Vec < foxglove_msgs :: msg :: LinePrimitive > , pub triangles : Vec < foxglove_msgs :: msg :: TriangleListPrimitive > , pub texts : Vec < foxglove_msgs :: msg :: TextPrimitive > , pub models : Vec < foxglove_msgs :: msg :: ModelPrimitive > } impl WrappedTypesupport for SceneEntity { type CStruct = foxglove_msgs__msg__SceneEntity ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__foxglove_msgs__msg__SceneEntity () } } fn create_msg () -> * mut foxglove_msgs__msg__SceneEntity { unsafe { foxglove_msgs__msg__SceneEntity__create () } } fn destroy_msg (msg : * mut foxglove_msgs__msg__SceneEntity) -> () { unsafe { foxglove_msgs__msg__SceneEntity__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> SceneEntity { SceneEntity { timestamp : builtin_interfaces :: msg :: Time :: from_native (& msg . timestamp) , frame_id : msg . frame_id . to_str () . to_owned () , id : msg . id . to_str () . to_owned () , lifetime : builtin_interfaces :: msg :: Duration :: from_native (& msg . lifetime) , frame_locked : msg . frame_locked , metadata : { let mut temp = Vec :: with_capacity (msg . metadata . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . metadata . data , msg . metadata . size) } ; for s in slice { temp . push (foxglove_msgs :: msg :: KeyValuePair :: from_native (s)) ; } temp } , arrows : { let mut temp = Vec :: with_capacity (msg . arrows . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . arrows . data , msg . arrows . size) } ; for s in slice { temp . push (foxglove_msgs :: msg :: ArrowPrimitive :: from_native (s)) ; } temp } , cubes : { let mut temp = Vec :: with_capacity (msg . cubes . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . cubes . data , msg . cubes . size) } ; for s in slice { temp . push (foxglove_msgs :: msg :: CubePrimitive :: from_native (s)) ; } temp } , spheres : { let mut temp = Vec :: with_capacity (msg . spheres . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . spheres . data , msg . spheres . size) } ; for s in slice { temp . push (foxglove_msgs :: msg :: SpherePrimitive :: from_native (s)) ; } temp } , cylinders : { let mut temp = Vec :: with_capacity (msg . cylinders . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . cylinders . data , msg . cylinders . size) } ; for s in slice { temp . push (foxglove_msgs :: msg :: CylinderPrimitive :: from_native (s)) ; } temp } , lines : { let mut temp = Vec :: with_capacity (msg . lines . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . lines . data , msg . lines . size) } ; for s in slice { temp . push (foxglove_msgs :: msg :: LinePrimitive :: from_native (s)) ; } temp } , triangles : { let mut temp = Vec :: with_capacity (msg . triangles . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . triangles . data , msg . triangles . size) } ; for s in slice { temp . push (foxglove_msgs :: msg :: TriangleListPrimitive :: from_native (s)) ; } temp } , texts : { let mut temp = Vec :: with_capacity (msg . texts . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . texts . data , msg . texts . size) } ; for s in slice { temp . push (foxglove_msgs :: msg :: TextPrimitive :: from_native (s)) ; } temp } , models : { let mut temp = Vec :: with_capacity (msg . models . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . models . data , msg . models . size) } ; for s in slice { temp . push (foxglove_msgs :: msg :: ModelPrimitive :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . timestamp . copy_to_native (& mut msg . timestamp) ; msg . frame_id . assign (& self . frame_id) ; msg . id . assign (& self . id) ; self . lifetime . copy_to_native (& mut msg . lifetime) ; msg . frame_locked = self . frame_locked ; unsafe { foxglove_msgs__msg__KeyValuePair__Sequence__fini (& mut msg . metadata) ; foxglove_msgs__msg__KeyValuePair__Sequence__init (& mut msg . metadata , self . metadata . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . metadata . data , msg . metadata . size) ; for (t , s) in slice . iter_mut () . zip (& self . metadata) { s . copy_to_native (t) ; } } unsafe { foxglove_msgs__msg__ArrowPrimitive__Sequence__fini (& mut msg . arrows) ; foxglove_msgs__msg__ArrowPrimitive__Sequence__init (& mut msg . arrows , self . arrows . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . arrows . data , msg . arrows . size) ; for (t , s) in slice . iter_mut () . zip (& self . arrows) { s . copy_to_native (t) ; } } unsafe { foxglove_msgs__msg__CubePrimitive__Sequence__fini (& mut msg . cubes) ; foxglove_msgs__msg__CubePrimitive__Sequence__init (& mut msg . cubes , self . cubes . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . cubes . data , msg . cubes . size) ; for (t , s) in slice . iter_mut () . zip (& self . cubes) { s . copy_to_native (t) ; } } unsafe { foxglove_msgs__msg__SpherePrimitive__Sequence__fini (& mut msg . spheres) ; foxglove_msgs__msg__SpherePrimitive__Sequence__init (& mut msg . spheres , self . spheres . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . spheres . data , msg . spheres . size) ; for (t , s) in slice . iter_mut () . zip (& self . spheres) { s . copy_to_native (t) ; } } unsafe { foxglove_msgs__msg__CylinderPrimitive__Sequence__fini (& mut msg . cylinders) ; foxglove_msgs__msg__CylinderPrimitive__Sequence__init (& mut msg . cylinders , self . cylinders . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . cylinders . data , msg . cylinders . size) ; for (t , s) in slice . iter_mut () . zip (& self . cylinders) { s . copy_to_native (t) ; } } unsafe { foxglove_msgs__msg__LinePrimitive__Sequence__fini (& mut msg . lines) ; foxglove_msgs__msg__LinePrimitive__Sequence__init (& mut msg . lines , self . lines . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . lines . data , msg . lines . size) ; for (t , s) in slice . iter_mut () . zip (& self . lines) { s . copy_to_native (t) ; } } unsafe { foxglove_msgs__msg__TriangleListPrimitive__Sequence__fini (& mut msg . triangles) ; foxglove_msgs__msg__TriangleListPrimitive__Sequence__init (& mut msg . triangles , self . triangles . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . triangles . data , msg . triangles . size) ; for (t , s) in slice . iter_mut () . zip (& self . triangles) { s . copy_to_native (t) ; } } unsafe { foxglove_msgs__msg__TextPrimitive__Sequence__fini (& mut msg . texts) ; foxglove_msgs__msg__TextPrimitive__Sequence__init (& mut msg . texts , self . texts . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . texts . data , msg . texts . size) ; for (t , s) in slice . iter_mut () . zip (& self . texts) { s . copy_to_native (t) ; } } unsafe { foxglove_msgs__msg__ModelPrimitive__Sequence__fini (& mut msg . models) ; foxglove_msgs__msg__ModelPrimitive__Sequence__init (& mut msg . models , self . models . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . models . data , msg . models . size) ; for (t , s) in slice . iter_mut () . zip (& self . models) { s . copy_to_native (t) ; } } } } impl Default for SceneEntity { fn default () -> Self { let msg_native = WrappedNativeMsg :: < SceneEntity > :: new () ; SceneEntity :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct SceneEntityDeletion { pub timestamp : builtin_interfaces :: msg :: Time , # [serde (rename = "type")] pub type_ : u8 , pub id : std :: string :: String } impl WrappedTypesupport for SceneEntityDeletion { type CStruct = foxglove_msgs__msg__SceneEntityDeletion ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__foxglove_msgs__msg__SceneEntityDeletion () } } fn create_msg () -> * mut foxglove_msgs__msg__SceneEntityDeletion { unsafe { foxglove_msgs__msg__SceneEntityDeletion__create () } } fn destroy_msg (msg : * mut foxglove_msgs__msg__SceneEntityDeletion) -> () { unsafe { foxglove_msgs__msg__SceneEntityDeletion__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> SceneEntityDeletion { SceneEntityDeletion { timestamp : builtin_interfaces :: msg :: Time :: from_native (& msg . timestamp) , type_ : msg . type_ , id : msg . id . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . timestamp . copy_to_native (& mut msg . timestamp) ; msg . type_ = self . type_ ; msg . id . assign (& self . id) ; } } impl Default for SceneEntityDeletion { fn default () -> Self { let msg_native = WrappedNativeMsg :: < SceneEntityDeletion > :: new () ; SceneEntityDeletion :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl SceneEntityDeletion { pub const ALL : _bindgen_ty_218 = foxglove_msgs__msg__SceneEntityDeletion__ALL ; pub const MATCHING_ID : _bindgen_ty_217 = foxglove_msgs__msg__SceneEntityDeletion__MATCHING_ID ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct SceneEntityUpdate { pub deletions : Vec < foxglove_msgs :: msg :: SceneEntityDeletion > , pub entities : Vec < foxglove_msgs :: msg :: SceneEntity > } impl WrappedTypesupport for SceneEntityUpdate { type CStruct = foxglove_msgs__msg__SceneEntityUpdate ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__foxglove_msgs__msg__SceneEntityUpdate () } } fn create_msg () -> * mut foxglove_msgs__msg__SceneEntityUpdate { unsafe { foxglove_msgs__msg__SceneEntityUpdate__create () } } fn destroy_msg (msg : * mut foxglove_msgs__msg__SceneEntityUpdate) -> () { unsafe { foxglove_msgs__msg__SceneEntityUpdate__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> SceneEntityUpdate { SceneEntityUpdate { deletions : { let mut temp = Vec :: with_capacity (msg . deletions . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . deletions . data , msg . deletions . size) } ; for s in slice { temp . push (foxglove_msgs :: msg :: SceneEntityDeletion :: from_native (s)) ; } temp } , entities : { let mut temp = Vec :: with_capacity (msg . entities . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . entities . data , msg . entities . size) } ; for s in slice { temp . push (foxglove_msgs :: msg :: SceneEntity :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { unsafe { foxglove_msgs__msg__SceneEntityDeletion__Sequence__fini (& mut msg . deletions) ; foxglove_msgs__msg__SceneEntityDeletion__Sequence__init (& mut msg . deletions , self . deletions . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . deletions . data , msg . deletions . size) ; for (t , s) in slice . iter_mut () . zip (& self . deletions) { s . copy_to_native (t) ; } } unsafe { foxglove_msgs__msg__SceneEntity__Sequence__fini (& mut msg . entities) ; foxglove_msgs__msg__SceneEntity__Sequence__init (& mut msg . entities , self . entities . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . entities . data , msg . entities . size) ; for (t , s) in slice . iter_mut () . zip (& self . entities) { s . copy_to_native (t) ; } } } } impl Default for SceneEntityUpdate { fn default () -> Self { let msg_native = WrappedNativeMsg :: < SceneEntityUpdate > :: new () ; SceneEntityUpdate :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct SceneUpdate { pub deletions : Vec < foxglove_msgs :: msg :: SceneEntityDeletion > , pub entities : Vec < foxglove_msgs :: msg :: SceneEntity > } impl WrappedTypesupport for SceneUpdate { type CStruct = foxglove_msgs__msg__SceneUpdate ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__foxglove_msgs__msg__SceneUpdate () } } fn create_msg () -> * mut foxglove_msgs__msg__SceneUpdate { unsafe { foxglove_msgs__msg__SceneUpdate__create () } } fn destroy_msg (msg : * mut foxglove_msgs__msg__SceneUpdate) -> () { unsafe { foxglove_msgs__msg__SceneUpdate__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> SceneUpdate { SceneUpdate { deletions : { let mut temp = Vec :: with_capacity (msg . deletions . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . deletions . data , msg . deletions . size) } ; for s in slice { temp . push (foxglove_msgs :: msg :: SceneEntityDeletion :: from_native (s)) ; } temp } , entities : { let mut temp = Vec :: with_capacity (msg . entities . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . entities . data , msg . entities . size) } ; for s in slice { temp . push (foxglove_msgs :: msg :: SceneEntity :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { unsafe { foxglove_msgs__msg__SceneEntityDeletion__Sequence__fini (& mut msg . deletions) ; foxglove_msgs__msg__SceneEntityDeletion__Sequence__init (& mut msg . deletions , self . deletions . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . deletions . data , msg . deletions . size) ; for (t , s) in slice . iter_mut () . zip (& self . deletions) { s . copy_to_native (t) ; } } unsafe { foxglove_msgs__msg__SceneEntity__Sequence__fini (& mut msg . entities) ; foxglove_msgs__msg__SceneEntity__Sequence__init (& mut msg . entities , self . entities . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . entities . data , msg . entities . size) ; for (t , s) in slice . iter_mut () . zip (& self . entities) { s . copy_to_native (t) ; } } } } impl Default for SceneUpdate { fn default () -> Self { let msg_native = WrappedNativeMsg :: < SceneUpdate > :: new () ; SceneUpdate :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct SphereAttributes { pub pose : geometry_msgs :: msg :: Pose , pub size : geometry_msgs :: msg :: Vector3 , pub color : foxglove_msgs :: msg :: Color } impl WrappedTypesupport for SphereAttributes { type CStruct = foxglove_msgs__msg__SphereAttributes ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__foxglove_msgs__msg__SphereAttributes () } } fn create_msg () -> * mut foxglove_msgs__msg__SphereAttributes { unsafe { foxglove_msgs__msg__SphereAttributes__create () } } fn destroy_msg (msg : * mut foxglove_msgs__msg__SphereAttributes) -> () { unsafe { foxglove_msgs__msg__SphereAttributes__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> SphereAttributes { SphereAttributes { pose : geometry_msgs :: msg :: Pose :: from_native (& msg . pose) , size : geometry_msgs :: msg :: Vector3 :: from_native (& msg . size) , color : foxglove_msgs :: msg :: Color :: from_native (& msg . color) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . pose . copy_to_native (& mut msg . pose) ; self . size . copy_to_native (& mut msg . size) ; self . color . copy_to_native (& mut msg . color) ; } } impl Default for SphereAttributes { fn default () -> Self { let msg_native = WrappedNativeMsg :: < SphereAttributes > :: new () ; SphereAttributes :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct SphereListMarker { pub timestamp : builtin_interfaces :: msg :: Time , pub frame_id : std :: string :: String , pub id : std :: string :: String , pub lifetime : builtin_interfaces :: msg :: Duration , pub frame_locked : bool , pub metadata : Vec < foxglove_msgs :: msg :: KeyValuePair > , pub attributes : Vec < foxglove_msgs :: msg :: SphereAttributes > } impl WrappedTypesupport for SphereListMarker { type CStruct = foxglove_msgs__msg__SphereListMarker ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__foxglove_msgs__msg__SphereListMarker () } } fn create_msg () -> * mut foxglove_msgs__msg__SphereListMarker { unsafe { foxglove_msgs__msg__SphereListMarker__create () } } fn destroy_msg (msg : * mut foxglove_msgs__msg__SphereListMarker) -> () { unsafe { foxglove_msgs__msg__SphereListMarker__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> SphereListMarker { SphereListMarker { timestamp : builtin_interfaces :: msg :: Time :: from_native (& msg . timestamp) , frame_id : msg . frame_id . to_str () . to_owned () , id : msg . id . to_str () . to_owned () , lifetime : builtin_interfaces :: msg :: Duration :: from_native (& msg . lifetime) , frame_locked : msg . frame_locked , metadata : { let mut temp = Vec :: with_capacity (msg . metadata . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . metadata . data , msg . metadata . size) } ; for s in slice { temp . push (foxglove_msgs :: msg :: KeyValuePair :: from_native (s)) ; } temp } , attributes : { let mut temp = Vec :: with_capacity (msg . attributes . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . attributes . data , msg . attributes . size) } ; for s in slice { temp . push (foxglove_msgs :: msg :: SphereAttributes :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . timestamp . copy_to_native (& mut msg . timestamp) ; msg . frame_id . assign (& self . frame_id) ; msg . id . assign (& self . id) ; self . lifetime . copy_to_native (& mut msg . lifetime) ; msg . frame_locked = self . frame_locked ; unsafe { foxglove_msgs__msg__KeyValuePair__Sequence__fini (& mut msg . metadata) ; foxglove_msgs__msg__KeyValuePair__Sequence__init (& mut msg . metadata , self . metadata . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . metadata . data , msg . metadata . size) ; for (t , s) in slice . iter_mut () . zip (& self . metadata) { s . copy_to_native (t) ; } } unsafe { foxglove_msgs__msg__SphereAttributes__Sequence__fini (& mut msg . attributes) ; foxglove_msgs__msg__SphereAttributes__Sequence__init (& mut msg . attributes , self . attributes . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . attributes . data , msg . attributes . size) ; for (t , s) in slice . iter_mut () . zip (& self . attributes) { s . copy_to_native (t) ; } } } } impl Default for SphereListMarker { fn default () -> Self { let msg_native = WrappedNativeMsg :: < SphereListMarker > :: new () ; SphereListMarker :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct SphereMarker { pub pose : geometry_msgs :: msg :: Pose , pub size : geometry_msgs :: msg :: Vector3 , pub color : foxglove_msgs :: msg :: Color } impl WrappedTypesupport for SphereMarker { type CStruct = foxglove_msgs__msg__SphereMarker ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__foxglove_msgs__msg__SphereMarker () } } fn create_msg () -> * mut foxglove_msgs__msg__SphereMarker { unsafe { foxglove_msgs__msg__SphereMarker__create () } } fn destroy_msg (msg : * mut foxglove_msgs__msg__SphereMarker) -> () { unsafe { foxglove_msgs__msg__SphereMarker__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> SphereMarker { SphereMarker { pose : geometry_msgs :: msg :: Pose :: from_native (& msg . pose) , size : geometry_msgs :: msg :: Vector3 :: from_native (& msg . size) , color : foxglove_msgs :: msg :: Color :: from_native (& msg . color) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . pose . copy_to_native (& mut msg . pose) ; self . size . copy_to_native (& mut msg . size) ; self . color . copy_to_native (& mut msg . color) ; } } impl Default for SphereMarker { fn default () -> Self { let msg_native = WrappedNativeMsg :: < SphereMarker > :: new () ; SphereMarker :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct SpherePrimitive { pub pose : geometry_msgs :: msg :: Pose , pub size : geometry_msgs :: msg :: Vector3 , pub color : foxglove_msgs :: msg :: Color } impl WrappedTypesupport for SpherePrimitive { type CStruct = foxglove_msgs__msg__SpherePrimitive ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__foxglove_msgs__msg__SpherePrimitive () } } fn create_msg () -> * mut foxglove_msgs__msg__SpherePrimitive { unsafe { foxglove_msgs__msg__SpherePrimitive__create () } } fn destroy_msg (msg : * mut foxglove_msgs__msg__SpherePrimitive) -> () { unsafe { foxglove_msgs__msg__SpherePrimitive__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> SpherePrimitive { SpherePrimitive { pose : geometry_msgs :: msg :: Pose :: from_native (& msg . pose) , size : geometry_msgs :: msg :: Vector3 :: from_native (& msg . size) , color : foxglove_msgs :: msg :: Color :: from_native (& msg . color) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . pose . copy_to_native (& mut msg . pose) ; self . size . copy_to_native (& mut msg . size) ; self . color . copy_to_native (& mut msg . color) ; } } impl Default for SpherePrimitive { fn default () -> Self { let msg_native = WrappedNativeMsg :: < SpherePrimitive > :: new () ; SpherePrimitive :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct TextMarker { pub pose : geometry_msgs :: msg :: Pose , pub billboard : bool , pub font_size : f64 , pub scale_invariant : bool , pub color : foxglove_msgs :: msg :: Color , pub text : std :: string :: String } impl WrappedTypesupport for TextMarker { type CStruct = foxglove_msgs__msg__TextMarker ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__foxglove_msgs__msg__TextMarker () } } fn create_msg () -> * mut foxglove_msgs__msg__TextMarker { unsafe { foxglove_msgs__msg__TextMarker__create () } } fn destroy_msg (msg : * mut foxglove_msgs__msg__TextMarker) -> () { unsafe { foxglove_msgs__msg__TextMarker__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> TextMarker { TextMarker { pose : geometry_msgs :: msg :: Pose :: from_native (& msg . pose) , billboard : msg . billboard , font_size : msg . font_size , scale_invariant : msg . scale_invariant , color : foxglove_msgs :: msg :: Color :: from_native (& msg . color) , text : msg . text . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . pose . copy_to_native (& mut msg . pose) ; msg . billboard = self . billboard ; msg . font_size = self . font_size ; msg . scale_invariant = self . scale_invariant ; self . color . copy_to_native (& mut msg . color) ; msg . text . assign (& self . text) ; } } impl Default for TextMarker { fn default () -> Self { let msg_native = WrappedNativeMsg :: < TextMarker > :: new () ; TextMarker :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct TextPrimitive { pub pose : geometry_msgs :: msg :: Pose , pub billboard : bool , pub font_size : f64 , pub scale_invariant : bool , pub color : foxglove_msgs :: msg :: Color , pub text : std :: string :: String } impl WrappedTypesupport for TextPrimitive { type CStruct = foxglove_msgs__msg__TextPrimitive ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__foxglove_msgs__msg__TextPrimitive () } } fn create_msg () -> * mut foxglove_msgs__msg__TextPrimitive { unsafe { foxglove_msgs__msg__TextPrimitive__create () } } fn destroy_msg (msg : * mut foxglove_msgs__msg__TextPrimitive) -> () { unsafe { foxglove_msgs__msg__TextPrimitive__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> TextPrimitive { TextPrimitive { pose : geometry_msgs :: msg :: Pose :: from_native (& msg . pose) , billboard : msg . billboard , font_size : msg . font_size , scale_invariant : msg . scale_invariant , color : foxglove_msgs :: msg :: Color :: from_native (& msg . color) , text : msg . text . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . pose . copy_to_native (& mut msg . pose) ; msg . billboard = self . billboard ; msg . font_size = self . font_size ; msg . scale_invariant = self . scale_invariant ; self . color . copy_to_native (& mut msg . color) ; msg . text . assign (& self . text) ; } } impl Default for TextPrimitive { fn default () -> Self { let msg_native = WrappedNativeMsg :: < TextPrimitive > :: new () ; TextPrimitive :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Transform { pub timestamp : builtin_interfaces :: msg :: Time , pub translation : geometry_msgs :: msg :: Vector3 , pub rotation : geometry_msgs :: msg :: Quaternion } impl WrappedTypesupport for Transform { type CStruct = foxglove_msgs__msg__Transform ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__foxglove_msgs__msg__Transform () } } fn create_msg () -> * mut foxglove_msgs__msg__Transform { unsafe { foxglove_msgs__msg__Transform__create () } } fn destroy_msg (msg : * mut foxglove_msgs__msg__Transform) -> () { unsafe { foxglove_msgs__msg__Transform__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Transform { Transform { timestamp : builtin_interfaces :: msg :: Time :: from_native (& msg . timestamp) , translation : geometry_msgs :: msg :: Vector3 :: from_native (& msg . translation) , rotation : geometry_msgs :: msg :: Quaternion :: from_native (& msg . rotation) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . timestamp . copy_to_native (& mut msg . timestamp) ; self . translation . copy_to_native (& mut msg . translation) ; self . rotation . copy_to_native (& mut msg . rotation) ; } } impl Default for Transform { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Transform > :: new () ; Transform :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct TriangleListMarker { pub pose : geometry_msgs :: msg :: Pose , pub points : Vec < geometry_msgs :: msg :: Point > , pub color : foxglove_msgs :: msg :: Color , pub colors : Vec < foxglove_msgs :: msg :: Color > , pub indices : Vec < u32 > } impl WrappedTypesupport for TriangleListMarker { type CStruct = foxglove_msgs__msg__TriangleListMarker ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__foxglove_msgs__msg__TriangleListMarker () } } fn create_msg () -> * mut foxglove_msgs__msg__TriangleListMarker { unsafe { foxglove_msgs__msg__TriangleListMarker__create () } } fn destroy_msg (msg : * mut foxglove_msgs__msg__TriangleListMarker) -> () { unsafe { foxglove_msgs__msg__TriangleListMarker__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> TriangleListMarker { TriangleListMarker { pose : geometry_msgs :: msg :: Pose :: from_native (& msg . pose) , points : { let mut temp = Vec :: with_capacity (msg . points . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . points . data , msg . points . size) } ; for s in slice { temp . push (geometry_msgs :: msg :: Point :: from_native (s)) ; } temp } , color : foxglove_msgs :: msg :: Color :: from_native (& msg . color) , colors : { let mut temp = Vec :: with_capacity (msg . colors . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . colors . data , msg . colors . size) } ; for s in slice { temp . push (foxglove_msgs :: msg :: Color :: from_native (s)) ; } temp } , indices : msg . indices . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . pose . copy_to_native (& mut msg . pose) ; unsafe { geometry_msgs__msg__Point__Sequence__fini (& mut msg . points) ; geometry_msgs__msg__Point__Sequence__init (& mut msg . points , self . points . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . points . data , msg . points . size) ; for (t , s) in slice . iter_mut () . zip (& self . points) { s . copy_to_native (t) ; } } self . color . copy_to_native (& mut msg . color) ; unsafe { foxglove_msgs__msg__Color__Sequence__fini (& mut msg . colors) ; foxglove_msgs__msg__Color__Sequence__init (& mut msg . colors , self . colors . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . colors . data , msg . colors . size) ; for (t , s) in slice . iter_mut () . zip (& self . colors) { s . copy_to_native (t) ; } } msg . indices . update (& self . indices) ; } } impl Default for TriangleListMarker { fn default () -> Self { let msg_native = WrappedNativeMsg :: < TriangleListMarker > :: new () ; TriangleListMarker :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct TriangleListPrimitive { pub pose : geometry_msgs :: msg :: Pose , pub points : Vec < geometry_msgs :: msg :: Point > , pub color : foxglove_msgs :: msg :: Color , pub colors : Vec < foxglove_msgs :: msg :: Color > , pub indices : Vec < u32 > } impl WrappedTypesupport for TriangleListPrimitive { type CStruct = foxglove_msgs__msg__TriangleListPrimitive ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__foxglove_msgs__msg__TriangleListPrimitive () } } fn create_msg () -> * mut foxglove_msgs__msg__TriangleListPrimitive { unsafe { foxglove_msgs__msg__TriangleListPrimitive__create () } } fn destroy_msg (msg : * mut foxglove_msgs__msg__TriangleListPrimitive) -> () { unsafe { foxglove_msgs__msg__TriangleListPrimitive__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> TriangleListPrimitive { TriangleListPrimitive { pose : geometry_msgs :: msg :: Pose :: from_native (& msg . pose) , points : { let mut temp = Vec :: with_capacity (msg . points . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . points . data , msg . points . size) } ; for s in slice { temp . push (geometry_msgs :: msg :: Point :: from_native (s)) ; } temp } , color : foxglove_msgs :: msg :: Color :: from_native (& msg . color) , colors : { let mut temp = Vec :: with_capacity (msg . colors . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . colors . data , msg . colors . size) } ; for s in slice { temp . push (foxglove_msgs :: msg :: Color :: from_native (s)) ; } temp } , indices : msg . indices . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . pose . copy_to_native (& mut msg . pose) ; unsafe { geometry_msgs__msg__Point__Sequence__fini (& mut msg . points) ; geometry_msgs__msg__Point__Sequence__init (& mut msg . points , self . points . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . points . data , msg . points . size) ; for (t , s) in slice . iter_mut () . zip (& self . points) { s . copy_to_native (t) ; } } self . color . copy_to_native (& mut msg . color) ; unsafe { foxglove_msgs__msg__Color__Sequence__fini (& mut msg . colors) ; foxglove_msgs__msg__Color__Sequence__init (& mut msg . colors , self . colors . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . colors . data , msg . colors . size) ; for (t , s) in slice . iter_mut () . zip (& self . colors) { s . copy_to_native (t) ; } } msg . indices . update (& self . indices) ; } } impl Default for TriangleListPrimitive { fn default () -> Self { let msg_native = WrappedNativeMsg :: < TriangleListPrimitive > :: new () ; TriangleListPrimitive :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct TrianglesMarker { pub timestamp : builtin_interfaces :: msg :: Time , pub frame_id : std :: string :: String , pub id : std :: string :: String , pub lifetime : builtin_interfaces :: msg :: Duration , pub frame_locked : bool , pub metadata : Vec < foxglove_msgs :: msg :: KeyValuePair > , pub pose : geometry_msgs :: msg :: Pose , pub points : Vec < geometry_msgs :: msg :: Point > , pub color : foxglove_msgs :: msg :: Color , pub colors : Vec < foxglove_msgs :: msg :: Color > , pub indices : Vec < u32 > } impl WrappedTypesupport for TrianglesMarker { type CStruct = foxglove_msgs__msg__TrianglesMarker ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__foxglove_msgs__msg__TrianglesMarker () } } fn create_msg () -> * mut foxglove_msgs__msg__TrianglesMarker { unsafe { foxglove_msgs__msg__TrianglesMarker__create () } } fn destroy_msg (msg : * mut foxglove_msgs__msg__TrianglesMarker) -> () { unsafe { foxglove_msgs__msg__TrianglesMarker__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> TrianglesMarker { TrianglesMarker { timestamp : builtin_interfaces :: msg :: Time :: from_native (& msg . timestamp) , frame_id : msg . frame_id . to_str () . to_owned () , id : msg . id . to_str () . to_owned () , lifetime : builtin_interfaces :: msg :: Duration :: from_native (& msg . lifetime) , frame_locked : msg . frame_locked , metadata : { let mut temp = Vec :: with_capacity (msg . metadata . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . metadata . data , msg . metadata . size) } ; for s in slice { temp . push (foxglove_msgs :: msg :: KeyValuePair :: from_native (s)) ; } temp } , pose : geometry_msgs :: msg :: Pose :: from_native (& msg . pose) , points : { let mut temp = Vec :: with_capacity (msg . points . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . points . data , msg . points . size) } ; for s in slice { temp . push (geometry_msgs :: msg :: Point :: from_native (s)) ; } temp } , color : foxglove_msgs :: msg :: Color :: from_native (& msg . color) , colors : { let mut temp = Vec :: with_capacity (msg . colors . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . colors . data , msg . colors . size) } ; for s in slice { temp . push (foxglove_msgs :: msg :: Color :: from_native (s)) ; } temp } , indices : msg . indices . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . timestamp . copy_to_native (& mut msg . timestamp) ; msg . frame_id . assign (& self . frame_id) ; msg . id . assign (& self . id) ; self . lifetime . copy_to_native (& mut msg . lifetime) ; msg . frame_locked = self . frame_locked ; unsafe { foxglove_msgs__msg__KeyValuePair__Sequence__fini (& mut msg . metadata) ; foxglove_msgs__msg__KeyValuePair__Sequence__init (& mut msg . metadata , self . metadata . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . metadata . data , msg . metadata . size) ; for (t , s) in slice . iter_mut () . zip (& self . metadata) { s . copy_to_native (t) ; } } self . pose . copy_to_native (& mut msg . pose) ; unsafe { geometry_msgs__msg__Point__Sequence__fini (& mut msg . points) ; geometry_msgs__msg__Point__Sequence__init (& mut msg . points , self . points . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . points . data , msg . points . size) ; for (t , s) in slice . iter_mut () . zip (& self . points) { s . copy_to_native (t) ; } } self . color . copy_to_native (& mut msg . color) ; unsafe { foxglove_msgs__msg__Color__Sequence__fini (& mut msg . colors) ; foxglove_msgs__msg__Color__Sequence__init (& mut msg . colors , self . colors . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . colors . data , msg . colors . size) ; for (t , s) in slice . iter_mut () . zip (& self . colors) { s . copy_to_native (t) ; } } msg . indices . update (& self . indices) ; } } impl Default for TrianglesMarker { fn default () -> Self { let msg_native = WrappedNativeMsg :: < TrianglesMarker > :: new () ; TrianglesMarker :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Vector2 { pub x : f64 , pub y : f64 } impl WrappedTypesupport for Vector2 { type CStruct = foxglove_msgs__msg__Vector2 ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__foxglove_msgs__msg__Vector2 () } } fn create_msg () -> * mut foxglove_msgs__msg__Vector2 { unsafe { foxglove_msgs__msg__Vector2__create () } } fn destroy_msg (msg : * mut foxglove_msgs__msg__Vector2) -> () { unsafe { foxglove_msgs__msg__Vector2__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Vector2 { Vector2 { x : msg . x , y : msg . y , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . x = self . x ; msg . y = self . y ; } } impl Default for Vector2 { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Vector2 > :: new () ; Vector2 :: from_native (& msg_native) } } }