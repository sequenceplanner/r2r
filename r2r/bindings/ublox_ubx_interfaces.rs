pub mod srv { # [allow (non_snake_case)] pub mod ColdStart { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__ublox_ubx_interfaces__srv__ColdStart () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub reset_type : u8 } impl WrappedTypesupport for Request { type CStruct = ublox_ubx_interfaces__srv__ColdStart_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ublox_ubx_interfaces__srv__ColdStart_Request () } } fn create_msg () -> * mut ublox_ubx_interfaces__srv__ColdStart_Request { unsafe { ublox_ubx_interfaces__srv__ColdStart_Request__create () } } fn destroy_msg (msg : * mut ublox_ubx_interfaces__srv__ColdStart_Request) -> () { unsafe { ublox_ubx_interfaces__srv__ColdStart_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { reset_type : msg . reset_type , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . reset_type = self . reset_type ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl Request { pub const GNSS_START_CONTROLLED : _bindgen_ty_2449 = ublox_ubx_interfaces__srv__ColdStart_Request__GNSS_START_CONTROLLED ; pub const GNSS_STOP_CONTROLLED : _bindgen_ty_2448 = ublox_ubx_interfaces__srv__ColdStart_Request__GNSS_STOP_CONTROLLED ; pub const HW_RESET_AFTER_SHUTDOWN : _bindgen_ty_2447 = ublox_ubx_interfaces__srv__ColdStart_Request__HW_RESET_AFTER_SHUTDOWN ; pub const HW_RESET_IMMEDIATELY : _bindgen_ty_2444 = ublox_ubx_interfaces__srv__ColdStart_Request__HW_RESET_IMMEDIATELY ; pub const SW_RESET_CONTROLLED : _bindgen_ty_2445 = ublox_ubx_interfaces__srv__ColdStart_Request__SW_RESET_CONTROLLED ; pub const SW_RESET_CONTROLLED_GNSS : _bindgen_ty_2446 = ublox_ubx_interfaces__srv__ColdStart_Request__SW_RESET_CONTROLLED_GNSS ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { } impl WrappedTypesupport for Response { type CStruct = ublox_ubx_interfaces__srv__ColdStart_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ublox_ubx_interfaces__srv__ColdStart_Response () } } fn create_msg () -> * mut ublox_ubx_interfaces__srv__ColdStart_Response { unsafe { ublox_ubx_interfaces__srv__ColdStart_Response__create () } } fn destroy_msg (msg : * mut ublox_ubx_interfaces__srv__ColdStart_Response) -> () { unsafe { ublox_ubx_interfaces__srv__ColdStart_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod HotStart { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__ublox_ubx_interfaces__srv__HotStart () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub reset_type : u8 } impl WrappedTypesupport for Request { type CStruct = ublox_ubx_interfaces__srv__HotStart_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ublox_ubx_interfaces__srv__HotStart_Request () } } fn create_msg () -> * mut ublox_ubx_interfaces__srv__HotStart_Request { unsafe { ublox_ubx_interfaces__srv__HotStart_Request__create () } } fn destroy_msg (msg : * mut ublox_ubx_interfaces__srv__HotStart_Request) -> () { unsafe { ublox_ubx_interfaces__srv__HotStart_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { reset_type : msg . reset_type , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . reset_type = self . reset_type ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { } impl WrappedTypesupport for Response { type CStruct = ublox_ubx_interfaces__srv__HotStart_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ublox_ubx_interfaces__srv__HotStart_Response () } } fn create_msg () -> * mut ublox_ubx_interfaces__srv__HotStart_Response { unsafe { ublox_ubx_interfaces__srv__HotStart_Response__create () } } fn destroy_msg (msg : * mut ublox_ubx_interfaces__srv__HotStart_Response) -> () { unsafe { ublox_ubx_interfaces__srv__HotStart_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod ResetODO { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__ublox_ubx_interfaces__srv__ResetODO () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { } impl WrappedTypesupport for Request { type CStruct = ublox_ubx_interfaces__srv__ResetODO_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ublox_ubx_interfaces__srv__ResetODO_Request () } } fn create_msg () -> * mut ublox_ubx_interfaces__srv__ResetODO_Request { unsafe { ublox_ubx_interfaces__srv__ResetODO_Request__create () } } fn destroy_msg (msg : * mut ublox_ubx_interfaces__srv__ResetODO_Request) -> () { unsafe { ublox_ubx_interfaces__srv__ResetODO_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { } impl WrappedTypesupport for Response { type CStruct = ublox_ubx_interfaces__srv__ResetODO_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ublox_ubx_interfaces__srv__ResetODO_Response () } } fn create_msg () -> * mut ublox_ubx_interfaces__srv__ResetODO_Response { unsafe { ublox_ubx_interfaces__srv__ResetODO_Response__create () } } fn destroy_msg (msg : * mut ublox_ubx_interfaces__srv__ResetODO_Response) -> () { unsafe { ublox_ubx_interfaces__srv__ResetODO_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod WarmStart { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__ublox_ubx_interfaces__srv__WarmStart () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub reset_type : u8 } impl WrappedTypesupport for Request { type CStruct = ublox_ubx_interfaces__srv__WarmStart_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ublox_ubx_interfaces__srv__WarmStart_Request () } } fn create_msg () -> * mut ublox_ubx_interfaces__srv__WarmStart_Request { unsafe { ublox_ubx_interfaces__srv__WarmStart_Request__create () } } fn destroy_msg (msg : * mut ublox_ubx_interfaces__srv__WarmStart_Request) -> () { unsafe { ublox_ubx_interfaces__srv__WarmStart_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { reset_type : msg . reset_type , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . reset_type = self . reset_type ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { } impl WrappedTypesupport for Response { type CStruct = ublox_ubx_interfaces__srv__WarmStart_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ublox_ubx_interfaces__srv__WarmStart_Response () } } fn create_msg () -> * mut ublox_ubx_interfaces__srv__WarmStart_Response { unsafe { ublox_ubx_interfaces__srv__WarmStart_Response__create () } } fn destroy_msg (msg : * mut ublox_ubx_interfaces__srv__WarmStart_Response) -> () { unsafe { ublox_ubx_interfaces__srv__WarmStart_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } }