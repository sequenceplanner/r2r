pub mod msg { use super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Accelerometer { pub name : std :: string :: String , pub x : f32 , pub y : f32 , pub z : f32 } impl WrappedTypesupport for Accelerometer { type CStruct = rcss3d_agent_msgs__msg__Accelerometer ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rcss3d_agent_msgs__msg__Accelerometer () } } fn create_msg () -> * mut rcss3d_agent_msgs__msg__Accelerometer { unsafe { rcss3d_agent_msgs__msg__Accelerometer__create () } } fn destroy_msg (msg : * mut rcss3d_agent_msgs__msg__Accelerometer) -> () { unsafe { rcss3d_agent_msgs__msg__Accelerometer__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Accelerometer { Accelerometer { name : msg . name . to_str () . to_owned () , x : msg . x , y : msg . y , z : msg . z , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . name . assign (& self . name) ; msg . x = self . x ; msg . y = self . y ; msg . z = self . z ; } } impl Default for Accelerometer { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Accelerometer > :: new () ; Accelerometer :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct AgentState { pub temp : f32 , pub battery : f32 } impl WrappedTypesupport for AgentState { type CStruct = rcss3d_agent_msgs__msg__AgentState ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rcss3d_agent_msgs__msg__AgentState () } } fn create_msg () -> * mut rcss3d_agent_msgs__msg__AgentState { unsafe { rcss3d_agent_msgs__msg__AgentState__create () } } fn destroy_msg (msg : * mut rcss3d_agent_msgs__msg__AgentState) -> () { unsafe { rcss3d_agent_msgs__msg__AgentState__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> AgentState { AgentState { temp : msg . temp , battery : msg . battery , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . temp = self . temp ; msg . battery = self . battery ; } } impl Default for AgentState { fn default () -> Self { let msg_native = WrappedNativeMsg :: < AgentState > :: new () ; AgentState :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Ball { pub center : rcss3d_agent_msgs :: msg :: Spherical } impl WrappedTypesupport for Ball { type CStruct = rcss3d_agent_msgs__msg__Ball ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rcss3d_agent_msgs__msg__Ball () } } fn create_msg () -> * mut rcss3d_agent_msgs__msg__Ball { unsafe { rcss3d_agent_msgs__msg__Ball__create () } } fn destroy_msg (msg : * mut rcss3d_agent_msgs__msg__Ball) -> () { unsafe { rcss3d_agent_msgs__msg__Ball__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Ball { Ball { center : rcss3d_agent_msgs :: msg :: Spherical :: from_native (& msg . center) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . center . copy_to_native (& mut msg . center) ; } } impl Default for Ball { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Ball > :: new () ; Ball :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Beam { pub x : f64 , pub y : f64 , pub rot : f64 } impl WrappedTypesupport for Beam { type CStruct = rcss3d_agent_msgs__msg__Beam ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rcss3d_agent_msgs__msg__Beam () } } fn create_msg () -> * mut rcss3d_agent_msgs__msg__Beam { unsafe { rcss3d_agent_msgs__msg__Beam__create () } } fn destroy_msg (msg : * mut rcss3d_agent_msgs__msg__Beam) -> () { unsafe { rcss3d_agent_msgs__msg__Beam__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Beam { Beam { x : msg . x , y : msg . y , rot : msg . rot , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . x = self . x ; msg . y = self . y ; msg . rot = self . rot ; } } impl Default for Beam { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Beam > :: new () ; Beam :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Effector { pub hinge_joint_vels : Vec < rcss3d_agent_msgs :: msg :: HingeJointVel > , pub universal_joint_vels : Vec < rcss3d_agent_msgs :: msg :: UniversalJointVel > , pub beams : Vec < rcss3d_agent_msgs :: msg :: Beam > , pub says : Vec < rcss3d_agent_msgs :: msg :: Say > } impl WrappedTypesupport for Effector { type CStruct = rcss3d_agent_msgs__msg__Effector ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rcss3d_agent_msgs__msg__Effector () } } fn create_msg () -> * mut rcss3d_agent_msgs__msg__Effector { unsafe { rcss3d_agent_msgs__msg__Effector__create () } } fn destroy_msg (msg : * mut rcss3d_agent_msgs__msg__Effector) -> () { unsafe { rcss3d_agent_msgs__msg__Effector__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Effector { Effector { hinge_joint_vels : { let mut temp = Vec :: with_capacity (msg . hinge_joint_vels . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . hinge_joint_vels . data , msg . hinge_joint_vels . size) } ; for s in slice { temp . push (rcss3d_agent_msgs :: msg :: HingeJointVel :: from_native (s)) ; } temp } , universal_joint_vels : { let mut temp = Vec :: with_capacity (msg . universal_joint_vels . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . universal_joint_vels . data , msg . universal_joint_vels . size) } ; for s in slice { temp . push (rcss3d_agent_msgs :: msg :: UniversalJointVel :: from_native (s)) ; } temp } , beams : { let mut temp = Vec :: with_capacity (msg . beams . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . beams . data , msg . beams . size) } ; for s in slice { temp . push (rcss3d_agent_msgs :: msg :: Beam :: from_native (s)) ; } temp } , says : { let mut temp = Vec :: with_capacity (msg . says . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . says . data , msg . says . size) } ; for s in slice { temp . push (rcss3d_agent_msgs :: msg :: Say :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { unsafe { rcss3d_agent_msgs__msg__HingeJointVel__Sequence__fini (& mut msg . hinge_joint_vels) ; rcss3d_agent_msgs__msg__HingeJointVel__Sequence__init (& mut msg . hinge_joint_vels , self . hinge_joint_vels . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . hinge_joint_vels . data , msg . hinge_joint_vels . size) ; for (t , s) in slice . iter_mut () . zip (& self . hinge_joint_vels) { s . copy_to_native (t) ; } } unsafe { rcss3d_agent_msgs__msg__UniversalJointVel__Sequence__fini (& mut msg . universal_joint_vels) ; rcss3d_agent_msgs__msg__UniversalJointVel__Sequence__init (& mut msg . universal_joint_vels , self . universal_joint_vels . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . universal_joint_vels . data , msg . universal_joint_vels . size) ; for (t , s) in slice . iter_mut () . zip (& self . universal_joint_vels) { s . copy_to_native (t) ; } } unsafe { rcss3d_agent_msgs__msg__Beam__Sequence__fini (& mut msg . beams) ; rcss3d_agent_msgs__msg__Beam__Sequence__init (& mut msg . beams , self . beams . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . beams . data , msg . beams . size) ; for (t , s) in slice . iter_mut () . zip (& self . beams) { s . copy_to_native (t) ; } } unsafe { rcss3d_agent_msgs__msg__Say__Sequence__fini (& mut msg . says) ; rcss3d_agent_msgs__msg__Say__Sequence__init (& mut msg . says , self . says . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . says . data , msg . says . size) ; for (t , s) in slice . iter_mut () . zip (& self . says) { s . copy_to_native (t) ; } } } } impl Default for Effector { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Effector > :: new () ; Effector :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct FieldLine { pub start : rcss3d_agent_msgs :: msg :: Spherical , pub end : rcss3d_agent_msgs :: msg :: Spherical } impl WrappedTypesupport for FieldLine { type CStruct = rcss3d_agent_msgs__msg__FieldLine ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rcss3d_agent_msgs__msg__FieldLine () } } fn create_msg () -> * mut rcss3d_agent_msgs__msg__FieldLine { unsafe { rcss3d_agent_msgs__msg__FieldLine__create () } } fn destroy_msg (msg : * mut rcss3d_agent_msgs__msg__FieldLine) -> () { unsafe { rcss3d_agent_msgs__msg__FieldLine__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> FieldLine { FieldLine { start : rcss3d_agent_msgs :: msg :: Spherical :: from_native (& msg . start) , end : rcss3d_agent_msgs :: msg :: Spherical :: from_native (& msg . end) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . start . copy_to_native (& mut msg . start) ; self . end . copy_to_native (& mut msg . end) ; } } impl Default for FieldLine { fn default () -> Self { let msg_native = WrappedNativeMsg :: < FieldLine > :: new () ; FieldLine :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Flag { pub name : std :: string :: String , pub base : rcss3d_agent_msgs :: msg :: Spherical } impl WrappedTypesupport for Flag { type CStruct = rcss3d_agent_msgs__msg__Flag ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rcss3d_agent_msgs__msg__Flag () } } fn create_msg () -> * mut rcss3d_agent_msgs__msg__Flag { unsafe { rcss3d_agent_msgs__msg__Flag__create () } } fn destroy_msg (msg : * mut rcss3d_agent_msgs__msg__Flag) -> () { unsafe { rcss3d_agent_msgs__msg__Flag__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Flag { Flag { name : msg . name . to_str () . to_owned () , base : rcss3d_agent_msgs :: msg :: Spherical :: from_native (& msg . base) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . name . assign (& self . name) ; self . base . copy_to_native (& mut msg . base) ; } } impl Default for Flag { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Flag > :: new () ; Flag :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ForceResistance { pub name : std :: string :: String , pub px : f32 , pub py : f32 , pub pz : f32 , pub fx : f32 , pub fy : f32 , pub fz : f32 } impl WrappedTypesupport for ForceResistance { type CStruct = rcss3d_agent_msgs__msg__ForceResistance ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rcss3d_agent_msgs__msg__ForceResistance () } } fn create_msg () -> * mut rcss3d_agent_msgs__msg__ForceResistance { unsafe { rcss3d_agent_msgs__msg__ForceResistance__create () } } fn destroy_msg (msg : * mut rcss3d_agent_msgs__msg__ForceResistance) -> () { unsafe { rcss3d_agent_msgs__msg__ForceResistance__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ForceResistance { ForceResistance { name : msg . name . to_str () . to_owned () , px : msg . px , py : msg . py , pz : msg . pz , fx : msg . fx , fy : msg . fy , fz : msg . fz , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . name . assign (& self . name) ; msg . px = self . px ; msg . py = self . py ; msg . pz = self . pz ; msg . fx = self . fx ; msg . fy = self . fy ; msg . fz = self . fz ; } } impl Default for ForceResistance { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ForceResistance > :: new () ; ForceResistance :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct GameState { pub time : f32 , pub playmode : std :: string :: String , pub score_left : i32 , pub score_right : i32 } impl WrappedTypesupport for GameState { type CStruct = rcss3d_agent_msgs__msg__GameState ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rcss3d_agent_msgs__msg__GameState () } } fn create_msg () -> * mut rcss3d_agent_msgs__msg__GameState { unsafe { rcss3d_agent_msgs__msg__GameState__create () } } fn destroy_msg (msg : * mut rcss3d_agent_msgs__msg__GameState) -> () { unsafe { rcss3d_agent_msgs__msg__GameState__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> GameState { GameState { time : msg . time , playmode : msg . playmode . to_str () . to_owned () , score_left : msg . score_left , score_right : msg . score_right , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . time = self . time ; msg . playmode . assign (& self . playmode) ; msg . score_left = self . score_left ; msg . score_right = self . score_right ; } } impl Default for GameState { fn default () -> Self { let msg_native = WrappedNativeMsg :: < GameState > :: new () ; GameState :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Goalpost { pub name : std :: string :: String , pub top : rcss3d_agent_msgs :: msg :: Spherical } impl WrappedTypesupport for Goalpost { type CStruct = rcss3d_agent_msgs__msg__Goalpost ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rcss3d_agent_msgs__msg__Goalpost () } } fn create_msg () -> * mut rcss3d_agent_msgs__msg__Goalpost { unsafe { rcss3d_agent_msgs__msg__Goalpost__create () } } fn destroy_msg (msg : * mut rcss3d_agent_msgs__msg__Goalpost) -> () { unsafe { rcss3d_agent_msgs__msg__Goalpost__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Goalpost { Goalpost { name : msg . name . to_str () . to_owned () , top : rcss3d_agent_msgs :: msg :: Spherical :: from_native (& msg . top) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . name . assign (& self . name) ; self . top . copy_to_native (& mut msg . top) ; } } impl Default for Goalpost { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Goalpost > :: new () ; Goalpost :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct GyroRate { pub name : std :: string :: String , pub x : f32 , pub y : f32 , pub z : f32 } impl WrappedTypesupport for GyroRate { type CStruct = rcss3d_agent_msgs__msg__GyroRate ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rcss3d_agent_msgs__msg__GyroRate () } } fn create_msg () -> * mut rcss3d_agent_msgs__msg__GyroRate { unsafe { rcss3d_agent_msgs__msg__GyroRate__create () } } fn destroy_msg (msg : * mut rcss3d_agent_msgs__msg__GyroRate) -> () { unsafe { rcss3d_agent_msgs__msg__GyroRate__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> GyroRate { GyroRate { name : msg . name . to_str () . to_owned () , x : msg . x , y : msg . y , z : msg . z , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . name . assign (& self . name) ; msg . x = self . x ; msg . y = self . y ; msg . z = self . z ; } } impl Default for GyroRate { fn default () -> Self { let msg_native = WrappedNativeMsg :: < GyroRate > :: new () ; GyroRate :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Hear { pub team : std :: string :: String , pub time : f32 , # [serde (rename = "self")] pub self_ : bool , pub direction : Vec < f32 > , pub message : std :: string :: String } impl WrappedTypesupport for Hear { type CStruct = rcss3d_agent_msgs__msg__Hear ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rcss3d_agent_msgs__msg__Hear () } } fn create_msg () -> * mut rcss3d_agent_msgs__msg__Hear { unsafe { rcss3d_agent_msgs__msg__Hear__create () } } fn destroy_msg (msg : * mut rcss3d_agent_msgs__msg__Hear) -> () { unsafe { rcss3d_agent_msgs__msg__Hear__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Hear { Hear { team : msg . team . to_str () . to_owned () , time : msg . time , self_ : msg . self_ , direction : msg . direction . to_vec () , message : msg . message . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . team . assign (& self . team) ; msg . time = self . time ; msg . self_ = self . self_ ; assert ! (self . direction . len () <= 1usize , "Field {} is upper bounded by {}!" , "direction" , 1usize) ; msg . direction . update (& self . direction) ; msg . message . assign (& self . message) ; } } impl Default for Hear { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Hear > :: new () ; Hear :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct HingeJointPos { pub name : std :: string :: String , pub ax : f32 } impl WrappedTypesupport for HingeJointPos { type CStruct = rcss3d_agent_msgs__msg__HingeJointPos ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rcss3d_agent_msgs__msg__HingeJointPos () } } fn create_msg () -> * mut rcss3d_agent_msgs__msg__HingeJointPos { unsafe { rcss3d_agent_msgs__msg__HingeJointPos__create () } } fn destroy_msg (msg : * mut rcss3d_agent_msgs__msg__HingeJointPos) -> () { unsafe { rcss3d_agent_msgs__msg__HingeJointPos__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> HingeJointPos { HingeJointPos { name : msg . name . to_str () . to_owned () , ax : msg . ax , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . name . assign (& self . name) ; msg . ax = self . ax ; } } impl Default for HingeJointPos { fn default () -> Self { let msg_native = WrappedNativeMsg :: < HingeJointPos > :: new () ; HingeJointPos :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct HingeJointVel { pub name : std :: string :: String , pub ax : f32 } impl WrappedTypesupport for HingeJointVel { type CStruct = rcss3d_agent_msgs__msg__HingeJointVel ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rcss3d_agent_msgs__msg__HingeJointVel () } } fn create_msg () -> * mut rcss3d_agent_msgs__msg__HingeJointVel { unsafe { rcss3d_agent_msgs__msg__HingeJointVel__create () } } fn destroy_msg (msg : * mut rcss3d_agent_msgs__msg__HingeJointVel) -> () { unsafe { rcss3d_agent_msgs__msg__HingeJointVel__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> HingeJointVel { HingeJointVel { name : msg . name . to_str () . to_owned () , ax : msg . ax , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . name . assign (& self . name) ; msg . ax = self . ax ; } } impl Default for HingeJointVel { fn default () -> Self { let msg_native = WrappedNativeMsg :: < HingeJointVel > :: new () ; HingeJointVel :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Percept { pub gyro_rates : Vec < rcss3d_agent_msgs :: msg :: GyroRate > , pub hinge_joints : Vec < rcss3d_agent_msgs :: msg :: HingeJointPos > , pub universal_joints : Vec < rcss3d_agent_msgs :: msg :: UniversalJointPos > , pub force_resistances : Vec < rcss3d_agent_msgs :: msg :: ForceResistance > , pub accelerometers : Vec < rcss3d_agent_msgs :: msg :: Accelerometer > , pub vision : Vec < rcss3d_agent_msgs :: msg :: Vision > , pub game_state : rcss3d_agent_msgs :: msg :: GameState , pub agent_state : Vec < rcss3d_agent_msgs :: msg :: AgentState > , pub hears : Vec < rcss3d_agent_msgs :: msg :: Hear > } impl WrappedTypesupport for Percept { type CStruct = rcss3d_agent_msgs__msg__Percept ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rcss3d_agent_msgs__msg__Percept () } } fn create_msg () -> * mut rcss3d_agent_msgs__msg__Percept { unsafe { rcss3d_agent_msgs__msg__Percept__create () } } fn destroy_msg (msg : * mut rcss3d_agent_msgs__msg__Percept) -> () { unsafe { rcss3d_agent_msgs__msg__Percept__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Percept { Percept { gyro_rates : { let mut temp = Vec :: with_capacity (msg . gyro_rates . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . gyro_rates . data , msg . gyro_rates . size) } ; for s in slice { temp . push (rcss3d_agent_msgs :: msg :: GyroRate :: from_native (s)) ; } temp } , hinge_joints : { let mut temp = Vec :: with_capacity (msg . hinge_joints . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . hinge_joints . data , msg . hinge_joints . size) } ; for s in slice { temp . push (rcss3d_agent_msgs :: msg :: HingeJointPos :: from_native (s)) ; } temp } , universal_joints : { let mut temp = Vec :: with_capacity (msg . universal_joints . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . universal_joints . data , msg . universal_joints . size) } ; for s in slice { temp . push (rcss3d_agent_msgs :: msg :: UniversalJointPos :: from_native (s)) ; } temp } , force_resistances : { let mut temp = Vec :: with_capacity (msg . force_resistances . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . force_resistances . data , msg . force_resistances . size) } ; for s in slice { temp . push (rcss3d_agent_msgs :: msg :: ForceResistance :: from_native (s)) ; } temp } , accelerometers : { let mut temp = Vec :: with_capacity (msg . accelerometers . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . accelerometers . data , msg . accelerometers . size) } ; for s in slice { temp . push (rcss3d_agent_msgs :: msg :: Accelerometer :: from_native (s)) ; } temp } , vision : { let mut temp = Vec :: with_capacity (msg . vision . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . vision . data , msg . vision . size) } ; for s in slice { temp . push (rcss3d_agent_msgs :: msg :: Vision :: from_native (s)) ; } temp } , game_state : rcss3d_agent_msgs :: msg :: GameState :: from_native (& msg . game_state) , agent_state : { let mut temp = Vec :: with_capacity (msg . agent_state . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . agent_state . data , msg . agent_state . size) } ; for s in slice { temp . push (rcss3d_agent_msgs :: msg :: AgentState :: from_native (s)) ; } temp } , hears : { let mut temp = Vec :: with_capacity (msg . hears . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . hears . data , msg . hears . size) } ; for s in slice { temp . push (rcss3d_agent_msgs :: msg :: Hear :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { unsafe { rcss3d_agent_msgs__msg__GyroRate__Sequence__fini (& mut msg . gyro_rates) ; rcss3d_agent_msgs__msg__GyroRate__Sequence__init (& mut msg . gyro_rates , self . gyro_rates . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . gyro_rates . data , msg . gyro_rates . size) ; for (t , s) in slice . iter_mut () . zip (& self . gyro_rates) { s . copy_to_native (t) ; } } unsafe { rcss3d_agent_msgs__msg__HingeJointPos__Sequence__fini (& mut msg . hinge_joints) ; rcss3d_agent_msgs__msg__HingeJointPos__Sequence__init (& mut msg . hinge_joints , self . hinge_joints . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . hinge_joints . data , msg . hinge_joints . size) ; for (t , s) in slice . iter_mut () . zip (& self . hinge_joints) { s . copy_to_native (t) ; } } unsafe { rcss3d_agent_msgs__msg__UniversalJointPos__Sequence__fini (& mut msg . universal_joints) ; rcss3d_agent_msgs__msg__UniversalJointPos__Sequence__init (& mut msg . universal_joints , self . universal_joints . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . universal_joints . data , msg . universal_joints . size) ; for (t , s) in slice . iter_mut () . zip (& self . universal_joints) { s . copy_to_native (t) ; } } unsafe { rcss3d_agent_msgs__msg__ForceResistance__Sequence__fini (& mut msg . force_resistances) ; rcss3d_agent_msgs__msg__ForceResistance__Sequence__init (& mut msg . force_resistances , self . force_resistances . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . force_resistances . data , msg . force_resistances . size) ; for (t , s) in slice . iter_mut () . zip (& self . force_resistances) { s . copy_to_native (t) ; } } unsafe { rcss3d_agent_msgs__msg__Accelerometer__Sequence__fini (& mut msg . accelerometers) ; rcss3d_agent_msgs__msg__Accelerometer__Sequence__init (& mut msg . accelerometers , self . accelerometers . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . accelerometers . data , msg . accelerometers . size) ; for (t , s) in slice . iter_mut () . zip (& self . accelerometers) { s . copy_to_native (t) ; } } unsafe { rcss3d_agent_msgs__msg__Vision__Sequence__fini (& mut msg . vision) ; rcss3d_agent_msgs__msg__Vision__Sequence__init (& mut msg . vision , self . vision . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . vision . data , msg . vision . size) ; for (t , s) in slice . iter_mut () . zip (& self . vision) { s . copy_to_native (t) ; } } self . game_state . copy_to_native (& mut msg . game_state) ; unsafe { rcss3d_agent_msgs__msg__AgentState__Sequence__fini (& mut msg . agent_state) ; rcss3d_agent_msgs__msg__AgentState__Sequence__init (& mut msg . agent_state , self . agent_state . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . agent_state . data , msg . agent_state . size) ; for (t , s) in slice . iter_mut () . zip (& self . agent_state) { s . copy_to_native (t) ; } } unsafe { rcss3d_agent_msgs__msg__Hear__Sequence__fini (& mut msg . hears) ; rcss3d_agent_msgs__msg__Hear__Sequence__init (& mut msg . hears , self . hears . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . hears . data , msg . hears . size) ; for (t , s) in slice . iter_mut () . zip (& self . hears) { s . copy_to_native (t) ; } } } } impl Default for Percept { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Percept > :: new () ; Percept :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Player { pub team : std :: string :: String , pub id : i32 , pub head : Vec < rcss3d_agent_msgs :: msg :: Spherical > , pub rlowerarm : Vec < rcss3d_agent_msgs :: msg :: Spherical > , pub llowerarm : Vec < rcss3d_agent_msgs :: msg :: Spherical > , pub rfoot : Vec < rcss3d_agent_msgs :: msg :: Spherical > , pub lfoot : Vec < rcss3d_agent_msgs :: msg :: Spherical > } impl WrappedTypesupport for Player { type CStruct = rcss3d_agent_msgs__msg__Player ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rcss3d_agent_msgs__msg__Player () } } fn create_msg () -> * mut rcss3d_agent_msgs__msg__Player { unsafe { rcss3d_agent_msgs__msg__Player__create () } } fn destroy_msg (msg : * mut rcss3d_agent_msgs__msg__Player) -> () { unsafe { rcss3d_agent_msgs__msg__Player__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Player { Player { team : msg . team . to_str () . to_owned () , id : msg . id , head : { let mut temp = Vec :: with_capacity (msg . head . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . head . data , msg . head . size) } ; for s in slice { temp . push (rcss3d_agent_msgs :: msg :: Spherical :: from_native (s)) ; } temp } , rlowerarm : { let mut temp = Vec :: with_capacity (msg . rlowerarm . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . rlowerarm . data , msg . rlowerarm . size) } ; for s in slice { temp . push (rcss3d_agent_msgs :: msg :: Spherical :: from_native (s)) ; } temp } , llowerarm : { let mut temp = Vec :: with_capacity (msg . llowerarm . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . llowerarm . data , msg . llowerarm . size) } ; for s in slice { temp . push (rcss3d_agent_msgs :: msg :: Spherical :: from_native (s)) ; } temp } , rfoot : { let mut temp = Vec :: with_capacity (msg . rfoot . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . rfoot . data , msg . rfoot . size) } ; for s in slice { temp . push (rcss3d_agent_msgs :: msg :: Spherical :: from_native (s)) ; } temp } , lfoot : { let mut temp = Vec :: with_capacity (msg . lfoot . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . lfoot . data , msg . lfoot . size) } ; for s in slice { temp . push (rcss3d_agent_msgs :: msg :: Spherical :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . team . assign (& self . team) ; msg . id = self . id ; unsafe { rcss3d_agent_msgs__msg__Spherical__Sequence__fini (& mut msg . head) ; rcss3d_agent_msgs__msg__Spherical__Sequence__init (& mut msg . head , self . head . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . head . data , msg . head . size) ; for (t , s) in slice . iter_mut () . zip (& self . head) { s . copy_to_native (t) ; } } unsafe { rcss3d_agent_msgs__msg__Spherical__Sequence__fini (& mut msg . rlowerarm) ; rcss3d_agent_msgs__msg__Spherical__Sequence__init (& mut msg . rlowerarm , self . rlowerarm . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . rlowerarm . data , msg . rlowerarm . size) ; for (t , s) in slice . iter_mut () . zip (& self . rlowerarm) { s . copy_to_native (t) ; } } unsafe { rcss3d_agent_msgs__msg__Spherical__Sequence__fini (& mut msg . llowerarm) ; rcss3d_agent_msgs__msg__Spherical__Sequence__init (& mut msg . llowerarm , self . llowerarm . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . llowerarm . data , msg . llowerarm . size) ; for (t , s) in slice . iter_mut () . zip (& self . llowerarm) { s . copy_to_native (t) ; } } unsafe { rcss3d_agent_msgs__msg__Spherical__Sequence__fini (& mut msg . rfoot) ; rcss3d_agent_msgs__msg__Spherical__Sequence__init (& mut msg . rfoot , self . rfoot . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . rfoot . data , msg . rfoot . size) ; for (t , s) in slice . iter_mut () . zip (& self . rfoot) { s . copy_to_native (t) ; } } unsafe { rcss3d_agent_msgs__msg__Spherical__Sequence__fini (& mut msg . lfoot) ; rcss3d_agent_msgs__msg__Spherical__Sequence__init (& mut msg . lfoot , self . lfoot . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . lfoot . data , msg . lfoot . size) ; for (t , s) in slice . iter_mut () . zip (& self . lfoot) { s . copy_to_native (t) ; } } } } impl Default for Player { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Player > :: new () ; Player :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Say { pub message : std :: string :: String } impl WrappedTypesupport for Say { type CStruct = rcss3d_agent_msgs__msg__Say ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rcss3d_agent_msgs__msg__Say () } } fn create_msg () -> * mut rcss3d_agent_msgs__msg__Say { unsafe { rcss3d_agent_msgs__msg__Say__create () } } fn destroy_msg (msg : * mut rcss3d_agent_msgs__msg__Say) -> () { unsafe { rcss3d_agent_msgs__msg__Say__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Say { Say { message : msg . message . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . message . assign (& self . message) ; } } impl Default for Say { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Say > :: new () ; Say :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Spherical { pub r : f32 , pub phi : f32 , pub theta : f32 } impl WrappedTypesupport for Spherical { type CStruct = rcss3d_agent_msgs__msg__Spherical ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rcss3d_agent_msgs__msg__Spherical () } } fn create_msg () -> * mut rcss3d_agent_msgs__msg__Spherical { unsafe { rcss3d_agent_msgs__msg__Spherical__create () } } fn destroy_msg (msg : * mut rcss3d_agent_msgs__msg__Spherical) -> () { unsafe { rcss3d_agent_msgs__msg__Spherical__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Spherical { Spherical { r : msg . r , phi : msg . phi , theta : msg . theta , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . r = self . r ; msg . phi = self . phi ; msg . theta = self . theta ; } } impl Default for Spherical { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Spherical > :: new () ; Spherical :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Synchronize { } impl WrappedTypesupport for Synchronize { type CStruct = rcss3d_agent_msgs__msg__Synchronize ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rcss3d_agent_msgs__msg__Synchronize () } } fn create_msg () -> * mut rcss3d_agent_msgs__msg__Synchronize { unsafe { rcss3d_agent_msgs__msg__Synchronize__create () } } fn destroy_msg (msg : * mut rcss3d_agent_msgs__msg__Synchronize) -> () { unsafe { rcss3d_agent_msgs__msg__Synchronize__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Synchronize { Synchronize { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Synchronize { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Synchronize > :: new () ; Synchronize :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct UniversalJointPos { pub name : std :: string :: String , pub ax1 : f32 , pub ax2 : f32 } impl WrappedTypesupport for UniversalJointPos { type CStruct = rcss3d_agent_msgs__msg__UniversalJointPos ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rcss3d_agent_msgs__msg__UniversalJointPos () } } fn create_msg () -> * mut rcss3d_agent_msgs__msg__UniversalJointPos { unsafe { rcss3d_agent_msgs__msg__UniversalJointPos__create () } } fn destroy_msg (msg : * mut rcss3d_agent_msgs__msg__UniversalJointPos) -> () { unsafe { rcss3d_agent_msgs__msg__UniversalJointPos__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> UniversalJointPos { UniversalJointPos { name : msg . name . to_str () . to_owned () , ax1 : msg . ax1 , ax2 : msg . ax2 , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . name . assign (& self . name) ; msg . ax1 = self . ax1 ; msg . ax2 = self . ax2 ; } } impl Default for UniversalJointPos { fn default () -> Self { let msg_native = WrappedNativeMsg :: < UniversalJointPos > :: new () ; UniversalJointPos :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct UniversalJointVel { pub name : std :: string :: String , pub ax1 : f32 , pub ax2 : f32 } impl WrappedTypesupport for UniversalJointVel { type CStruct = rcss3d_agent_msgs__msg__UniversalJointVel ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rcss3d_agent_msgs__msg__UniversalJointVel () } } fn create_msg () -> * mut rcss3d_agent_msgs__msg__UniversalJointVel { unsafe { rcss3d_agent_msgs__msg__UniversalJointVel__create () } } fn destroy_msg (msg : * mut rcss3d_agent_msgs__msg__UniversalJointVel) -> () { unsafe { rcss3d_agent_msgs__msg__UniversalJointVel__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> UniversalJointVel { UniversalJointVel { name : msg . name . to_str () . to_owned () , ax1 : msg . ax1 , ax2 : msg . ax2 , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . name . assign (& self . name) ; msg . ax1 = self . ax1 ; msg . ax2 = self . ax2 ; } } impl Default for UniversalJointVel { fn default () -> Self { let msg_native = WrappedNativeMsg :: < UniversalJointVel > :: new () ; UniversalJointVel :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Vision { pub ball : Vec < rcss3d_agent_msgs :: msg :: Ball > , pub field_lines : Vec < rcss3d_agent_msgs :: msg :: FieldLine > , pub flags : Vec < rcss3d_agent_msgs :: msg :: Flag > , pub goalposts : Vec < rcss3d_agent_msgs :: msg :: Goalpost > , pub players : Vec < rcss3d_agent_msgs :: msg :: Player > } impl WrappedTypesupport for Vision { type CStruct = rcss3d_agent_msgs__msg__Vision ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rcss3d_agent_msgs__msg__Vision () } } fn create_msg () -> * mut rcss3d_agent_msgs__msg__Vision { unsafe { rcss3d_agent_msgs__msg__Vision__create () } } fn destroy_msg (msg : * mut rcss3d_agent_msgs__msg__Vision) -> () { unsafe { rcss3d_agent_msgs__msg__Vision__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Vision { Vision { ball : { let mut temp = Vec :: with_capacity (msg . ball . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . ball . data , msg . ball . size) } ; for s in slice { temp . push (rcss3d_agent_msgs :: msg :: Ball :: from_native (s)) ; } temp } , field_lines : { let mut temp = Vec :: with_capacity (msg . field_lines . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . field_lines . data , msg . field_lines . size) } ; for s in slice { temp . push (rcss3d_agent_msgs :: msg :: FieldLine :: from_native (s)) ; } temp } , flags : { let mut temp = Vec :: with_capacity (msg . flags . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . flags . data , msg . flags . size) } ; for s in slice { temp . push (rcss3d_agent_msgs :: msg :: Flag :: from_native (s)) ; } temp } , goalposts : { let mut temp = Vec :: with_capacity (msg . goalposts . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . goalposts . data , msg . goalposts . size) } ; for s in slice { temp . push (rcss3d_agent_msgs :: msg :: Goalpost :: from_native (s)) ; } temp } , players : { let mut temp = Vec :: with_capacity (msg . players . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . players . data , msg . players . size) } ; for s in slice { temp . push (rcss3d_agent_msgs :: msg :: Player :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { unsafe { rcss3d_agent_msgs__msg__Ball__Sequence__fini (& mut msg . ball) ; rcss3d_agent_msgs__msg__Ball__Sequence__init (& mut msg . ball , self . ball . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . ball . data , msg . ball . size) ; for (t , s) in slice . iter_mut () . zip (& self . ball) { s . copy_to_native (t) ; } } unsafe { rcss3d_agent_msgs__msg__FieldLine__Sequence__fini (& mut msg . field_lines) ; rcss3d_agent_msgs__msg__FieldLine__Sequence__init (& mut msg . field_lines , self . field_lines . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . field_lines . data , msg . field_lines . size) ; for (t , s) in slice . iter_mut () . zip (& self . field_lines) { s . copy_to_native (t) ; } } unsafe { rcss3d_agent_msgs__msg__Flag__Sequence__fini (& mut msg . flags) ; rcss3d_agent_msgs__msg__Flag__Sequence__init (& mut msg . flags , self . flags . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . flags . data , msg . flags . size) ; for (t , s) in slice . iter_mut () . zip (& self . flags) { s . copy_to_native (t) ; } } unsafe { rcss3d_agent_msgs__msg__Goalpost__Sequence__fini (& mut msg . goalposts) ; rcss3d_agent_msgs__msg__Goalpost__Sequence__init (& mut msg . goalposts , self . goalposts . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . goalposts . data , msg . goalposts . size) ; for (t , s) in slice . iter_mut () . zip (& self . goalposts) { s . copy_to_native (t) ; } } unsafe { rcss3d_agent_msgs__msg__Player__Sequence__fini (& mut msg . players) ; rcss3d_agent_msgs__msg__Player__Sequence__init (& mut msg . players , self . players . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . players . data , msg . players . size) ; for (t , s) in slice . iter_mut () . zip (& self . players) { s . copy_to_native (t) ; } } } } impl Default for Vision { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Vision > :: new () ; Vision :: from_native (& msg_native) } } }