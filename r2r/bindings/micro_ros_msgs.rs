pub mod msg { use super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Entity { pub entity_type : u8 , pub name : std :: string :: String , pub types : Vec < std :: string :: String > } impl WrappedTypesupport for Entity { type CStruct = micro_ros_msgs__msg__Entity ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__micro_ros_msgs__msg__Entity () } } fn create_msg () -> * mut micro_ros_msgs__msg__Entity { unsafe { micro_ros_msgs__msg__Entity__create () } } fn destroy_msg (msg : * mut micro_ros_msgs__msg__Entity) -> () { unsafe { micro_ros_msgs__msg__Entity__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Entity { Entity { entity_type : msg . entity_type , name : msg . name . to_str () . to_owned () , types : msg . types . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . entity_type = self . entity_type ; msg . name . assign (& self . name) ; msg . types . update (& self . types) ; } } impl Default for Entity { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Entity > :: new () ; Entity :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl Entity { pub const PUBLISHER : _bindgen_ty_866 = micro_ros_msgs__msg__Entity__PUBLISHER ; pub const SERVICE_CLIENT : _bindgen_ty_869 = micro_ros_msgs__msg__Entity__SERVICE_CLIENT ; pub const SERVICE_SERVER : _bindgen_ty_868 = micro_ros_msgs__msg__Entity__SERVICE_SERVER ; pub const SUBSCRIBER : _bindgen_ty_867 = micro_ros_msgs__msg__Entity__SUBSCRIBER ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Graph { pub nodes : Vec < micro_ros_msgs :: msg :: Node > } impl WrappedTypesupport for Graph { type CStruct = micro_ros_msgs__msg__Graph ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__micro_ros_msgs__msg__Graph () } } fn create_msg () -> * mut micro_ros_msgs__msg__Graph { unsafe { micro_ros_msgs__msg__Graph__create () } } fn destroy_msg (msg : * mut micro_ros_msgs__msg__Graph) -> () { unsafe { micro_ros_msgs__msg__Graph__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Graph { Graph { nodes : { let mut temp = Vec :: with_capacity (msg . nodes . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . nodes . data , msg . nodes . size) } ; for s in slice { temp . push (micro_ros_msgs :: msg :: Node :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { unsafe { micro_ros_msgs__msg__Node__Sequence__fini (& mut msg . nodes) ; micro_ros_msgs__msg__Node__Sequence__init (& mut msg . nodes , self . nodes . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . nodes . data , msg . nodes . size) ; for (t , s) in slice . iter_mut () . zip (& self . nodes) { s . copy_to_native (t) ; } } } } impl Default for Graph { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Graph > :: new () ; Graph :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Node { pub node_namespace : std :: string :: String , pub node_name : std :: string :: String , pub entities : Vec < micro_ros_msgs :: msg :: Entity > } impl WrappedTypesupport for Node { type CStruct = micro_ros_msgs__msg__Node ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__micro_ros_msgs__msg__Node () } } fn create_msg () -> * mut micro_ros_msgs__msg__Node { unsafe { micro_ros_msgs__msg__Node__create () } } fn destroy_msg (msg : * mut micro_ros_msgs__msg__Node) -> () { unsafe { micro_ros_msgs__msg__Node__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Node { Node { node_namespace : msg . node_namespace . to_str () . to_owned () , node_name : msg . node_name . to_str () . to_owned () , entities : { let mut temp = Vec :: with_capacity (msg . entities . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . entities . data , msg . entities . size) } ; for s in slice { temp . push (micro_ros_msgs :: msg :: Entity :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . node_namespace . assign (& self . node_namespace) ; msg . node_name . assign (& self . node_name) ; unsafe { micro_ros_msgs__msg__Entity__Sequence__fini (& mut msg . entities) ; micro_ros_msgs__msg__Entity__Sequence__init (& mut msg . entities , self . entities . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . entities . data , msg . entities . size) ; for (t , s) in slice . iter_mut () . zip (& self . entities) { s . copy_to_native (t) ; } } } } impl Default for Node { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Node > :: new () ; Node :: from_native (& msg_native) } } }