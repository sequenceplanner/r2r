pub mod srv { # [allow (non_snake_case)] pub mod Trigger { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__rc_common_msgs__srv__Trigger () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { } impl WrappedTypesupport for Request { type CStruct = rc_common_msgs__srv__Trigger_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rc_common_msgs__srv__Trigger_Request () } } fn create_msg () -> * mut rc_common_msgs__srv__Trigger_Request { unsafe { rc_common_msgs__srv__Trigger_Request__create () } } fn destroy_msg (msg : * mut rc_common_msgs__srv__Trigger_Request) -> () { unsafe { rc_common_msgs__srv__Trigger_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub return_code : rc_common_msgs :: msg :: ReturnCode } impl WrappedTypesupport for Response { type CStruct = rc_common_msgs__srv__Trigger_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rc_common_msgs__srv__Trigger_Response () } } fn create_msg () -> * mut rc_common_msgs__srv__Trigger_Response { unsafe { rc_common_msgs__srv__Trigger_Response__create () } } fn destroy_msg (msg : * mut rc_common_msgs__srv__Trigger_Response) -> () { unsafe { rc_common_msgs__srv__Trigger_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { return_code : rc_common_msgs :: msg :: ReturnCode :: from_native (& msg . return_code) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . return_code . copy_to_native (& mut msg . return_code) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } } pub mod msg { use super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct CameraParam { pub header : std_msgs :: msg :: Header , pub is_color_camera : bool , pub exposure_time : f32 , pub gain : f32 , pub line_status_all : u32 , pub line_source : Vec < rc_common_msgs :: msg :: KeyValue > , pub extra_data : Vec < rc_common_msgs :: msg :: KeyValue > } impl WrappedTypesupport for CameraParam { type CStruct = rc_common_msgs__msg__CameraParam ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rc_common_msgs__msg__CameraParam () } } fn create_msg () -> * mut rc_common_msgs__msg__CameraParam { unsafe { rc_common_msgs__msg__CameraParam__create () } } fn destroy_msg (msg : * mut rc_common_msgs__msg__CameraParam) -> () { unsafe { rc_common_msgs__msg__CameraParam__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> CameraParam { CameraParam { header : std_msgs :: msg :: Header :: from_native (& msg . header) , is_color_camera : msg . is_color_camera , exposure_time : msg . exposure_time , gain : msg . gain , line_status_all : msg . line_status_all , line_source : { let mut temp = Vec :: with_capacity (msg . line_source . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . line_source . data , msg . line_source . size) } ; for s in slice { temp . push (rc_common_msgs :: msg :: KeyValue :: from_native (s)) ; } temp } , extra_data : { let mut temp = Vec :: with_capacity (msg . extra_data . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . extra_data . data , msg . extra_data . size) } ; for s in slice { temp . push (rc_common_msgs :: msg :: KeyValue :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . is_color_camera = self . is_color_camera ; msg . exposure_time = self . exposure_time ; msg . gain = self . gain ; msg . line_status_all = self . line_status_all ; unsafe { rc_common_msgs__msg__KeyValue__Sequence__fini (& mut msg . line_source) ; rc_common_msgs__msg__KeyValue__Sequence__init (& mut msg . line_source , self . line_source . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . line_source . data , msg . line_source . size) ; for (t , s) in slice . iter_mut () . zip (& self . line_source) { s . copy_to_native (t) ; } } unsafe { rc_common_msgs__msg__KeyValue__Sequence__fini (& mut msg . extra_data) ; rc_common_msgs__msg__KeyValue__Sequence__init (& mut msg . extra_data , self . extra_data . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . extra_data . data , msg . extra_data . size) ; for (t , s) in slice . iter_mut () . zip (& self . extra_data) { s . copy_to_native (t) ; } } } } impl Default for CameraParam { fn default () -> Self { let msg_native = WrappedNativeMsg :: < CameraParam > :: new () ; CameraParam :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct KeyValue { pub key : std :: string :: String , pub value : std :: string :: String } impl WrappedTypesupport for KeyValue { type CStruct = rc_common_msgs__msg__KeyValue ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rc_common_msgs__msg__KeyValue () } } fn create_msg () -> * mut rc_common_msgs__msg__KeyValue { unsafe { rc_common_msgs__msg__KeyValue__create () } } fn destroy_msg (msg : * mut rc_common_msgs__msg__KeyValue) -> () { unsafe { rc_common_msgs__msg__KeyValue__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> KeyValue { KeyValue { key : msg . key . to_str () . to_owned () , value : msg . value . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . key . assign (& self . key) ; msg . value . assign (& self . value) ; } } impl Default for KeyValue { fn default () -> Self { let msg_native = WrappedNativeMsg :: < KeyValue > :: new () ; KeyValue :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ReturnCode { pub value : i16 , pub message : std :: string :: String } impl WrappedTypesupport for ReturnCode { type CStruct = rc_common_msgs__msg__ReturnCode ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rc_common_msgs__msg__ReturnCode () } } fn create_msg () -> * mut rc_common_msgs__msg__ReturnCode { unsafe { rc_common_msgs__msg__ReturnCode__create () } } fn destroy_msg (msg : * mut rc_common_msgs__msg__ReturnCode) -> () { unsafe { rc_common_msgs__msg__ReturnCode__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ReturnCode { ReturnCode { value : msg . value , message : msg . message . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . value = self . value ; msg . message . assign (& self . message) ; } } impl Default for ReturnCode { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ReturnCode > :: new () ; ReturnCode :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ReturnCodeConstants { } impl WrappedTypesupport for ReturnCodeConstants { type CStruct = rc_common_msgs__msg__ReturnCodeConstants ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rc_common_msgs__msg__ReturnCodeConstants () } } fn create_msg () -> * mut rc_common_msgs__msg__ReturnCodeConstants { unsafe { rc_common_msgs__msg__ReturnCodeConstants__create () } } fn destroy_msg (msg : * mut rc_common_msgs__msg__ReturnCodeConstants) -> () { unsafe { rc_common_msgs__msg__ReturnCodeConstants__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ReturnCodeConstants { ReturnCodeConstants { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for ReturnCodeConstants { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ReturnCodeConstants > :: new () ; ReturnCodeConstants :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl ReturnCodeConstants { pub const CAPACITY_EXCEEDED : _bindgen_ty_1426 = rc_common_msgs__msg__ReturnCodeConstants__CAPACITY_EXCEEDED ; pub const CAPACITY_REACHED : _bindgen_ty_1428 = rc_common_msgs__msg__ReturnCodeConstants__CAPACITY_REACHED ; pub const HINTS : _bindgen_ty_1430 = rc_common_msgs__msg__ReturnCodeConstants__HINTS ; pub const INTERNAL_ERROR : _bindgen_ty_1420 = rc_common_msgs__msg__ReturnCodeConstants__INTERNAL_ERROR ; pub const INTERNAL_TIMEOUT : _bindgen_ty_1421 = rc_common_msgs__msg__ReturnCodeConstants__INTERNAL_TIMEOUT ; pub const INVALID_ARGUMENT : _bindgen_ty_1419 = rc_common_msgs__msg__ReturnCodeConstants__INVALID_ARGUMENT ; pub const INVALID_LICENSE : _bindgen_ty_1425 = rc_common_msgs__msg__ReturnCodeConstants__INVALID_LICENSE ; pub const IO_ERROR : _bindgen_ty_1423 = rc_common_msgs__msg__ReturnCodeConstants__IO_ERROR ; pub const NOT_APPLICABLE : _bindgen_ty_1424 = rc_common_msgs__msg__ReturnCodeConstants__NOT_APPLICABLE ; pub const OVERWRITTEN : _bindgen_ty_1429 = rc_common_msgs__msg__ReturnCodeConstants__OVERWRITTEN ; pub const SENSOR_TIMEOUT : _bindgen_ty_1422 = rc_common_msgs__msg__ReturnCodeConstants__SENSOR_TIMEOUT ; pub const SUCCESS : _bindgen_ty_1418 = rc_common_msgs__msg__ReturnCodeConstants__SUCCESS ; pub const TIMEOUT_REACHED : _bindgen_ty_1427 = rc_common_msgs__msg__ReturnCodeConstants__TIMEOUT_REACHED ; } }