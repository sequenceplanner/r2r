pub mod msg { use super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct AutoFocusCtrl { pub auto_focus_mode : u8 , pub trigger_auto_focus : bool } impl WrappedTypesupport for AutoFocusCtrl { type CStruct = depthai_ros_msgs__msg__AutoFocusCtrl ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__depthai_ros_msgs__msg__AutoFocusCtrl () } } fn create_msg () -> * mut depthai_ros_msgs__msg__AutoFocusCtrl { unsafe { depthai_ros_msgs__msg__AutoFocusCtrl__create () } } fn destroy_msg (msg : * mut depthai_ros_msgs__msg__AutoFocusCtrl) -> () { unsafe { depthai_ros_msgs__msg__AutoFocusCtrl__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> AutoFocusCtrl { AutoFocusCtrl { auto_focus_mode : msg . auto_focus_mode , trigger_auto_focus : msg . trigger_auto_focus , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . auto_focus_mode = self . auto_focus_mode ; msg . trigger_auto_focus = self . trigger_auto_focus ; } } impl Default for AutoFocusCtrl { fn default () -> Self { let msg_native = WrappedNativeMsg :: < AutoFocusCtrl > :: new () ; AutoFocusCtrl :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl AutoFocusCtrl { pub const AF_MODE_AUTO : _bindgen_ty_162 = depthai_ros_msgs__msg__AutoFocusCtrl__AF_MODE_AUTO ; pub const AF_MODE_CONTINUOUS_PICTURE : _bindgen_ty_165 = depthai_ros_msgs__msg__AutoFocusCtrl__AF_MODE_CONTINUOUS_PICTURE ; pub const AF_MODE_CONTINUOUS_VIDEO : _bindgen_ty_164 = depthai_ros_msgs__msg__AutoFocusCtrl__AF_MODE_CONTINUOUS_VIDEO ; pub const AF_MODE_EDOF : _bindgen_ty_166 = depthai_ros_msgs__msg__AutoFocusCtrl__AF_MODE_EDOF ; pub const AF_MODE_MACRO : _bindgen_ty_163 = depthai_ros_msgs__msg__AutoFocusCtrl__AF_MODE_MACRO ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct HandLandmark { pub label : std :: string :: String , pub lm_score : f32 , pub landmark : Vec < geometry_msgs :: msg :: Pose2D > , pub position : geometry_msgs :: msg :: Point , pub is_spatial : bool } impl WrappedTypesupport for HandLandmark { type CStruct = depthai_ros_msgs__msg__HandLandmark ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__depthai_ros_msgs__msg__HandLandmark () } } fn create_msg () -> * mut depthai_ros_msgs__msg__HandLandmark { unsafe { depthai_ros_msgs__msg__HandLandmark__create () } } fn destroy_msg (msg : * mut depthai_ros_msgs__msg__HandLandmark) -> () { unsafe { depthai_ros_msgs__msg__HandLandmark__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> HandLandmark { HandLandmark { label : msg . label . to_str () . to_owned () , lm_score : msg . lm_score , landmark : { let mut temp = Vec :: with_capacity (msg . landmark . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . landmark . data , msg . landmark . size) } ; for s in slice { temp . push (geometry_msgs :: msg :: Pose2D :: from_native (s)) ; } temp } , position : geometry_msgs :: msg :: Point :: from_native (& msg . position) , is_spatial : msg . is_spatial , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . label . assign (& self . label) ; msg . lm_score = self . lm_score ; unsafe { geometry_msgs__msg__Pose2D__Sequence__fini (& mut msg . landmark) ; geometry_msgs__msg__Pose2D__Sequence__init (& mut msg . landmark , self . landmark . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . landmark . data , msg . landmark . size) ; for (t , s) in slice . iter_mut () . zip (& self . landmark) { s . copy_to_native (t) ; } } self . position . copy_to_native (& mut msg . position) ; msg . is_spatial = self . is_spatial ; } } impl Default for HandLandmark { fn default () -> Self { let msg_native = WrappedNativeMsg :: < HandLandmark > :: new () ; HandLandmark :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct HandLandmarkArray { pub header : std_msgs :: msg :: Header , pub landmarks : Vec < depthai_ros_msgs :: msg :: HandLandmark > } impl WrappedTypesupport for HandLandmarkArray { type CStruct = depthai_ros_msgs__msg__HandLandmarkArray ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__depthai_ros_msgs__msg__HandLandmarkArray () } } fn create_msg () -> * mut depthai_ros_msgs__msg__HandLandmarkArray { unsafe { depthai_ros_msgs__msg__HandLandmarkArray__create () } } fn destroy_msg (msg : * mut depthai_ros_msgs__msg__HandLandmarkArray) -> () { unsafe { depthai_ros_msgs__msg__HandLandmarkArray__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> HandLandmarkArray { HandLandmarkArray { header : std_msgs :: msg :: Header :: from_native (& msg . header) , landmarks : { let mut temp = Vec :: with_capacity (msg . landmarks . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . landmarks . data , msg . landmarks . size) } ; for s in slice { temp . push (depthai_ros_msgs :: msg :: HandLandmark :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; unsafe { depthai_ros_msgs__msg__HandLandmark__Sequence__fini (& mut msg . landmarks) ; depthai_ros_msgs__msg__HandLandmark__Sequence__init (& mut msg . landmarks , self . landmarks . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . landmarks . data , msg . landmarks . size) ; for (t , s) in slice . iter_mut () . zip (& self . landmarks) { s . copy_to_native (t) ; } } } } impl Default for HandLandmarkArray { fn default () -> Self { let msg_native = WrappedNativeMsg :: < HandLandmarkArray > :: new () ; HandLandmarkArray :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct SpatialDetection { pub results : Vec < vision_msgs :: msg :: ObjectHypothesis > , pub bbox : vision_msgs :: msg :: BoundingBox2D , pub position : geometry_msgs :: msg :: Point , pub is_tracking : bool , pub tracking_id : std :: string :: String } impl WrappedTypesupport for SpatialDetection { type CStruct = depthai_ros_msgs__msg__SpatialDetection ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__depthai_ros_msgs__msg__SpatialDetection () } } fn create_msg () -> * mut depthai_ros_msgs__msg__SpatialDetection { unsafe { depthai_ros_msgs__msg__SpatialDetection__create () } } fn destroy_msg (msg : * mut depthai_ros_msgs__msg__SpatialDetection) -> () { unsafe { depthai_ros_msgs__msg__SpatialDetection__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> SpatialDetection { SpatialDetection { results : { let mut temp = Vec :: with_capacity (msg . results . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . results . data , msg . results . size) } ; for s in slice { temp . push (vision_msgs :: msg :: ObjectHypothesis :: from_native (s)) ; } temp } , bbox : vision_msgs :: msg :: BoundingBox2D :: from_native (& msg . bbox) , position : geometry_msgs :: msg :: Point :: from_native (& msg . position) , is_tracking : msg . is_tracking , tracking_id : msg . tracking_id . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { unsafe { vision_msgs__msg__ObjectHypothesis__Sequence__fini (& mut msg . results) ; vision_msgs__msg__ObjectHypothesis__Sequence__init (& mut msg . results , self . results . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . results . data , msg . results . size) ; for (t , s) in slice . iter_mut () . zip (& self . results) { s . copy_to_native (t) ; } } self . bbox . copy_to_native (& mut msg . bbox) ; self . position . copy_to_native (& mut msg . position) ; msg . is_tracking = self . is_tracking ; msg . tracking_id . assign (& self . tracking_id) ; } } impl Default for SpatialDetection { fn default () -> Self { let msg_native = WrappedNativeMsg :: < SpatialDetection > :: new () ; SpatialDetection :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct SpatialDetectionArray { pub header : std_msgs :: msg :: Header , pub detections : Vec < depthai_ros_msgs :: msg :: SpatialDetection > } impl WrappedTypesupport for SpatialDetectionArray { type CStruct = depthai_ros_msgs__msg__SpatialDetectionArray ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__depthai_ros_msgs__msg__SpatialDetectionArray () } } fn create_msg () -> * mut depthai_ros_msgs__msg__SpatialDetectionArray { unsafe { depthai_ros_msgs__msg__SpatialDetectionArray__create () } } fn destroy_msg (msg : * mut depthai_ros_msgs__msg__SpatialDetectionArray) -> () { unsafe { depthai_ros_msgs__msg__SpatialDetectionArray__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> SpatialDetectionArray { SpatialDetectionArray { header : std_msgs :: msg :: Header :: from_native (& msg . header) , detections : { let mut temp = Vec :: with_capacity (msg . detections . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . detections . data , msg . detections . size) } ; for s in slice { temp . push (depthai_ros_msgs :: msg :: SpatialDetection :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; unsafe { depthai_ros_msgs__msg__SpatialDetection__Sequence__fini (& mut msg . detections) ; depthai_ros_msgs__msg__SpatialDetection__Sequence__init (& mut msg . detections , self . detections . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . detections . data , msg . detections . size) ; for (t , s) in slice . iter_mut () . zip (& self . detections) { s . copy_to_native (t) ; } } } } impl Default for SpatialDetectionArray { fn default () -> Self { let msg_native = WrappedNativeMsg :: < SpatialDetectionArray > :: new () ; SpatialDetectionArray :: from_native (& msg_native) } } } pub mod srv { # [allow (non_snake_case)] pub mod NormalizedImageCrop { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__depthai_ros_msgs__srv__NormalizedImageCrop () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub top_left : geometry_msgs :: msg :: Pose2D , pub bottom_right : geometry_msgs :: msg :: Pose2D } impl WrappedTypesupport for Request { type CStruct = depthai_ros_msgs__srv__NormalizedImageCrop_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__depthai_ros_msgs__srv__NormalizedImageCrop_Request () } } fn create_msg () -> * mut depthai_ros_msgs__srv__NormalizedImageCrop_Request { unsafe { depthai_ros_msgs__srv__NormalizedImageCrop_Request__create () } } fn destroy_msg (msg : * mut depthai_ros_msgs__srv__NormalizedImageCrop_Request) -> () { unsafe { depthai_ros_msgs__srv__NormalizedImageCrop_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { top_left : geometry_msgs :: msg :: Pose2D :: from_native (& msg . top_left) , bottom_right : geometry_msgs :: msg :: Pose2D :: from_native (& msg . bottom_right) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . top_left . copy_to_native (& mut msg . top_left) ; self . bottom_right . copy_to_native (& mut msg . bottom_right) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub status : i64 } impl WrappedTypesupport for Response { type CStruct = depthai_ros_msgs__srv__NormalizedImageCrop_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__depthai_ros_msgs__srv__NormalizedImageCrop_Response () } } fn create_msg () -> * mut depthai_ros_msgs__srv__NormalizedImageCrop_Response { unsafe { depthai_ros_msgs__srv__NormalizedImageCrop_Response__create () } } fn destroy_msg (msg : * mut depthai_ros_msgs__srv__NormalizedImageCrop_Response) -> () { unsafe { depthai_ros_msgs__srv__NormalizedImageCrop_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { status : msg . status , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . status = self . status ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod TriggerNamed { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__depthai_ros_msgs__srv__TriggerNamed () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub name : std :: string :: String } impl WrappedTypesupport for Request { type CStruct = depthai_ros_msgs__srv__TriggerNamed_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__depthai_ros_msgs__srv__TriggerNamed_Request () } } fn create_msg () -> * mut depthai_ros_msgs__srv__TriggerNamed_Request { unsafe { depthai_ros_msgs__srv__TriggerNamed_Request__create () } } fn destroy_msg (msg : * mut depthai_ros_msgs__srv__TriggerNamed_Request) -> () { unsafe { depthai_ros_msgs__srv__TriggerNamed_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { name : msg . name . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . name . assign (& self . name) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool , pub message : std :: string :: String } impl WrappedTypesupport for Response { type CStruct = depthai_ros_msgs__srv__TriggerNamed_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__depthai_ros_msgs__srv__TriggerNamed_Response () } } fn create_msg () -> * mut depthai_ros_msgs__srv__TriggerNamed_Response { unsafe { depthai_ros_msgs__srv__TriggerNamed_Response__create () } } fn destroy_msg (msg : * mut depthai_ros_msgs__srv__TriggerNamed_Response) -> () { unsafe { depthai_ros_msgs__srv__TriggerNamed_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , message : msg . message . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; msg . message . assign (& self . message) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } }