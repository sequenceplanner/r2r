pub mod msg { use super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Edges { pub node_ids : Vec < u32 > , pub weights : Vec < f64 > } impl WrappedTypesupport for Edges { type CStruct = graph_msgs__msg__Edges ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__graph_msgs__msg__Edges () } } fn create_msg () -> * mut graph_msgs__msg__Edges { unsafe { graph_msgs__msg__Edges__create () } } fn destroy_msg (msg : * mut graph_msgs__msg__Edges) -> () { unsafe { graph_msgs__msg__Edges__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Edges { Edges { node_ids : msg . node_ids . to_vec () , weights : msg . weights . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . node_ids . update (& self . node_ids) ; msg . weights . update (& self . weights) ; } } impl Default for Edges { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Edges > :: new () ; Edges :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct GeometryGraph { pub header : std_msgs :: msg :: Header , pub nodes : Vec < geometry_msgs :: msg :: Point > , pub edges : Vec < graph_msgs :: msg :: Edges > } impl WrappedTypesupport for GeometryGraph { type CStruct = graph_msgs__msg__GeometryGraph ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__graph_msgs__msg__GeometryGraph () } } fn create_msg () -> * mut graph_msgs__msg__GeometryGraph { unsafe { graph_msgs__msg__GeometryGraph__create () } } fn destroy_msg (msg : * mut graph_msgs__msg__GeometryGraph) -> () { unsafe { graph_msgs__msg__GeometryGraph__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> GeometryGraph { GeometryGraph { header : std_msgs :: msg :: Header :: from_native (& msg . header) , nodes : { let mut temp = Vec :: with_capacity (msg . nodes . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . nodes . data , msg . nodes . size) } ; for s in slice { temp . push (geometry_msgs :: msg :: Point :: from_native (s)) ; } temp } , edges : { let mut temp = Vec :: with_capacity (msg . edges . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . edges . data , msg . edges . size) } ; for s in slice { temp . push (graph_msgs :: msg :: Edges :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; unsafe { geometry_msgs__msg__Point__Sequence__fini (& mut msg . nodes) ; geometry_msgs__msg__Point__Sequence__init (& mut msg . nodes , self . nodes . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . nodes . data , msg . nodes . size) ; for (t , s) in slice . iter_mut () . zip (& self . nodes) { s . copy_to_native (t) ; } } unsafe { graph_msgs__msg__Edges__Sequence__fini (& mut msg . edges) ; graph_msgs__msg__Edges__Sequence__init (& mut msg . edges , self . edges . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . edges . data , msg . edges . size) ; for (t , s) in slice . iter_mut () . zip (& self . edges) { s . copy_to_native (t) ; } } } } impl Default for GeometryGraph { fn default () -> Self { let msg_native = WrappedNativeMsg :: < GeometryGraph > :: new () ; GeometryGraph :: from_native (& msg_native) } } }