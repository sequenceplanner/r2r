pub mod srv { # [allow (non_snake_case)] pub mod FinishTrajectory { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__cartographer_ros_msgs__srv__FinishTrajectory () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub trajectory_id : i32 } impl WrappedTypesupport for Request { type CStruct = cartographer_ros_msgs__srv__FinishTrajectory_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__cartographer_ros_msgs__srv__FinishTrajectory_Request () } } fn create_msg () -> * mut cartographer_ros_msgs__srv__FinishTrajectory_Request { unsafe { cartographer_ros_msgs__srv__FinishTrajectory_Request__create () } } fn destroy_msg (msg : * mut cartographer_ros_msgs__srv__FinishTrajectory_Request) -> () { unsafe { cartographer_ros_msgs__srv__FinishTrajectory_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { trajectory_id : msg . trajectory_id , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . trajectory_id = self . trajectory_id ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub status : cartographer_ros_msgs :: msg :: StatusResponse } impl WrappedTypesupport for Response { type CStruct = cartographer_ros_msgs__srv__FinishTrajectory_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__cartographer_ros_msgs__srv__FinishTrajectory_Response () } } fn create_msg () -> * mut cartographer_ros_msgs__srv__FinishTrajectory_Response { unsafe { cartographer_ros_msgs__srv__FinishTrajectory_Response__create () } } fn destroy_msg (msg : * mut cartographer_ros_msgs__srv__FinishTrajectory_Response) -> () { unsafe { cartographer_ros_msgs__srv__FinishTrajectory_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { status : cartographer_ros_msgs :: msg :: StatusResponse :: from_native (& msg . status) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . status . copy_to_native (& mut msg . status) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod StartTrajectory { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__cartographer_ros_msgs__srv__StartTrajectory () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub options : cartographer_ros_msgs :: msg :: TrajectoryOptions , pub topics : cartographer_ros_msgs :: msg :: SensorTopics } impl WrappedTypesupport for Request { type CStruct = cartographer_ros_msgs__srv__StartTrajectory_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__cartographer_ros_msgs__srv__StartTrajectory_Request () } } fn create_msg () -> * mut cartographer_ros_msgs__srv__StartTrajectory_Request { unsafe { cartographer_ros_msgs__srv__StartTrajectory_Request__create () } } fn destroy_msg (msg : * mut cartographer_ros_msgs__srv__StartTrajectory_Request) -> () { unsafe { cartographer_ros_msgs__srv__StartTrajectory_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { options : cartographer_ros_msgs :: msg :: TrajectoryOptions :: from_native (& msg . options) , topics : cartographer_ros_msgs :: msg :: SensorTopics :: from_native (& msg . topics) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . options . copy_to_native (& mut msg . options) ; self . topics . copy_to_native (& mut msg . topics) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub status : cartographer_ros_msgs :: msg :: StatusResponse , pub trajectory_id : i32 } impl WrappedTypesupport for Response { type CStruct = cartographer_ros_msgs__srv__StartTrajectory_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__cartographer_ros_msgs__srv__StartTrajectory_Response () } } fn create_msg () -> * mut cartographer_ros_msgs__srv__StartTrajectory_Response { unsafe { cartographer_ros_msgs__srv__StartTrajectory_Response__create () } } fn destroy_msg (msg : * mut cartographer_ros_msgs__srv__StartTrajectory_Response) -> () { unsafe { cartographer_ros_msgs__srv__StartTrajectory_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { status : cartographer_ros_msgs :: msg :: StatusResponse :: from_native (& msg . status) , trajectory_id : msg . trajectory_id , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . status . copy_to_native (& mut msg . status) ; msg . trajectory_id = self . trajectory_id ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod SubmapQuery { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__cartographer_ros_msgs__srv__SubmapQuery () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub trajectory_id : i32 , pub submap_index : i32 } impl WrappedTypesupport for Request { type CStruct = cartographer_ros_msgs__srv__SubmapQuery_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__cartographer_ros_msgs__srv__SubmapQuery_Request () } } fn create_msg () -> * mut cartographer_ros_msgs__srv__SubmapQuery_Request { unsafe { cartographer_ros_msgs__srv__SubmapQuery_Request__create () } } fn destroy_msg (msg : * mut cartographer_ros_msgs__srv__SubmapQuery_Request) -> () { unsafe { cartographer_ros_msgs__srv__SubmapQuery_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { trajectory_id : msg . trajectory_id , submap_index : msg . submap_index , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . trajectory_id = self . trajectory_id ; msg . submap_index = self . submap_index ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub status : cartographer_ros_msgs :: msg :: StatusResponse , pub submap_version : i32 , pub textures : Vec < cartographer_ros_msgs :: msg :: SubmapTexture > } impl WrappedTypesupport for Response { type CStruct = cartographer_ros_msgs__srv__SubmapQuery_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__cartographer_ros_msgs__srv__SubmapQuery_Response () } } fn create_msg () -> * mut cartographer_ros_msgs__srv__SubmapQuery_Response { unsafe { cartographer_ros_msgs__srv__SubmapQuery_Response__create () } } fn destroy_msg (msg : * mut cartographer_ros_msgs__srv__SubmapQuery_Response) -> () { unsafe { cartographer_ros_msgs__srv__SubmapQuery_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { status : cartographer_ros_msgs :: msg :: StatusResponse :: from_native (& msg . status) , submap_version : msg . submap_version , textures : { let mut temp = Vec :: with_capacity (msg . textures . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . textures . data , msg . textures . size) } ; for s in slice { temp . push (cartographer_ros_msgs :: msg :: SubmapTexture :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . status . copy_to_native (& mut msg . status) ; msg . submap_version = self . submap_version ; unsafe { cartographer_ros_msgs__msg__SubmapTexture__Sequence__fini (& mut msg . textures) ; cartographer_ros_msgs__msg__SubmapTexture__Sequence__init (& mut msg . textures , self . textures . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . textures . data , msg . textures . size) ; for (t , s) in slice . iter_mut () . zip (& self . textures) { s . copy_to_native (t) ; } } } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod WriteState { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__cartographer_ros_msgs__srv__WriteState () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub filename : std :: string :: String } impl WrappedTypesupport for Request { type CStruct = cartographer_ros_msgs__srv__WriteState_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__cartographer_ros_msgs__srv__WriteState_Request () } } fn create_msg () -> * mut cartographer_ros_msgs__srv__WriteState_Request { unsafe { cartographer_ros_msgs__srv__WriteState_Request__create () } } fn destroy_msg (msg : * mut cartographer_ros_msgs__srv__WriteState_Request) -> () { unsafe { cartographer_ros_msgs__srv__WriteState_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { filename : msg . filename . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . filename . assign (& self . filename) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub status : cartographer_ros_msgs :: msg :: StatusResponse } impl WrappedTypesupport for Response { type CStruct = cartographer_ros_msgs__srv__WriteState_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__cartographer_ros_msgs__srv__WriteState_Response () } } fn create_msg () -> * mut cartographer_ros_msgs__srv__WriteState_Response { unsafe { cartographer_ros_msgs__srv__WriteState_Response__create () } } fn destroy_msg (msg : * mut cartographer_ros_msgs__srv__WriteState_Response) -> () { unsafe { cartographer_ros_msgs__srv__WriteState_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { status : cartographer_ros_msgs :: msg :: StatusResponse :: from_native (& msg . status) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . status . copy_to_native (& mut msg . status) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } } pub mod msg { use super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct LandmarkEntry { pub id : std :: string :: String , pub tracking_from_landmark_transform : geometry_msgs :: msg :: Pose , pub translation_weight : f64 , pub rotation_weight : f64 } impl WrappedTypesupport for LandmarkEntry { type CStruct = cartographer_ros_msgs__msg__LandmarkEntry ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__cartographer_ros_msgs__msg__LandmarkEntry () } } fn create_msg () -> * mut cartographer_ros_msgs__msg__LandmarkEntry { unsafe { cartographer_ros_msgs__msg__LandmarkEntry__create () } } fn destroy_msg (msg : * mut cartographer_ros_msgs__msg__LandmarkEntry) -> () { unsafe { cartographer_ros_msgs__msg__LandmarkEntry__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> LandmarkEntry { LandmarkEntry { id : msg . id . to_str () . to_owned () , tracking_from_landmark_transform : geometry_msgs :: msg :: Pose :: from_native (& msg . tracking_from_landmark_transform) , translation_weight : msg . translation_weight , rotation_weight : msg . rotation_weight , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . id . assign (& self . id) ; self . tracking_from_landmark_transform . copy_to_native (& mut msg . tracking_from_landmark_transform) ; msg . translation_weight = self . translation_weight ; msg . rotation_weight = self . rotation_weight ; } } impl Default for LandmarkEntry { fn default () -> Self { let msg_native = WrappedNativeMsg :: < LandmarkEntry > :: new () ; LandmarkEntry :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct LandmarkList { pub header : std_msgs :: msg :: Header , pub landmark : Vec < cartographer_ros_msgs :: msg :: LandmarkEntry > } impl WrappedTypesupport for LandmarkList { type CStruct = cartographer_ros_msgs__msg__LandmarkList ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__cartographer_ros_msgs__msg__LandmarkList () } } fn create_msg () -> * mut cartographer_ros_msgs__msg__LandmarkList { unsafe { cartographer_ros_msgs__msg__LandmarkList__create () } } fn destroy_msg (msg : * mut cartographer_ros_msgs__msg__LandmarkList) -> () { unsafe { cartographer_ros_msgs__msg__LandmarkList__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> LandmarkList { LandmarkList { header : std_msgs :: msg :: Header :: from_native (& msg . header) , landmark : { let mut temp = Vec :: with_capacity (msg . landmark . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . landmark . data , msg . landmark . size) } ; for s in slice { temp . push (cartographer_ros_msgs :: msg :: LandmarkEntry :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; unsafe { cartographer_ros_msgs__msg__LandmarkEntry__Sequence__fini (& mut msg . landmark) ; cartographer_ros_msgs__msg__LandmarkEntry__Sequence__init (& mut msg . landmark , self . landmark . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . landmark . data , msg . landmark . size) ; for (t , s) in slice . iter_mut () . zip (& self . landmark) { s . copy_to_native (t) ; } } } } impl Default for LandmarkList { fn default () -> Self { let msg_native = WrappedNativeMsg :: < LandmarkList > :: new () ; LandmarkList :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct SensorTopics { pub laser_scan_topic : std :: string :: String , pub multi_echo_laser_scan_topic : std :: string :: String , pub point_cloud2_topic : std :: string :: String , pub imu_topic : std :: string :: String , pub odometry_topic : std :: string :: String , pub nav_sat_fix_topic : std :: string :: String , pub landmark_topic : std :: string :: String } impl WrappedTypesupport for SensorTopics { type CStruct = cartographer_ros_msgs__msg__SensorTopics ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__cartographer_ros_msgs__msg__SensorTopics () } } fn create_msg () -> * mut cartographer_ros_msgs__msg__SensorTopics { unsafe { cartographer_ros_msgs__msg__SensorTopics__create () } } fn destroy_msg (msg : * mut cartographer_ros_msgs__msg__SensorTopics) -> () { unsafe { cartographer_ros_msgs__msg__SensorTopics__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> SensorTopics { SensorTopics { laser_scan_topic : msg . laser_scan_topic . to_str () . to_owned () , multi_echo_laser_scan_topic : msg . multi_echo_laser_scan_topic . to_str () . to_owned () , point_cloud2_topic : msg . point_cloud2_topic . to_str () . to_owned () , imu_topic : msg . imu_topic . to_str () . to_owned () , odometry_topic : msg . odometry_topic . to_str () . to_owned () , nav_sat_fix_topic : msg . nav_sat_fix_topic . to_str () . to_owned () , landmark_topic : msg . landmark_topic . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . laser_scan_topic . assign (& self . laser_scan_topic) ; msg . multi_echo_laser_scan_topic . assign (& self . multi_echo_laser_scan_topic) ; msg . point_cloud2_topic . assign (& self . point_cloud2_topic) ; msg . imu_topic . assign (& self . imu_topic) ; msg . odometry_topic . assign (& self . odometry_topic) ; msg . nav_sat_fix_topic . assign (& self . nav_sat_fix_topic) ; msg . landmark_topic . assign (& self . landmark_topic) ; } } impl Default for SensorTopics { fn default () -> Self { let msg_native = WrappedNativeMsg :: < SensorTopics > :: new () ; SensorTopics :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct StatusCode { } impl WrappedTypesupport for StatusCode { type CStruct = cartographer_ros_msgs__msg__StatusCode ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__cartographer_ros_msgs__msg__StatusCode () } } fn create_msg () -> * mut cartographer_ros_msgs__msg__StatusCode { unsafe { cartographer_ros_msgs__msg__StatusCode__create () } } fn destroy_msg (msg : * mut cartographer_ros_msgs__msg__StatusCode) -> () { unsafe { cartographer_ros_msgs__msg__StatusCode__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> StatusCode { StatusCode { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for StatusCode { fn default () -> Self { let msg_native = WrappedNativeMsg :: < StatusCode > :: new () ; StatusCode :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl StatusCode { pub const ABORTED : _bindgen_ty_141 = cartographer_ros_msgs__msg__StatusCode__ABORTED ; pub const ALREADY_EXISTS : _bindgen_ty_137 = cartographer_ros_msgs__msg__StatusCode__ALREADY_EXISTS ; pub const CANCELLED : _bindgen_ty_132 = cartographer_ros_msgs__msg__StatusCode__CANCELLED ; pub const DATA_LOSS : _bindgen_ty_146 = cartographer_ros_msgs__msg__StatusCode__DATA_LOSS ; pub const DEADLINE_EXCEEDED : _bindgen_ty_135 = cartographer_ros_msgs__msg__StatusCode__DEADLINE_EXCEEDED ; pub const FAILED_PRECONDITION : _bindgen_ty_140 = cartographer_ros_msgs__msg__StatusCode__FAILED_PRECONDITION ; pub const INTERNAL : _bindgen_ty_144 = cartographer_ros_msgs__msg__StatusCode__INTERNAL ; pub const INVALID_ARGUMENT : _bindgen_ty_134 = cartographer_ros_msgs__msg__StatusCode__INVALID_ARGUMENT ; pub const NOT_FOUND : _bindgen_ty_136 = cartographer_ros_msgs__msg__StatusCode__NOT_FOUND ; pub const OK : _bindgen_ty_131 = cartographer_ros_msgs__msg__StatusCode__OK ; pub const OUT_OF_RANGE : _bindgen_ty_142 = cartographer_ros_msgs__msg__StatusCode__OUT_OF_RANGE ; pub const PERMISSION_DENIED : _bindgen_ty_138 = cartographer_ros_msgs__msg__StatusCode__PERMISSION_DENIED ; pub const RESOURCE_EXHAUSTED : _bindgen_ty_139 = cartographer_ros_msgs__msg__StatusCode__RESOURCE_EXHAUSTED ; pub const UNAVAILABLE : _bindgen_ty_145 = cartographer_ros_msgs__msg__StatusCode__UNAVAILABLE ; pub const UNIMPLEMENTED : _bindgen_ty_143 = cartographer_ros_msgs__msg__StatusCode__UNIMPLEMENTED ; pub const UNKNOWN : _bindgen_ty_133 = cartographer_ros_msgs__msg__StatusCode__UNKNOWN ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct StatusResponse { pub code : u8 , pub message : std :: string :: String } impl WrappedTypesupport for StatusResponse { type CStruct = cartographer_ros_msgs__msg__StatusResponse ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__cartographer_ros_msgs__msg__StatusResponse () } } fn create_msg () -> * mut cartographer_ros_msgs__msg__StatusResponse { unsafe { cartographer_ros_msgs__msg__StatusResponse__create () } } fn destroy_msg (msg : * mut cartographer_ros_msgs__msg__StatusResponse) -> () { unsafe { cartographer_ros_msgs__msg__StatusResponse__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> StatusResponse { StatusResponse { code : msg . code , message : msg . message . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . code = self . code ; msg . message . assign (& self . message) ; } } impl Default for StatusResponse { fn default () -> Self { let msg_native = WrappedNativeMsg :: < StatusResponse > :: new () ; StatusResponse :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct SubmapEntry { pub trajectory_id : i32 , pub submap_index : i32 , pub submap_version : i32 , pub pose : geometry_msgs :: msg :: Pose } impl WrappedTypesupport for SubmapEntry { type CStruct = cartographer_ros_msgs__msg__SubmapEntry ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__cartographer_ros_msgs__msg__SubmapEntry () } } fn create_msg () -> * mut cartographer_ros_msgs__msg__SubmapEntry { unsafe { cartographer_ros_msgs__msg__SubmapEntry__create () } } fn destroy_msg (msg : * mut cartographer_ros_msgs__msg__SubmapEntry) -> () { unsafe { cartographer_ros_msgs__msg__SubmapEntry__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> SubmapEntry { SubmapEntry { trajectory_id : msg . trajectory_id , submap_index : msg . submap_index , submap_version : msg . submap_version , pose : geometry_msgs :: msg :: Pose :: from_native (& msg . pose) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . trajectory_id = self . trajectory_id ; msg . submap_index = self . submap_index ; msg . submap_version = self . submap_version ; self . pose . copy_to_native (& mut msg . pose) ; } } impl Default for SubmapEntry { fn default () -> Self { let msg_native = WrappedNativeMsg :: < SubmapEntry > :: new () ; SubmapEntry :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct SubmapList { pub header : std_msgs :: msg :: Header , pub submap : Vec < cartographer_ros_msgs :: msg :: SubmapEntry > } impl WrappedTypesupport for SubmapList { type CStruct = cartographer_ros_msgs__msg__SubmapList ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__cartographer_ros_msgs__msg__SubmapList () } } fn create_msg () -> * mut cartographer_ros_msgs__msg__SubmapList { unsafe { cartographer_ros_msgs__msg__SubmapList__create () } } fn destroy_msg (msg : * mut cartographer_ros_msgs__msg__SubmapList) -> () { unsafe { cartographer_ros_msgs__msg__SubmapList__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> SubmapList { SubmapList { header : std_msgs :: msg :: Header :: from_native (& msg . header) , submap : { let mut temp = Vec :: with_capacity (msg . submap . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . submap . data , msg . submap . size) } ; for s in slice { temp . push (cartographer_ros_msgs :: msg :: SubmapEntry :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; unsafe { cartographer_ros_msgs__msg__SubmapEntry__Sequence__fini (& mut msg . submap) ; cartographer_ros_msgs__msg__SubmapEntry__Sequence__init (& mut msg . submap , self . submap . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . submap . data , msg . submap . size) ; for (t , s) in slice . iter_mut () . zip (& self . submap) { s . copy_to_native (t) ; } } } } impl Default for SubmapList { fn default () -> Self { let msg_native = WrappedNativeMsg :: < SubmapList > :: new () ; SubmapList :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct SubmapTexture { pub cells : Vec < u8 > , pub width : i32 , pub height : i32 , pub resolution : f64 , pub slice_pose : geometry_msgs :: msg :: Pose } impl WrappedTypesupport for SubmapTexture { type CStruct = cartographer_ros_msgs__msg__SubmapTexture ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__cartographer_ros_msgs__msg__SubmapTexture () } } fn create_msg () -> * mut cartographer_ros_msgs__msg__SubmapTexture { unsafe { cartographer_ros_msgs__msg__SubmapTexture__create () } } fn destroy_msg (msg : * mut cartographer_ros_msgs__msg__SubmapTexture) -> () { unsafe { cartographer_ros_msgs__msg__SubmapTexture__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> SubmapTexture { SubmapTexture { cells : msg . cells . to_vec () , width : msg . width , height : msg . height , resolution : msg . resolution , slice_pose : geometry_msgs :: msg :: Pose :: from_native (& msg . slice_pose) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . cells . update (& self . cells) ; msg . width = self . width ; msg . height = self . height ; msg . resolution = self . resolution ; self . slice_pose . copy_to_native (& mut msg . slice_pose) ; } } impl Default for SubmapTexture { fn default () -> Self { let msg_native = WrappedNativeMsg :: < SubmapTexture > :: new () ; SubmapTexture :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct TrajectoryOptions { pub tracking_frame : std :: string :: String , pub published_frame : std :: string :: String , pub odom_frame : std :: string :: String , pub provide_odom_frame : bool , pub use_odometry : bool , pub use_nav_sat : bool , pub use_landmarks : bool , pub publish_frame_projected_to_2d : bool , pub num_laser_scans : i32 , pub num_multi_echo_laser_scans : i32 , pub num_subdivisions_per_laser_scan : i32 , pub num_point_clouds : i32 , pub rangefinder_sampling_ratio : f64 , pub odometry_sampling_ratio : f64 , pub fixed_frame_pose_sampling_ratio : f64 , pub imu_sampling_ratio : f64 , pub landmarks_sampling_ratio : f64 , pub trajectory_builder_options_proto : std :: string :: String } impl WrappedTypesupport for TrajectoryOptions { type CStruct = cartographer_ros_msgs__msg__TrajectoryOptions ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__cartographer_ros_msgs__msg__TrajectoryOptions () } } fn create_msg () -> * mut cartographer_ros_msgs__msg__TrajectoryOptions { unsafe { cartographer_ros_msgs__msg__TrajectoryOptions__create () } } fn destroy_msg (msg : * mut cartographer_ros_msgs__msg__TrajectoryOptions) -> () { unsafe { cartographer_ros_msgs__msg__TrajectoryOptions__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> TrajectoryOptions { TrajectoryOptions { tracking_frame : msg . tracking_frame . to_str () . to_owned () , published_frame : msg . published_frame . to_str () . to_owned () , odom_frame : msg . odom_frame . to_str () . to_owned () , provide_odom_frame : msg . provide_odom_frame , use_odometry : msg . use_odometry , use_nav_sat : msg . use_nav_sat , use_landmarks : msg . use_landmarks , publish_frame_projected_to_2d : msg . publish_frame_projected_to_2d , num_laser_scans : msg . num_laser_scans , num_multi_echo_laser_scans : msg . num_multi_echo_laser_scans , num_subdivisions_per_laser_scan : msg . num_subdivisions_per_laser_scan , num_point_clouds : msg . num_point_clouds , rangefinder_sampling_ratio : msg . rangefinder_sampling_ratio , odometry_sampling_ratio : msg . odometry_sampling_ratio , fixed_frame_pose_sampling_ratio : msg . fixed_frame_pose_sampling_ratio , imu_sampling_ratio : msg . imu_sampling_ratio , landmarks_sampling_ratio : msg . landmarks_sampling_ratio , trajectory_builder_options_proto : msg . trajectory_builder_options_proto . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . tracking_frame . assign (& self . tracking_frame) ; msg . published_frame . assign (& self . published_frame) ; msg . odom_frame . assign (& self . odom_frame) ; msg . provide_odom_frame = self . provide_odom_frame ; msg . use_odometry = self . use_odometry ; msg . use_nav_sat = self . use_nav_sat ; msg . use_landmarks = self . use_landmarks ; msg . publish_frame_projected_to_2d = self . publish_frame_projected_to_2d ; msg . num_laser_scans = self . num_laser_scans ; msg . num_multi_echo_laser_scans = self . num_multi_echo_laser_scans ; msg . num_subdivisions_per_laser_scan = self . num_subdivisions_per_laser_scan ; msg . num_point_clouds = self . num_point_clouds ; msg . rangefinder_sampling_ratio = self . rangefinder_sampling_ratio ; msg . odometry_sampling_ratio = self . odometry_sampling_ratio ; msg . fixed_frame_pose_sampling_ratio = self . fixed_frame_pose_sampling_ratio ; msg . imu_sampling_ratio = self . imu_sampling_ratio ; msg . landmarks_sampling_ratio = self . landmarks_sampling_ratio ; msg . trajectory_builder_options_proto . assign (& self . trajectory_builder_options_proto) ; } } impl Default for TrajectoryOptions { fn default () -> Self { let msg_native = WrappedNativeMsg :: < TrajectoryOptions > :: new () ; TrajectoryOptions :: from_native (& msg_native) } } }