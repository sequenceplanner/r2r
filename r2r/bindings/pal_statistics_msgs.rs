pub mod msg { use super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Statistic { pub name : std :: string :: String , pub value : f64 } impl WrappedTypesupport for Statistic { type CStruct = pal_statistics_msgs__msg__Statistic ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__pal_statistics_msgs__msg__Statistic () } } fn create_msg () -> * mut pal_statistics_msgs__msg__Statistic { unsafe { pal_statistics_msgs__msg__Statistic__create () } } fn destroy_msg (msg : * mut pal_statistics_msgs__msg__Statistic) -> () { unsafe { pal_statistics_msgs__msg__Statistic__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Statistic { Statistic { name : msg . name . to_str () . to_owned () , value : msg . value , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . name . assign (& self . name) ; msg . value = self . value ; } } impl Default for Statistic { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Statistic > :: new () ; Statistic :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Statistics { pub header : std_msgs :: msg :: Header , pub statistics : Vec < pal_statistics_msgs :: msg :: Statistic > } impl WrappedTypesupport for Statistics { type CStruct = pal_statistics_msgs__msg__Statistics ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__pal_statistics_msgs__msg__Statistics () } } fn create_msg () -> * mut pal_statistics_msgs__msg__Statistics { unsafe { pal_statistics_msgs__msg__Statistics__create () } } fn destroy_msg (msg : * mut pal_statistics_msgs__msg__Statistics) -> () { unsafe { pal_statistics_msgs__msg__Statistics__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Statistics { Statistics { header : std_msgs :: msg :: Header :: from_native (& msg . header) , statistics : { let mut temp = Vec :: with_capacity (msg . statistics . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . statistics . data , msg . statistics . size) } ; for s in slice { temp . push (pal_statistics_msgs :: msg :: Statistic :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; unsafe { pal_statistics_msgs__msg__Statistic__Sequence__fini (& mut msg . statistics) ; pal_statistics_msgs__msg__Statistic__Sequence__init (& mut msg . statistics , self . statistics . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . statistics . data , msg . statistics . size) ; for (t , s) in slice . iter_mut () . zip (& self . statistics) { s . copy_to_native (t) ; } } } } impl Default for Statistics { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Statistics > :: new () ; Statistics :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct StatisticsNames { pub header : std_msgs :: msg :: Header , pub names : Vec < std :: string :: String > , pub names_version : u32 } impl WrappedTypesupport for StatisticsNames { type CStruct = pal_statistics_msgs__msg__StatisticsNames ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__pal_statistics_msgs__msg__StatisticsNames () } } fn create_msg () -> * mut pal_statistics_msgs__msg__StatisticsNames { unsafe { pal_statistics_msgs__msg__StatisticsNames__create () } } fn destroy_msg (msg : * mut pal_statistics_msgs__msg__StatisticsNames) -> () { unsafe { pal_statistics_msgs__msg__StatisticsNames__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> StatisticsNames { StatisticsNames { header : std_msgs :: msg :: Header :: from_native (& msg . header) , names : msg . names . to_vec () , names_version : msg . names_version , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . names . update (& self . names) ; msg . names_version = self . names_version ; } } impl Default for StatisticsNames { fn default () -> Self { let msg_native = WrappedNativeMsg :: < StatisticsNames > :: new () ; StatisticsNames :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct StatisticsValues { pub header : std_msgs :: msg :: Header , pub values : Vec < f64 > , pub names_version : u32 } impl WrappedTypesupport for StatisticsValues { type CStruct = pal_statistics_msgs__msg__StatisticsValues ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__pal_statistics_msgs__msg__StatisticsValues () } } fn create_msg () -> * mut pal_statistics_msgs__msg__StatisticsValues { unsafe { pal_statistics_msgs__msg__StatisticsValues__create () } } fn destroy_msg (msg : * mut pal_statistics_msgs__msg__StatisticsValues) -> () { unsafe { pal_statistics_msgs__msg__StatisticsValues__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> StatisticsValues { StatisticsValues { header : std_msgs :: msg :: Header :: from_native (& msg . header) , values : msg . values . to_vec () , names_version : msg . names_version , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . values . update (& self . values) ; msg . names_version = self . names_version ; } } impl Default for StatisticsValues { fn default () -> Self { let msg_native = WrappedNativeMsg :: < StatisticsValues > :: new () ; StatisticsValues :: from_native (& msg_native) } } }