pub mod msg { use super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct AGVAction { pub action_type : std :: string :: String , pub action_description : std :: string :: String , pub action_scopes : Vec < std :: string :: String > , pub action_parameters : Vec < vda5050_msgs :: msg :: ActionParameterDefinition > , pub result_description : std :: string :: String } impl WrappedTypesupport for AGVAction { type CStruct = vda5050_msgs__msg__AGVAction ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__vda5050_msgs__msg__AGVAction () } } fn create_msg () -> * mut vda5050_msgs__msg__AGVAction { unsafe { vda5050_msgs__msg__AGVAction__create () } } fn destroy_msg (msg : * mut vda5050_msgs__msg__AGVAction) -> () { unsafe { vda5050_msgs__msg__AGVAction__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> AGVAction { AGVAction { action_type : msg . action_type . to_str () . to_owned () , action_description : msg . action_description . to_str () . to_owned () , action_scopes : msg . action_scopes . to_vec () , action_parameters : { let mut temp = Vec :: with_capacity (msg . action_parameters . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . action_parameters . data , msg . action_parameters . size) } ; for s in slice { temp . push (vda5050_msgs :: msg :: ActionParameterDefinition :: from_native (s)) ; } temp } , result_description : msg . result_description . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . action_type . assign (& self . action_type) ; msg . action_description . assign (& self . action_description) ; msg . action_scopes . update (& self . action_scopes) ; unsafe { vda5050_msgs__msg__ActionParameterDefinition__Sequence__fini (& mut msg . action_parameters) ; vda5050_msgs__msg__ActionParameterDefinition__Sequence__init (& mut msg . action_parameters , self . action_parameters . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . action_parameters . data , msg . action_parameters . size) ; for (t , s) in slice . iter_mut () . zip (& self . action_parameters) { s . copy_to_native (t) ; } } msg . result_description . assign (& self . result_description) ; } } impl Default for AGVAction { fn default () -> Self { let msg_native = WrappedNativeMsg :: < AGVAction > :: new () ; AGVAction :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl AGVAction { pub const EDGE : & [u8 ; 5usize] = vda5050_msgs__msg__AGVAction__EDGE ; pub const INSTANT : & [u8 ; 8usize] = vda5050_msgs__msg__AGVAction__INSTANT ; pub const NODE : & [u8 ; 5usize] = vda5050_msgs__msg__AGVAction__NODE ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct AGVGeometry { pub wheel_definitions : Vec < vda5050_msgs :: msg :: WheelDefinition > , pub envelopes2d : Vec < vda5050_msgs :: msg :: Envelope2D > , pub envelopes3d : Vec < vda5050_msgs :: msg :: Envelope3D > } impl WrappedTypesupport for AGVGeometry { type CStruct = vda5050_msgs__msg__AGVGeometry ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__vda5050_msgs__msg__AGVGeometry () } } fn create_msg () -> * mut vda5050_msgs__msg__AGVGeometry { unsafe { vda5050_msgs__msg__AGVGeometry__create () } } fn destroy_msg (msg : * mut vda5050_msgs__msg__AGVGeometry) -> () { unsafe { vda5050_msgs__msg__AGVGeometry__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> AGVGeometry { AGVGeometry { wheel_definitions : { let mut temp = Vec :: with_capacity (msg . wheel_definitions . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . wheel_definitions . data , msg . wheel_definitions . size) } ; for s in slice { temp . push (vda5050_msgs :: msg :: WheelDefinition :: from_native (s)) ; } temp } , envelopes2d : { let mut temp = Vec :: with_capacity (msg . envelopes2d . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . envelopes2d . data , msg . envelopes2d . size) } ; for s in slice { temp . push (vda5050_msgs :: msg :: Envelope2D :: from_native (s)) ; } temp } , envelopes3d : { let mut temp = Vec :: with_capacity (msg . envelopes3d . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . envelopes3d . data , msg . envelopes3d . size) } ; for s in slice { temp . push (vda5050_msgs :: msg :: Envelope3D :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { unsafe { vda5050_msgs__msg__WheelDefinition__Sequence__fini (& mut msg . wheel_definitions) ; vda5050_msgs__msg__WheelDefinition__Sequence__init (& mut msg . wheel_definitions , self . wheel_definitions . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . wheel_definitions . data , msg . wheel_definitions . size) ; for (t , s) in slice . iter_mut () . zip (& self . wheel_definitions) { s . copy_to_native (t) ; } } unsafe { vda5050_msgs__msg__Envelope2D__Sequence__fini (& mut msg . envelopes2d) ; vda5050_msgs__msg__Envelope2D__Sequence__init (& mut msg . envelopes2d , self . envelopes2d . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . envelopes2d . data , msg . envelopes2d . size) ; for (t , s) in slice . iter_mut () . zip (& self . envelopes2d) { s . copy_to_native (t) ; } } unsafe { vda5050_msgs__msg__Envelope3D__Sequence__fini (& mut msg . envelopes3d) ; vda5050_msgs__msg__Envelope3D__Sequence__init (& mut msg . envelopes3d , self . envelopes3d . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . envelopes3d . data , msg . envelopes3d . size) ; for (t , s) in slice . iter_mut () . zip (& self . envelopes3d) { s . copy_to_native (t) ; } } } } impl Default for AGVGeometry { fn default () -> Self { let msg_native = WrappedNativeMsg :: < AGVGeometry > :: new () ; AGVGeometry :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct AGVPosition { pub position_initialized : bool , pub localization_score : f64 , pub deviation_range : f64 , pub x : f64 , pub y : f64 , pub theta : f64 , pub map_id : std :: string :: String , pub map_description : std :: string :: String } impl WrappedTypesupport for AGVPosition { type CStruct = vda5050_msgs__msg__AGVPosition ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__vda5050_msgs__msg__AGVPosition () } } fn create_msg () -> * mut vda5050_msgs__msg__AGVPosition { unsafe { vda5050_msgs__msg__AGVPosition__create () } } fn destroy_msg (msg : * mut vda5050_msgs__msg__AGVPosition) -> () { unsafe { vda5050_msgs__msg__AGVPosition__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> AGVPosition { AGVPosition { position_initialized : msg . position_initialized , localization_score : msg . localization_score , deviation_range : msg . deviation_range , x : msg . x , y : msg . y , theta : msg . theta , map_id : msg . map_id . to_str () . to_owned () , map_description : msg . map_description . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . position_initialized = self . position_initialized ; msg . localization_score = self . localization_score ; msg . deviation_range = self . deviation_range ; msg . x = self . x ; msg . y = self . y ; msg . theta = self . theta ; msg . map_id . assign (& self . map_id) ; msg . map_description . assign (& self . map_description) ; } } impl Default for AGVPosition { fn default () -> Self { let msg_native = WrappedNativeMsg :: < AGVPosition > :: new () ; AGVPosition :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Action { pub action_type : std :: string :: String , pub action_id : std :: string :: String , pub action_description : std :: string :: String , pub blocking_type : std :: string :: String , pub action_parameters : Vec < vda5050_msgs :: msg :: ActionParameter > } impl WrappedTypesupport for Action { type CStruct = vda5050_msgs__msg__Action ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__vda5050_msgs__msg__Action () } } fn create_msg () -> * mut vda5050_msgs__msg__Action { unsafe { vda5050_msgs__msg__Action__create () } } fn destroy_msg (msg : * mut vda5050_msgs__msg__Action) -> () { unsafe { vda5050_msgs__msg__Action__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Action { Action { action_type : msg . action_type . to_str () . to_owned () , action_id : msg . action_id . to_str () . to_owned () , action_description : msg . action_description . to_str () . to_owned () , blocking_type : msg . blocking_type . to_str () . to_owned () , action_parameters : { let mut temp = Vec :: with_capacity (msg . action_parameters . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . action_parameters . data , msg . action_parameters . size) } ; for s in slice { temp . push (vda5050_msgs :: msg :: ActionParameter :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . action_type . assign (& self . action_type) ; msg . action_id . assign (& self . action_id) ; msg . action_description . assign (& self . action_description) ; msg . blocking_type . assign (& self . blocking_type) ; unsafe { vda5050_msgs__msg__ActionParameter__Sequence__fini (& mut msg . action_parameters) ; vda5050_msgs__msg__ActionParameter__Sequence__init (& mut msg . action_parameters , self . action_parameters . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . action_parameters . data , msg . action_parameters . size) ; for (t , s) in slice . iter_mut () . zip (& self . action_parameters) { s . copy_to_native (t) ; } } } } impl Default for Action { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Action > :: new () ; Action :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl Action { pub const HARD : & [u8 ; 5usize] = vda5050_msgs__msg__Action__HARD ; pub const NONE : & [u8 ; 5usize] = vda5050_msgs__msg__Action__NONE ; pub const SOFT : & [u8 ; 5usize] = vda5050_msgs__msg__Action__SOFT ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ActionParameter { pub key : std :: string :: String , pub value : std :: string :: String } impl WrappedTypesupport for ActionParameter { type CStruct = vda5050_msgs__msg__ActionParameter ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__vda5050_msgs__msg__ActionParameter () } } fn create_msg () -> * mut vda5050_msgs__msg__ActionParameter { unsafe { vda5050_msgs__msg__ActionParameter__create () } } fn destroy_msg (msg : * mut vda5050_msgs__msg__ActionParameter) -> () { unsafe { vda5050_msgs__msg__ActionParameter__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ActionParameter { ActionParameter { key : msg . key . to_str () . to_owned () , value : msg . value . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . key . assign (& self . key) ; msg . value . assign (& self . value) ; } } impl Default for ActionParameter { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ActionParameter > :: new () ; ActionParameter :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ActionParameterDefinition { pub key : std :: string :: String , pub value_data_type : std :: string :: String , pub description : std :: string :: String , pub is_optional : bool } impl WrappedTypesupport for ActionParameterDefinition { type CStruct = vda5050_msgs__msg__ActionParameterDefinition ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__vda5050_msgs__msg__ActionParameterDefinition () } } fn create_msg () -> * mut vda5050_msgs__msg__ActionParameterDefinition { unsafe { vda5050_msgs__msg__ActionParameterDefinition__create () } } fn destroy_msg (msg : * mut vda5050_msgs__msg__ActionParameterDefinition) -> () { unsafe { vda5050_msgs__msg__ActionParameterDefinition__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ActionParameterDefinition { ActionParameterDefinition { key : msg . key . to_str () . to_owned () , value_data_type : msg . value_data_type . to_str () . to_owned () , description : msg . description . to_str () . to_owned () , is_optional : msg . is_optional , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . key . assign (& self . key) ; msg . value_data_type . assign (& self . value_data_type) ; msg . description . assign (& self . description) ; msg . is_optional = self . is_optional ; } } impl Default for ActionParameterDefinition { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ActionParameterDefinition > :: new () ; ActionParameterDefinition :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl ActionParameterDefinition { pub const ARRAY : & [u8 ; 6usize] = vda5050_msgs__msg__ActionParameterDefinition__ARRAY ; pub const BOOL : & [u8 ; 5usize] = vda5050_msgs__msg__ActionParameterDefinition__BOOL ; pub const FLOAT : & [u8 ; 6usize] = vda5050_msgs__msg__ActionParameterDefinition__FLOAT ; pub const INTEGER : & [u8 ; 8usize] = vda5050_msgs__msg__ActionParameterDefinition__INTEGER ; pub const NUMBER : & [u8 ; 7usize] = vda5050_msgs__msg__ActionParameterDefinition__NUMBER ; pub const OBJECT : & [u8 ; 7usize] = vda5050_msgs__msg__ActionParameterDefinition__OBJECT ; pub const STRING : & [u8 ; 7usize] = vda5050_msgs__msg__ActionParameterDefinition__STRING ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct BatteryState { pub battery_charge : f64 , pub battery_voltage : f64 , pub battery_health : i8 , pub charging : bool , pub reach : u32 } impl WrappedTypesupport for BatteryState { type CStruct = vda5050_msgs__msg__BatteryState ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__vda5050_msgs__msg__BatteryState () } } fn create_msg () -> * mut vda5050_msgs__msg__BatteryState { unsafe { vda5050_msgs__msg__BatteryState__create () } } fn destroy_msg (msg : * mut vda5050_msgs__msg__BatteryState) -> () { unsafe { vda5050_msgs__msg__BatteryState__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> BatteryState { BatteryState { battery_charge : msg . battery_charge , battery_voltage : msg . battery_voltage , battery_health : msg . battery_health , charging : msg . charging , reach : msg . reach , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . battery_charge = self . battery_charge ; msg . battery_voltage = self . battery_voltage ; msg . battery_health = self . battery_health ; msg . charging = self . charging ; msg . reach = self . reach ; } } impl Default for BatteryState { fn default () -> Self { let msg_native = WrappedNativeMsg :: < BatteryState > :: new () ; BatteryState :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct BoundingBoxReference { pub x : f64 , pub y : f64 , pub z : f64 , pub theta : f64 } impl WrappedTypesupport for BoundingBoxReference { type CStruct = vda5050_msgs__msg__BoundingBoxReference ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__vda5050_msgs__msg__BoundingBoxReference () } } fn create_msg () -> * mut vda5050_msgs__msg__BoundingBoxReference { unsafe { vda5050_msgs__msg__BoundingBoxReference__create () } } fn destroy_msg (msg : * mut vda5050_msgs__msg__BoundingBoxReference) -> () { unsafe { vda5050_msgs__msg__BoundingBoxReference__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> BoundingBoxReference { BoundingBoxReference { x : msg . x , y : msg . y , z : msg . z , theta : msg . theta , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . x = self . x ; msg . y = self . y ; msg . z = self . z ; msg . theta = self . theta ; } } impl Default for BoundingBoxReference { fn default () -> Self { let msg_native = WrappedNativeMsg :: < BoundingBoxReference > :: new () ; BoundingBoxReference :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Connection { pub header_id : u32 , pub timestamp : std :: string :: String , pub version : std :: string :: String , pub manufacturer : std :: string :: String , pub serial_number : std :: string :: String , pub connection_state : std :: string :: String } impl WrappedTypesupport for Connection { type CStruct = vda5050_msgs__msg__Connection ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__vda5050_msgs__msg__Connection () } } fn create_msg () -> * mut vda5050_msgs__msg__Connection { unsafe { vda5050_msgs__msg__Connection__create () } } fn destroy_msg (msg : * mut vda5050_msgs__msg__Connection) -> () { unsafe { vda5050_msgs__msg__Connection__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Connection { Connection { header_id : msg . header_id , timestamp : msg . timestamp . to_str () . to_owned () , version : msg . version . to_str () . to_owned () , manufacturer : msg . manufacturer . to_str () . to_owned () , serial_number : msg . serial_number . to_str () . to_owned () , connection_state : msg . connection_state . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . header_id = self . header_id ; msg . timestamp . assign (& self . timestamp) ; msg . version . assign (& self . version) ; msg . manufacturer . assign (& self . manufacturer) ; msg . serial_number . assign (& self . serial_number) ; msg . connection_state . assign (& self . connection_state) ; } } impl Default for Connection { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Connection > :: new () ; Connection :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl Connection { pub const CONNECTIONBROKEN : & [u8 ; 17usize] = vda5050_msgs__msg__Connection__CONNECTIONBROKEN ; pub const OFFLINE : & [u8 ; 8usize] = vda5050_msgs__msg__Connection__OFFLINE ; pub const ONLINE : & [u8 ; 7usize] = vda5050_msgs__msg__Connection__ONLINE ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ControlPoint { pub x : f64 , pub y : f64 , pub orientation : f64 , pub weight : f64 } impl WrappedTypesupport for ControlPoint { type CStruct = vda5050_msgs__msg__ControlPoint ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__vda5050_msgs__msg__ControlPoint () } } fn create_msg () -> * mut vda5050_msgs__msg__ControlPoint { unsafe { vda5050_msgs__msg__ControlPoint__create () } } fn destroy_msg (msg : * mut vda5050_msgs__msg__ControlPoint) -> () { unsafe { vda5050_msgs__msg__ControlPoint__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ControlPoint { ControlPoint { x : msg . x , y : msg . y , orientation : msg . orientation , weight : msg . weight , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . x = self . x ; msg . y = self . y ; msg . orientation = self . orientation ; msg . weight = self . weight ; } } impl Default for ControlPoint { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ControlPoint > :: new () ; ControlPoint :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct CurrentAction { pub action_id : std :: string :: String , pub action_description : std :: string :: String , pub action_status : std :: string :: String , pub result_description : std :: string :: String } impl WrappedTypesupport for CurrentAction { type CStruct = vda5050_msgs__msg__CurrentAction ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__vda5050_msgs__msg__CurrentAction () } } fn create_msg () -> * mut vda5050_msgs__msg__CurrentAction { unsafe { vda5050_msgs__msg__CurrentAction__create () } } fn destroy_msg (msg : * mut vda5050_msgs__msg__CurrentAction) -> () { unsafe { vda5050_msgs__msg__CurrentAction__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> CurrentAction { CurrentAction { action_id : msg . action_id . to_str () . to_owned () , action_description : msg . action_description . to_str () . to_owned () , action_status : msg . action_status . to_str () . to_owned () , result_description : msg . result_description . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . action_id . assign (& self . action_id) ; msg . action_description . assign (& self . action_description) ; msg . action_status . assign (& self . action_status) ; msg . result_description . assign (& self . result_description) ; } } impl Default for CurrentAction { fn default () -> Self { let msg_native = WrappedNativeMsg :: < CurrentAction > :: new () ; CurrentAction :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl CurrentAction { pub const FAILED : & [u8 ; 7usize] = vda5050_msgs__msg__CurrentAction__FAILED ; pub const FINISHED : & [u8 ; 9usize] = vda5050_msgs__msg__CurrentAction__FINISHED ; pub const INITIALIZING : & [u8 ; 13usize] = vda5050_msgs__msg__CurrentAction__INITIALIZING ; pub const PAUSED : & [u8 ; 7usize] = vda5050_msgs__msg__CurrentAction__PAUSED ; pub const RUNNING : & [u8 ; 8usize] = vda5050_msgs__msg__CurrentAction__RUNNING ; pub const WAITING : & [u8 ; 8usize] = vda5050_msgs__msg__CurrentAction__WAITING ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Edge { pub edge_id : std :: string :: String , pub sequence_id : u32 , pub edge_description : std :: string :: String , pub released : bool , pub start_node_id : std :: string :: String , pub end_node_id : std :: string :: String , pub max_speed : f64 , pub max_height : f64 , pub min_height : f64 , pub orientation : f64 , pub direction : std :: string :: String , pub rotation_allowed : bool , pub max_rotation_speed : f64 , pub trajectory : vda5050_msgs :: msg :: Trajectory , pub length : f64 , pub actions : Vec < vda5050_msgs :: msg :: Action > } impl WrappedTypesupport for Edge { type CStruct = vda5050_msgs__msg__Edge ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__vda5050_msgs__msg__Edge () } } fn create_msg () -> * mut vda5050_msgs__msg__Edge { unsafe { vda5050_msgs__msg__Edge__create () } } fn destroy_msg (msg : * mut vda5050_msgs__msg__Edge) -> () { unsafe { vda5050_msgs__msg__Edge__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Edge { Edge { edge_id : msg . edge_id . to_str () . to_owned () , sequence_id : msg . sequence_id , edge_description : msg . edge_description . to_str () . to_owned () , released : msg . released , start_node_id : msg . start_node_id . to_str () . to_owned () , end_node_id : msg . end_node_id . to_str () . to_owned () , max_speed : msg . max_speed , max_height : msg . max_height , min_height : msg . min_height , orientation : msg . orientation , direction : msg . direction . to_str () . to_owned () , rotation_allowed : msg . rotation_allowed , max_rotation_speed : msg . max_rotation_speed , trajectory : vda5050_msgs :: msg :: Trajectory :: from_native (& msg . trajectory) , length : msg . length , actions : { let mut temp = Vec :: with_capacity (msg . actions . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . actions . data , msg . actions . size) } ; for s in slice { temp . push (vda5050_msgs :: msg :: Action :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . edge_id . assign (& self . edge_id) ; msg . sequence_id = self . sequence_id ; msg . edge_description . assign (& self . edge_description) ; msg . released = self . released ; msg . start_node_id . assign (& self . start_node_id) ; msg . end_node_id . assign (& self . end_node_id) ; msg . max_speed = self . max_speed ; msg . max_height = self . max_height ; msg . min_height = self . min_height ; msg . orientation = self . orientation ; msg . direction . assign (& self . direction) ; msg . rotation_allowed = self . rotation_allowed ; msg . max_rotation_speed = self . max_rotation_speed ; self . trajectory . copy_to_native (& mut msg . trajectory) ; msg . length = self . length ; unsafe { vda5050_msgs__msg__Action__Sequence__fini (& mut msg . actions) ; vda5050_msgs__msg__Action__Sequence__init (& mut msg . actions , self . actions . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . actions . data , msg . actions . size) ; for (t , s) in slice . iter_mut () . zip (& self . actions) { s . copy_to_native (t) ; } } } } impl Default for Edge { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Edge > :: new () ; Edge :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct EdgeState { pub edge_id : std :: string :: String , pub sequence_id : u32 , pub edge_description : std :: string :: String , pub released : bool , pub trajectory : vda5050_msgs :: msg :: Trajectory } impl WrappedTypesupport for EdgeState { type CStruct = vda5050_msgs__msg__EdgeState ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__vda5050_msgs__msg__EdgeState () } } fn create_msg () -> * mut vda5050_msgs__msg__EdgeState { unsafe { vda5050_msgs__msg__EdgeState__create () } } fn destroy_msg (msg : * mut vda5050_msgs__msg__EdgeState) -> () { unsafe { vda5050_msgs__msg__EdgeState__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> EdgeState { EdgeState { edge_id : msg . edge_id . to_str () . to_owned () , sequence_id : msg . sequence_id , edge_description : msg . edge_description . to_str () . to_owned () , released : msg . released , trajectory : vda5050_msgs :: msg :: Trajectory :: from_native (& msg . trajectory) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . edge_id . assign (& self . edge_id) ; msg . sequence_id = self . sequence_id ; msg . edge_description . assign (& self . edge_description) ; msg . released = self . released ; self . trajectory . copy_to_native (& mut msg . trajectory) ; } } impl Default for EdgeState { fn default () -> Self { let msg_native = WrappedNativeMsg :: < EdgeState > :: new () ; EdgeState :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Envelope2D { pub set : std :: string :: String , pub polygon_points : Vec < vda5050_msgs :: msg :: PolygonPoint > , pub description : std :: string :: String } impl WrappedTypesupport for Envelope2D { type CStruct = vda5050_msgs__msg__Envelope2D ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__vda5050_msgs__msg__Envelope2D () } } fn create_msg () -> * mut vda5050_msgs__msg__Envelope2D { unsafe { vda5050_msgs__msg__Envelope2D__create () } } fn destroy_msg (msg : * mut vda5050_msgs__msg__Envelope2D) -> () { unsafe { vda5050_msgs__msg__Envelope2D__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Envelope2D { Envelope2D { set : msg . set . to_str () . to_owned () , polygon_points : { let mut temp = Vec :: with_capacity (msg . polygon_points . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . polygon_points . data , msg . polygon_points . size) } ; for s in slice { temp . push (vda5050_msgs :: msg :: PolygonPoint :: from_native (s)) ; } temp } , description : msg . description . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . set . assign (& self . set) ; unsafe { vda5050_msgs__msg__PolygonPoint__Sequence__fini (& mut msg . polygon_points) ; vda5050_msgs__msg__PolygonPoint__Sequence__init (& mut msg . polygon_points , self . polygon_points . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . polygon_points . data , msg . polygon_points . size) ; for (t , s) in slice . iter_mut () . zip (& self . polygon_points) { s . copy_to_native (t) ; } } msg . description . assign (& self . description) ; } } impl Default for Envelope2D { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Envelope2D > :: new () ; Envelope2D :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Envelope3D { pub set : std :: string :: String , pub format : std :: string :: String , pub data : std :: string :: String , pub url : std :: string :: String , pub description : std :: string :: String } impl WrappedTypesupport for Envelope3D { type CStruct = vda5050_msgs__msg__Envelope3D ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__vda5050_msgs__msg__Envelope3D () } } fn create_msg () -> * mut vda5050_msgs__msg__Envelope3D { unsafe { vda5050_msgs__msg__Envelope3D__create () } } fn destroy_msg (msg : * mut vda5050_msgs__msg__Envelope3D) -> () { unsafe { vda5050_msgs__msg__Envelope3D__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Envelope3D { Envelope3D { set : msg . set . to_str () . to_owned () , format : msg . format . to_str () . to_owned () , data : msg . data . to_str () . to_owned () , url : msg . url . to_str () . to_owned () , description : msg . description . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . set . assign (& self . set) ; msg . format . assign (& self . format) ; msg . data . assign (& self . data) ; msg . url . assign (& self . url) ; msg . description . assign (& self . description) ; } } impl Default for Envelope3D { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Envelope3D > :: new () ; Envelope3D :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Error { pub error_type : std :: string :: String , pub error_references : Vec < vda5050_msgs :: msg :: ErrorReference > , pub error_description : std :: string :: String , pub error_level : std :: string :: String } impl WrappedTypesupport for Error { type CStruct = vda5050_msgs__msg__Error ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__vda5050_msgs__msg__Error () } } fn create_msg () -> * mut vda5050_msgs__msg__Error { unsafe { vda5050_msgs__msg__Error__create () } } fn destroy_msg (msg : * mut vda5050_msgs__msg__Error) -> () { unsafe { vda5050_msgs__msg__Error__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Error { Error { error_type : msg . error_type . to_str () . to_owned () , error_references : { let mut temp = Vec :: with_capacity (msg . error_references . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . error_references . data , msg . error_references . size) } ; for s in slice { temp . push (vda5050_msgs :: msg :: ErrorReference :: from_native (s)) ; } temp } , error_description : msg . error_description . to_str () . to_owned () , error_level : msg . error_level . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . error_type . assign (& self . error_type) ; unsafe { vda5050_msgs__msg__ErrorReference__Sequence__fini (& mut msg . error_references) ; vda5050_msgs__msg__ErrorReference__Sequence__init (& mut msg . error_references , self . error_references . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . error_references . data , msg . error_references . size) ; for (t , s) in slice . iter_mut () . zip (& self . error_references) { s . copy_to_native (t) ; } } msg . error_description . assign (& self . error_description) ; msg . error_level . assign (& self . error_level) ; } } impl Default for Error { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Error > :: new () ; Error :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl Error { pub const FATAL : & [u8 ; 6usize] = vda5050_msgs__msg__Error__FATAL ; pub const WARNING : & [u8 ; 8usize] = vda5050_msgs__msg__Error__WARNING ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ErrorReference { pub reference_key : std :: string :: String , pub reference_value : std :: string :: String } impl WrappedTypesupport for ErrorReference { type CStruct = vda5050_msgs__msg__ErrorReference ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__vda5050_msgs__msg__ErrorReference () } } fn create_msg () -> * mut vda5050_msgs__msg__ErrorReference { unsafe { vda5050_msgs__msg__ErrorReference__create () } } fn destroy_msg (msg : * mut vda5050_msgs__msg__ErrorReference) -> () { unsafe { vda5050_msgs__msg__ErrorReference__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ErrorReference { ErrorReference { reference_key : msg . reference_key . to_str () . to_owned () , reference_value : msg . reference_value . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . reference_key . assign (& self . reference_key) ; msg . reference_value . assign (& self . reference_value) ; } } impl Default for ErrorReference { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ErrorReference > :: new () ; ErrorReference :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Factsheet { pub header_id : u32 , pub timestamp : std :: string :: String , pub version : std :: string :: String , pub manufacturer : std :: string :: String , pub serial_number : std :: string :: String , pub type_specification : vda5050_msgs :: msg :: TypeSpecification , pub physical_parameters : vda5050_msgs :: msg :: PhysicalParameters , pub protocol_limits : vda5050_msgs :: msg :: ProtocolLimits , pub protocol_features : vda5050_msgs :: msg :: ProtocolFeatures , pub agv_geometry : vda5050_msgs :: msg :: AGVGeometry , pub load_specification : vda5050_msgs :: msg :: LoadSpecification , pub localization_parameters : i32 } impl WrappedTypesupport for Factsheet { type CStruct = vda5050_msgs__msg__Factsheet ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__vda5050_msgs__msg__Factsheet () } } fn create_msg () -> * mut vda5050_msgs__msg__Factsheet { unsafe { vda5050_msgs__msg__Factsheet__create () } } fn destroy_msg (msg : * mut vda5050_msgs__msg__Factsheet) -> () { unsafe { vda5050_msgs__msg__Factsheet__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Factsheet { Factsheet { header_id : msg . header_id , timestamp : msg . timestamp . to_str () . to_owned () , version : msg . version . to_str () . to_owned () , manufacturer : msg . manufacturer . to_str () . to_owned () , serial_number : msg . serial_number . to_str () . to_owned () , type_specification : vda5050_msgs :: msg :: TypeSpecification :: from_native (& msg . type_specification) , physical_parameters : vda5050_msgs :: msg :: PhysicalParameters :: from_native (& msg . physical_parameters) , protocol_limits : vda5050_msgs :: msg :: ProtocolLimits :: from_native (& msg . protocol_limits) , protocol_features : vda5050_msgs :: msg :: ProtocolFeatures :: from_native (& msg . protocol_features) , agv_geometry : vda5050_msgs :: msg :: AGVGeometry :: from_native (& msg . agv_geometry) , load_specification : vda5050_msgs :: msg :: LoadSpecification :: from_native (& msg . load_specification) , localization_parameters : msg . localization_parameters , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . header_id = self . header_id ; msg . timestamp . assign (& self . timestamp) ; msg . version . assign (& self . version) ; msg . manufacturer . assign (& self . manufacturer) ; msg . serial_number . assign (& self . serial_number) ; self . type_specification . copy_to_native (& mut msg . type_specification) ; self . physical_parameters . copy_to_native (& mut msg . physical_parameters) ; self . protocol_limits . copy_to_native (& mut msg . protocol_limits) ; self . protocol_features . copy_to_native (& mut msg . protocol_features) ; self . agv_geometry . copy_to_native (& mut msg . agv_geometry) ; self . load_specification . copy_to_native (& mut msg . load_specification) ; msg . localization_parameters = self . localization_parameters ; } } impl Default for Factsheet { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Factsheet > :: new () ; Factsheet :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Header { pub header_id : i32 , pub timestamp : std :: string :: String , pub version : std :: string :: String , pub manufacturer : std :: string :: String , pub serial_number : std :: string :: String } impl WrappedTypesupport for Header { type CStruct = vda5050_msgs__msg__Header ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__vda5050_msgs__msg__Header () } } fn create_msg () -> * mut vda5050_msgs__msg__Header { unsafe { vda5050_msgs__msg__Header__create () } } fn destroy_msg (msg : * mut vda5050_msgs__msg__Header) -> () { unsafe { vda5050_msgs__msg__Header__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Header { Header { header_id : msg . header_id , timestamp : msg . timestamp . to_str () . to_owned () , version : msg . version . to_str () . to_owned () , manufacturer : msg . manufacturer . to_str () . to_owned () , serial_number : msg . serial_number . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . header_id = self . header_id ; msg . timestamp . assign (& self . timestamp) ; msg . version . assign (& self . version) ; msg . manufacturer . assign (& self . manufacturer) ; msg . serial_number . assign (& self . serial_number) ; } } impl Default for Header { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Header > :: new () ; Header :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Info { pub info_type : std :: string :: String , pub info_references : Vec < vda5050_msgs :: msg :: InfoReference > , pub info_description : std :: string :: String , pub info_level : std :: string :: String } impl WrappedTypesupport for Info { type CStruct = vda5050_msgs__msg__Info ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__vda5050_msgs__msg__Info () } } fn create_msg () -> * mut vda5050_msgs__msg__Info { unsafe { vda5050_msgs__msg__Info__create () } } fn destroy_msg (msg : * mut vda5050_msgs__msg__Info) -> () { unsafe { vda5050_msgs__msg__Info__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Info { Info { info_type : msg . info_type . to_str () . to_owned () , info_references : { let mut temp = Vec :: with_capacity (msg . info_references . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . info_references . data , msg . info_references . size) } ; for s in slice { temp . push (vda5050_msgs :: msg :: InfoReference :: from_native (s)) ; } temp } , info_description : msg . info_description . to_str () . to_owned () , info_level : msg . info_level . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . info_type . assign (& self . info_type) ; unsafe { vda5050_msgs__msg__InfoReference__Sequence__fini (& mut msg . info_references) ; vda5050_msgs__msg__InfoReference__Sequence__init (& mut msg . info_references , self . info_references . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . info_references . data , msg . info_references . size) ; for (t , s) in slice . iter_mut () . zip (& self . info_references) { s . copy_to_native (t) ; } } msg . info_description . assign (& self . info_description) ; msg . info_level . assign (& self . info_level) ; } } impl Default for Info { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Info > :: new () ; Info :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl Info { pub const DEBUG : & [u8 ; 6usize] = vda5050_msgs__msg__Info__DEBUG ; pub const INFO : & [u8 ; 5usize] = vda5050_msgs__msg__Info__INFO ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct InfoReference { pub reference_key : std :: string :: String , pub reference_value : std :: string :: String } impl WrappedTypesupport for InfoReference { type CStruct = vda5050_msgs__msg__InfoReference ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__vda5050_msgs__msg__InfoReference () } } fn create_msg () -> * mut vda5050_msgs__msg__InfoReference { unsafe { vda5050_msgs__msg__InfoReference__create () } } fn destroy_msg (msg : * mut vda5050_msgs__msg__InfoReference) -> () { unsafe { vda5050_msgs__msg__InfoReference__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> InfoReference { InfoReference { reference_key : msg . reference_key . to_str () . to_owned () , reference_value : msg . reference_value . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . reference_key . assign (& self . reference_key) ; msg . reference_value . assign (& self . reference_value) ; } } impl Default for InfoReference { fn default () -> Self { let msg_native = WrappedNativeMsg :: < InfoReference > :: new () ; InfoReference :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct InstantActions { pub header_id : u32 , pub timestamp : std :: string :: String , pub version : std :: string :: String , pub manufacturer : std :: string :: String , pub serial_number : std :: string :: String , pub actions : Vec < vda5050_msgs :: msg :: Action > } impl WrappedTypesupport for InstantActions { type CStruct = vda5050_msgs__msg__InstantActions ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__vda5050_msgs__msg__InstantActions () } } fn create_msg () -> * mut vda5050_msgs__msg__InstantActions { unsafe { vda5050_msgs__msg__InstantActions__create () } } fn destroy_msg (msg : * mut vda5050_msgs__msg__InstantActions) -> () { unsafe { vda5050_msgs__msg__InstantActions__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> InstantActions { InstantActions { header_id : msg . header_id , timestamp : msg . timestamp . to_str () . to_owned () , version : msg . version . to_str () . to_owned () , manufacturer : msg . manufacturer . to_str () . to_owned () , serial_number : msg . serial_number . to_str () . to_owned () , actions : { let mut temp = Vec :: with_capacity (msg . actions . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . actions . data , msg . actions . size) } ; for s in slice { temp . push (vda5050_msgs :: msg :: Action :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . header_id = self . header_id ; msg . timestamp . assign (& self . timestamp) ; msg . version . assign (& self . version) ; msg . manufacturer . assign (& self . manufacturer) ; msg . serial_number . assign (& self . serial_number) ; unsafe { vda5050_msgs__msg__Action__Sequence__fini (& mut msg . actions) ; vda5050_msgs__msg__Action__Sequence__init (& mut msg . actions , self . actions . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . actions . data , msg . actions . size) ; for (t , s) in slice . iter_mut () . zip (& self . actions) { s . copy_to_native (t) ; } } } } impl Default for InstantActions { fn default () -> Self { let msg_native = WrappedNativeMsg :: < InstantActions > :: new () ; InstantActions :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Load { pub load_id : std :: string :: String , pub load_type : std :: string :: String , pub load_position : std :: string :: String , pub bounding_box_reference : vda5050_msgs :: msg :: BoundingBoxReference , pub load_dimensions : vda5050_msgs :: msg :: LoadDimensions , pub weight : f64 } impl WrappedTypesupport for Load { type CStruct = vda5050_msgs__msg__Load ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__vda5050_msgs__msg__Load () } } fn create_msg () -> * mut vda5050_msgs__msg__Load { unsafe { vda5050_msgs__msg__Load__create () } } fn destroy_msg (msg : * mut vda5050_msgs__msg__Load) -> () { unsafe { vda5050_msgs__msg__Load__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Load { Load { load_id : msg . load_id . to_str () . to_owned () , load_type : msg . load_type . to_str () . to_owned () , load_position : msg . load_position . to_str () . to_owned () , bounding_box_reference : vda5050_msgs :: msg :: BoundingBoxReference :: from_native (& msg . bounding_box_reference) , load_dimensions : vda5050_msgs :: msg :: LoadDimensions :: from_native (& msg . load_dimensions) , weight : msg . weight , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . load_id . assign (& self . load_id) ; msg . load_type . assign (& self . load_type) ; msg . load_position . assign (& self . load_position) ; self . bounding_box_reference . copy_to_native (& mut msg . bounding_box_reference) ; self . load_dimensions . copy_to_native (& mut msg . load_dimensions) ; msg . weight = self . weight ; } } impl Default for Load { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Load > :: new () ; Load :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct LoadDimensions { pub length : f64 , pub width : f64 , pub height : f64 } impl WrappedTypesupport for LoadDimensions { type CStruct = vda5050_msgs__msg__LoadDimensions ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__vda5050_msgs__msg__LoadDimensions () } } fn create_msg () -> * mut vda5050_msgs__msg__LoadDimensions { unsafe { vda5050_msgs__msg__LoadDimensions__create () } } fn destroy_msg (msg : * mut vda5050_msgs__msg__LoadDimensions) -> () { unsafe { vda5050_msgs__msg__LoadDimensions__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> LoadDimensions { LoadDimensions { length : msg . length , width : msg . width , height : msg . height , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . length = self . length ; msg . width = self . width ; msg . height = self . height ; } } impl Default for LoadDimensions { fn default () -> Self { let msg_native = WrappedNativeMsg :: < LoadDimensions > :: new () ; LoadDimensions :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct LoadSet { pub set_name : std :: string :: String , pub load_type : std :: string :: String , pub load_positions : Vec < std :: string :: String > , pub bounding_box_reference : vda5050_msgs :: msg :: BoundingBoxReference , pub load_dimensions : vda5050_msgs :: msg :: LoadDimensions , pub max_weight : f64 , pub min_loadhandling_height : f64 , pub max_loadhandling_height : f64 , pub min_loadhandling_depth : f64 , pub max_loadhandling_depth : f64 , pub min_loadhandling_tilt : f64 , pub max_loadhandling_tilt : f64 , pub agv_speed_limit : f64 , pub agv_acceleration_limit : f64 , pub agv_deceleration_limit : f64 , pub pick_time : f64 , pub drop_time : f64 , pub description : std :: string :: String } impl WrappedTypesupport for LoadSet { type CStruct = vda5050_msgs__msg__LoadSet ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__vda5050_msgs__msg__LoadSet () } } fn create_msg () -> * mut vda5050_msgs__msg__LoadSet { unsafe { vda5050_msgs__msg__LoadSet__create () } } fn destroy_msg (msg : * mut vda5050_msgs__msg__LoadSet) -> () { unsafe { vda5050_msgs__msg__LoadSet__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> LoadSet { LoadSet { set_name : msg . set_name . to_str () . to_owned () , load_type : msg . load_type . to_str () . to_owned () , load_positions : msg . load_positions . to_vec () , bounding_box_reference : vda5050_msgs :: msg :: BoundingBoxReference :: from_native (& msg . bounding_box_reference) , load_dimensions : vda5050_msgs :: msg :: LoadDimensions :: from_native (& msg . load_dimensions) , max_weight : msg . max_weight , min_loadhandling_height : msg . min_loadhandling_height , max_loadhandling_height : msg . max_loadhandling_height , min_loadhandling_depth : msg . min_loadhandling_depth , max_loadhandling_depth : msg . max_loadhandling_depth , min_loadhandling_tilt : msg . min_loadhandling_tilt , max_loadhandling_tilt : msg . max_loadhandling_tilt , agv_speed_limit : msg . agv_speed_limit , agv_acceleration_limit : msg . agv_acceleration_limit , agv_deceleration_limit : msg . agv_deceleration_limit , pick_time : msg . pick_time , drop_time : msg . drop_time , description : msg . description . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . set_name . assign (& self . set_name) ; msg . load_type . assign (& self . load_type) ; msg . load_positions . update (& self . load_positions) ; self . bounding_box_reference . copy_to_native (& mut msg . bounding_box_reference) ; self . load_dimensions . copy_to_native (& mut msg . load_dimensions) ; msg . max_weight = self . max_weight ; msg . min_loadhandling_height = self . min_loadhandling_height ; msg . max_loadhandling_height = self . max_loadhandling_height ; msg . min_loadhandling_depth = self . min_loadhandling_depth ; msg . max_loadhandling_depth = self . max_loadhandling_depth ; msg . min_loadhandling_tilt = self . min_loadhandling_tilt ; msg . max_loadhandling_tilt = self . max_loadhandling_tilt ; msg . agv_speed_limit = self . agv_speed_limit ; msg . agv_acceleration_limit = self . agv_acceleration_limit ; msg . agv_deceleration_limit = self . agv_deceleration_limit ; msg . pick_time = self . pick_time ; msg . drop_time = self . drop_time ; msg . description . assign (& self . description) ; } } impl Default for LoadSet { fn default () -> Self { let msg_native = WrappedNativeMsg :: < LoadSet > :: new () ; LoadSet :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct LoadSpecification { pub load_positions : Vec < std :: string :: String > , pub load_sets : Vec < vda5050_msgs :: msg :: LoadSet > } impl WrappedTypesupport for LoadSpecification { type CStruct = vda5050_msgs__msg__LoadSpecification ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__vda5050_msgs__msg__LoadSpecification () } } fn create_msg () -> * mut vda5050_msgs__msg__LoadSpecification { unsafe { vda5050_msgs__msg__LoadSpecification__create () } } fn destroy_msg (msg : * mut vda5050_msgs__msg__LoadSpecification) -> () { unsafe { vda5050_msgs__msg__LoadSpecification__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> LoadSpecification { LoadSpecification { load_positions : msg . load_positions . to_vec () , load_sets : { let mut temp = Vec :: with_capacity (msg . load_sets . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . load_sets . data , msg . load_sets . size) } ; for s in slice { temp . push (vda5050_msgs :: msg :: LoadSet :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . load_positions . update (& self . load_positions) ; unsafe { vda5050_msgs__msg__LoadSet__Sequence__fini (& mut msg . load_sets) ; vda5050_msgs__msg__LoadSet__Sequence__init (& mut msg . load_sets , self . load_sets . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . load_sets . data , msg . load_sets . size) ; for (t , s) in slice . iter_mut () . zip (& self . load_sets) { s . copy_to_native (t) ; } } } } impl Default for LoadSpecification { fn default () -> Self { let msg_native = WrappedNativeMsg :: < LoadSpecification > :: new () ; LoadSpecification :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct MaxArrayLens { pub order_nodes : u32 , pub order_edges : u32 , pub node_actions : u32 , pub edge_actions : u32 , pub actions_parameters : u32 , pub instant_actions : u32 , pub trajectory_knot_vector : u32 , pub trajectory_control_points : u32 , pub state_node_states : u32 , pub state_edge_states : u32 , pub state_loads : u32 , pub state_action_states : u32 , pub state_errors : u32 , pub state_information : u32 , pub error_references : u32 , pub info_references : u32 } impl WrappedTypesupport for MaxArrayLens { type CStruct = vda5050_msgs__msg__MaxArrayLens ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__vda5050_msgs__msg__MaxArrayLens () } } fn create_msg () -> * mut vda5050_msgs__msg__MaxArrayLens { unsafe { vda5050_msgs__msg__MaxArrayLens__create () } } fn destroy_msg (msg : * mut vda5050_msgs__msg__MaxArrayLens) -> () { unsafe { vda5050_msgs__msg__MaxArrayLens__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> MaxArrayLens { MaxArrayLens { order_nodes : msg . order_nodes , order_edges : msg . order_edges , node_actions : msg . node_actions , edge_actions : msg . edge_actions , actions_parameters : msg . actions_parameters , instant_actions : msg . instant_actions , trajectory_knot_vector : msg . trajectory_knot_vector , trajectory_control_points : msg . trajectory_control_points , state_node_states : msg . state_node_states , state_edge_states : msg . state_edge_states , state_loads : msg . state_loads , state_action_states : msg . state_action_states , state_errors : msg . state_errors , state_information : msg . state_information , error_references : msg . error_references , info_references : msg . info_references , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . order_nodes = self . order_nodes ; msg . order_edges = self . order_edges ; msg . node_actions = self . node_actions ; msg . edge_actions = self . edge_actions ; msg . actions_parameters = self . actions_parameters ; msg . instant_actions = self . instant_actions ; msg . trajectory_knot_vector = self . trajectory_knot_vector ; msg . trajectory_control_points = self . trajectory_control_points ; msg . state_node_states = self . state_node_states ; msg . state_edge_states = self . state_edge_states ; msg . state_loads = self . state_loads ; msg . state_action_states = self . state_action_states ; msg . state_errors = self . state_errors ; msg . state_information = self . state_information ; msg . error_references = self . error_references ; msg . info_references = self . info_references ; } } impl Default for MaxArrayLens { fn default () -> Self { let msg_native = WrappedNativeMsg :: < MaxArrayLens > :: new () ; MaxArrayLens :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct MaxStringLens { pub msg_len : u32 , pub topic_serial_len : u32 , pub topic_elem_len : u32 , pub id_len : u32 , pub id_numerical_only : bool , pub enum_len : u32 , pub load_id_len : u32 } impl WrappedTypesupport for MaxStringLens { type CStruct = vda5050_msgs__msg__MaxStringLens ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__vda5050_msgs__msg__MaxStringLens () } } fn create_msg () -> * mut vda5050_msgs__msg__MaxStringLens { unsafe { vda5050_msgs__msg__MaxStringLens__create () } } fn destroy_msg (msg : * mut vda5050_msgs__msg__MaxStringLens) -> () { unsafe { vda5050_msgs__msg__MaxStringLens__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> MaxStringLens { MaxStringLens { msg_len : msg . msg_len , topic_serial_len : msg . topic_serial_len , topic_elem_len : msg . topic_elem_len , id_len : msg . id_len , id_numerical_only : msg . id_numerical_only , enum_len : msg . enum_len , load_id_len : msg . load_id_len , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . msg_len = self . msg_len ; msg . topic_serial_len = self . topic_serial_len ; msg . topic_elem_len = self . topic_elem_len ; msg . id_len = self . id_len ; msg . id_numerical_only = self . id_numerical_only ; msg . enum_len = self . enum_len ; msg . load_id_len = self . load_id_len ; } } impl Default for MaxStringLens { fn default () -> Self { let msg_native = WrappedNativeMsg :: < MaxStringLens > :: new () ; MaxStringLens :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Node { pub node_id : std :: string :: String , pub sequence_id : u32 , pub node_description : std :: string :: String , pub released : bool , pub node_position : vda5050_msgs :: msg :: NodePosition , pub actions : Vec < vda5050_msgs :: msg :: Action > } impl WrappedTypesupport for Node { type CStruct = vda5050_msgs__msg__Node ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__vda5050_msgs__msg__Node () } } fn create_msg () -> * mut vda5050_msgs__msg__Node { unsafe { vda5050_msgs__msg__Node__create () } } fn destroy_msg (msg : * mut vda5050_msgs__msg__Node) -> () { unsafe { vda5050_msgs__msg__Node__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Node { Node { node_id : msg . node_id . to_str () . to_owned () , sequence_id : msg . sequence_id , node_description : msg . node_description . to_str () . to_owned () , released : msg . released , node_position : vda5050_msgs :: msg :: NodePosition :: from_native (& msg . node_position) , actions : { let mut temp = Vec :: with_capacity (msg . actions . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . actions . data , msg . actions . size) } ; for s in slice { temp . push (vda5050_msgs :: msg :: Action :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . node_id . assign (& self . node_id) ; msg . sequence_id = self . sequence_id ; msg . node_description . assign (& self . node_description) ; msg . released = self . released ; self . node_position . copy_to_native (& mut msg . node_position) ; unsafe { vda5050_msgs__msg__Action__Sequence__fini (& mut msg . actions) ; vda5050_msgs__msg__Action__Sequence__init (& mut msg . actions , self . actions . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . actions . data , msg . actions . size) ; for (t , s) in slice . iter_mut () . zip (& self . actions) { s . copy_to_native (t) ; } } } } impl Default for Node { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Node > :: new () ; Node :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct NodePosition { pub x : f64 , pub y : f64 , pub theta : f64 , pub allowed_deviation_x_y : f32 , pub allowed_deviation_theta : f32 , pub map_id : std :: string :: String , pub map_description : std :: string :: String } impl WrappedTypesupport for NodePosition { type CStruct = vda5050_msgs__msg__NodePosition ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__vda5050_msgs__msg__NodePosition () } } fn create_msg () -> * mut vda5050_msgs__msg__NodePosition { unsafe { vda5050_msgs__msg__NodePosition__create () } } fn destroy_msg (msg : * mut vda5050_msgs__msg__NodePosition) -> () { unsafe { vda5050_msgs__msg__NodePosition__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> NodePosition { NodePosition { x : msg . x , y : msg . y , theta : msg . theta , allowed_deviation_x_y : msg . allowed_deviation_x_y , allowed_deviation_theta : msg . allowed_deviation_theta , map_id : msg . map_id . to_str () . to_owned () , map_description : msg . map_description . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . x = self . x ; msg . y = self . y ; msg . theta = self . theta ; msg . allowed_deviation_x_y = self . allowed_deviation_x_y ; msg . allowed_deviation_theta = self . allowed_deviation_theta ; msg . map_id . assign (& self . map_id) ; msg . map_description . assign (& self . map_description) ; } } impl Default for NodePosition { fn default () -> Self { let msg_native = WrappedNativeMsg :: < NodePosition > :: new () ; NodePosition :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct NodeState { pub node_id : std :: string :: String , pub sequence_id : u32 , pub node_description : std :: string :: String , pub position : vda5050_msgs :: msg :: NodePosition , pub released : bool } impl WrappedTypesupport for NodeState { type CStruct = vda5050_msgs__msg__NodeState ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__vda5050_msgs__msg__NodeState () } } fn create_msg () -> * mut vda5050_msgs__msg__NodeState { unsafe { vda5050_msgs__msg__NodeState__create () } } fn destroy_msg (msg : * mut vda5050_msgs__msg__NodeState) -> () { unsafe { vda5050_msgs__msg__NodeState__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> NodeState { NodeState { node_id : msg . node_id . to_str () . to_owned () , sequence_id : msg . sequence_id , node_description : msg . node_description . to_str () . to_owned () , position : vda5050_msgs :: msg :: NodePosition :: from_native (& msg . position) , released : msg . released , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . node_id . assign (& self . node_id) ; msg . sequence_id = self . sequence_id ; msg . node_description . assign (& self . node_description) ; self . position . copy_to_native (& mut msg . position) ; msg . released = self . released ; } } impl Default for NodeState { fn default () -> Self { let msg_native = WrappedNativeMsg :: < NodeState > :: new () ; NodeState :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct OptionalParameter { pub parameter : std :: string :: String , pub support : std :: string :: String , pub description : std :: string :: String } impl WrappedTypesupport for OptionalParameter { type CStruct = vda5050_msgs__msg__OptionalParameter ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__vda5050_msgs__msg__OptionalParameter () } } fn create_msg () -> * mut vda5050_msgs__msg__OptionalParameter { unsafe { vda5050_msgs__msg__OptionalParameter__create () } } fn destroy_msg (msg : * mut vda5050_msgs__msg__OptionalParameter) -> () { unsafe { vda5050_msgs__msg__OptionalParameter__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> OptionalParameter { OptionalParameter { parameter : msg . parameter . to_str () . to_owned () , support : msg . support . to_str () . to_owned () , description : msg . description . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . parameter . assign (& self . parameter) ; msg . support . assign (& self . support) ; msg . description . assign (& self . description) ; } } impl Default for OptionalParameter { fn default () -> Self { let msg_native = WrappedNativeMsg :: < OptionalParameter > :: new () ; OptionalParameter :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl OptionalParameter { pub const REQUIRED : & [u8 ; 9usize] = vda5050_msgs__msg__OptionalParameter__REQUIRED ; pub const SUPPORTED : & [u8 ; 10usize] = vda5050_msgs__msg__OptionalParameter__SUPPORTED ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Order { pub header_id : u32 , pub timestamp : std :: string :: String , pub version : std :: string :: String , pub manufacturer : std :: string :: String , pub serial_number : std :: string :: String , pub order_id : std :: string :: String , pub order_update_id : u32 , pub zone_set_id : std :: string :: String , pub nodes : Vec < vda5050_msgs :: msg :: Node > , pub edges : Vec < vda5050_msgs :: msg :: Edge > } impl WrappedTypesupport for Order { type CStruct = vda5050_msgs__msg__Order ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__vda5050_msgs__msg__Order () } } fn create_msg () -> * mut vda5050_msgs__msg__Order { unsafe { vda5050_msgs__msg__Order__create () } } fn destroy_msg (msg : * mut vda5050_msgs__msg__Order) -> () { unsafe { vda5050_msgs__msg__Order__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Order { Order { header_id : msg . header_id , timestamp : msg . timestamp . to_str () . to_owned () , version : msg . version . to_str () . to_owned () , manufacturer : msg . manufacturer . to_str () . to_owned () , serial_number : msg . serial_number . to_str () . to_owned () , order_id : msg . order_id . to_str () . to_owned () , order_update_id : msg . order_update_id , zone_set_id : msg . zone_set_id . to_str () . to_owned () , nodes : { let mut temp = Vec :: with_capacity (msg . nodes . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . nodes . data , msg . nodes . size) } ; for s in slice { temp . push (vda5050_msgs :: msg :: Node :: from_native (s)) ; } temp } , edges : { let mut temp = Vec :: with_capacity (msg . edges . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . edges . data , msg . edges . size) } ; for s in slice { temp . push (vda5050_msgs :: msg :: Edge :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . header_id = self . header_id ; msg . timestamp . assign (& self . timestamp) ; msg . version . assign (& self . version) ; msg . manufacturer . assign (& self . manufacturer) ; msg . serial_number . assign (& self . serial_number) ; msg . order_id . assign (& self . order_id) ; msg . order_update_id = self . order_update_id ; msg . zone_set_id . assign (& self . zone_set_id) ; unsafe { vda5050_msgs__msg__Node__Sequence__fini (& mut msg . nodes) ; vda5050_msgs__msg__Node__Sequence__init (& mut msg . nodes , self . nodes . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . nodes . data , msg . nodes . size) ; for (t , s) in slice . iter_mut () . zip (& self . nodes) { s . copy_to_native (t) ; } } unsafe { vda5050_msgs__msg__Edge__Sequence__fini (& mut msg . edges) ; vda5050_msgs__msg__Edge__Sequence__init (& mut msg . edges , self . edges . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . edges . data , msg . edges . size) ; for (t , s) in slice . iter_mut () . zip (& self . edges) { s . copy_to_native (t) ; } } } } impl Default for Order { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Order > :: new () ; Order :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct OrderState { pub header_id : u32 , pub timestamp : std :: string :: String , pub version : std :: string :: String , pub manufacturer : std :: string :: String , pub serial_number : std :: string :: String , pub order_id : std :: string :: String , pub order_update_id : u32 , pub zone_set_id : std :: string :: String , pub last_node_id : std :: string :: String , pub last_node_sequence_id : u32 , pub node_states : Vec < vda5050_msgs :: msg :: NodeState > , pub edge_states : Vec < vda5050_msgs :: msg :: EdgeState > , pub agv_position : vda5050_msgs :: msg :: AGVPosition , pub velocity : vda5050_msgs :: msg :: Velocity , pub loads : Vec < vda5050_msgs :: msg :: Load > , pub driving : bool , pub paused : bool , pub new_base_requested : bool , pub distance_since_last_node : f64 , pub action_states : Vec < vda5050_msgs :: msg :: CurrentAction > , pub battery_state : vda5050_msgs :: msg :: BatteryState , pub operating_mode : std :: string :: String , pub errors : Vec < vda5050_msgs :: msg :: Error > , pub informations : Vec < vda5050_msgs :: msg :: Info > , pub safety_state : vda5050_msgs :: msg :: SafetyState } impl WrappedTypesupport for OrderState { type CStruct = vda5050_msgs__msg__OrderState ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__vda5050_msgs__msg__OrderState () } } fn create_msg () -> * mut vda5050_msgs__msg__OrderState { unsafe { vda5050_msgs__msg__OrderState__create () } } fn destroy_msg (msg : * mut vda5050_msgs__msg__OrderState) -> () { unsafe { vda5050_msgs__msg__OrderState__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> OrderState { OrderState { header_id : msg . header_id , timestamp : msg . timestamp . to_str () . to_owned () , version : msg . version . to_str () . to_owned () , manufacturer : msg . manufacturer . to_str () . to_owned () , serial_number : msg . serial_number . to_str () . to_owned () , order_id : msg . order_id . to_str () . to_owned () , order_update_id : msg . order_update_id , zone_set_id : msg . zone_set_id . to_str () . to_owned () , last_node_id : msg . last_node_id . to_str () . to_owned () , last_node_sequence_id : msg . last_node_sequence_id , node_states : { let mut temp = Vec :: with_capacity (msg . node_states . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . node_states . data , msg . node_states . size) } ; for s in slice { temp . push (vda5050_msgs :: msg :: NodeState :: from_native (s)) ; } temp } , edge_states : { let mut temp = Vec :: with_capacity (msg . edge_states . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . edge_states . data , msg . edge_states . size) } ; for s in slice { temp . push (vda5050_msgs :: msg :: EdgeState :: from_native (s)) ; } temp } , agv_position : vda5050_msgs :: msg :: AGVPosition :: from_native (& msg . agv_position) , velocity : vda5050_msgs :: msg :: Velocity :: from_native (& msg . velocity) , loads : { let mut temp = Vec :: with_capacity (msg . loads . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . loads . data , msg . loads . size) } ; for s in slice { temp . push (vda5050_msgs :: msg :: Load :: from_native (s)) ; } temp } , driving : msg . driving , paused : msg . paused , new_base_requested : msg . new_base_requested , distance_since_last_node : msg . distance_since_last_node , action_states : { let mut temp = Vec :: with_capacity (msg . action_states . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . action_states . data , msg . action_states . size) } ; for s in slice { temp . push (vda5050_msgs :: msg :: CurrentAction :: from_native (s)) ; } temp } , battery_state : vda5050_msgs :: msg :: BatteryState :: from_native (& msg . battery_state) , operating_mode : msg . operating_mode . to_str () . to_owned () , errors : { let mut temp = Vec :: with_capacity (msg . errors . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . errors . data , msg . errors . size) } ; for s in slice { temp . push (vda5050_msgs :: msg :: Error :: from_native (s)) ; } temp } , informations : { let mut temp = Vec :: with_capacity (msg . informations . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . informations . data , msg . informations . size) } ; for s in slice { temp . push (vda5050_msgs :: msg :: Info :: from_native (s)) ; } temp } , safety_state : vda5050_msgs :: msg :: SafetyState :: from_native (& msg . safety_state) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . header_id = self . header_id ; msg . timestamp . assign (& self . timestamp) ; msg . version . assign (& self . version) ; msg . manufacturer . assign (& self . manufacturer) ; msg . serial_number . assign (& self . serial_number) ; msg . order_id . assign (& self . order_id) ; msg . order_update_id = self . order_update_id ; msg . zone_set_id . assign (& self . zone_set_id) ; msg . last_node_id . assign (& self . last_node_id) ; msg . last_node_sequence_id = self . last_node_sequence_id ; unsafe { vda5050_msgs__msg__NodeState__Sequence__fini (& mut msg . node_states) ; vda5050_msgs__msg__NodeState__Sequence__init (& mut msg . node_states , self . node_states . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . node_states . data , msg . node_states . size) ; for (t , s) in slice . iter_mut () . zip (& self . node_states) { s . copy_to_native (t) ; } } unsafe { vda5050_msgs__msg__EdgeState__Sequence__fini (& mut msg . edge_states) ; vda5050_msgs__msg__EdgeState__Sequence__init (& mut msg . edge_states , self . edge_states . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . edge_states . data , msg . edge_states . size) ; for (t , s) in slice . iter_mut () . zip (& self . edge_states) { s . copy_to_native (t) ; } } self . agv_position . copy_to_native (& mut msg . agv_position) ; self . velocity . copy_to_native (& mut msg . velocity) ; unsafe { vda5050_msgs__msg__Load__Sequence__fini (& mut msg . loads) ; vda5050_msgs__msg__Load__Sequence__init (& mut msg . loads , self . loads . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . loads . data , msg . loads . size) ; for (t , s) in slice . iter_mut () . zip (& self . loads) { s . copy_to_native (t) ; } } msg . driving = self . driving ; msg . paused = self . paused ; msg . new_base_requested = self . new_base_requested ; msg . distance_since_last_node = self . distance_since_last_node ; unsafe { vda5050_msgs__msg__CurrentAction__Sequence__fini (& mut msg . action_states) ; vda5050_msgs__msg__CurrentAction__Sequence__init (& mut msg . action_states , self . action_states . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . action_states . data , msg . action_states . size) ; for (t , s) in slice . iter_mut () . zip (& self . action_states) { s . copy_to_native (t) ; } } self . battery_state . copy_to_native (& mut msg . battery_state) ; msg . operating_mode . assign (& self . operating_mode) ; unsafe { vda5050_msgs__msg__Error__Sequence__fini (& mut msg . errors) ; vda5050_msgs__msg__Error__Sequence__init (& mut msg . errors , self . errors . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . errors . data , msg . errors . size) ; for (t , s) in slice . iter_mut () . zip (& self . errors) { s . copy_to_native (t) ; } } unsafe { vda5050_msgs__msg__Info__Sequence__fini (& mut msg . informations) ; vda5050_msgs__msg__Info__Sequence__init (& mut msg . informations , self . informations . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . informations . data , msg . informations . size) ; for (t , s) in slice . iter_mut () . zip (& self . informations) { s . copy_to_native (t) ; } } self . safety_state . copy_to_native (& mut msg . safety_state) ; } } impl Default for OrderState { fn default () -> Self { let msg_native = WrappedNativeMsg :: < OrderState > :: new () ; OrderState :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl OrderState { pub const AUTOMATIC : & [u8 ; 10usize] = vda5050_msgs__msg__OrderState__AUTOMATIC ; pub const MANUAL : & [u8 ; 7usize] = vda5050_msgs__msg__OrderState__MANUAL ; pub const SEMIAUTOMATIC : & [u8 ; 14usize] = vda5050_msgs__msg__OrderState__SEMIAUTOMATIC ; pub const SERVICE : & [u8 ; 8usize] = vda5050_msgs__msg__OrderState__SERVICE ; pub const TEACHIN : & [u8 ; 8usize] = vda5050_msgs__msg__OrderState__TEACHIN ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct PhysicalParameters { pub speed_min : f64 , pub speed_max : f64 , pub acceleration_max : f64 , pub deceleration_max : f64 , pub height_min : f64 , pub height_max : f64 , pub width : f64 , pub length : f64 } impl WrappedTypesupport for PhysicalParameters { type CStruct = vda5050_msgs__msg__PhysicalParameters ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__vda5050_msgs__msg__PhysicalParameters () } } fn create_msg () -> * mut vda5050_msgs__msg__PhysicalParameters { unsafe { vda5050_msgs__msg__PhysicalParameters__create () } } fn destroy_msg (msg : * mut vda5050_msgs__msg__PhysicalParameters) -> () { unsafe { vda5050_msgs__msg__PhysicalParameters__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> PhysicalParameters { PhysicalParameters { speed_min : msg . speed_min , speed_max : msg . speed_max , acceleration_max : msg . acceleration_max , deceleration_max : msg . deceleration_max , height_min : msg . height_min , height_max : msg . height_max , width : msg . width , length : msg . length , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . speed_min = self . speed_min ; msg . speed_max = self . speed_max ; msg . acceleration_max = self . acceleration_max ; msg . deceleration_max = self . deceleration_max ; msg . height_min = self . height_min ; msg . height_max = self . height_max ; msg . width = self . width ; msg . length = self . length ; } } impl Default for PhysicalParameters { fn default () -> Self { let msg_native = WrappedNativeMsg :: < PhysicalParameters > :: new () ; PhysicalParameters :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct PolygonPoint { pub x : f64 , pub y : f64 } impl WrappedTypesupport for PolygonPoint { type CStruct = vda5050_msgs__msg__PolygonPoint ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__vda5050_msgs__msg__PolygonPoint () } } fn create_msg () -> * mut vda5050_msgs__msg__PolygonPoint { unsafe { vda5050_msgs__msg__PolygonPoint__create () } } fn destroy_msg (msg : * mut vda5050_msgs__msg__PolygonPoint) -> () { unsafe { vda5050_msgs__msg__PolygonPoint__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> PolygonPoint { PolygonPoint { x : msg . x , y : msg . y , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . x = self . x ; msg . y = self . y ; } } impl Default for PolygonPoint { fn default () -> Self { let msg_native = WrappedNativeMsg :: < PolygonPoint > :: new () ; PolygonPoint :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Position { pub x : f64 , pub y : f64 , pub theta : f64 } impl WrappedTypesupport for Position { type CStruct = vda5050_msgs__msg__Position ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__vda5050_msgs__msg__Position () } } fn create_msg () -> * mut vda5050_msgs__msg__Position { unsafe { vda5050_msgs__msg__Position__create () } } fn destroy_msg (msg : * mut vda5050_msgs__msg__Position) -> () { unsafe { vda5050_msgs__msg__Position__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Position { Position { x : msg . x , y : msg . y , theta : msg . theta , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . x = self . x ; msg . y = self . y ; msg . theta = self . theta ; } } impl Default for Position { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Position > :: new () ; Position :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ProtocolFeatures { pub optional_parameters : Vec < vda5050_msgs :: msg :: OptionalParameter > , pub agv_actions : Vec < vda5050_msgs :: msg :: AGVAction > } impl WrappedTypesupport for ProtocolFeatures { type CStruct = vda5050_msgs__msg__ProtocolFeatures ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__vda5050_msgs__msg__ProtocolFeatures () } } fn create_msg () -> * mut vda5050_msgs__msg__ProtocolFeatures { unsafe { vda5050_msgs__msg__ProtocolFeatures__create () } } fn destroy_msg (msg : * mut vda5050_msgs__msg__ProtocolFeatures) -> () { unsafe { vda5050_msgs__msg__ProtocolFeatures__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ProtocolFeatures { ProtocolFeatures { optional_parameters : { let mut temp = Vec :: with_capacity (msg . optional_parameters . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . optional_parameters . data , msg . optional_parameters . size) } ; for s in slice { temp . push (vda5050_msgs :: msg :: OptionalParameter :: from_native (s)) ; } temp } , agv_actions : { let mut temp = Vec :: with_capacity (msg . agv_actions . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . agv_actions . data , msg . agv_actions . size) } ; for s in slice { temp . push (vda5050_msgs :: msg :: AGVAction :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { unsafe { vda5050_msgs__msg__OptionalParameter__Sequence__fini (& mut msg . optional_parameters) ; vda5050_msgs__msg__OptionalParameter__Sequence__init (& mut msg . optional_parameters , self . optional_parameters . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . optional_parameters . data , msg . optional_parameters . size) ; for (t , s) in slice . iter_mut () . zip (& self . optional_parameters) { s . copy_to_native (t) ; } } unsafe { vda5050_msgs__msg__AGVAction__Sequence__fini (& mut msg . agv_actions) ; vda5050_msgs__msg__AGVAction__Sequence__init (& mut msg . agv_actions , self . agv_actions . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . agv_actions . data , msg . agv_actions . size) ; for (t , s) in slice . iter_mut () . zip (& self . agv_actions) { s . copy_to_native (t) ; } } } } impl Default for ProtocolFeatures { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ProtocolFeatures > :: new () ; ProtocolFeatures :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ProtocolLimits { pub max_string_lens : vda5050_msgs :: msg :: MaxStringLens , pub max_array_lens : vda5050_msgs :: msg :: MaxArrayLens , pub timing : vda5050_msgs :: msg :: Timing } impl WrappedTypesupport for ProtocolLimits { type CStruct = vda5050_msgs__msg__ProtocolLimits ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__vda5050_msgs__msg__ProtocolLimits () } } fn create_msg () -> * mut vda5050_msgs__msg__ProtocolLimits { unsafe { vda5050_msgs__msg__ProtocolLimits__create () } } fn destroy_msg (msg : * mut vda5050_msgs__msg__ProtocolLimits) -> () { unsafe { vda5050_msgs__msg__ProtocolLimits__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ProtocolLimits { ProtocolLimits { max_string_lens : vda5050_msgs :: msg :: MaxStringLens :: from_native (& msg . max_string_lens) , max_array_lens : vda5050_msgs :: msg :: MaxArrayLens :: from_native (& msg . max_array_lens) , timing : vda5050_msgs :: msg :: Timing :: from_native (& msg . timing) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . max_string_lens . copy_to_native (& mut msg . max_string_lens) ; self . max_array_lens . copy_to_native (& mut msg . max_array_lens) ; self . timing . copy_to_native (& mut msg . timing) ; } } impl Default for ProtocolLimits { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ProtocolLimits > :: new () ; ProtocolLimits :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct SafetyState { pub e_stop : std :: string :: String , pub field_violation : bool } impl WrappedTypesupport for SafetyState { type CStruct = vda5050_msgs__msg__SafetyState ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__vda5050_msgs__msg__SafetyState () } } fn create_msg () -> * mut vda5050_msgs__msg__SafetyState { unsafe { vda5050_msgs__msg__SafetyState__create () } } fn destroy_msg (msg : * mut vda5050_msgs__msg__SafetyState) -> () { unsafe { vda5050_msgs__msg__SafetyState__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> SafetyState { SafetyState { e_stop : msg . e_stop . to_str () . to_owned () , field_violation : msg . field_violation , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . e_stop . assign (& self . e_stop) ; msg . field_violation = self . field_violation ; } } impl Default for SafetyState { fn default () -> Self { let msg_native = WrappedNativeMsg :: < SafetyState > :: new () ; SafetyState :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl SafetyState { pub const AUTO_ACK : & [u8 ; 8usize] = vda5050_msgs__msg__SafetyState__AUTO_ACK ; pub const MANUAL : & [u8 ; 7usize] = vda5050_msgs__msg__SafetyState__MANUAL ; pub const NONE : & [u8 ; 5usize] = vda5050_msgs__msg__SafetyState__NONE ; pub const REMOTE : & [u8 ; 7usize] = vda5050_msgs__msg__SafetyState__REMOTE ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Timing { pub min_order_interval : f32 , pub min_state_interval : f32 , pub default_state_interval : f32 , pub visualization_interval : f32 } impl WrappedTypesupport for Timing { type CStruct = vda5050_msgs__msg__Timing ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__vda5050_msgs__msg__Timing () } } fn create_msg () -> * mut vda5050_msgs__msg__Timing { unsafe { vda5050_msgs__msg__Timing__create () } } fn destroy_msg (msg : * mut vda5050_msgs__msg__Timing) -> () { unsafe { vda5050_msgs__msg__Timing__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Timing { Timing { min_order_interval : msg . min_order_interval , min_state_interval : msg . min_state_interval , default_state_interval : msg . default_state_interval , visualization_interval : msg . visualization_interval , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . min_order_interval = self . min_order_interval ; msg . min_state_interval = self . min_state_interval ; msg . default_state_interval = self . default_state_interval ; msg . visualization_interval = self . visualization_interval ; } } impl Default for Timing { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Timing > :: new () ; Timing :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Trajectory { pub degree : f64 , pub knot_vector : Vec < f64 > , pub control_points : Vec < vda5050_msgs :: msg :: ControlPoint > } impl WrappedTypesupport for Trajectory { type CStruct = vda5050_msgs__msg__Trajectory ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__vda5050_msgs__msg__Trajectory () } } fn create_msg () -> * mut vda5050_msgs__msg__Trajectory { unsafe { vda5050_msgs__msg__Trajectory__create () } } fn destroy_msg (msg : * mut vda5050_msgs__msg__Trajectory) -> () { unsafe { vda5050_msgs__msg__Trajectory__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Trajectory { Trajectory { degree : msg . degree , knot_vector : msg . knot_vector . to_vec () , control_points : { let mut temp = Vec :: with_capacity (msg . control_points . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . control_points . data , msg . control_points . size) } ; for s in slice { temp . push (vda5050_msgs :: msg :: ControlPoint :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . degree = self . degree ; msg . knot_vector . update (& self . knot_vector) ; unsafe { vda5050_msgs__msg__ControlPoint__Sequence__fini (& mut msg . control_points) ; vda5050_msgs__msg__ControlPoint__Sequence__init (& mut msg . control_points , self . control_points . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . control_points . data , msg . control_points . size) ; for (t , s) in slice . iter_mut () . zip (& self . control_points) { s . copy_to_native (t) ; } } } } impl Default for Trajectory { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Trajectory > :: new () ; Trajectory :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct TypeSpecification { pub series_name : std :: string :: String , pub series_description : std :: string :: String , pub agv_kinematic : std :: string :: String , pub agv_class : std :: string :: String , pub max_load_mass : f64 , pub localization_types : Vec < std :: string :: String > , pub navigation_types : Vec < std :: string :: String > } impl WrappedTypesupport for TypeSpecification { type CStruct = vda5050_msgs__msg__TypeSpecification ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__vda5050_msgs__msg__TypeSpecification () } } fn create_msg () -> * mut vda5050_msgs__msg__TypeSpecification { unsafe { vda5050_msgs__msg__TypeSpecification__create () } } fn destroy_msg (msg : * mut vda5050_msgs__msg__TypeSpecification) -> () { unsafe { vda5050_msgs__msg__TypeSpecification__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> TypeSpecification { TypeSpecification { series_name : msg . series_name . to_str () . to_owned () , series_description : msg . series_description . to_str () . to_owned () , agv_kinematic : msg . agv_kinematic . to_str () . to_owned () , agv_class : msg . agv_class . to_str () . to_owned () , max_load_mass : msg . max_load_mass , localization_types : msg . localization_types . to_vec () , navigation_types : msg . navigation_types . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . series_name . assign (& self . series_name) ; msg . series_description . assign (& self . series_description) ; msg . agv_kinematic . assign (& self . agv_kinematic) ; msg . agv_class . assign (& self . agv_class) ; msg . max_load_mass = self . max_load_mass ; msg . localization_types . update (& self . localization_types) ; msg . navigation_types . update (& self . navigation_types) ; } } impl Default for TypeSpecification { fn default () -> Self { let msg_native = WrappedNativeMsg :: < TypeSpecification > :: new () ; TypeSpecification :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl TypeSpecification { pub const AUTONOMOUS : & [u8 ; 11usize] = vda5050_msgs__msg__TypeSpecification__AUTONOMOUS ; pub const CARRIER : & [u8 ; 8usize] = vda5050_msgs__msg__TypeSpecification__CARRIER ; pub const CONVEYOR : & [u8 ; 9usize] = vda5050_msgs__msg__TypeSpecification__CONVEYOR ; pub const DIFF : & [u8 ; 5usize] = vda5050_msgs__msg__TypeSpecification__DIFF ; pub const DMC : & [u8 ; 4usize] = vda5050_msgs__msg__TypeSpecification__DMC ; pub const FORKLIFT : & [u8 ; 9usize] = vda5050_msgs__msg__TypeSpecification__FORKLIFT ; pub const GRID : & [u8 ; 5usize] = vda5050_msgs__msg__TypeSpecification__GRID ; pub const NATURAL : & [u8 ; 8usize] = vda5050_msgs__msg__TypeSpecification__NATURAL ; pub const OMNI : & [u8 ; 5usize] = vda5050_msgs__msg__TypeSpecification__OMNI ; pub const PHYSICAL_LINE_GUIDED : & [u8 ; 21usize] = vda5050_msgs__msg__TypeSpecification__PHYSICAL_LINE_GUIDED ; pub const REFLECTOR : & [u8 ; 10usize] = vda5050_msgs__msg__TypeSpecification__REFLECTOR ; pub const RFID : & [u8 ; 5usize] = vda5050_msgs__msg__TypeSpecification__RFID ; pub const SPOT : & [u8 ; 5usize] = vda5050_msgs__msg__TypeSpecification__SPOT ; pub const THREEWHEEL : & [u8 ; 11usize] = vda5050_msgs__msg__TypeSpecification__THREEWHEEL ; pub const TUGGER : & [u8 ; 7usize] = vda5050_msgs__msg__TypeSpecification__TUGGER ; pub const VIRTUAL_LINE_GUIDED : & [u8 ; 20usize] = vda5050_msgs__msg__TypeSpecification__VIRTUAL_LINE_GUIDED ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Velocity { pub vx : f64 , pub vy : f64 , pub omega : f64 } impl WrappedTypesupport for Velocity { type CStruct = vda5050_msgs__msg__Velocity ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__vda5050_msgs__msg__Velocity () } } fn create_msg () -> * mut vda5050_msgs__msg__Velocity { unsafe { vda5050_msgs__msg__Velocity__create () } } fn destroy_msg (msg : * mut vda5050_msgs__msg__Velocity) -> () { unsafe { vda5050_msgs__msg__Velocity__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Velocity { Velocity { vx : msg . vx , vy : msg . vy , omega : msg . omega , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . vx = self . vx ; msg . vy = self . vy ; msg . omega = self . omega ; } } impl Default for Velocity { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Velocity > :: new () ; Velocity :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Visualization { pub header_id : u32 , pub timestamp : std :: string :: String , pub version : std :: string :: String , pub manufacturer : std :: string :: String , pub serial_number : std :: string :: String , pub agv_position : vda5050_msgs :: msg :: AGVPosition , pub velocity : vda5050_msgs :: msg :: Velocity } impl WrappedTypesupport for Visualization { type CStruct = vda5050_msgs__msg__Visualization ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__vda5050_msgs__msg__Visualization () } } fn create_msg () -> * mut vda5050_msgs__msg__Visualization { unsafe { vda5050_msgs__msg__Visualization__create () } } fn destroy_msg (msg : * mut vda5050_msgs__msg__Visualization) -> () { unsafe { vda5050_msgs__msg__Visualization__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Visualization { Visualization { header_id : msg . header_id , timestamp : msg . timestamp . to_str () . to_owned () , version : msg . version . to_str () . to_owned () , manufacturer : msg . manufacturer . to_str () . to_owned () , serial_number : msg . serial_number . to_str () . to_owned () , agv_position : vda5050_msgs :: msg :: AGVPosition :: from_native (& msg . agv_position) , velocity : vda5050_msgs :: msg :: Velocity :: from_native (& msg . velocity) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . header_id = self . header_id ; msg . timestamp . assign (& self . timestamp) ; msg . version . assign (& self . version) ; msg . manufacturer . assign (& self . manufacturer) ; msg . serial_number . assign (& self . serial_number) ; self . agv_position . copy_to_native (& mut msg . agv_position) ; self . velocity . copy_to_native (& mut msg . velocity) ; } } impl Default for Visualization { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Visualization > :: new () ; Visualization :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct WheelDefinition { # [serde (rename = "type")] pub type_ : std :: string :: String , pub is_active_driven : bool , pub is_active_steered : bool , pub position : vda5050_msgs :: msg :: Position , pub diameter : f64 , pub width : f64 , pub center_displacement : f64 , pub constraints : std :: string :: String } impl WrappedTypesupport for WheelDefinition { type CStruct = vda5050_msgs__msg__WheelDefinition ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__vda5050_msgs__msg__WheelDefinition () } } fn create_msg () -> * mut vda5050_msgs__msg__WheelDefinition { unsafe { vda5050_msgs__msg__WheelDefinition__create () } } fn destroy_msg (msg : * mut vda5050_msgs__msg__WheelDefinition) -> () { unsafe { vda5050_msgs__msg__WheelDefinition__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> WheelDefinition { WheelDefinition { type_ : msg . type_ . to_str () . to_owned () , is_active_driven : msg . is_active_driven , is_active_steered : msg . is_active_steered , position : vda5050_msgs :: msg :: Position :: from_native (& msg . position) , diameter : msg . diameter , width : msg . width , center_displacement : msg . center_displacement , constraints : msg . constraints . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . type_ . assign (& self . type_) ; msg . is_active_driven = self . is_active_driven ; msg . is_active_steered = self . is_active_steered ; self . position . copy_to_native (& mut msg . position) ; msg . diameter = self . diameter ; msg . width = self . width ; msg . center_displacement = self . center_displacement ; msg . constraints . assign (& self . constraints) ; } } impl Default for WheelDefinition { fn default () -> Self { let msg_native = WrappedNativeMsg :: < WheelDefinition > :: new () ; WheelDefinition :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl WheelDefinition { pub const CASTER : & [u8 ; 7usize] = vda5050_msgs__msg__WheelDefinition__CASTER ; pub const DRIVE : & [u8 ; 6usize] = vda5050_msgs__msg__WheelDefinition__DRIVE ; pub const FIXED : & [u8 ; 6usize] = vda5050_msgs__msg__WheelDefinition__FIXED ; pub const MECANUM : & [u8 ; 8usize] = vda5050_msgs__msg__WheelDefinition__MECANUM ; } }