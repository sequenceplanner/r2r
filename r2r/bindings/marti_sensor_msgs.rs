pub mod msg { use super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Altitude { pub header : std_msgs :: msg :: Header , pub altitude : f64 , pub sigma : f64 } impl WrappedTypesupport for Altitude { type CStruct = marti_sensor_msgs__msg__Altitude ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__marti_sensor_msgs__msg__Altitude () } } fn create_msg () -> * mut marti_sensor_msgs__msg__Altitude { unsafe { marti_sensor_msgs__msg__Altitude__create () } } fn destroy_msg (msg : * mut marti_sensor_msgs__msg__Altitude) -> () { unsafe { marti_sensor_msgs__msg__Altitude__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Altitude { Altitude { header : std_msgs :: msg :: Header :: from_native (& msg . header) , altitude : msg . altitude , sigma : msg . sigma , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . altitude = self . altitude ; msg . sigma = self . sigma ; } } impl Default for Altitude { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Altitude > :: new () ; Altitude :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct DifferentialMeasurement { pub header : std_msgs :: msg :: Header , pub base_frame_id : std :: string :: String , pub baseline_length : f64 , pub baseline_length_variance : f64 , pub heading : f64 , pub heading_variance : f64 , pub pitch : f64 , pub pitch_variance : f64 , pub roll : f64 , pub roll_variance : f64 , pub position : geometry_msgs :: msg :: Vector3 , pub position_covariance : Vec < f64 > } impl WrappedTypesupport for DifferentialMeasurement { type CStruct = marti_sensor_msgs__msg__DifferentialMeasurement ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__marti_sensor_msgs__msg__DifferentialMeasurement () } } fn create_msg () -> * mut marti_sensor_msgs__msg__DifferentialMeasurement { unsafe { marti_sensor_msgs__msg__DifferentialMeasurement__create () } } fn destroy_msg (msg : * mut marti_sensor_msgs__msg__DifferentialMeasurement) -> () { unsafe { marti_sensor_msgs__msg__DifferentialMeasurement__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> DifferentialMeasurement { DifferentialMeasurement { header : std_msgs :: msg :: Header :: from_native (& msg . header) , base_frame_id : msg . base_frame_id . to_str () . to_owned () , baseline_length : msg . baseline_length , baseline_length_variance : msg . baseline_length_variance , heading : msg . heading , heading_variance : msg . heading_variance , pitch : msg . pitch , pitch_variance : msg . pitch_variance , roll : msg . roll , roll_variance : msg . roll_variance , position : geometry_msgs :: msg :: Vector3 :: from_native (& msg . position) , position_covariance : msg . position_covariance . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . base_frame_id . assign (& self . base_frame_id) ; msg . baseline_length = self . baseline_length ; msg . baseline_length_variance = self . baseline_length_variance ; msg . heading = self . heading ; msg . heading_variance = self . heading_variance ; msg . pitch = self . pitch ; msg . pitch_variance = self . pitch_variance ; msg . roll = self . roll ; msg . roll_variance = self . roll_variance ; self . position . copy_to_native (& mut msg . position) ; assert_eq ! (self . position_covariance . len () , 9usize , "Field {} is fixed size of {}!" , "position_covariance" , 9usize) ; msg . position_covariance . copy_from_slice (& self . position_covariance [.. 9usize]) ; } } impl Default for DifferentialMeasurement { fn default () -> Self { let msg_native = WrappedNativeMsg :: < DifferentialMeasurement > :: new () ; DifferentialMeasurement :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct DioPortState { pub header : std_msgs :: msg :: Header , pub value : u64 } impl WrappedTypesupport for DioPortState { type CStruct = marti_sensor_msgs__msg__DioPortState ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__marti_sensor_msgs__msg__DioPortState () } } fn create_msg () -> * mut marti_sensor_msgs__msg__DioPortState { unsafe { marti_sensor_msgs__msg__DioPortState__create () } } fn destroy_msg (msg : * mut marti_sensor_msgs__msg__DioPortState) -> () { unsafe { marti_sensor_msgs__msg__DioPortState__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> DioPortState { DioPortState { header : std_msgs :: msg :: Header :: from_native (& msg . header) , value : msg . value , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . value = self . value ; } } impl Default for DioPortState { fn default () -> Self { let msg_native = WrappedNativeMsg :: < DioPortState > :: new () ; DioPortState :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct DioRealTimeData { pub header : std_msgs :: msg :: Header , pub sample_frequency : f64 , pub latest_sample_time : u64 , pub sample_states : Vec < u16 > , pub sample_times : Vec < u32 > } impl WrappedTypesupport for DioRealTimeData { type CStruct = marti_sensor_msgs__msg__DioRealTimeData ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__marti_sensor_msgs__msg__DioRealTimeData () } } fn create_msg () -> * mut marti_sensor_msgs__msg__DioRealTimeData { unsafe { marti_sensor_msgs__msg__DioRealTimeData__create () } } fn destroy_msg (msg : * mut marti_sensor_msgs__msg__DioRealTimeData) -> () { unsafe { marti_sensor_msgs__msg__DioRealTimeData__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> DioRealTimeData { DioRealTimeData { header : std_msgs :: msg :: Header :: from_native (& msg . header) , sample_frequency : msg . sample_frequency , latest_sample_time : msg . latest_sample_time , sample_states : msg . sample_states . to_vec () , sample_times : msg . sample_times . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . sample_frequency = self . sample_frequency ; msg . latest_sample_time = self . latest_sample_time ; msg . sample_states . update (& self . sample_states) ; msg . sample_times . update (& self . sample_times) ; } } impl Default for DioRealTimeData { fn default () -> Self { let msg_native = WrappedNativeMsg :: < DioRealTimeData > :: new () ; DioRealTimeData :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Direction { pub header : std_msgs :: msg :: Header , pub direction : i8 } impl WrappedTypesupport for Direction { type CStruct = marti_sensor_msgs__msg__Direction ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__marti_sensor_msgs__msg__Direction () } } fn create_msg () -> * mut marti_sensor_msgs__msg__Direction { unsafe { marti_sensor_msgs__msg__Direction__create () } } fn destroy_msg (msg : * mut marti_sensor_msgs__msg__Direction) -> () { unsafe { marti_sensor_msgs__msg__Direction__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Direction { Direction { header : std_msgs :: msg :: Header :: from_native (& msg . header) , direction : msg . direction , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . direction = self . direction ; } } impl Default for Direction { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Direction > :: new () ; Direction :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl Direction { pub const BACKWARD : _bindgen_ty_449 = marti_sensor_msgs__msg__Direction__BACKWARD ; pub const FORWARD : _bindgen_ty_451 = marti_sensor_msgs__msg__Direction__FORWARD ; pub const UNKNOWN : _bindgen_ty_452 = marti_sensor_msgs__msg__Direction__UNKNOWN ; pub const ZERO : _bindgen_ty_450 = marti_sensor_msgs__msg__Direction__ZERO ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Exposure { pub header : std_msgs :: msg :: Header , pub value : u64 } impl WrappedTypesupport for Exposure { type CStruct = marti_sensor_msgs__msg__Exposure ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__marti_sensor_msgs__msg__Exposure () } } fn create_msg () -> * mut marti_sensor_msgs__msg__Exposure { unsafe { marti_sensor_msgs__msg__Exposure__create () } } fn destroy_msg (msg : * mut marti_sensor_msgs__msg__Exposure) -> () { unsafe { marti_sensor_msgs__msg__Exposure__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Exposure { Exposure { header : std_msgs :: msg :: Header :: from_native (& msg . header) , value : msg . value , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . value = self . value ; } } impl Default for Exposure { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Exposure > :: new () ; Exposure :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Gyro { pub header : std_msgs :: msg :: Header , pub angular_rate : f64 , pub variance : f64 } impl WrappedTypesupport for Gyro { type CStruct = marti_sensor_msgs__msg__Gyro ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__marti_sensor_msgs__msg__Gyro () } } fn create_msg () -> * mut marti_sensor_msgs__msg__Gyro { unsafe { marti_sensor_msgs__msg__Gyro__create () } } fn destroy_msg (msg : * mut marti_sensor_msgs__msg__Gyro) -> () { unsafe { marti_sensor_msgs__msg__Gyro__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Gyro { Gyro { header : std_msgs :: msg :: Header :: from_native (& msg . header) , angular_rate : msg . angular_rate , variance : msg . variance , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . angular_rate = self . angular_rate ; msg . variance = self . variance ; } } impl Default for Gyro { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Gyro > :: new () ; Gyro :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Velocity { pub header : std_msgs :: msg :: Header , pub velocity : f64 , pub variance : f64 } impl WrappedTypesupport for Velocity { type CStruct = marti_sensor_msgs__msg__Velocity ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__marti_sensor_msgs__msg__Velocity () } } fn create_msg () -> * mut marti_sensor_msgs__msg__Velocity { unsafe { marti_sensor_msgs__msg__Velocity__create () } } fn destroy_msg (msg : * mut marti_sensor_msgs__msg__Velocity) -> () { unsafe { marti_sensor_msgs__msg__Velocity__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Velocity { Velocity { header : std_msgs :: msg :: Header :: from_native (& msg . header) , velocity : msg . velocity , variance : msg . variance , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . velocity = self . velocity ; msg . variance = self . variance ; } } impl Default for Velocity { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Velocity > :: new () ; Velocity :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct WheelEncoder { pub frequency : f64 , pub directional : bool , pub id : u8 } impl WrappedTypesupport for WheelEncoder { type CStruct = marti_sensor_msgs__msg__WheelEncoder ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__marti_sensor_msgs__msg__WheelEncoder () } } fn create_msg () -> * mut marti_sensor_msgs__msg__WheelEncoder { unsafe { marti_sensor_msgs__msg__WheelEncoder__create () } } fn destroy_msg (msg : * mut marti_sensor_msgs__msg__WheelEncoder) -> () { unsafe { marti_sensor_msgs__msg__WheelEncoder__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> WheelEncoder { WheelEncoder { frequency : msg . frequency , directional : msg . directional , id : msg . id , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . frequency = self . frequency ; msg . directional = self . directional ; msg . id = self . id ; } } impl Default for WheelEncoder { fn default () -> Self { let msg_native = WrappedNativeMsg :: < WheelEncoder > :: new () ; WheelEncoder :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct WheelEncoderSet { pub header : std_msgs :: msg :: Header , pub encoders : Vec < marti_sensor_msgs :: msg :: WheelEncoder > } impl WrappedTypesupport for WheelEncoderSet { type CStruct = marti_sensor_msgs__msg__WheelEncoderSet ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__marti_sensor_msgs__msg__WheelEncoderSet () } } fn create_msg () -> * mut marti_sensor_msgs__msg__WheelEncoderSet { unsafe { marti_sensor_msgs__msg__WheelEncoderSet__create () } } fn destroy_msg (msg : * mut marti_sensor_msgs__msg__WheelEncoderSet) -> () { unsafe { marti_sensor_msgs__msg__WheelEncoderSet__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> WheelEncoderSet { WheelEncoderSet { header : std_msgs :: msg :: Header :: from_native (& msg . header) , encoders : { let mut temp = Vec :: with_capacity (msg . encoders . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . encoders . data , msg . encoders . size) } ; for s in slice { temp . push (marti_sensor_msgs :: msg :: WheelEncoder :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; unsafe { marti_sensor_msgs__msg__WheelEncoder__Sequence__fini (& mut msg . encoders) ; marti_sensor_msgs__msg__WheelEncoder__Sequence__init (& mut msg . encoders , self . encoders . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . encoders . data , msg . encoders . size) ; for (t , s) in slice . iter_mut () . zip (& self . encoders) { s . copy_to_native (t) ; } } } } impl Default for WheelEncoderSet { fn default () -> Self { let msg_native = WrappedNativeMsg :: < WheelEncoderSet > :: new () ; WheelEncoderSet :: from_native (& msg_native) } } } pub mod srv { # [allow (non_snake_case)] pub mod SetExposure { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__marti_sensor_msgs__srv__SetExposure () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub auto_exposure : bool , pub time : i64 } impl WrappedTypesupport for Request { type CStruct = marti_sensor_msgs__srv__SetExposure_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__marti_sensor_msgs__srv__SetExposure_Request () } } fn create_msg () -> * mut marti_sensor_msgs__srv__SetExposure_Request { unsafe { marti_sensor_msgs__srv__SetExposure_Request__create () } } fn destroy_msg (msg : * mut marti_sensor_msgs__srv__SetExposure_Request) -> () { unsafe { marti_sensor_msgs__srv__SetExposure_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { auto_exposure : msg . auto_exposure , time : msg . time , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . auto_exposure = self . auto_exposure ; msg . time = self . time ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub auto_exposure : bool , pub time : i64 } impl WrappedTypesupport for Response { type CStruct = marti_sensor_msgs__srv__SetExposure_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__marti_sensor_msgs__srv__SetExposure_Response () } } fn create_msg () -> * mut marti_sensor_msgs__srv__SetExposure_Response { unsafe { marti_sensor_msgs__srv__SetExposure_Response__create () } } fn destroy_msg (msg : * mut marti_sensor_msgs__srv__SetExposure_Response) -> () { unsafe { marti_sensor_msgs__srv__SetExposure_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { auto_exposure : msg . auto_exposure , time : msg . time , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . auto_exposure = self . auto_exposure ; msg . time = self . time ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } }