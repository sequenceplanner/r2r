pub mod msg { use super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct CommandWithHandshake { pub header : std_msgs :: msg :: Header , pub msg_counter : u8 , pub command : i16 } impl WrappedTypesupport for CommandWithHandshake { type CStruct = automotive_navigation_msgs__msg__CommandWithHandshake ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__automotive_navigation_msgs__msg__CommandWithHandshake () } } fn create_msg () -> * mut automotive_navigation_msgs__msg__CommandWithHandshake { unsafe { automotive_navigation_msgs__msg__CommandWithHandshake__create () } } fn destroy_msg (msg : * mut automotive_navigation_msgs__msg__CommandWithHandshake) -> () { unsafe { automotive_navigation_msgs__msg__CommandWithHandshake__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> CommandWithHandshake { CommandWithHandshake { header : std_msgs :: msg :: Header :: from_native (& msg . header) , msg_counter : msg . msg_counter , command : msg . command , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . msg_counter = self . msg_counter ; msg . command = self . command ; } } impl Default for CommandWithHandshake { fn default () -> Self { let msg_native = WrappedNativeMsg :: < CommandWithHandshake > :: new () ; CommandWithHandshake :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct DesiredDestination { pub header : std_msgs :: msg :: Header , pub msg_counter : u8 , pub valid : u16 , pub latitude : f64 , pub longitude : f64 } impl WrappedTypesupport for DesiredDestination { type CStruct = automotive_navigation_msgs__msg__DesiredDestination ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__automotive_navigation_msgs__msg__DesiredDestination () } } fn create_msg () -> * mut automotive_navigation_msgs__msg__DesiredDestination { unsafe { automotive_navigation_msgs__msg__DesiredDestination__create () } } fn destroy_msg (msg : * mut automotive_navigation_msgs__msg__DesiredDestination) -> () { unsafe { automotive_navigation_msgs__msg__DesiredDestination__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> DesiredDestination { DesiredDestination { header : std_msgs :: msg :: Header :: from_native (& msg . header) , msg_counter : msg . msg_counter , valid : msg . valid , latitude : msg . latitude , longitude : msg . longitude , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . msg_counter = self . msg_counter ; msg . valid = self . valid ; msg . latitude = self . latitude ; msg . longitude = self . longitude ; } } impl Default for DesiredDestination { fn default () -> Self { let msg_native = WrappedNativeMsg :: < DesiredDestination > :: new () ; DesiredDestination :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Direction { pub header : std_msgs :: msg :: Header , pub direction : i8 } impl WrappedTypesupport for Direction { type CStruct = automotive_navigation_msgs__msg__Direction ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__automotive_navigation_msgs__msg__Direction () } } fn create_msg () -> * mut automotive_navigation_msgs__msg__Direction { unsafe { automotive_navigation_msgs__msg__Direction__create () } } fn destroy_msg (msg : * mut automotive_navigation_msgs__msg__Direction) -> () { unsafe { automotive_navigation_msgs__msg__Direction__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Direction { Direction { header : std_msgs :: msg :: Header :: from_native (& msg . header) , direction : msg . direction , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . direction = self . direction ; } } impl Default for Direction { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Direction > :: new () ; Direction :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl Direction { pub const BACKWARD : _bindgen_ty_22 = automotive_navigation_msgs__msg__Direction__BACKWARD ; pub const FORWARD : _bindgen_ty_24 = automotive_navigation_msgs__msg__Direction__FORWARD ; pub const ZERO : _bindgen_ty_23 = automotive_navigation_msgs__msg__Direction__ZERO ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct DistanceToDestination { pub header : std_msgs :: msg :: Header , pub msg_counter : u8 , pub distance : f32 } impl WrappedTypesupport for DistanceToDestination { type CStruct = automotive_navigation_msgs__msg__DistanceToDestination ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__automotive_navigation_msgs__msg__DistanceToDestination () } } fn create_msg () -> * mut automotive_navigation_msgs__msg__DistanceToDestination { unsafe { automotive_navigation_msgs__msg__DistanceToDestination__create () } } fn destroy_msg (msg : * mut automotive_navigation_msgs__msg__DistanceToDestination) -> () { unsafe { automotive_navigation_msgs__msg__DistanceToDestination__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> DistanceToDestination { DistanceToDestination { header : std_msgs :: msg :: Header :: from_native (& msg . header) , msg_counter : msg . msg_counter , distance : msg . distance , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . msg_counter = self . msg_counter ; msg . distance = self . distance ; } } impl Default for DistanceToDestination { fn default () -> Self { let msg_native = WrappedNativeMsg :: < DistanceToDestination > :: new () ; DistanceToDestination :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct LaneBoundary { pub style : u8 , pub color : u8 , pub line : Vec < geometry_msgs :: msg :: Point > } impl WrappedTypesupport for LaneBoundary { type CStruct = automotive_navigation_msgs__msg__LaneBoundary ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__automotive_navigation_msgs__msg__LaneBoundary () } } fn create_msg () -> * mut automotive_navigation_msgs__msg__LaneBoundary { unsafe { automotive_navigation_msgs__msg__LaneBoundary__create () } } fn destroy_msg (msg : * mut automotive_navigation_msgs__msg__LaneBoundary) -> () { unsafe { automotive_navigation_msgs__msg__LaneBoundary__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> LaneBoundary { LaneBoundary { style : msg . style , color : msg . color , line : { let mut temp = Vec :: with_capacity (msg . line . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . line . data , msg . line . size) } ; for s in slice { temp . push (geometry_msgs :: msg :: Point :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . style = self . style ; msg . color = self . color ; unsafe { geometry_msgs__msg__Point__Sequence__fini (& mut msg . line) ; geometry_msgs__msg__Point__Sequence__init (& mut msg . line , self . line . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . line . data , msg . line . size) ; for (t , s) in slice . iter_mut () . zip (& self . line) { s . copy_to_native (t) ; } } } } impl Default for LaneBoundary { fn default () -> Self { let msg_native = WrappedNativeMsg :: < LaneBoundary > :: new () ; LaneBoundary :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl LaneBoundary { pub const DASHED : _bindgen_ty_27 = automotive_navigation_msgs__msg__LaneBoundary__DASHED ; pub const DASHED_SOLID : _bindgen_ty_29 = automotive_navigation_msgs__msg__LaneBoundary__DASHED_SOLID ; pub const SOLID : _bindgen_ty_26 = automotive_navigation_msgs__msg__LaneBoundary__SOLID ; pub const SOLID_DASHED : _bindgen_ty_28 = automotive_navigation_msgs__msg__LaneBoundary__SOLID_DASHED ; pub const SOLID_SOLID : _bindgen_ty_30 = automotive_navigation_msgs__msg__LaneBoundary__SOLID_SOLID ; pub const UNKNOWN : _bindgen_ty_25 = automotive_navigation_msgs__msg__LaneBoundary__UNKNOWN ; pub const WHITE : _bindgen_ty_31 = automotive_navigation_msgs__msg__LaneBoundary__WHITE ; pub const YELLOW : _bindgen_ty_32 = automotive_navigation_msgs__msg__LaneBoundary__YELLOW ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct LaneBoundaryArray { pub boundaries : Vec < automotive_navigation_msgs :: msg :: LaneBoundary > } impl WrappedTypesupport for LaneBoundaryArray { type CStruct = automotive_navigation_msgs__msg__LaneBoundaryArray ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__automotive_navigation_msgs__msg__LaneBoundaryArray () } } fn create_msg () -> * mut automotive_navigation_msgs__msg__LaneBoundaryArray { unsafe { automotive_navigation_msgs__msg__LaneBoundaryArray__create () } } fn destroy_msg (msg : * mut automotive_navigation_msgs__msg__LaneBoundaryArray) -> () { unsafe { automotive_navigation_msgs__msg__LaneBoundaryArray__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> LaneBoundaryArray { LaneBoundaryArray { boundaries : { let mut temp = Vec :: with_capacity (msg . boundaries . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . boundaries . data , msg . boundaries . size) } ; for s in slice { temp . push (automotive_navigation_msgs :: msg :: LaneBoundary :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { unsafe { automotive_navigation_msgs__msg__LaneBoundary__Sequence__fini (& mut msg . boundaries) ; automotive_navigation_msgs__msg__LaneBoundary__Sequence__init (& mut msg . boundaries , self . boundaries . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . boundaries . data , msg . boundaries . size) ; for (t , s) in slice . iter_mut () . zip (& self . boundaries) { s . copy_to_native (t) ; } } } } impl Default for LaneBoundaryArray { fn default () -> Self { let msg_native = WrappedNativeMsg :: < LaneBoundaryArray > :: new () ; LaneBoundaryArray :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ModuleState { pub header : std_msgs :: msg :: Header , pub name : std :: string :: String , pub state : std :: string :: String , pub info : std :: string :: String } impl WrappedTypesupport for ModuleState { type CStruct = automotive_navigation_msgs__msg__ModuleState ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__automotive_navigation_msgs__msg__ModuleState () } } fn create_msg () -> * mut automotive_navigation_msgs__msg__ModuleState { unsafe { automotive_navigation_msgs__msg__ModuleState__create () } } fn destroy_msg (msg : * mut automotive_navigation_msgs__msg__ModuleState) -> () { unsafe { automotive_navigation_msgs__msg__ModuleState__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ModuleState { ModuleState { header : std_msgs :: msg :: Header :: from_native (& msg . header) , name : msg . name . to_str () . to_owned () , state : msg . state . to_str () . to_owned () , info : msg . info . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . name . assign (& self . name) ; msg . state . assign (& self . state) ; msg . info . assign (& self . info) ; } } impl Default for ModuleState { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ModuleState > :: new () ; ModuleState :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct PointOfInterest { pub guid : u64 , pub latitude : f64 , pub longitude : f64 , pub params : std :: string :: String } impl WrappedTypesupport for PointOfInterest { type CStruct = automotive_navigation_msgs__msg__PointOfInterest ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__automotive_navigation_msgs__msg__PointOfInterest () } } fn create_msg () -> * mut automotive_navigation_msgs__msg__PointOfInterest { unsafe { automotive_navigation_msgs__msg__PointOfInterest__create () } } fn destroy_msg (msg : * mut automotive_navigation_msgs__msg__PointOfInterest) -> () { unsafe { automotive_navigation_msgs__msg__PointOfInterest__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> PointOfInterest { PointOfInterest { guid : msg . guid , latitude : msg . latitude , longitude : msg . longitude , params : msg . params . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . guid = self . guid ; msg . latitude = self . latitude ; msg . longitude = self . longitude ; msg . params . assign (& self . params) ; } } impl Default for PointOfInterest { fn default () -> Self { let msg_native = WrappedNativeMsg :: < PointOfInterest > :: new () ; PointOfInterest :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct PointOfInterestArray { pub header : std_msgs :: msg :: Header , pub update_num : u16 , pub point_list : Vec < automotive_navigation_msgs :: msg :: PointOfInterest > } impl WrappedTypesupport for PointOfInterestArray { type CStruct = automotive_navigation_msgs__msg__PointOfInterestArray ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__automotive_navigation_msgs__msg__PointOfInterestArray () } } fn create_msg () -> * mut automotive_navigation_msgs__msg__PointOfInterestArray { unsafe { automotive_navigation_msgs__msg__PointOfInterestArray__create () } } fn destroy_msg (msg : * mut automotive_navigation_msgs__msg__PointOfInterestArray) -> () { unsafe { automotive_navigation_msgs__msg__PointOfInterestArray__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> PointOfInterestArray { PointOfInterestArray { header : std_msgs :: msg :: Header :: from_native (& msg . header) , update_num : msg . update_num , point_list : { let mut temp = Vec :: with_capacity (msg . point_list . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . point_list . data , msg . point_list . size) } ; for s in slice { temp . push (automotive_navigation_msgs :: msg :: PointOfInterest :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . update_num = self . update_num ; unsafe { automotive_navigation_msgs__msg__PointOfInterest__Sequence__fini (& mut msg . point_list) ; automotive_navigation_msgs__msg__PointOfInterest__Sequence__init (& mut msg . point_list , self . point_list . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . point_list . data , msg . point_list . size) ; for (t , s) in slice . iter_mut () . zip (& self . point_list) { s . copy_to_native (t) ; } } } } impl Default for PointOfInterestArray { fn default () -> Self { let msg_native = WrappedNativeMsg :: < PointOfInterestArray > :: new () ; PointOfInterestArray :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct PointOfInterestRequest { pub header : std_msgs :: msg :: Header , pub name : std :: string :: String , pub module_name : std :: string :: String , pub request_id : u16 , pub cancel : u16 , pub update_num : u16 , pub guid_valid : u16 , pub guid : u64 , pub tolerance : f32 } impl WrappedTypesupport for PointOfInterestRequest { type CStruct = automotive_navigation_msgs__msg__PointOfInterestRequest ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__automotive_navigation_msgs__msg__PointOfInterestRequest () } } fn create_msg () -> * mut automotive_navigation_msgs__msg__PointOfInterestRequest { unsafe { automotive_navigation_msgs__msg__PointOfInterestRequest__create () } } fn destroy_msg (msg : * mut automotive_navigation_msgs__msg__PointOfInterestRequest) -> () { unsafe { automotive_navigation_msgs__msg__PointOfInterestRequest__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> PointOfInterestRequest { PointOfInterestRequest { header : std_msgs :: msg :: Header :: from_native (& msg . header) , name : msg . name . to_str () . to_owned () , module_name : msg . module_name . to_str () . to_owned () , request_id : msg . request_id , cancel : msg . cancel , update_num : msg . update_num , guid_valid : msg . guid_valid , guid : msg . guid , tolerance : msg . tolerance , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . name . assign (& self . name) ; msg . module_name . assign (& self . module_name) ; msg . request_id = self . request_id ; msg . cancel = self . cancel ; msg . update_num = self . update_num ; msg . guid_valid = self . guid_valid ; msg . guid = self . guid ; msg . tolerance = self . tolerance ; } } impl Default for PointOfInterestRequest { fn default () -> Self { let msg_native = WrappedNativeMsg :: < PointOfInterestRequest > :: new () ; PointOfInterestRequest :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct PointOfInterestResponse { pub header : std_msgs :: msg :: Header , pub name : std :: string :: String , pub module_name : std :: string :: String , pub request_id : u16 , pub update_num : u16 , pub point_statuses : Vec < automotive_navigation_msgs :: msg :: PointOfInterestStatus > } impl WrappedTypesupport for PointOfInterestResponse { type CStruct = automotive_navigation_msgs__msg__PointOfInterestResponse ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__automotive_navigation_msgs__msg__PointOfInterestResponse () } } fn create_msg () -> * mut automotive_navigation_msgs__msg__PointOfInterestResponse { unsafe { automotive_navigation_msgs__msg__PointOfInterestResponse__create () } } fn destroy_msg (msg : * mut automotive_navigation_msgs__msg__PointOfInterestResponse) -> () { unsafe { automotive_navigation_msgs__msg__PointOfInterestResponse__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> PointOfInterestResponse { PointOfInterestResponse { header : std_msgs :: msg :: Header :: from_native (& msg . header) , name : msg . name . to_str () . to_owned () , module_name : msg . module_name . to_str () . to_owned () , request_id : msg . request_id , update_num : msg . update_num , point_statuses : { let mut temp = Vec :: with_capacity (msg . point_statuses . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . point_statuses . data , msg . point_statuses . size) } ; for s in slice { temp . push (automotive_navigation_msgs :: msg :: PointOfInterestStatus :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . name . assign (& self . name) ; msg . module_name . assign (& self . module_name) ; msg . request_id = self . request_id ; msg . update_num = self . update_num ; unsafe { automotive_navigation_msgs__msg__PointOfInterestStatus__Sequence__fini (& mut msg . point_statuses) ; automotive_navigation_msgs__msg__PointOfInterestStatus__Sequence__init (& mut msg . point_statuses , self . point_statuses . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . point_statuses . data , msg . point_statuses . size) ; for (t , s) in slice . iter_mut () . zip (& self . point_statuses) { s . copy_to_native (t) ; } } } } impl Default for PointOfInterestResponse { fn default () -> Self { let msg_native = WrappedNativeMsg :: < PointOfInterestResponse > :: new () ; PointOfInterestResponse :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct PointOfInterestStatus { pub guid : u64 , pub distance : f32 , pub heading : f32 , pub x_position : f32 , pub y_position : f32 , pub params : std :: string :: String } impl WrappedTypesupport for PointOfInterestStatus { type CStruct = automotive_navigation_msgs__msg__PointOfInterestStatus ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__automotive_navigation_msgs__msg__PointOfInterestStatus () } } fn create_msg () -> * mut automotive_navigation_msgs__msg__PointOfInterestStatus { unsafe { automotive_navigation_msgs__msg__PointOfInterestStatus__create () } } fn destroy_msg (msg : * mut automotive_navigation_msgs__msg__PointOfInterestStatus) -> () { unsafe { automotive_navigation_msgs__msg__PointOfInterestStatus__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> PointOfInterestStatus { PointOfInterestStatus { guid : msg . guid , distance : msg . distance , heading : msg . heading , x_position : msg . x_position , y_position : msg . y_position , params : msg . params . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . guid = self . guid ; msg . distance = self . distance ; msg . heading = self . heading ; msg . x_position = self . x_position ; msg . y_position = self . y_position ; msg . params . assign (& self . params) ; } } impl Default for PointOfInterestStatus { fn default () -> Self { let msg_native = WrappedNativeMsg :: < PointOfInterestStatus > :: new () ; PointOfInterestStatus :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct RoadNetworkBoundaries { pub header : std_msgs :: msg :: Header , pub road_network_boundaries : Vec < automotive_navigation_msgs :: msg :: LaneBoundaryArray > } impl WrappedTypesupport for RoadNetworkBoundaries { type CStruct = automotive_navigation_msgs__msg__RoadNetworkBoundaries ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__automotive_navigation_msgs__msg__RoadNetworkBoundaries () } } fn create_msg () -> * mut automotive_navigation_msgs__msg__RoadNetworkBoundaries { unsafe { automotive_navigation_msgs__msg__RoadNetworkBoundaries__create () } } fn destroy_msg (msg : * mut automotive_navigation_msgs__msg__RoadNetworkBoundaries) -> () { unsafe { automotive_navigation_msgs__msg__RoadNetworkBoundaries__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> RoadNetworkBoundaries { RoadNetworkBoundaries { header : std_msgs :: msg :: Header :: from_native (& msg . header) , road_network_boundaries : { let mut temp = Vec :: with_capacity (msg . road_network_boundaries . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . road_network_boundaries . data , msg . road_network_boundaries . size) } ; for s in slice { temp . push (automotive_navigation_msgs :: msg :: LaneBoundaryArray :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; unsafe { automotive_navigation_msgs__msg__LaneBoundaryArray__Sequence__fini (& mut msg . road_network_boundaries) ; automotive_navigation_msgs__msg__LaneBoundaryArray__Sequence__init (& mut msg . road_network_boundaries , self . road_network_boundaries . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . road_network_boundaries . data , msg . road_network_boundaries . size) ; for (t , s) in slice . iter_mut () . zip (& self . road_network_boundaries) { s . copy_to_native (t) ; } } } } impl Default for RoadNetworkBoundaries { fn default () -> Self { let msg_native = WrappedNativeMsg :: < RoadNetworkBoundaries > :: new () ; RoadNetworkBoundaries :: from_native (& msg_native) } } }