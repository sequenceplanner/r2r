pub mod msg { use super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Mode { pub label : std :: string :: String } impl WrappedTypesupport for Mode { type CStruct = system_modes_msgs__msg__Mode ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__system_modes_msgs__msg__Mode () } } fn create_msg () -> * mut system_modes_msgs__msg__Mode { unsafe { system_modes_msgs__msg__Mode__create () } } fn destroy_msg (msg : * mut system_modes_msgs__msg__Mode) -> () { unsafe { system_modes_msgs__msg__Mode__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Mode { Mode { label : msg . label . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . label . assign (& self . label) ; } } impl Default for Mode { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Mode > :: new () ; Mode :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ModeEvent { pub timestamp : u64 , pub start_mode : system_modes_msgs :: msg :: Mode , pub goal_mode : system_modes_msgs :: msg :: Mode } impl WrappedTypesupport for ModeEvent { type CStruct = system_modes_msgs__msg__ModeEvent ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__system_modes_msgs__msg__ModeEvent () } } fn create_msg () -> * mut system_modes_msgs__msg__ModeEvent { unsafe { system_modes_msgs__msg__ModeEvent__create () } } fn destroy_msg (msg : * mut system_modes_msgs__msg__ModeEvent) -> () { unsafe { system_modes_msgs__msg__ModeEvent__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ModeEvent { ModeEvent { timestamp : msg . timestamp , start_mode : system_modes_msgs :: msg :: Mode :: from_native (& msg . start_mode) , goal_mode : system_modes_msgs :: msg :: Mode :: from_native (& msg . goal_mode) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . timestamp = self . timestamp ; self . start_mode . copy_to_native (& mut msg . start_mode) ; self . goal_mode . copy_to_native (& mut msg . goal_mode) ; } } impl Default for ModeEvent { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ModeEvent > :: new () ; ModeEvent :: from_native (& msg_native) } } } pub mod srv { # [allow (non_snake_case)] pub mod ChangeMode { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__system_modes_msgs__srv__ChangeMode () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub mode_name : std :: string :: String } impl WrappedTypesupport for Request { type CStruct = system_modes_msgs__srv__ChangeMode_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__system_modes_msgs__srv__ChangeMode_Request () } } fn create_msg () -> * mut system_modes_msgs__srv__ChangeMode_Request { unsafe { system_modes_msgs__srv__ChangeMode_Request__create () } } fn destroy_msg (msg : * mut system_modes_msgs__srv__ChangeMode_Request) -> () { unsafe { system_modes_msgs__srv__ChangeMode_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { mode_name : msg . mode_name . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . mode_name . assign (& self . mode_name) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool } impl WrappedTypesupport for Response { type CStruct = system_modes_msgs__srv__ChangeMode_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__system_modes_msgs__srv__ChangeMode_Response () } } fn create_msg () -> * mut system_modes_msgs__srv__ChangeMode_Response { unsafe { system_modes_msgs__srv__ChangeMode_Response__create () } } fn destroy_msg (msg : * mut system_modes_msgs__srv__ChangeMode_Response) -> () { unsafe { system_modes_msgs__srv__ChangeMode_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetAvailableModes { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__system_modes_msgs__srv__GetAvailableModes () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { } impl WrappedTypesupport for Request { type CStruct = system_modes_msgs__srv__GetAvailableModes_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__system_modes_msgs__srv__GetAvailableModes_Request () } } fn create_msg () -> * mut system_modes_msgs__srv__GetAvailableModes_Request { unsafe { system_modes_msgs__srv__GetAvailableModes_Request__create () } } fn destroy_msg (msg : * mut system_modes_msgs__srv__GetAvailableModes_Request) -> () { unsafe { system_modes_msgs__srv__GetAvailableModes_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub available_modes : Vec < std :: string :: String > } impl WrappedTypesupport for Response { type CStruct = system_modes_msgs__srv__GetAvailableModes_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__system_modes_msgs__srv__GetAvailableModes_Response () } } fn create_msg () -> * mut system_modes_msgs__srv__GetAvailableModes_Response { unsafe { system_modes_msgs__srv__GetAvailableModes_Response__create () } } fn destroy_msg (msg : * mut system_modes_msgs__srv__GetAvailableModes_Response) -> () { unsafe { system_modes_msgs__srv__GetAvailableModes_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { available_modes : msg . available_modes . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . available_modes . update (& self . available_modes) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetMode { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__system_modes_msgs__srv__GetMode () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { } impl WrappedTypesupport for Request { type CStruct = system_modes_msgs__srv__GetMode_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__system_modes_msgs__srv__GetMode_Request () } } fn create_msg () -> * mut system_modes_msgs__srv__GetMode_Request { unsafe { system_modes_msgs__srv__GetMode_Request__create () } } fn destroy_msg (msg : * mut system_modes_msgs__srv__GetMode_Request) -> () { unsafe { system_modes_msgs__srv__GetMode_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub current_mode : std :: string :: String } impl WrappedTypesupport for Response { type CStruct = system_modes_msgs__srv__GetMode_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__system_modes_msgs__srv__GetMode_Response () } } fn create_msg () -> * mut system_modes_msgs__srv__GetMode_Response { unsafe { system_modes_msgs__srv__GetMode_Response__create () } } fn destroy_msg (msg : * mut system_modes_msgs__srv__GetMode_Response) -> () { unsafe { system_modes_msgs__srv__GetMode_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { current_mode : msg . current_mode . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . current_mode . assign (& self . current_mode) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } }