pub mod msg { use super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct BlockadeCancel { pub participant : u64 , pub all_reservations : bool , pub reservation : u64 } impl WrappedTypesupport for BlockadeCancel { type CStruct = rmf_traffic_msgs__msg__BlockadeCancel ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_traffic_msgs__msg__BlockadeCancel () } } fn create_msg () -> * mut rmf_traffic_msgs__msg__BlockadeCancel { unsafe { rmf_traffic_msgs__msg__BlockadeCancel__create () } } fn destroy_msg (msg : * mut rmf_traffic_msgs__msg__BlockadeCancel) -> () { unsafe { rmf_traffic_msgs__msg__BlockadeCancel__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> BlockadeCancel { BlockadeCancel { participant : msg . participant , all_reservations : msg . all_reservations , reservation : msg . reservation , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . participant = self . participant ; msg . all_reservations = self . all_reservations ; msg . reservation = self . reservation ; } } impl Default for BlockadeCancel { fn default () -> Self { let msg_native = WrappedNativeMsg :: < BlockadeCancel > :: new () ; BlockadeCancel :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct BlockadeCheckpoint { pub position : Vec < f64 > , pub map_name : std :: string :: String , pub can_hold : bool } impl WrappedTypesupport for BlockadeCheckpoint { type CStruct = rmf_traffic_msgs__msg__BlockadeCheckpoint ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_traffic_msgs__msg__BlockadeCheckpoint () } } fn create_msg () -> * mut rmf_traffic_msgs__msg__BlockadeCheckpoint { unsafe { rmf_traffic_msgs__msg__BlockadeCheckpoint__create () } } fn destroy_msg (msg : * mut rmf_traffic_msgs__msg__BlockadeCheckpoint) -> () { unsafe { rmf_traffic_msgs__msg__BlockadeCheckpoint__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> BlockadeCheckpoint { BlockadeCheckpoint { position : msg . position . to_vec () , map_name : msg . map_name . to_str () . to_owned () , can_hold : msg . can_hold , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { assert_eq ! (self . position . len () , 2usize , "Field {} is fixed size of {}!" , "position" , 2usize) ; msg . position . copy_from_slice (& self . position [.. 2usize]) ; msg . map_name . assign (& self . map_name) ; msg . can_hold = self . can_hold ; } } impl Default for BlockadeCheckpoint { fn default () -> Self { let msg_native = WrappedNativeMsg :: < BlockadeCheckpoint > :: new () ; BlockadeCheckpoint :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct BlockadeHeartbeat { pub statuses : Vec < rmf_traffic_msgs :: msg :: BlockadeStatus > , pub has_gridlock : bool } impl WrappedTypesupport for BlockadeHeartbeat { type CStruct = rmf_traffic_msgs__msg__BlockadeHeartbeat ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_traffic_msgs__msg__BlockadeHeartbeat () } } fn create_msg () -> * mut rmf_traffic_msgs__msg__BlockadeHeartbeat { unsafe { rmf_traffic_msgs__msg__BlockadeHeartbeat__create () } } fn destroy_msg (msg : * mut rmf_traffic_msgs__msg__BlockadeHeartbeat) -> () { unsafe { rmf_traffic_msgs__msg__BlockadeHeartbeat__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> BlockadeHeartbeat { BlockadeHeartbeat { statuses : { let mut temp = Vec :: with_capacity (msg . statuses . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . statuses . data , msg . statuses . size) } ; for s in slice { temp . push (rmf_traffic_msgs :: msg :: BlockadeStatus :: from_native (s)) ; } temp } , has_gridlock : msg . has_gridlock , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { unsafe { rmf_traffic_msgs__msg__BlockadeStatus__Sequence__fini (& mut msg . statuses) ; rmf_traffic_msgs__msg__BlockadeStatus__Sequence__init (& mut msg . statuses , self . statuses . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . statuses . data , msg . statuses . size) ; for (t , s) in slice . iter_mut () . zip (& self . statuses) { s . copy_to_native (t) ; } } msg . has_gridlock = self . has_gridlock ; } } impl Default for BlockadeHeartbeat { fn default () -> Self { let msg_native = WrappedNativeMsg :: < BlockadeHeartbeat > :: new () ; BlockadeHeartbeat :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct BlockadeReached { pub participant : u64 , pub reservation : u64 , pub checkpoint : u64 } impl WrappedTypesupport for BlockadeReached { type CStruct = rmf_traffic_msgs__msg__BlockadeReached ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_traffic_msgs__msg__BlockadeReached () } } fn create_msg () -> * mut rmf_traffic_msgs__msg__BlockadeReached { unsafe { rmf_traffic_msgs__msg__BlockadeReached__create () } } fn destroy_msg (msg : * mut rmf_traffic_msgs__msg__BlockadeReached) -> () { unsafe { rmf_traffic_msgs__msg__BlockadeReached__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> BlockadeReached { BlockadeReached { participant : msg . participant , reservation : msg . reservation , checkpoint : msg . checkpoint , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . participant = self . participant ; msg . reservation = self . reservation ; msg . checkpoint = self . checkpoint ; } } impl Default for BlockadeReached { fn default () -> Self { let msg_native = WrappedNativeMsg :: < BlockadeReached > :: new () ; BlockadeReached :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct BlockadeReady { pub participant : u64 , pub reservation : u64 , pub checkpoint : u64 } impl WrappedTypesupport for BlockadeReady { type CStruct = rmf_traffic_msgs__msg__BlockadeReady ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_traffic_msgs__msg__BlockadeReady () } } fn create_msg () -> * mut rmf_traffic_msgs__msg__BlockadeReady { unsafe { rmf_traffic_msgs__msg__BlockadeReady__create () } } fn destroy_msg (msg : * mut rmf_traffic_msgs__msg__BlockadeReady) -> () { unsafe { rmf_traffic_msgs__msg__BlockadeReady__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> BlockadeReady { BlockadeReady { participant : msg . participant , reservation : msg . reservation , checkpoint : msg . checkpoint , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . participant = self . participant ; msg . reservation = self . reservation ; msg . checkpoint = self . checkpoint ; } } impl Default for BlockadeReady { fn default () -> Self { let msg_native = WrappedNativeMsg :: < BlockadeReady > :: new () ; BlockadeReady :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct BlockadeRelease { pub participant : u64 , pub reservation : u64 , pub checkpoint : u64 } impl WrappedTypesupport for BlockadeRelease { type CStruct = rmf_traffic_msgs__msg__BlockadeRelease ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_traffic_msgs__msg__BlockadeRelease () } } fn create_msg () -> * mut rmf_traffic_msgs__msg__BlockadeRelease { unsafe { rmf_traffic_msgs__msg__BlockadeRelease__create () } } fn destroy_msg (msg : * mut rmf_traffic_msgs__msg__BlockadeRelease) -> () { unsafe { rmf_traffic_msgs__msg__BlockadeRelease__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> BlockadeRelease { BlockadeRelease { participant : msg . participant , reservation : msg . reservation , checkpoint : msg . checkpoint , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . participant = self . participant ; msg . reservation = self . reservation ; msg . checkpoint = self . checkpoint ; } } impl Default for BlockadeRelease { fn default () -> Self { let msg_native = WrappedNativeMsg :: < BlockadeRelease > :: new () ; BlockadeRelease :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct BlockadeSet { pub participant : u64 , pub reservation : u64 , pub radius : f64 , pub path : Vec < rmf_traffic_msgs :: msg :: BlockadeCheckpoint > } impl WrappedTypesupport for BlockadeSet { type CStruct = rmf_traffic_msgs__msg__BlockadeSet ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_traffic_msgs__msg__BlockadeSet () } } fn create_msg () -> * mut rmf_traffic_msgs__msg__BlockadeSet { unsafe { rmf_traffic_msgs__msg__BlockadeSet__create () } } fn destroy_msg (msg : * mut rmf_traffic_msgs__msg__BlockadeSet) -> () { unsafe { rmf_traffic_msgs__msg__BlockadeSet__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> BlockadeSet { BlockadeSet { participant : msg . participant , reservation : msg . reservation , radius : msg . radius , path : { let mut temp = Vec :: with_capacity (msg . path . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . path . data , msg . path . size) } ; for s in slice { temp . push (rmf_traffic_msgs :: msg :: BlockadeCheckpoint :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . participant = self . participant ; msg . reservation = self . reservation ; msg . radius = self . radius ; unsafe { rmf_traffic_msgs__msg__BlockadeCheckpoint__Sequence__fini (& mut msg . path) ; rmf_traffic_msgs__msg__BlockadeCheckpoint__Sequence__init (& mut msg . path , self . path . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . path . data , msg . path . size) ; for (t , s) in slice . iter_mut () . zip (& self . path) { s . copy_to_native (t) ; } } } } impl Default for BlockadeSet { fn default () -> Self { let msg_native = WrappedNativeMsg :: < BlockadeSet > :: new () ; BlockadeSet :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct BlockadeStatus { pub participant : u64 , pub reservation : u64 , pub any_ready : bool , pub last_ready : u64 , pub last_reached : u64 , pub assignment_begin : u64 , pub assignment_end : u64 } impl WrappedTypesupport for BlockadeStatus { type CStruct = rmf_traffic_msgs__msg__BlockadeStatus ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_traffic_msgs__msg__BlockadeStatus () } } fn create_msg () -> * mut rmf_traffic_msgs__msg__BlockadeStatus { unsafe { rmf_traffic_msgs__msg__BlockadeStatus__create () } } fn destroy_msg (msg : * mut rmf_traffic_msgs__msg__BlockadeStatus) -> () { unsafe { rmf_traffic_msgs__msg__BlockadeStatus__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> BlockadeStatus { BlockadeStatus { participant : msg . participant , reservation : msg . reservation , any_ready : msg . any_ready , last_ready : msg . last_ready , last_reached : msg . last_reached , assignment_begin : msg . assignment_begin , assignment_end : msg . assignment_end , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . participant = self . participant ; msg . reservation = self . reservation ; msg . any_ready = self . any_ready ; msg . last_ready = self . last_ready ; msg . last_reached = self . last_reached ; msg . assignment_begin = self . assignment_begin ; msg . assignment_end = self . assignment_end ; } } impl Default for BlockadeStatus { fn default () -> Self { let msg_native = WrappedNativeMsg :: < BlockadeStatus > :: new () ; BlockadeStatus :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Circle { pub radius : f64 } impl WrappedTypesupport for Circle { type CStruct = rmf_traffic_msgs__msg__Circle ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_traffic_msgs__msg__Circle () } } fn create_msg () -> * mut rmf_traffic_msgs__msg__Circle { unsafe { rmf_traffic_msgs__msg__Circle__create () } } fn destroy_msg (msg : * mut rmf_traffic_msgs__msg__Circle) -> () { unsafe { rmf_traffic_msgs__msg__Circle__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Circle { Circle { radius : msg . radius , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . radius = self . radius ; } } impl Default for Circle { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Circle > :: new () ; Circle :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ConvexShape { # [serde (rename = "type")] pub type_ : u8 , pub index : u8 } impl WrappedTypesupport for ConvexShape { type CStruct = rmf_traffic_msgs__msg__ConvexShape ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_traffic_msgs__msg__ConvexShape () } } fn create_msg () -> * mut rmf_traffic_msgs__msg__ConvexShape { unsafe { rmf_traffic_msgs__msg__ConvexShape__create () } } fn destroy_msg (msg : * mut rmf_traffic_msgs__msg__ConvexShape) -> () { unsafe { rmf_traffic_msgs__msg__ConvexShape__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ConvexShape { ConvexShape { type_ : msg . type_ , index : msg . index , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . type_ = self . type_ ; msg . index = self . index ; } } impl Default for ConvexShape { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ConvexShape > :: new () ; ConvexShape :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl ConvexShape { pub const BOX : _bindgen_ty_1585 = rmf_traffic_msgs__msg__ConvexShape__BOX ; pub const CIRCLE : _bindgen_ty_1586 = rmf_traffic_msgs__msg__ConvexShape__CIRCLE ; pub const NONE : _bindgen_ty_1584 = rmf_traffic_msgs__msg__ConvexShape__NONE ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ConvexShapeContext { pub circles : Vec < rmf_traffic_msgs :: msg :: Circle > } impl WrappedTypesupport for ConvexShapeContext { type CStruct = rmf_traffic_msgs__msg__ConvexShapeContext ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_traffic_msgs__msg__ConvexShapeContext () } } fn create_msg () -> * mut rmf_traffic_msgs__msg__ConvexShapeContext { unsafe { rmf_traffic_msgs__msg__ConvexShapeContext__create () } } fn destroy_msg (msg : * mut rmf_traffic_msgs__msg__ConvexShapeContext) -> () { unsafe { rmf_traffic_msgs__msg__ConvexShapeContext__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ConvexShapeContext { ConvexShapeContext { circles : { let mut temp = Vec :: with_capacity (msg . circles . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . circles . data , msg . circles . size) } ; for s in slice { temp . push (rmf_traffic_msgs :: msg :: Circle :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { unsafe { rmf_traffic_msgs__msg__Circle__Sequence__fini (& mut msg . circles) ; rmf_traffic_msgs__msg__Circle__Sequence__init (& mut msg . circles , self . circles . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . circles . data , msg . circles . size) ; for (t , s) in slice . iter_mut () . zip (& self . circles) { s . copy_to_native (t) ; } } } } impl Default for ConvexShapeContext { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ConvexShapeContext > :: new () ; ConvexShapeContext :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct FailOverEvent { pub new_schedule_node_version : u64 } impl WrappedTypesupport for FailOverEvent { type CStruct = rmf_traffic_msgs__msg__FailOverEvent ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_traffic_msgs__msg__FailOverEvent () } } fn create_msg () -> * mut rmf_traffic_msgs__msg__FailOverEvent { unsafe { rmf_traffic_msgs__msg__FailOverEvent__create () } } fn destroy_msg (msg : * mut rmf_traffic_msgs__msg__FailOverEvent) -> () { unsafe { rmf_traffic_msgs__msg__FailOverEvent__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> FailOverEvent { FailOverEvent { new_schedule_node_version : msg . new_schedule_node_version , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . new_schedule_node_version = self . new_schedule_node_version ; } } impl Default for FailOverEvent { fn default () -> Self { let msg_native = WrappedNativeMsg :: < FailOverEvent > :: new () ; FailOverEvent :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Heartbeat { } impl WrappedTypesupport for Heartbeat { type CStruct = rmf_traffic_msgs__msg__Heartbeat ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_traffic_msgs__msg__Heartbeat () } } fn create_msg () -> * mut rmf_traffic_msgs__msg__Heartbeat { unsafe { rmf_traffic_msgs__msg__Heartbeat__create () } } fn destroy_msg (msg : * mut rmf_traffic_msgs__msg__Heartbeat) -> () { unsafe { rmf_traffic_msgs__msg__Heartbeat__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Heartbeat { Heartbeat { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Heartbeat { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Heartbeat > :: new () ; Heartbeat :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Itinerary { pub routes : Vec < rmf_traffic_msgs :: msg :: Route > } impl WrappedTypesupport for Itinerary { type CStruct = rmf_traffic_msgs__msg__Itinerary ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_traffic_msgs__msg__Itinerary () } } fn create_msg () -> * mut rmf_traffic_msgs__msg__Itinerary { unsafe { rmf_traffic_msgs__msg__Itinerary__create () } } fn destroy_msg (msg : * mut rmf_traffic_msgs__msg__Itinerary) -> () { unsafe { rmf_traffic_msgs__msg__Itinerary__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Itinerary { Itinerary { routes : { let mut temp = Vec :: with_capacity (msg . routes . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . routes . data , msg . routes . size) } ; for s in slice { temp . push (rmf_traffic_msgs :: msg :: Route :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { unsafe { rmf_traffic_msgs__msg__Route__Sequence__fini (& mut msg . routes) ; rmf_traffic_msgs__msg__Route__Sequence__init (& mut msg . routes , self . routes . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . routes . data , msg . routes . size) ; for (t , s) in slice . iter_mut () . zip (& self . routes) { s . copy_to_native (t) ; } } } } impl Default for Itinerary { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Itinerary > :: new () ; Itinerary :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ItineraryClear { pub participant : u64 , pub itinerary_version : u64 } impl WrappedTypesupport for ItineraryClear { type CStruct = rmf_traffic_msgs__msg__ItineraryClear ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_traffic_msgs__msg__ItineraryClear () } } fn create_msg () -> * mut rmf_traffic_msgs__msg__ItineraryClear { unsafe { rmf_traffic_msgs__msg__ItineraryClear__create () } } fn destroy_msg (msg : * mut rmf_traffic_msgs__msg__ItineraryClear) -> () { unsafe { rmf_traffic_msgs__msg__ItineraryClear__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ItineraryClear { ItineraryClear { participant : msg . participant , itinerary_version : msg . itinerary_version , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . participant = self . participant ; msg . itinerary_version = self . itinerary_version ; } } impl Default for ItineraryClear { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ItineraryClear > :: new () ; ItineraryClear :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ItineraryDelay { pub participant : u64 , pub from_time : i64 , pub delay : i64 , pub itinerary_version : u64 } impl WrappedTypesupport for ItineraryDelay { type CStruct = rmf_traffic_msgs__msg__ItineraryDelay ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_traffic_msgs__msg__ItineraryDelay () } } fn create_msg () -> * mut rmf_traffic_msgs__msg__ItineraryDelay { unsafe { rmf_traffic_msgs__msg__ItineraryDelay__create () } } fn destroy_msg (msg : * mut rmf_traffic_msgs__msg__ItineraryDelay) -> () { unsafe { rmf_traffic_msgs__msg__ItineraryDelay__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ItineraryDelay { ItineraryDelay { participant : msg . participant , from_time : msg . from_time , delay : msg . delay , itinerary_version : msg . itinerary_version , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . participant = self . participant ; msg . from_time = self . from_time ; msg . delay = self . delay ; msg . itinerary_version = self . itinerary_version ; } } impl Default for ItineraryDelay { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ItineraryDelay > :: new () ; ItineraryDelay :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ItineraryErase { pub participant : u64 , pub routes : Vec < u64 > , pub itinerary_version : u64 } impl WrappedTypesupport for ItineraryErase { type CStruct = rmf_traffic_msgs__msg__ItineraryErase ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_traffic_msgs__msg__ItineraryErase () } } fn create_msg () -> * mut rmf_traffic_msgs__msg__ItineraryErase { unsafe { rmf_traffic_msgs__msg__ItineraryErase__create () } } fn destroy_msg (msg : * mut rmf_traffic_msgs__msg__ItineraryErase) -> () { unsafe { rmf_traffic_msgs__msg__ItineraryErase__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ItineraryErase { ItineraryErase { participant : msg . participant , routes : msg . routes . to_vec () , itinerary_version : msg . itinerary_version , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . participant = self . participant ; msg . routes . update (& self . routes) ; msg . itinerary_version = self . itinerary_version ; } } impl Default for ItineraryErase { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ItineraryErase > :: new () ; ItineraryErase :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ItineraryExtend { pub participant : u64 , pub routes : Vec < rmf_traffic_msgs :: msg :: ScheduleWriterItem > , pub itinerary_version : u64 } impl WrappedTypesupport for ItineraryExtend { type CStruct = rmf_traffic_msgs__msg__ItineraryExtend ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_traffic_msgs__msg__ItineraryExtend () } } fn create_msg () -> * mut rmf_traffic_msgs__msg__ItineraryExtend { unsafe { rmf_traffic_msgs__msg__ItineraryExtend__create () } } fn destroy_msg (msg : * mut rmf_traffic_msgs__msg__ItineraryExtend) -> () { unsafe { rmf_traffic_msgs__msg__ItineraryExtend__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ItineraryExtend { ItineraryExtend { participant : msg . participant , routes : { let mut temp = Vec :: with_capacity (msg . routes . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . routes . data , msg . routes . size) } ; for s in slice { temp . push (rmf_traffic_msgs :: msg :: ScheduleWriterItem :: from_native (s)) ; } temp } , itinerary_version : msg . itinerary_version , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . participant = self . participant ; unsafe { rmf_traffic_msgs__msg__ScheduleWriterItem__Sequence__fini (& mut msg . routes) ; rmf_traffic_msgs__msg__ScheduleWriterItem__Sequence__init (& mut msg . routes , self . routes . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . routes . data , msg . routes . size) ; for (t , s) in slice . iter_mut () . zip (& self . routes) { s . copy_to_native (t) ; } } msg . itinerary_version = self . itinerary_version ; } } impl Default for ItineraryExtend { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ItineraryExtend > :: new () ; ItineraryExtend :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ItinerarySet { pub participant : u64 , pub itinerary : Vec < rmf_traffic_msgs :: msg :: ScheduleWriterItem > , pub itinerary_version : u64 } impl WrappedTypesupport for ItinerarySet { type CStruct = rmf_traffic_msgs__msg__ItinerarySet ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_traffic_msgs__msg__ItinerarySet () } } fn create_msg () -> * mut rmf_traffic_msgs__msg__ItinerarySet { unsafe { rmf_traffic_msgs__msg__ItinerarySet__create () } } fn destroy_msg (msg : * mut rmf_traffic_msgs__msg__ItinerarySet) -> () { unsafe { rmf_traffic_msgs__msg__ItinerarySet__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ItinerarySet { ItinerarySet { participant : msg . participant , itinerary : { let mut temp = Vec :: with_capacity (msg . itinerary . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . itinerary . data , msg . itinerary . size) } ; for s in slice { temp . push (rmf_traffic_msgs :: msg :: ScheduleWriterItem :: from_native (s)) ; } temp } , itinerary_version : msg . itinerary_version , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . participant = self . participant ; unsafe { rmf_traffic_msgs__msg__ScheduleWriterItem__Sequence__fini (& mut msg . itinerary) ; rmf_traffic_msgs__msg__ScheduleWriterItem__Sequence__init (& mut msg . itinerary , self . itinerary . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . itinerary . data , msg . itinerary . size) ; for (t , s) in slice . iter_mut () . zip (& self . itinerary) { s . copy_to_native (t) ; } } msg . itinerary_version = self . itinerary_version ; } } impl Default for ItinerarySet { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ItinerarySet > :: new () ; ItinerarySet :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct MirrorUpdate { pub node_version : u64 , pub database_version : u64 , pub patch : rmf_traffic_msgs :: msg :: SchedulePatch , pub is_remedial_update : bool } impl WrappedTypesupport for MirrorUpdate { type CStruct = rmf_traffic_msgs__msg__MirrorUpdate ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_traffic_msgs__msg__MirrorUpdate () } } fn create_msg () -> * mut rmf_traffic_msgs__msg__MirrorUpdate { unsafe { rmf_traffic_msgs__msg__MirrorUpdate__create () } } fn destroy_msg (msg : * mut rmf_traffic_msgs__msg__MirrorUpdate) -> () { unsafe { rmf_traffic_msgs__msg__MirrorUpdate__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> MirrorUpdate { MirrorUpdate { node_version : msg . node_version , database_version : msg . database_version , patch : rmf_traffic_msgs :: msg :: SchedulePatch :: from_native (& msg . patch) , is_remedial_update : msg . is_remedial_update , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . node_version = self . node_version ; msg . database_version = self . database_version ; self . patch . copy_to_native (& mut msg . patch) ; msg . is_remedial_update = self . is_remedial_update ; } } impl Default for MirrorUpdate { fn default () -> Self { let msg_native = WrappedNativeMsg :: < MirrorUpdate > :: new () ; MirrorUpdate :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct NegotiationAck { pub conflict_version : u64 , pub acknowledgments : Vec < rmf_traffic_msgs :: msg :: NegotiationParticipantAck > } impl WrappedTypesupport for NegotiationAck { type CStruct = rmf_traffic_msgs__msg__NegotiationAck ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_traffic_msgs__msg__NegotiationAck () } } fn create_msg () -> * mut rmf_traffic_msgs__msg__NegotiationAck { unsafe { rmf_traffic_msgs__msg__NegotiationAck__create () } } fn destroy_msg (msg : * mut rmf_traffic_msgs__msg__NegotiationAck) -> () { unsafe { rmf_traffic_msgs__msg__NegotiationAck__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> NegotiationAck { NegotiationAck { conflict_version : msg . conflict_version , acknowledgments : { let mut temp = Vec :: with_capacity (msg . acknowledgments . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . acknowledgments . data , msg . acknowledgments . size) } ; for s in slice { temp . push (rmf_traffic_msgs :: msg :: NegotiationParticipantAck :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . conflict_version = self . conflict_version ; unsafe { rmf_traffic_msgs__msg__NegotiationParticipantAck__Sequence__fini (& mut msg . acknowledgments) ; rmf_traffic_msgs__msg__NegotiationParticipantAck__Sequence__init (& mut msg . acknowledgments , self . acknowledgments . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . acknowledgments . data , msg . acknowledgments . size) ; for (t , s) in slice . iter_mut () . zip (& self . acknowledgments) { s . copy_to_native (t) ; } } } } impl Default for NegotiationAck { fn default () -> Self { let msg_native = WrappedNativeMsg :: < NegotiationAck > :: new () ; NegotiationAck :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct NegotiationConclusion { pub conflict_version : u64 , pub resolved : bool , pub table : Vec < rmf_traffic_msgs :: msg :: NegotiationKey > } impl WrappedTypesupport for NegotiationConclusion { type CStruct = rmf_traffic_msgs__msg__NegotiationConclusion ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_traffic_msgs__msg__NegotiationConclusion () } } fn create_msg () -> * mut rmf_traffic_msgs__msg__NegotiationConclusion { unsafe { rmf_traffic_msgs__msg__NegotiationConclusion__create () } } fn destroy_msg (msg : * mut rmf_traffic_msgs__msg__NegotiationConclusion) -> () { unsafe { rmf_traffic_msgs__msg__NegotiationConclusion__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> NegotiationConclusion { NegotiationConclusion { conflict_version : msg . conflict_version , resolved : msg . resolved , table : { let mut temp = Vec :: with_capacity (msg . table . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . table . data , msg . table . size) } ; for s in slice { temp . push (rmf_traffic_msgs :: msg :: NegotiationKey :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . conflict_version = self . conflict_version ; msg . resolved = self . resolved ; unsafe { rmf_traffic_msgs__msg__NegotiationKey__Sequence__fini (& mut msg . table) ; rmf_traffic_msgs__msg__NegotiationKey__Sequence__init (& mut msg . table , self . table . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . table . data , msg . table . size) ; for (t , s) in slice . iter_mut () . zip (& self . table) { s . copy_to_native (t) ; } } } } impl Default for NegotiationConclusion { fn default () -> Self { let msg_native = WrappedNativeMsg :: < NegotiationConclusion > :: new () ; NegotiationConclusion :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct NegotiationForfeit { pub conflict_version : u64 , pub table : Vec < rmf_traffic_msgs :: msg :: NegotiationKey > } impl WrappedTypesupport for NegotiationForfeit { type CStruct = rmf_traffic_msgs__msg__NegotiationForfeit ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_traffic_msgs__msg__NegotiationForfeit () } } fn create_msg () -> * mut rmf_traffic_msgs__msg__NegotiationForfeit { unsafe { rmf_traffic_msgs__msg__NegotiationForfeit__create () } } fn destroy_msg (msg : * mut rmf_traffic_msgs__msg__NegotiationForfeit) -> () { unsafe { rmf_traffic_msgs__msg__NegotiationForfeit__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> NegotiationForfeit { NegotiationForfeit { conflict_version : msg . conflict_version , table : { let mut temp = Vec :: with_capacity (msg . table . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . table . data , msg . table . size) } ; for s in slice { temp . push (rmf_traffic_msgs :: msg :: NegotiationKey :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . conflict_version = self . conflict_version ; unsafe { rmf_traffic_msgs__msg__NegotiationKey__Sequence__fini (& mut msg . table) ; rmf_traffic_msgs__msg__NegotiationKey__Sequence__init (& mut msg . table , self . table . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . table . data , msg . table . size) ; for (t , s) in slice . iter_mut () . zip (& self . table) { s . copy_to_native (t) ; } } } } impl Default for NegotiationForfeit { fn default () -> Self { let msg_native = WrappedNativeMsg :: < NegotiationForfeit > :: new () ; NegotiationForfeit :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct NegotiationKey { pub participant : u64 , pub version : u64 } impl WrappedTypesupport for NegotiationKey { type CStruct = rmf_traffic_msgs__msg__NegotiationKey ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_traffic_msgs__msg__NegotiationKey () } } fn create_msg () -> * mut rmf_traffic_msgs__msg__NegotiationKey { unsafe { rmf_traffic_msgs__msg__NegotiationKey__create () } } fn destroy_msg (msg : * mut rmf_traffic_msgs__msg__NegotiationKey) -> () { unsafe { rmf_traffic_msgs__msg__NegotiationKey__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> NegotiationKey { NegotiationKey { participant : msg . participant , version : msg . version , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . participant = self . participant ; msg . version = self . version ; } } impl Default for NegotiationKey { fn default () -> Self { let msg_native = WrappedNativeMsg :: < NegotiationKey > :: new () ; NegotiationKey :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct NegotiationNotice { pub conflict_version : u64 , pub participants : Vec < u64 > } impl WrappedTypesupport for NegotiationNotice { type CStruct = rmf_traffic_msgs__msg__NegotiationNotice ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_traffic_msgs__msg__NegotiationNotice () } } fn create_msg () -> * mut rmf_traffic_msgs__msg__NegotiationNotice { unsafe { rmf_traffic_msgs__msg__NegotiationNotice__create () } } fn destroy_msg (msg : * mut rmf_traffic_msgs__msg__NegotiationNotice) -> () { unsafe { rmf_traffic_msgs__msg__NegotiationNotice__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> NegotiationNotice { NegotiationNotice { conflict_version : msg . conflict_version , participants : msg . participants . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . conflict_version = self . conflict_version ; msg . participants . update (& self . participants) ; } } impl Default for NegotiationNotice { fn default () -> Self { let msg_native = WrappedNativeMsg :: < NegotiationNotice > :: new () ; NegotiationNotice :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct NegotiationParticipantAck { pub participant : u64 , pub updating : bool , pub itinerary_version : u64 } impl WrappedTypesupport for NegotiationParticipantAck { type CStruct = rmf_traffic_msgs__msg__NegotiationParticipantAck ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_traffic_msgs__msg__NegotiationParticipantAck () } } fn create_msg () -> * mut rmf_traffic_msgs__msg__NegotiationParticipantAck { unsafe { rmf_traffic_msgs__msg__NegotiationParticipantAck__create () } } fn destroy_msg (msg : * mut rmf_traffic_msgs__msg__NegotiationParticipantAck) -> () { unsafe { rmf_traffic_msgs__msg__NegotiationParticipantAck__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> NegotiationParticipantAck { NegotiationParticipantAck { participant : msg . participant , updating : msg . updating , itinerary_version : msg . itinerary_version , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . participant = self . participant ; msg . updating = self . updating ; msg . itinerary_version = self . itinerary_version ; } } impl Default for NegotiationParticipantAck { fn default () -> Self { let msg_native = WrappedNativeMsg :: < NegotiationParticipantAck > :: new () ; NegotiationParticipantAck :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct NegotiationProposal { pub conflict_version : u64 , pub proposal_version : u64 , pub for_participant : u64 , pub to_accommodate : Vec < rmf_traffic_msgs :: msg :: NegotiationKey > , pub itinerary : Vec < rmf_traffic_msgs :: msg :: Route > } impl WrappedTypesupport for NegotiationProposal { type CStruct = rmf_traffic_msgs__msg__NegotiationProposal ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_traffic_msgs__msg__NegotiationProposal () } } fn create_msg () -> * mut rmf_traffic_msgs__msg__NegotiationProposal { unsafe { rmf_traffic_msgs__msg__NegotiationProposal__create () } } fn destroy_msg (msg : * mut rmf_traffic_msgs__msg__NegotiationProposal) -> () { unsafe { rmf_traffic_msgs__msg__NegotiationProposal__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> NegotiationProposal { NegotiationProposal { conflict_version : msg . conflict_version , proposal_version : msg . proposal_version , for_participant : msg . for_participant , to_accommodate : { let mut temp = Vec :: with_capacity (msg . to_accommodate . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . to_accommodate . data , msg . to_accommodate . size) } ; for s in slice { temp . push (rmf_traffic_msgs :: msg :: NegotiationKey :: from_native (s)) ; } temp } , itinerary : { let mut temp = Vec :: with_capacity (msg . itinerary . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . itinerary . data , msg . itinerary . size) } ; for s in slice { temp . push (rmf_traffic_msgs :: msg :: Route :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . conflict_version = self . conflict_version ; msg . proposal_version = self . proposal_version ; msg . for_participant = self . for_participant ; unsafe { rmf_traffic_msgs__msg__NegotiationKey__Sequence__fini (& mut msg . to_accommodate) ; rmf_traffic_msgs__msg__NegotiationKey__Sequence__init (& mut msg . to_accommodate , self . to_accommodate . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . to_accommodate . data , msg . to_accommodate . size) ; for (t , s) in slice . iter_mut () . zip (& self . to_accommodate) { s . copy_to_native (t) ; } } unsafe { rmf_traffic_msgs__msg__Route__Sequence__fini (& mut msg . itinerary) ; rmf_traffic_msgs__msg__Route__Sequence__init (& mut msg . itinerary , self . itinerary . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . itinerary . data , msg . itinerary . size) ; for (t , s) in slice . iter_mut () . zip (& self . itinerary) { s . copy_to_native (t) ; } } } } impl Default for NegotiationProposal { fn default () -> Self { let msg_native = WrappedNativeMsg :: < NegotiationProposal > :: new () ; NegotiationProposal :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct NegotiationRefusal { pub conflict_version : u64 } impl WrappedTypesupport for NegotiationRefusal { type CStruct = rmf_traffic_msgs__msg__NegotiationRefusal ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_traffic_msgs__msg__NegotiationRefusal () } } fn create_msg () -> * mut rmf_traffic_msgs__msg__NegotiationRefusal { unsafe { rmf_traffic_msgs__msg__NegotiationRefusal__create () } } fn destroy_msg (msg : * mut rmf_traffic_msgs__msg__NegotiationRefusal) -> () { unsafe { rmf_traffic_msgs__msg__NegotiationRefusal__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> NegotiationRefusal { NegotiationRefusal { conflict_version : msg . conflict_version , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . conflict_version = self . conflict_version ; } } impl Default for NegotiationRefusal { fn default () -> Self { let msg_native = WrappedNativeMsg :: < NegotiationRefusal > :: new () ; NegotiationRefusal :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct NegotiationRejection { pub conflict_version : u64 , pub table : Vec < rmf_traffic_msgs :: msg :: NegotiationKey > , pub rejected_by : u64 , pub alternatives : Vec < rmf_traffic_msgs :: msg :: Itinerary > } impl WrappedTypesupport for NegotiationRejection { type CStruct = rmf_traffic_msgs__msg__NegotiationRejection ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_traffic_msgs__msg__NegotiationRejection () } } fn create_msg () -> * mut rmf_traffic_msgs__msg__NegotiationRejection { unsafe { rmf_traffic_msgs__msg__NegotiationRejection__create () } } fn destroy_msg (msg : * mut rmf_traffic_msgs__msg__NegotiationRejection) -> () { unsafe { rmf_traffic_msgs__msg__NegotiationRejection__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> NegotiationRejection { NegotiationRejection { conflict_version : msg . conflict_version , table : { let mut temp = Vec :: with_capacity (msg . table . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . table . data , msg . table . size) } ; for s in slice { temp . push (rmf_traffic_msgs :: msg :: NegotiationKey :: from_native (s)) ; } temp } , rejected_by : msg . rejected_by , alternatives : { let mut temp = Vec :: with_capacity (msg . alternatives . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . alternatives . data , msg . alternatives . size) } ; for s in slice { temp . push (rmf_traffic_msgs :: msg :: Itinerary :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . conflict_version = self . conflict_version ; unsafe { rmf_traffic_msgs__msg__NegotiationKey__Sequence__fini (& mut msg . table) ; rmf_traffic_msgs__msg__NegotiationKey__Sequence__init (& mut msg . table , self . table . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . table . data , msg . table . size) ; for (t , s) in slice . iter_mut () . zip (& self . table) { s . copy_to_native (t) ; } } msg . rejected_by = self . rejected_by ; unsafe { rmf_traffic_msgs__msg__Itinerary__Sequence__fini (& mut msg . alternatives) ; rmf_traffic_msgs__msg__Itinerary__Sequence__init (& mut msg . alternatives , self . alternatives . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . alternatives . data , msg . alternatives . size) ; for (t , s) in slice . iter_mut () . zip (& self . alternatives) { s . copy_to_native (t) ; } } } } impl Default for NegotiationRejection { fn default () -> Self { let msg_native = WrappedNativeMsg :: < NegotiationRejection > :: new () ; NegotiationRejection :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct NegotiationRepeat { pub conflict_version : u64 , pub table : Vec < u64 > } impl WrappedTypesupport for NegotiationRepeat { type CStruct = rmf_traffic_msgs__msg__NegotiationRepeat ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_traffic_msgs__msg__NegotiationRepeat () } } fn create_msg () -> * mut rmf_traffic_msgs__msg__NegotiationRepeat { unsafe { rmf_traffic_msgs__msg__NegotiationRepeat__create () } } fn destroy_msg (msg : * mut rmf_traffic_msgs__msg__NegotiationRepeat) -> () { unsafe { rmf_traffic_msgs__msg__NegotiationRepeat__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> NegotiationRepeat { NegotiationRepeat { conflict_version : msg . conflict_version , table : msg . table . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . conflict_version = self . conflict_version ; msg . table . update (& self . table) ; } } impl Default for NegotiationRepeat { fn default () -> Self { let msg_native = WrappedNativeMsg :: < NegotiationRepeat > :: new () ; NegotiationRepeat :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Participant { pub id : u64 , pub description : rmf_traffic_msgs :: msg :: ParticipantDescription } impl WrappedTypesupport for Participant { type CStruct = rmf_traffic_msgs__msg__Participant ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_traffic_msgs__msg__Participant () } } fn create_msg () -> * mut rmf_traffic_msgs__msg__Participant { unsafe { rmf_traffic_msgs__msg__Participant__create () } } fn destroy_msg (msg : * mut rmf_traffic_msgs__msg__Participant) -> () { unsafe { rmf_traffic_msgs__msg__Participant__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Participant { Participant { id : msg . id , description : rmf_traffic_msgs :: msg :: ParticipantDescription :: from_native (& msg . description) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . id = self . id ; self . description . copy_to_native (& mut msg . description) ; } } impl Default for Participant { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Participant > :: new () ; Participant :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ParticipantDescription { pub name : std :: string :: String , pub owner : std :: string :: String , pub responsiveness : u8 , pub profile : rmf_traffic_msgs :: msg :: Profile } impl WrappedTypesupport for ParticipantDescription { type CStruct = rmf_traffic_msgs__msg__ParticipantDescription ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_traffic_msgs__msg__ParticipantDescription () } } fn create_msg () -> * mut rmf_traffic_msgs__msg__ParticipantDescription { unsafe { rmf_traffic_msgs__msg__ParticipantDescription__create () } } fn destroy_msg (msg : * mut rmf_traffic_msgs__msg__ParticipantDescription) -> () { unsafe { rmf_traffic_msgs__msg__ParticipantDescription__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ParticipantDescription { ParticipantDescription { name : msg . name . to_str () . to_owned () , owner : msg . owner . to_str () . to_owned () , responsiveness : msg . responsiveness , profile : rmf_traffic_msgs :: msg :: Profile :: from_native (& msg . profile) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . name . assign (& self . name) ; msg . owner . assign (& self . owner) ; msg . responsiveness = self . responsiveness ; self . profile . copy_to_native (& mut msg . profile) ; } } impl Default for ParticipantDescription { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ParticipantDescription > :: new () ; ParticipantDescription :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl ParticipantDescription { pub const RX_INVALID : _bindgen_ty_1587 = rmf_traffic_msgs__msg__ParticipantDescription__RX_INVALID ; pub const RX_RESPONSIVE : _bindgen_ty_1589 = rmf_traffic_msgs__msg__ParticipantDescription__RX_RESPONSIVE ; pub const RX_UNRESPONSIVE : _bindgen_ty_1588 = rmf_traffic_msgs__msg__ParticipantDescription__RX_UNRESPONSIVE ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Participants { pub participants : Vec < rmf_traffic_msgs :: msg :: Participant > } impl WrappedTypesupport for Participants { type CStruct = rmf_traffic_msgs__msg__Participants ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_traffic_msgs__msg__Participants () } } fn create_msg () -> * mut rmf_traffic_msgs__msg__Participants { unsafe { rmf_traffic_msgs__msg__Participants__create () } } fn destroy_msg (msg : * mut rmf_traffic_msgs__msg__Participants) -> () { unsafe { rmf_traffic_msgs__msg__Participants__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Participants { Participants { participants : { let mut temp = Vec :: with_capacity (msg . participants . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . participants . data , msg . participants . size) } ; for s in slice { temp . push (rmf_traffic_msgs :: msg :: Participant :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { unsafe { rmf_traffic_msgs__msg__Participant__Sequence__fini (& mut msg . participants) ; rmf_traffic_msgs__msg__Participant__Sequence__init (& mut msg . participants , self . participants . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . participants . data , msg . participants . size) ; for (t , s) in slice . iter_mut () . zip (& self . participants) { s . copy_to_native (t) ; } } } } impl Default for Participants { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Participants > :: new () ; Participants :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Profile { pub footprint : rmf_traffic_msgs :: msg :: ConvexShape , pub vicinity : rmf_traffic_msgs :: msg :: ConvexShape , pub shape_context : rmf_traffic_msgs :: msg :: ConvexShapeContext } impl WrappedTypesupport for Profile { type CStruct = rmf_traffic_msgs__msg__Profile ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_traffic_msgs__msg__Profile () } } fn create_msg () -> * mut rmf_traffic_msgs__msg__Profile { unsafe { rmf_traffic_msgs__msg__Profile__create () } } fn destroy_msg (msg : * mut rmf_traffic_msgs__msg__Profile) -> () { unsafe { rmf_traffic_msgs__msg__Profile__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Profile { Profile { footprint : rmf_traffic_msgs :: msg :: ConvexShape :: from_native (& msg . footprint) , vicinity : rmf_traffic_msgs :: msg :: ConvexShape :: from_native (& msg . vicinity) , shape_context : rmf_traffic_msgs :: msg :: ConvexShapeContext :: from_native (& msg . shape_context) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . footprint . copy_to_native (& mut msg . footprint) ; self . vicinity . copy_to_native (& mut msg . vicinity) ; self . shape_context . copy_to_native (& mut msg . shape_context) ; } } impl Default for Profile { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Profile > :: new () ; Profile :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Region { pub map : std :: string :: String , pub spaces : Vec < rmf_traffic_msgs :: msg :: Space > , pub timespan : rmf_traffic_msgs :: msg :: Timespan } impl WrappedTypesupport for Region { type CStruct = rmf_traffic_msgs__msg__Region ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_traffic_msgs__msg__Region () } } fn create_msg () -> * mut rmf_traffic_msgs__msg__Region { unsafe { rmf_traffic_msgs__msg__Region__create () } } fn destroy_msg (msg : * mut rmf_traffic_msgs__msg__Region) -> () { unsafe { rmf_traffic_msgs__msg__Region__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Region { Region { map : msg . map . to_str () . to_owned () , spaces : { let mut temp = Vec :: with_capacity (msg . spaces . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . spaces . data , msg . spaces . size) } ; for s in slice { temp . push (rmf_traffic_msgs :: msg :: Space :: from_native (s)) ; } temp } , timespan : rmf_traffic_msgs :: msg :: Timespan :: from_native (& msg . timespan) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . map . assign (& self . map) ; unsafe { rmf_traffic_msgs__msg__Space__Sequence__fini (& mut msg . spaces) ; rmf_traffic_msgs__msg__Space__Sequence__init (& mut msg . spaces , self . spaces . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . spaces . data , msg . spaces . size) ; for (t , s) in slice . iter_mut () . zip (& self . spaces) { s . copy_to_native (t) ; } } self . timespan . copy_to_native (& mut msg . timespan) ; } } impl Default for Region { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Region > :: new () ; Region :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Route { pub map : std :: string :: String , pub trajectory : rmf_traffic_msgs :: msg :: Trajectory } impl WrappedTypesupport for Route { type CStruct = rmf_traffic_msgs__msg__Route ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_traffic_msgs__msg__Route () } } fn create_msg () -> * mut rmf_traffic_msgs__msg__Route { unsafe { rmf_traffic_msgs__msg__Route__create () } } fn destroy_msg (msg : * mut rmf_traffic_msgs__msg__Route) -> () { unsafe { rmf_traffic_msgs__msg__Route__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Route { Route { map : msg . map . to_str () . to_owned () , trajectory : rmf_traffic_msgs :: msg :: Trajectory :: from_native (& msg . trajectory) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . map . assign (& self . map) ; self . trajectory . copy_to_native (& mut msg . trajectory) ; } } impl Default for Route { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Route > :: new () ; Route :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ScheduleChangeAdd { pub id : u64 , pub route : rmf_traffic_msgs :: msg :: Route } impl WrappedTypesupport for ScheduleChangeAdd { type CStruct = rmf_traffic_msgs__msg__ScheduleChangeAdd ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_traffic_msgs__msg__ScheduleChangeAdd () } } fn create_msg () -> * mut rmf_traffic_msgs__msg__ScheduleChangeAdd { unsafe { rmf_traffic_msgs__msg__ScheduleChangeAdd__create () } } fn destroy_msg (msg : * mut rmf_traffic_msgs__msg__ScheduleChangeAdd) -> () { unsafe { rmf_traffic_msgs__msg__ScheduleChangeAdd__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ScheduleChangeAdd { ScheduleChangeAdd { id : msg . id , route : rmf_traffic_msgs :: msg :: Route :: from_native (& msg . route) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . id = self . id ; self . route . copy_to_native (& mut msg . route) ; } } impl Default for ScheduleChangeAdd { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ScheduleChangeAdd > :: new () ; ScheduleChangeAdd :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ScheduleChangeCull { pub time : i64 } impl WrappedTypesupport for ScheduleChangeCull { type CStruct = rmf_traffic_msgs__msg__ScheduleChangeCull ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_traffic_msgs__msg__ScheduleChangeCull () } } fn create_msg () -> * mut rmf_traffic_msgs__msg__ScheduleChangeCull { unsafe { rmf_traffic_msgs__msg__ScheduleChangeCull__create () } } fn destroy_msg (msg : * mut rmf_traffic_msgs__msg__ScheduleChangeCull) -> () { unsafe { rmf_traffic_msgs__msg__ScheduleChangeCull__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ScheduleChangeCull { ScheduleChangeCull { time : msg . time , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . time = self . time ; } } impl Default for ScheduleChangeCull { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ScheduleChangeCull > :: new () ; ScheduleChangeCull :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ScheduleChangeDelay { pub delay : i64 } impl WrappedTypesupport for ScheduleChangeDelay { type CStruct = rmf_traffic_msgs__msg__ScheduleChangeDelay ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_traffic_msgs__msg__ScheduleChangeDelay () } } fn create_msg () -> * mut rmf_traffic_msgs__msg__ScheduleChangeDelay { unsafe { rmf_traffic_msgs__msg__ScheduleChangeDelay__create () } } fn destroy_msg (msg : * mut rmf_traffic_msgs__msg__ScheduleChangeDelay) -> () { unsafe { rmf_traffic_msgs__msg__ScheduleChangeDelay__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ScheduleChangeDelay { ScheduleChangeDelay { delay : msg . delay , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . delay = self . delay ; } } impl Default for ScheduleChangeDelay { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ScheduleChangeDelay > :: new () ; ScheduleChangeDelay :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ScheduleInconsistency { pub participant : u64 , pub ranges : Vec < rmf_traffic_msgs :: msg :: ScheduleInconsistencyRange > , pub last_known_version : u64 } impl WrappedTypesupport for ScheduleInconsistency { type CStruct = rmf_traffic_msgs__msg__ScheduleInconsistency ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_traffic_msgs__msg__ScheduleInconsistency () } } fn create_msg () -> * mut rmf_traffic_msgs__msg__ScheduleInconsistency { unsafe { rmf_traffic_msgs__msg__ScheduleInconsistency__create () } } fn destroy_msg (msg : * mut rmf_traffic_msgs__msg__ScheduleInconsistency) -> () { unsafe { rmf_traffic_msgs__msg__ScheduleInconsistency__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ScheduleInconsistency { ScheduleInconsistency { participant : msg . participant , ranges : { let mut temp = Vec :: with_capacity (msg . ranges . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . ranges . data , msg . ranges . size) } ; for s in slice { temp . push (rmf_traffic_msgs :: msg :: ScheduleInconsistencyRange :: from_native (s)) ; } temp } , last_known_version : msg . last_known_version , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . participant = self . participant ; unsafe { rmf_traffic_msgs__msg__ScheduleInconsistencyRange__Sequence__fini (& mut msg . ranges) ; rmf_traffic_msgs__msg__ScheduleInconsistencyRange__Sequence__init (& mut msg . ranges , self . ranges . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . ranges . data , msg . ranges . size) ; for (t , s) in slice . iter_mut () . zip (& self . ranges) { s . copy_to_native (t) ; } } msg . last_known_version = self . last_known_version ; } } impl Default for ScheduleInconsistency { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ScheduleInconsistency > :: new () ; ScheduleInconsistency :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ScheduleInconsistencyRange { pub lower : u64 , pub upper : u64 } impl WrappedTypesupport for ScheduleInconsistencyRange { type CStruct = rmf_traffic_msgs__msg__ScheduleInconsistencyRange ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_traffic_msgs__msg__ScheduleInconsistencyRange () } } fn create_msg () -> * mut rmf_traffic_msgs__msg__ScheduleInconsistencyRange { unsafe { rmf_traffic_msgs__msg__ScheduleInconsistencyRange__create () } } fn destroy_msg (msg : * mut rmf_traffic_msgs__msg__ScheduleInconsistencyRange) -> () { unsafe { rmf_traffic_msgs__msg__ScheduleInconsistencyRange__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ScheduleInconsistencyRange { ScheduleInconsistencyRange { lower : msg . lower , upper : msg . upper , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . lower = self . lower ; msg . upper = self . upper ; } } impl Default for ScheduleInconsistencyRange { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ScheduleInconsistencyRange > :: new () ; ScheduleInconsistencyRange :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ScheduleParticipantPatch { pub participant_id : u64 , pub itinerary_version : u64 , pub erasures : Vec < u64 > , pub delays : Vec < rmf_traffic_msgs :: msg :: ScheduleChangeDelay > , pub additions : Vec < rmf_traffic_msgs :: msg :: ScheduleChangeAdd > } impl WrappedTypesupport for ScheduleParticipantPatch { type CStruct = rmf_traffic_msgs__msg__ScheduleParticipantPatch ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_traffic_msgs__msg__ScheduleParticipantPatch () } } fn create_msg () -> * mut rmf_traffic_msgs__msg__ScheduleParticipantPatch { unsafe { rmf_traffic_msgs__msg__ScheduleParticipantPatch__create () } } fn destroy_msg (msg : * mut rmf_traffic_msgs__msg__ScheduleParticipantPatch) -> () { unsafe { rmf_traffic_msgs__msg__ScheduleParticipantPatch__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ScheduleParticipantPatch { ScheduleParticipantPatch { participant_id : msg . participant_id , itinerary_version : msg . itinerary_version , erasures : msg . erasures . to_vec () , delays : { let mut temp = Vec :: with_capacity (msg . delays . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . delays . data , msg . delays . size) } ; for s in slice { temp . push (rmf_traffic_msgs :: msg :: ScheduleChangeDelay :: from_native (s)) ; } temp } , additions : { let mut temp = Vec :: with_capacity (msg . additions . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . additions . data , msg . additions . size) } ; for s in slice { temp . push (rmf_traffic_msgs :: msg :: ScheduleChangeAdd :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . participant_id = self . participant_id ; msg . itinerary_version = self . itinerary_version ; msg . erasures . update (& self . erasures) ; unsafe { rmf_traffic_msgs__msg__ScheduleChangeDelay__Sequence__fini (& mut msg . delays) ; rmf_traffic_msgs__msg__ScheduleChangeDelay__Sequence__init (& mut msg . delays , self . delays . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . delays . data , msg . delays . size) ; for (t , s) in slice . iter_mut () . zip (& self . delays) { s . copy_to_native (t) ; } } unsafe { rmf_traffic_msgs__msg__ScheduleChangeAdd__Sequence__fini (& mut msg . additions) ; rmf_traffic_msgs__msg__ScheduleChangeAdd__Sequence__init (& mut msg . additions , self . additions . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . additions . data , msg . additions . size) ; for (t , s) in slice . iter_mut () . zip (& self . additions) { s . copy_to_native (t) ; } } } } impl Default for ScheduleParticipantPatch { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ScheduleParticipantPatch > :: new () ; ScheduleParticipantPatch :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct SchedulePatch { pub participants : Vec < rmf_traffic_msgs :: msg :: ScheduleParticipantPatch > , pub cull : Vec < rmf_traffic_msgs :: msg :: ScheduleChangeCull > , pub has_base_version : bool , pub base_version : u64 , pub latest_version : u64 } impl WrappedTypesupport for SchedulePatch { type CStruct = rmf_traffic_msgs__msg__SchedulePatch ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_traffic_msgs__msg__SchedulePatch () } } fn create_msg () -> * mut rmf_traffic_msgs__msg__SchedulePatch { unsafe { rmf_traffic_msgs__msg__SchedulePatch__create () } } fn destroy_msg (msg : * mut rmf_traffic_msgs__msg__SchedulePatch) -> () { unsafe { rmf_traffic_msgs__msg__SchedulePatch__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> SchedulePatch { SchedulePatch { participants : { let mut temp = Vec :: with_capacity (msg . participants . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . participants . data , msg . participants . size) } ; for s in slice { temp . push (rmf_traffic_msgs :: msg :: ScheduleParticipantPatch :: from_native (s)) ; } temp } , cull : { let mut temp = Vec :: with_capacity (msg . cull . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . cull . data , msg . cull . size) } ; for s in slice { temp . push (rmf_traffic_msgs :: msg :: ScheduleChangeCull :: from_native (s)) ; } temp } , has_base_version : msg . has_base_version , base_version : msg . base_version , latest_version : msg . latest_version , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { unsafe { rmf_traffic_msgs__msg__ScheduleParticipantPatch__Sequence__fini (& mut msg . participants) ; rmf_traffic_msgs__msg__ScheduleParticipantPatch__Sequence__init (& mut msg . participants , self . participants . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . participants . data , msg . participants . size) ; for (t , s) in slice . iter_mut () . zip (& self . participants) { s . copy_to_native (t) ; } } unsafe { rmf_traffic_msgs__msg__ScheduleChangeCull__Sequence__fini (& mut msg . cull) ; rmf_traffic_msgs__msg__ScheduleChangeCull__Sequence__init (& mut msg . cull , self . cull . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . cull . data , msg . cull . size) ; for (t , s) in slice . iter_mut () . zip (& self . cull) { s . copy_to_native (t) ; } } msg . has_base_version = self . has_base_version ; msg . base_version = self . base_version ; msg . latest_version = self . latest_version ; } } impl Default for SchedulePatch { fn default () -> Self { let msg_native = WrappedNativeMsg :: < SchedulePatch > :: new () ; SchedulePatch :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ScheduleQueries { pub node_version : u64 , pub queries : Vec < rmf_traffic_msgs :: msg :: ScheduleQuery > , pub ids : Vec < u64 > } impl WrappedTypesupport for ScheduleQueries { type CStruct = rmf_traffic_msgs__msg__ScheduleQueries ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_traffic_msgs__msg__ScheduleQueries () } } fn create_msg () -> * mut rmf_traffic_msgs__msg__ScheduleQueries { unsafe { rmf_traffic_msgs__msg__ScheduleQueries__create () } } fn destroy_msg (msg : * mut rmf_traffic_msgs__msg__ScheduleQueries) -> () { unsafe { rmf_traffic_msgs__msg__ScheduleQueries__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ScheduleQueries { ScheduleQueries { node_version : msg . node_version , queries : { let mut temp = Vec :: with_capacity (msg . queries . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . queries . data , msg . queries . size) } ; for s in slice { temp . push (rmf_traffic_msgs :: msg :: ScheduleQuery :: from_native (s)) ; } temp } , ids : msg . ids . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . node_version = self . node_version ; unsafe { rmf_traffic_msgs__msg__ScheduleQuery__Sequence__fini (& mut msg . queries) ; rmf_traffic_msgs__msg__ScheduleQuery__Sequence__init (& mut msg . queries , self . queries . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . queries . data , msg . queries . size) ; for (t , s) in slice . iter_mut () . zip (& self . queries) { s . copy_to_native (t) ; } } msg . ids . update (& self . ids) ; } } impl Default for ScheduleQueries { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ScheduleQueries > :: new () ; ScheduleQueries :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ScheduleQuery { pub spacetime : rmf_traffic_msgs :: msg :: ScheduleQuerySpacetime , pub participants : rmf_traffic_msgs :: msg :: ScheduleQueryParticipants } impl WrappedTypesupport for ScheduleQuery { type CStruct = rmf_traffic_msgs__msg__ScheduleQuery ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_traffic_msgs__msg__ScheduleQuery () } } fn create_msg () -> * mut rmf_traffic_msgs__msg__ScheduleQuery { unsafe { rmf_traffic_msgs__msg__ScheduleQuery__create () } } fn destroy_msg (msg : * mut rmf_traffic_msgs__msg__ScheduleQuery) -> () { unsafe { rmf_traffic_msgs__msg__ScheduleQuery__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ScheduleQuery { ScheduleQuery { spacetime : rmf_traffic_msgs :: msg :: ScheduleQuerySpacetime :: from_native (& msg . spacetime) , participants : rmf_traffic_msgs :: msg :: ScheduleQueryParticipants :: from_native (& msg . participants) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . spacetime . copy_to_native (& mut msg . spacetime) ; self . participants . copy_to_native (& mut msg . participants) ; } } impl Default for ScheduleQuery { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ScheduleQuery > :: new () ; ScheduleQuery :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ScheduleQueryParticipants { # [serde (rename = "type")] pub type_ : u16 , pub ids : Vec < u64 > } impl WrappedTypesupport for ScheduleQueryParticipants { type CStruct = rmf_traffic_msgs__msg__ScheduleQueryParticipants ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_traffic_msgs__msg__ScheduleQueryParticipants () } } fn create_msg () -> * mut rmf_traffic_msgs__msg__ScheduleQueryParticipants { unsafe { rmf_traffic_msgs__msg__ScheduleQueryParticipants__create () } } fn destroy_msg (msg : * mut rmf_traffic_msgs__msg__ScheduleQueryParticipants) -> () { unsafe { rmf_traffic_msgs__msg__ScheduleQueryParticipants__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ScheduleQueryParticipants { ScheduleQueryParticipants { type_ : msg . type_ , ids : msg . ids . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . type_ = self . type_ ; msg . ids . update (& self . ids) ; } } impl Default for ScheduleQueryParticipants { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ScheduleQueryParticipants > :: new () ; ScheduleQueryParticipants :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl ScheduleQueryParticipants { pub const ALL : _bindgen_ty_1596 = rmf_traffic_msgs__msg__ScheduleQueryParticipants__ALL ; pub const EXCLUDE : _bindgen_ty_1598 = rmf_traffic_msgs__msg__ScheduleQueryParticipants__EXCLUDE ; pub const INCLUDE : _bindgen_ty_1597 = rmf_traffic_msgs__msg__ScheduleQueryParticipants__INCLUDE ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ScheduleQuerySpacetime { # [serde (rename = "type")] pub type_ : u16 , pub regions : Vec < rmf_traffic_msgs :: msg :: Region > , pub shape_context : rmf_traffic_msgs :: msg :: ShapeContext , pub timespan : rmf_traffic_msgs :: msg :: Timespan } impl WrappedTypesupport for ScheduleQuerySpacetime { type CStruct = rmf_traffic_msgs__msg__ScheduleQuerySpacetime ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_traffic_msgs__msg__ScheduleQuerySpacetime () } } fn create_msg () -> * mut rmf_traffic_msgs__msg__ScheduleQuerySpacetime { unsafe { rmf_traffic_msgs__msg__ScheduleQuerySpacetime__create () } } fn destroy_msg (msg : * mut rmf_traffic_msgs__msg__ScheduleQuerySpacetime) -> () { unsafe { rmf_traffic_msgs__msg__ScheduleQuerySpacetime__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ScheduleQuerySpacetime { ScheduleQuerySpacetime { type_ : msg . type_ , regions : { let mut temp = Vec :: with_capacity (msg . regions . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . regions . data , msg . regions . size) } ; for s in slice { temp . push (rmf_traffic_msgs :: msg :: Region :: from_native (s)) ; } temp } , shape_context : rmf_traffic_msgs :: msg :: ShapeContext :: from_native (& msg . shape_context) , timespan : rmf_traffic_msgs :: msg :: Timespan :: from_native (& msg . timespan) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . type_ = self . type_ ; unsafe { rmf_traffic_msgs__msg__Region__Sequence__fini (& mut msg . regions) ; rmf_traffic_msgs__msg__Region__Sequence__init (& mut msg . regions , self . regions . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . regions . data , msg . regions . size) ; for (t , s) in slice . iter_mut () . zip (& self . regions) { s . copy_to_native (t) ; } } self . shape_context . copy_to_native (& mut msg . shape_context) ; self . timespan . copy_to_native (& mut msg . timespan) ; } } impl Default for ScheduleQuerySpacetime { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ScheduleQuerySpacetime > :: new () ; ScheduleQuerySpacetime :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl ScheduleQuerySpacetime { pub const ALL : _bindgen_ty_1593 = rmf_traffic_msgs__msg__ScheduleQuerySpacetime__ALL ; pub const REGIONS : _bindgen_ty_1594 = rmf_traffic_msgs__msg__ScheduleQuerySpacetime__REGIONS ; pub const TIMESPAN : _bindgen_ty_1595 = rmf_traffic_msgs__msg__ScheduleQuerySpacetime__TIMESPAN ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ScheduleWriterItem { pub id : u64 , pub route : rmf_traffic_msgs :: msg :: Route } impl WrappedTypesupport for ScheduleWriterItem { type CStruct = rmf_traffic_msgs__msg__ScheduleWriterItem ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_traffic_msgs__msg__ScheduleWriterItem () } } fn create_msg () -> * mut rmf_traffic_msgs__msg__ScheduleWriterItem { unsafe { rmf_traffic_msgs__msg__ScheduleWriterItem__create () } } fn destroy_msg (msg : * mut rmf_traffic_msgs__msg__ScheduleWriterItem) -> () { unsafe { rmf_traffic_msgs__msg__ScheduleWriterItem__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ScheduleWriterItem { ScheduleWriterItem { id : msg . id , route : rmf_traffic_msgs :: msg :: Route :: from_native (& msg . route) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . id = self . id ; self . route . copy_to_native (& mut msg . route) ; } } impl Default for ScheduleWriterItem { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ScheduleWriterItem > :: new () ; ScheduleWriterItem :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Shape { # [serde (rename = "type")] pub type_ : u8 , pub index : u8 } impl WrappedTypesupport for Shape { type CStruct = rmf_traffic_msgs__msg__Shape ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_traffic_msgs__msg__Shape () } } fn create_msg () -> * mut rmf_traffic_msgs__msg__Shape { unsafe { rmf_traffic_msgs__msg__Shape__create () } } fn destroy_msg (msg : * mut rmf_traffic_msgs__msg__Shape) -> () { unsafe { rmf_traffic_msgs__msg__Shape__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Shape { Shape { type_ : msg . type_ , index : msg . index , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . type_ = self . type_ ; msg . index = self . index ; } } impl Default for Shape { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Shape > :: new () ; Shape :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl Shape { pub const BOX : _bindgen_ty_1591 = rmf_traffic_msgs__msg__Shape__BOX ; pub const CIRCLE : _bindgen_ty_1592 = rmf_traffic_msgs__msg__Shape__CIRCLE ; pub const NONE : _bindgen_ty_1590 = rmf_traffic_msgs__msg__Shape__NONE ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ShapeContext { pub convex_shapes : rmf_traffic_msgs :: msg :: ConvexShapeContext } impl WrappedTypesupport for ShapeContext { type CStruct = rmf_traffic_msgs__msg__ShapeContext ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_traffic_msgs__msg__ShapeContext () } } fn create_msg () -> * mut rmf_traffic_msgs__msg__ShapeContext { unsafe { rmf_traffic_msgs__msg__ShapeContext__create () } } fn destroy_msg (msg : * mut rmf_traffic_msgs__msg__ShapeContext) -> () { unsafe { rmf_traffic_msgs__msg__ShapeContext__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ShapeContext { ShapeContext { convex_shapes : rmf_traffic_msgs :: msg :: ConvexShapeContext :: from_native (& msg . convex_shapes) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . convex_shapes . copy_to_native (& mut msg . convex_shapes) ; } } impl Default for ShapeContext { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ShapeContext > :: new () ; ShapeContext :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Space { pub shape : rmf_traffic_msgs :: msg :: Shape , pub pose : geometry_msgs :: msg :: Pose2D } impl WrappedTypesupport for Space { type CStruct = rmf_traffic_msgs__msg__Space ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_traffic_msgs__msg__Space () } } fn create_msg () -> * mut rmf_traffic_msgs__msg__Space { unsafe { rmf_traffic_msgs__msg__Space__create () } } fn destroy_msg (msg : * mut rmf_traffic_msgs__msg__Space) -> () { unsafe { rmf_traffic_msgs__msg__Space__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Space { Space { shape : rmf_traffic_msgs :: msg :: Shape :: from_native (& msg . shape) , pose : geometry_msgs :: msg :: Pose2D :: from_native (& msg . pose) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . shape . copy_to_native (& mut msg . shape) ; self . pose . copy_to_native (& mut msg . pose) ; } } impl Default for Space { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Space > :: new () ; Space :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Timespan { pub maps : Vec < std :: string :: String > , pub has_lower_bound : bool , pub lower_bound : i64 , pub has_upper_bound : bool , pub upper_bound : i64 } impl WrappedTypesupport for Timespan { type CStruct = rmf_traffic_msgs__msg__Timespan ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_traffic_msgs__msg__Timespan () } } fn create_msg () -> * mut rmf_traffic_msgs__msg__Timespan { unsafe { rmf_traffic_msgs__msg__Timespan__create () } } fn destroy_msg (msg : * mut rmf_traffic_msgs__msg__Timespan) -> () { unsafe { rmf_traffic_msgs__msg__Timespan__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Timespan { Timespan { maps : msg . maps . to_vec () , has_lower_bound : msg . has_lower_bound , lower_bound : msg . lower_bound , has_upper_bound : msg . has_upper_bound , upper_bound : msg . upper_bound , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . maps . update (& self . maps) ; msg . has_lower_bound = self . has_lower_bound ; msg . lower_bound = self . lower_bound ; msg . has_upper_bound = self . has_upper_bound ; msg . upper_bound = self . upper_bound ; } } impl Default for Timespan { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Timespan > :: new () ; Timespan :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Trajectory { pub waypoints : Vec < rmf_traffic_msgs :: msg :: TrajectoryWaypoint > } impl WrappedTypesupport for Trajectory { type CStruct = rmf_traffic_msgs__msg__Trajectory ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_traffic_msgs__msg__Trajectory () } } fn create_msg () -> * mut rmf_traffic_msgs__msg__Trajectory { unsafe { rmf_traffic_msgs__msg__Trajectory__create () } } fn destroy_msg (msg : * mut rmf_traffic_msgs__msg__Trajectory) -> () { unsafe { rmf_traffic_msgs__msg__Trajectory__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Trajectory { Trajectory { waypoints : { let mut temp = Vec :: with_capacity (msg . waypoints . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . waypoints . data , msg . waypoints . size) } ; for s in slice { temp . push (rmf_traffic_msgs :: msg :: TrajectoryWaypoint :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { unsafe { rmf_traffic_msgs__msg__TrajectoryWaypoint__Sequence__fini (& mut msg . waypoints) ; rmf_traffic_msgs__msg__TrajectoryWaypoint__Sequence__init (& mut msg . waypoints , self . waypoints . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . waypoints . data , msg . waypoints . size) ; for (t , s) in slice . iter_mut () . zip (& self . waypoints) { s . copy_to_native (t) ; } } } } impl Default for Trajectory { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Trajectory > :: new () ; Trajectory :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct TrajectoryWaypoint { pub time : i64 , pub position : Vec < f64 > , pub velocity : Vec < f64 > } impl WrappedTypesupport for TrajectoryWaypoint { type CStruct = rmf_traffic_msgs__msg__TrajectoryWaypoint ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_traffic_msgs__msg__TrajectoryWaypoint () } } fn create_msg () -> * mut rmf_traffic_msgs__msg__TrajectoryWaypoint { unsafe { rmf_traffic_msgs__msg__TrajectoryWaypoint__create () } } fn destroy_msg (msg : * mut rmf_traffic_msgs__msg__TrajectoryWaypoint) -> () { unsafe { rmf_traffic_msgs__msg__TrajectoryWaypoint__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> TrajectoryWaypoint { TrajectoryWaypoint { time : msg . time , position : msg . position . to_vec () , velocity : msg . velocity . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . time = self . time ; assert_eq ! (self . position . len () , 3usize , "Field {} is fixed size of {}!" , "position" , 3usize) ; msg . position . copy_from_slice (& self . position [.. 3usize]) ; assert_eq ! (self . velocity . len () , 3usize , "Field {} is fixed size of {}!" , "velocity" , 3usize) ; msg . velocity . copy_from_slice (& self . velocity [.. 3usize]) ; } } impl Default for TrajectoryWaypoint { fn default () -> Self { let msg_native = WrappedNativeMsg :: < TrajectoryWaypoint > :: new () ; TrajectoryWaypoint :: from_native (& msg_native) } } } pub mod srv { # [allow (non_snake_case)] pub mod RegisterParticipant { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__rmf_traffic_msgs__srv__RegisterParticipant () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub description : rmf_traffic_msgs :: msg :: ParticipantDescription } impl WrappedTypesupport for Request { type CStruct = rmf_traffic_msgs__srv__RegisterParticipant_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_traffic_msgs__srv__RegisterParticipant_Request () } } fn create_msg () -> * mut rmf_traffic_msgs__srv__RegisterParticipant_Request { unsafe { rmf_traffic_msgs__srv__RegisterParticipant_Request__create () } } fn destroy_msg (msg : * mut rmf_traffic_msgs__srv__RegisterParticipant_Request) -> () { unsafe { rmf_traffic_msgs__srv__RegisterParticipant_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { description : rmf_traffic_msgs :: msg :: ParticipantDescription :: from_native (& msg . description) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . description . copy_to_native (& mut msg . description) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub participant_id : u64 , pub last_itinerary_version : u64 , pub last_route_id : u64 , pub error : std :: string :: String } impl WrappedTypesupport for Response { type CStruct = rmf_traffic_msgs__srv__RegisterParticipant_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_traffic_msgs__srv__RegisterParticipant_Response () } } fn create_msg () -> * mut rmf_traffic_msgs__srv__RegisterParticipant_Response { unsafe { rmf_traffic_msgs__srv__RegisterParticipant_Response__create () } } fn destroy_msg (msg : * mut rmf_traffic_msgs__srv__RegisterParticipant_Response) -> () { unsafe { rmf_traffic_msgs__srv__RegisterParticipant_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { participant_id : msg . participant_id , last_itinerary_version : msg . last_itinerary_version , last_route_id : msg . last_route_id , error : msg . error . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . participant_id = self . participant_id ; msg . last_itinerary_version = self . last_itinerary_version ; msg . last_route_id = self . last_route_id ; msg . error . assign (& self . error) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod RegisterQuery { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__rmf_traffic_msgs__srv__RegisterQuery () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub query : rmf_traffic_msgs :: msg :: ScheduleQuery } impl WrappedTypesupport for Request { type CStruct = rmf_traffic_msgs__srv__RegisterQuery_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_traffic_msgs__srv__RegisterQuery_Request () } } fn create_msg () -> * mut rmf_traffic_msgs__srv__RegisterQuery_Request { unsafe { rmf_traffic_msgs__srv__RegisterQuery_Request__create () } } fn destroy_msg (msg : * mut rmf_traffic_msgs__srv__RegisterQuery_Request) -> () { unsafe { rmf_traffic_msgs__srv__RegisterQuery_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { query : rmf_traffic_msgs :: msg :: ScheduleQuery :: from_native (& msg . query) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . query . copy_to_native (& mut msg . query) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub node_version : u64 , pub query_id : u64 , pub error : std :: string :: String } impl WrappedTypesupport for Response { type CStruct = rmf_traffic_msgs__srv__RegisterQuery_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_traffic_msgs__srv__RegisterQuery_Response () } } fn create_msg () -> * mut rmf_traffic_msgs__srv__RegisterQuery_Response { unsafe { rmf_traffic_msgs__srv__RegisterQuery_Response__create () } } fn destroy_msg (msg : * mut rmf_traffic_msgs__srv__RegisterQuery_Response) -> () { unsafe { rmf_traffic_msgs__srv__RegisterQuery_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { node_version : msg . node_version , query_id : msg . query_id , error : msg . error . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . node_version = self . node_version ; msg . query_id = self . query_id ; msg . error . assign (& self . error) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod RequestChanges { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__rmf_traffic_msgs__srv__RequestChanges () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub query_id : u64 , pub version : u64 , pub full_update : bool } impl WrappedTypesupport for Request { type CStruct = rmf_traffic_msgs__srv__RequestChanges_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_traffic_msgs__srv__RequestChanges_Request () } } fn create_msg () -> * mut rmf_traffic_msgs__srv__RequestChanges_Request { unsafe { rmf_traffic_msgs__srv__RequestChanges_Request__create () } } fn destroy_msg (msg : * mut rmf_traffic_msgs__srv__RequestChanges_Request) -> () { unsafe { rmf_traffic_msgs__srv__RequestChanges_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { query_id : msg . query_id , version : msg . version , full_update : msg . full_update , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . query_id = self . query_id ; msg . version = self . version ; msg . full_update = self . full_update ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub result : u8 } impl WrappedTypesupport for Response { type CStruct = rmf_traffic_msgs__srv__RequestChanges_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_traffic_msgs__srv__RequestChanges_Response () } } fn create_msg () -> * mut rmf_traffic_msgs__srv__RequestChanges_Response { unsafe { rmf_traffic_msgs__srv__RequestChanges_Response__create () } } fn destroy_msg (msg : * mut rmf_traffic_msgs__srv__RequestChanges_Response) -> () { unsafe { rmf_traffic_msgs__srv__RequestChanges_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { result : msg . result , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . result = self . result ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl Response { pub const REQUEST_ACCEPTED : _bindgen_ty_1599 = rmf_traffic_msgs__srv__RequestChanges_Response__REQUEST_ACCEPTED ; pub const UNKNOWN_QUERY_ID : _bindgen_ty_1600 = rmf_traffic_msgs__srv__RequestChanges_Response__UNKNOWN_QUERY_ID ; } } # [allow (non_snake_case)] pub mod UnregisterParticipant { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__rmf_traffic_msgs__srv__UnregisterParticipant () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub participant_id : u64 } impl WrappedTypesupport for Request { type CStruct = rmf_traffic_msgs__srv__UnregisterParticipant_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_traffic_msgs__srv__UnregisterParticipant_Request () } } fn create_msg () -> * mut rmf_traffic_msgs__srv__UnregisterParticipant_Request { unsafe { rmf_traffic_msgs__srv__UnregisterParticipant_Request__create () } } fn destroy_msg (msg : * mut rmf_traffic_msgs__srv__UnregisterParticipant_Request) -> () { unsafe { rmf_traffic_msgs__srv__UnregisterParticipant_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { participant_id : msg . participant_id , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . participant_id = self . participant_id ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub confirmation : bool , pub error : std :: string :: String } impl WrappedTypesupport for Response { type CStruct = rmf_traffic_msgs__srv__UnregisterParticipant_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_traffic_msgs__srv__UnregisterParticipant_Response () } } fn create_msg () -> * mut rmf_traffic_msgs__srv__UnregisterParticipant_Response { unsafe { rmf_traffic_msgs__srv__UnregisterParticipant_Response__create () } } fn destroy_msg (msg : * mut rmf_traffic_msgs__srv__UnregisterParticipant_Response) -> () { unsafe { rmf_traffic_msgs__srv__UnregisterParticipant_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { confirmation : msg . confirmation , error : msg . error . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . confirmation = self . confirmation ; msg . error . assign (& self . error) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } }