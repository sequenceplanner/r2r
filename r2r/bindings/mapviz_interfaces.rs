pub mod srv { # [allow (non_snake_case)] pub mod AddMapvizDisplay { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__mapviz_interfaces__srv__AddMapvizDisplay () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub name : std :: string :: String , # [serde (rename = "type")] pub type_ : std :: string :: String , pub draw_order : i32 , pub visible : bool , pub properties : Vec < marti_common_msgs :: msg :: KeyValue > } impl WrappedTypesupport for Request { type CStruct = mapviz_interfaces__srv__AddMapvizDisplay_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mapviz_interfaces__srv__AddMapvizDisplay_Request () } } fn create_msg () -> * mut mapviz_interfaces__srv__AddMapvizDisplay_Request { unsafe { mapviz_interfaces__srv__AddMapvizDisplay_Request__create () } } fn destroy_msg (msg : * mut mapviz_interfaces__srv__AddMapvizDisplay_Request) -> () { unsafe { mapviz_interfaces__srv__AddMapvizDisplay_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { name : msg . name . to_str () . to_owned () , type_ : msg . type_ . to_str () . to_owned () , draw_order : msg . draw_order , visible : msg . visible , properties : { let mut temp = Vec :: with_capacity (msg . properties . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . properties . data , msg . properties . size) } ; for s in slice { temp . push (marti_common_msgs :: msg :: KeyValue :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . name . assign (& self . name) ; msg . type_ . assign (& self . type_) ; msg . draw_order = self . draw_order ; msg . visible = self . visible ; unsafe { marti_common_msgs__msg__KeyValue__Sequence__fini (& mut msg . properties) ; marti_common_msgs__msg__KeyValue__Sequence__init (& mut msg . properties , self . properties . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . properties . data , msg . properties . size) ; for (t , s) in slice . iter_mut () . zip (& self . properties) { s . copy_to_native (t) ; } } } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool , pub message : std :: string :: String } impl WrappedTypesupport for Response { type CStruct = mapviz_interfaces__srv__AddMapvizDisplay_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mapviz_interfaces__srv__AddMapvizDisplay_Response () } } fn create_msg () -> * mut mapviz_interfaces__srv__AddMapvizDisplay_Response { unsafe { mapviz_interfaces__srv__AddMapvizDisplay_Response__create () } } fn destroy_msg (msg : * mut mapviz_interfaces__srv__AddMapvizDisplay_Response) -> () { unsafe { mapviz_interfaces__srv__AddMapvizDisplay_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , message : msg . message . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; msg . message . assign (& self . message) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } }