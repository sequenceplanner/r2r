pub mod action { # [allow (non_snake_case)] pub mod ObjectRecognition { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Action () ; impl WrappedActionTypeSupport for Action { type Goal = Goal ; type Result = Result ; type Feedback = Feedback ; type FeedbackMessage = FeedbackMessage ; type SendGoal = SendGoal :: Service ; type GetResult = GetResult :: Service ; fn get_ts () -> & 'static rosidl_action_type_support_t { unsafe { & * rosidl_typesupport_c__get_action_type_support_handle__object_recognition_msgs__action__ObjectRecognition () } } fn make_goal_request_msg (goal_id : unique_identifier_msgs :: msg :: UUID , goal : Goal) -> SendGoal :: Request { SendGoal :: Request { goal_id , goal } } fn make_goal_response_msg (accepted : bool , stamp : builtin_interfaces :: msg :: Time) -> SendGoal :: Response { SendGoal :: Response { accepted , stamp } } fn make_feedback_msg (goal_id : unique_identifier_msgs :: msg :: UUID , feedback : Feedback) -> FeedbackMessage { FeedbackMessage { goal_id , feedback } } fn make_result_request_msg (goal_id : unique_identifier_msgs :: msg :: UUID) -> GetResult :: Request { GetResult :: Request { goal_id , } } fn make_result_response_msg (status : i8 , result : Result) -> GetResult :: Response { GetResult :: Response { status , result , } } fn destructure_goal_request_msg (msg : SendGoal :: Request) -> (unique_identifier_msgs :: msg :: UUID , Goal) { (msg . goal_id , msg . goal) } fn destructure_goal_response_msg (msg : SendGoal :: Response) -> (bool , builtin_interfaces :: msg :: Time) { (msg . accepted , msg . stamp) } fn destructure_feedback_msg (msg : FeedbackMessage) -> (unique_identifier_msgs :: msg :: UUID , Feedback) { (msg . goal_id , msg . feedback) } fn destructure_result_response_msg (msg : GetResult :: Response) -> (i8 , Result) { (msg . status , msg . result) } fn destructure_result_request_msg (msg : GetResult :: Request) -> unique_identifier_msgs :: msg :: UUID { msg . goal_id } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Goal { pub use_roi : bool , pub filter_limits : Vec < f32 > } impl WrappedTypesupport for Goal { type CStruct = object_recognition_msgs__action__ObjectRecognition_Goal ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__object_recognition_msgs__action__ObjectRecognition_Goal () } } fn create_msg () -> * mut object_recognition_msgs__action__ObjectRecognition_Goal { unsafe { object_recognition_msgs__action__ObjectRecognition_Goal__create () } } fn destroy_msg (msg : * mut object_recognition_msgs__action__ObjectRecognition_Goal) -> () { unsafe { object_recognition_msgs__action__ObjectRecognition_Goal__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Goal { Goal { use_roi : msg . use_roi , filter_limits : msg . filter_limits . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . use_roi = self . use_roi ; msg . filter_limits . update (& self . filter_limits) ; } } impl Default for Goal { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Goal > :: new () ; Goal :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Result { pub recognized_objects : object_recognition_msgs :: msg :: RecognizedObjectArray } impl WrappedTypesupport for Result { type CStruct = object_recognition_msgs__action__ObjectRecognition_Result ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__object_recognition_msgs__action__ObjectRecognition_Result () } } fn create_msg () -> * mut object_recognition_msgs__action__ObjectRecognition_Result { unsafe { object_recognition_msgs__action__ObjectRecognition_Result__create () } } fn destroy_msg (msg : * mut object_recognition_msgs__action__ObjectRecognition_Result) -> () { unsafe { object_recognition_msgs__action__ObjectRecognition_Result__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Result { Result { recognized_objects : object_recognition_msgs :: msg :: RecognizedObjectArray :: from_native (& msg . recognized_objects) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . recognized_objects . copy_to_native (& mut msg . recognized_objects) ; } } impl Default for Result { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Result > :: new () ; Result :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Feedback { } impl WrappedTypesupport for Feedback { type CStruct = object_recognition_msgs__action__ObjectRecognition_Feedback ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__object_recognition_msgs__action__ObjectRecognition_Feedback () } } fn create_msg () -> * mut object_recognition_msgs__action__ObjectRecognition_Feedback { unsafe { object_recognition_msgs__action__ObjectRecognition_Feedback__create () } } fn destroy_msg (msg : * mut object_recognition_msgs__action__ObjectRecognition_Feedback) -> () { unsafe { object_recognition_msgs__action__ObjectRecognition_Feedback__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Feedback { Feedback { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Feedback { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Feedback > :: new () ; Feedback :: from_native (& msg_native) } } # [allow (non_snake_case)] pub mod SendGoal { use super :: super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__object_recognition_msgs__action__ObjectRecognition_SendGoal () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub goal_id : unique_identifier_msgs :: msg :: UUID , pub goal : object_recognition_msgs :: action :: ObjectRecognition :: Goal } impl WrappedTypesupport for Request { type CStruct = object_recognition_msgs__action__ObjectRecognition_SendGoal_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__object_recognition_msgs__action__ObjectRecognition_SendGoal_Request () } } fn create_msg () -> * mut object_recognition_msgs__action__ObjectRecognition_SendGoal_Request { unsafe { object_recognition_msgs__action__ObjectRecognition_SendGoal_Request__create () } } fn destroy_msg (msg : * mut object_recognition_msgs__action__ObjectRecognition_SendGoal_Request) -> () { unsafe { object_recognition_msgs__action__ObjectRecognition_SendGoal_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { goal_id : unique_identifier_msgs :: msg :: UUID :: from_native (& msg . goal_id) , goal : object_recognition_msgs :: action :: ObjectRecognition :: Goal :: from_native (& msg . goal) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . goal_id . copy_to_native (& mut msg . goal_id) ; self . goal . copy_to_native (& mut msg . goal) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub accepted : bool , pub stamp : builtin_interfaces :: msg :: Time } impl WrappedTypesupport for Response { type CStruct = object_recognition_msgs__action__ObjectRecognition_SendGoal_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__object_recognition_msgs__action__ObjectRecognition_SendGoal_Response () } } fn create_msg () -> * mut object_recognition_msgs__action__ObjectRecognition_SendGoal_Response { unsafe { object_recognition_msgs__action__ObjectRecognition_SendGoal_Response__create () } } fn destroy_msg (msg : * mut object_recognition_msgs__action__ObjectRecognition_SendGoal_Response) -> () { unsafe { object_recognition_msgs__action__ObjectRecognition_SendGoal_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { accepted : msg . accepted , stamp : builtin_interfaces :: msg :: Time :: from_native (& msg . stamp) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . accepted = self . accepted ; self . stamp . copy_to_native (& mut msg . stamp) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetResult { use super :: super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__object_recognition_msgs__action__ObjectRecognition_GetResult () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub goal_id : unique_identifier_msgs :: msg :: UUID } impl WrappedTypesupport for Request { type CStruct = object_recognition_msgs__action__ObjectRecognition_GetResult_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__object_recognition_msgs__action__ObjectRecognition_GetResult_Request () } } fn create_msg () -> * mut object_recognition_msgs__action__ObjectRecognition_GetResult_Request { unsafe { object_recognition_msgs__action__ObjectRecognition_GetResult_Request__create () } } fn destroy_msg (msg : * mut object_recognition_msgs__action__ObjectRecognition_GetResult_Request) -> () { unsafe { object_recognition_msgs__action__ObjectRecognition_GetResult_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { goal_id : unique_identifier_msgs :: msg :: UUID :: from_native (& msg . goal_id) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . goal_id . copy_to_native (& mut msg . goal_id) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub status : i8 , pub result : object_recognition_msgs :: action :: ObjectRecognition :: Result } impl WrappedTypesupport for Response { type CStruct = object_recognition_msgs__action__ObjectRecognition_GetResult_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__object_recognition_msgs__action__ObjectRecognition_GetResult_Response () } } fn create_msg () -> * mut object_recognition_msgs__action__ObjectRecognition_GetResult_Response { unsafe { object_recognition_msgs__action__ObjectRecognition_GetResult_Response__create () } } fn destroy_msg (msg : * mut object_recognition_msgs__action__ObjectRecognition_GetResult_Response) -> () { unsafe { object_recognition_msgs__action__ObjectRecognition_GetResult_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { status : msg . status , result : object_recognition_msgs :: action :: ObjectRecognition :: Result :: from_native (& msg . result) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . status = self . status ; self . result . copy_to_native (& mut msg . result) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct FeedbackMessage { pub goal_id : unique_identifier_msgs :: msg :: UUID , pub feedback : object_recognition_msgs :: action :: ObjectRecognition :: Feedback } impl WrappedTypesupport for FeedbackMessage { type CStruct = object_recognition_msgs__action__ObjectRecognition_FeedbackMessage ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__object_recognition_msgs__action__ObjectRecognition_FeedbackMessage () } } fn create_msg () -> * mut object_recognition_msgs__action__ObjectRecognition_FeedbackMessage { unsafe { object_recognition_msgs__action__ObjectRecognition_FeedbackMessage__create () } } fn destroy_msg (msg : * mut object_recognition_msgs__action__ObjectRecognition_FeedbackMessage) -> () { unsafe { object_recognition_msgs__action__ObjectRecognition_FeedbackMessage__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> FeedbackMessage { FeedbackMessage { goal_id : unique_identifier_msgs :: msg :: UUID :: from_native (& msg . goal_id) , feedback : object_recognition_msgs :: action :: ObjectRecognition :: Feedback :: from_native (& msg . feedback) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . goal_id . copy_to_native (& mut msg . goal_id) ; self . feedback . copy_to_native (& mut msg . feedback) ; } } impl Default for FeedbackMessage { fn default () -> Self { let msg_native = WrappedNativeMsg :: < FeedbackMessage > :: new () ; FeedbackMessage :: from_native (& msg_native) } } } } pub mod srv { # [allow (non_snake_case)] pub mod GetObjectInformation { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__object_recognition_msgs__srv__GetObjectInformation () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { # [serde (rename = "type")] pub type_ : object_recognition_msgs :: msg :: ObjectType } impl WrappedTypesupport for Request { type CStruct = object_recognition_msgs__srv__GetObjectInformation_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__object_recognition_msgs__srv__GetObjectInformation_Request () } } fn create_msg () -> * mut object_recognition_msgs__srv__GetObjectInformation_Request { unsafe { object_recognition_msgs__srv__GetObjectInformation_Request__create () } } fn destroy_msg (msg : * mut object_recognition_msgs__srv__GetObjectInformation_Request) -> () { unsafe { object_recognition_msgs__srv__GetObjectInformation_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { type_ : object_recognition_msgs :: msg :: ObjectType :: from_native (& msg . type_) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . type_ . copy_to_native (& mut msg . type_) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub information : object_recognition_msgs :: msg :: ObjectInformation } impl WrappedTypesupport for Response { type CStruct = object_recognition_msgs__srv__GetObjectInformation_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__object_recognition_msgs__srv__GetObjectInformation_Response () } } fn create_msg () -> * mut object_recognition_msgs__srv__GetObjectInformation_Response { unsafe { object_recognition_msgs__srv__GetObjectInformation_Response__create () } } fn destroy_msg (msg : * mut object_recognition_msgs__srv__GetObjectInformation_Response) -> () { unsafe { object_recognition_msgs__srv__GetObjectInformation_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { information : object_recognition_msgs :: msg :: ObjectInformation :: from_native (& msg . information) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . information . copy_to_native (& mut msg . information) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } } pub mod msg { use super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ObjectInformation { pub name : std :: string :: String , pub ground_truth_mesh : shape_msgs :: msg :: Mesh , pub ground_truth_point_cloud : sensor_msgs :: msg :: PointCloud2 } impl WrappedTypesupport for ObjectInformation { type CStruct = object_recognition_msgs__msg__ObjectInformation ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__object_recognition_msgs__msg__ObjectInformation () } } fn create_msg () -> * mut object_recognition_msgs__msg__ObjectInformation { unsafe { object_recognition_msgs__msg__ObjectInformation__create () } } fn destroy_msg (msg : * mut object_recognition_msgs__msg__ObjectInformation) -> () { unsafe { object_recognition_msgs__msg__ObjectInformation__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ObjectInformation { ObjectInformation { name : msg . name . to_str () . to_owned () , ground_truth_mesh : shape_msgs :: msg :: Mesh :: from_native (& msg . ground_truth_mesh) , ground_truth_point_cloud : sensor_msgs :: msg :: PointCloud2 :: from_native (& msg . ground_truth_point_cloud) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . name . assign (& self . name) ; self . ground_truth_mesh . copy_to_native (& mut msg . ground_truth_mesh) ; self . ground_truth_point_cloud . copy_to_native (& mut msg . ground_truth_point_cloud) ; } } impl Default for ObjectInformation { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ObjectInformation > :: new () ; ObjectInformation :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ObjectType { pub key : std :: string :: String , pub db : std :: string :: String } impl WrappedTypesupport for ObjectType { type CStruct = object_recognition_msgs__msg__ObjectType ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__object_recognition_msgs__msg__ObjectType () } } fn create_msg () -> * mut object_recognition_msgs__msg__ObjectType { unsafe { object_recognition_msgs__msg__ObjectType__create () } } fn destroy_msg (msg : * mut object_recognition_msgs__msg__ObjectType) -> () { unsafe { object_recognition_msgs__msg__ObjectType__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ObjectType { ObjectType { key : msg . key . to_str () . to_owned () , db : msg . db . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . key . assign (& self . key) ; msg . db . assign (& self . db) ; } } impl Default for ObjectType { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ObjectType > :: new () ; ObjectType :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct RecognizedObject { pub header : std_msgs :: msg :: Header , # [serde (rename = "type")] pub type_ : object_recognition_msgs :: msg :: ObjectType , pub confidence : f32 , pub point_clouds : Vec < sensor_msgs :: msg :: PointCloud2 > , pub bounding_mesh : shape_msgs :: msg :: Mesh , pub bounding_contours : Vec < geometry_msgs :: msg :: Point > , pub pose : geometry_msgs :: msg :: PoseWithCovarianceStamped } impl WrappedTypesupport for RecognizedObject { type CStruct = object_recognition_msgs__msg__RecognizedObject ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__object_recognition_msgs__msg__RecognizedObject () } } fn create_msg () -> * mut object_recognition_msgs__msg__RecognizedObject { unsafe { object_recognition_msgs__msg__RecognizedObject__create () } } fn destroy_msg (msg : * mut object_recognition_msgs__msg__RecognizedObject) -> () { unsafe { object_recognition_msgs__msg__RecognizedObject__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> RecognizedObject { RecognizedObject { header : std_msgs :: msg :: Header :: from_native (& msg . header) , type_ : object_recognition_msgs :: msg :: ObjectType :: from_native (& msg . type_) , confidence : msg . confidence , point_clouds : { let mut temp = Vec :: with_capacity (msg . point_clouds . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . point_clouds . data , msg . point_clouds . size) } ; for s in slice { temp . push (sensor_msgs :: msg :: PointCloud2 :: from_native (s)) ; } temp } , bounding_mesh : shape_msgs :: msg :: Mesh :: from_native (& msg . bounding_mesh) , bounding_contours : { let mut temp = Vec :: with_capacity (msg . bounding_contours . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . bounding_contours . data , msg . bounding_contours . size) } ; for s in slice { temp . push (geometry_msgs :: msg :: Point :: from_native (s)) ; } temp } , pose : geometry_msgs :: msg :: PoseWithCovarianceStamped :: from_native (& msg . pose) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; self . type_ . copy_to_native (& mut msg . type_) ; msg . confidence = self . confidence ; unsafe { sensor_msgs__msg__PointCloud2__Sequence__fini (& mut msg . point_clouds) ; sensor_msgs__msg__PointCloud2__Sequence__init (& mut msg . point_clouds , self . point_clouds . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . point_clouds . data , msg . point_clouds . size) ; for (t , s) in slice . iter_mut () . zip (& self . point_clouds) { s . copy_to_native (t) ; } } self . bounding_mesh . copy_to_native (& mut msg . bounding_mesh) ; unsafe { geometry_msgs__msg__Point__Sequence__fini (& mut msg . bounding_contours) ; geometry_msgs__msg__Point__Sequence__init (& mut msg . bounding_contours , self . bounding_contours . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . bounding_contours . data , msg . bounding_contours . size) ; for (t , s) in slice . iter_mut () . zip (& self . bounding_contours) { s . copy_to_native (t) ; } } self . pose . copy_to_native (& mut msg . pose) ; } } impl Default for RecognizedObject { fn default () -> Self { let msg_native = WrappedNativeMsg :: < RecognizedObject > :: new () ; RecognizedObject :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct RecognizedObjectArray { pub header : std_msgs :: msg :: Header , pub objects : Vec < object_recognition_msgs :: msg :: RecognizedObject > , pub cooccurrence : Vec < f32 > } impl WrappedTypesupport for RecognizedObjectArray { type CStruct = object_recognition_msgs__msg__RecognizedObjectArray ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__object_recognition_msgs__msg__RecognizedObjectArray () } } fn create_msg () -> * mut object_recognition_msgs__msg__RecognizedObjectArray { unsafe { object_recognition_msgs__msg__RecognizedObjectArray__create () } } fn destroy_msg (msg : * mut object_recognition_msgs__msg__RecognizedObjectArray) -> () { unsafe { object_recognition_msgs__msg__RecognizedObjectArray__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> RecognizedObjectArray { RecognizedObjectArray { header : std_msgs :: msg :: Header :: from_native (& msg . header) , objects : { let mut temp = Vec :: with_capacity (msg . objects . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . objects . data , msg . objects . size) } ; for s in slice { temp . push (object_recognition_msgs :: msg :: RecognizedObject :: from_native (s)) ; } temp } , cooccurrence : msg . cooccurrence . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; unsafe { object_recognition_msgs__msg__RecognizedObject__Sequence__fini (& mut msg . objects) ; object_recognition_msgs__msg__RecognizedObject__Sequence__init (& mut msg . objects , self . objects . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . objects . data , msg . objects . size) ; for (t , s) in slice . iter_mut () . zip (& self . objects) { s . copy_to_native (t) ; } } msg . cooccurrence . update (& self . cooccurrence) ; } } impl Default for RecognizedObjectArray { fn default () -> Self { let msg_native = WrappedNativeMsg :: < RecognizedObjectArray > :: new () ; RecognizedObjectArray :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Table { pub header : std_msgs :: msg :: Header , pub pose : geometry_msgs :: msg :: Pose , pub convex_hull : Vec < geometry_msgs :: msg :: Point > } impl WrappedTypesupport for Table { type CStruct = object_recognition_msgs__msg__Table ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__object_recognition_msgs__msg__Table () } } fn create_msg () -> * mut object_recognition_msgs__msg__Table { unsafe { object_recognition_msgs__msg__Table__create () } } fn destroy_msg (msg : * mut object_recognition_msgs__msg__Table) -> () { unsafe { object_recognition_msgs__msg__Table__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Table { Table { header : std_msgs :: msg :: Header :: from_native (& msg . header) , pose : geometry_msgs :: msg :: Pose :: from_native (& msg . pose) , convex_hull : { let mut temp = Vec :: with_capacity (msg . convex_hull . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . convex_hull . data , msg . convex_hull . size) } ; for s in slice { temp . push (geometry_msgs :: msg :: Point :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; self . pose . copy_to_native (& mut msg . pose) ; unsafe { geometry_msgs__msg__Point__Sequence__fini (& mut msg . convex_hull) ; geometry_msgs__msg__Point__Sequence__init (& mut msg . convex_hull , self . convex_hull . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . convex_hull . data , msg . convex_hull . size) ; for (t , s) in slice . iter_mut () . zip (& self . convex_hull) { s . copy_to_native (t) ; } } } } impl Default for Table { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Table > :: new () ; Table :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct TableArray { pub header : std_msgs :: msg :: Header , pub tables : Vec < object_recognition_msgs :: msg :: Table > } impl WrappedTypesupport for TableArray { type CStruct = object_recognition_msgs__msg__TableArray ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__object_recognition_msgs__msg__TableArray () } } fn create_msg () -> * mut object_recognition_msgs__msg__TableArray { unsafe { object_recognition_msgs__msg__TableArray__create () } } fn destroy_msg (msg : * mut object_recognition_msgs__msg__TableArray) -> () { unsafe { object_recognition_msgs__msg__TableArray__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> TableArray { TableArray { header : std_msgs :: msg :: Header :: from_native (& msg . header) , tables : { let mut temp = Vec :: with_capacity (msg . tables . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . tables . data , msg . tables . size) } ; for s in slice { temp . push (object_recognition_msgs :: msg :: Table :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; unsafe { object_recognition_msgs__msg__Table__Sequence__fini (& mut msg . tables) ; object_recognition_msgs__msg__Table__Sequence__init (& mut msg . tables , self . tables . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . tables . data , msg . tables . size) ; for (t , s) in slice . iter_mut () . zip (& self . tables) { s . copy_to_native (t) ; } } } } impl Default for TableArray { fn default () -> Self { let msg_native = WrappedNativeMsg :: < TableArray > :: new () ; TableArray :: from_native (& msg_native) } } }