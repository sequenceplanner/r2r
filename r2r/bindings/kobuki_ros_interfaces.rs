pub mod msg { use super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct BumperEvent { pub bumper : u8 , pub state : u8 } impl WrappedTypesupport for BumperEvent { type CStruct = kobuki_ros_interfaces__msg__BumperEvent ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__kobuki_ros_interfaces__msg__BumperEvent () } } fn create_msg () -> * mut kobuki_ros_interfaces__msg__BumperEvent { unsafe { kobuki_ros_interfaces__msg__BumperEvent__create () } } fn destroy_msg (msg : * mut kobuki_ros_interfaces__msg__BumperEvent) -> () { unsafe { kobuki_ros_interfaces__msg__BumperEvent__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> BumperEvent { BumperEvent { bumper : msg . bumper , state : msg . state , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . bumper = self . bumper ; msg . state = self . state ; } } impl Default for BumperEvent { fn default () -> Self { let msg_native = WrappedNativeMsg :: < BumperEvent > :: new () ; BumperEvent :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl BumperEvent { pub const CENTER : _bindgen_ty_270 = kobuki_ros_interfaces__msg__BumperEvent__CENTER ; pub const LEFT : _bindgen_ty_269 = kobuki_ros_interfaces__msg__BumperEvent__LEFT ; pub const PRESSED : _bindgen_ty_273 = kobuki_ros_interfaces__msg__BumperEvent__PRESSED ; pub const RELEASED : _bindgen_ty_272 = kobuki_ros_interfaces__msg__BumperEvent__RELEASED ; pub const RIGHT : _bindgen_ty_271 = kobuki_ros_interfaces__msg__BumperEvent__RIGHT ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ButtonEvent { pub button : u8 , pub state : u8 } impl WrappedTypesupport for ButtonEvent { type CStruct = kobuki_ros_interfaces__msg__ButtonEvent ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__kobuki_ros_interfaces__msg__ButtonEvent () } } fn create_msg () -> * mut kobuki_ros_interfaces__msg__ButtonEvent { unsafe { kobuki_ros_interfaces__msg__ButtonEvent__create () } } fn destroy_msg (msg : * mut kobuki_ros_interfaces__msg__ButtonEvent) -> () { unsafe { kobuki_ros_interfaces__msg__ButtonEvent__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ButtonEvent { ButtonEvent { button : msg . button , state : msg . state , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . button = self . button ; msg . state = self . state ; } } impl Default for ButtonEvent { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ButtonEvent > :: new () ; ButtonEvent :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl ButtonEvent { pub const BUTTON0 : _bindgen_ty_274 = kobuki_ros_interfaces__msg__ButtonEvent__BUTTON0 ; pub const BUTTON1 : _bindgen_ty_275 = kobuki_ros_interfaces__msg__ButtonEvent__BUTTON1 ; pub const BUTTON2 : _bindgen_ty_276 = kobuki_ros_interfaces__msg__ButtonEvent__BUTTON2 ; pub const PRESSED : _bindgen_ty_278 = kobuki_ros_interfaces__msg__ButtonEvent__PRESSED ; pub const RELEASED : _bindgen_ty_277 = kobuki_ros_interfaces__msg__ButtonEvent__RELEASED ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct CliffEvent { pub sensor : u8 , pub state : u8 , pub bottom : u16 } impl WrappedTypesupport for CliffEvent { type CStruct = kobuki_ros_interfaces__msg__CliffEvent ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__kobuki_ros_interfaces__msg__CliffEvent () } } fn create_msg () -> * mut kobuki_ros_interfaces__msg__CliffEvent { unsafe { kobuki_ros_interfaces__msg__CliffEvent__create () } } fn destroy_msg (msg : * mut kobuki_ros_interfaces__msg__CliffEvent) -> () { unsafe { kobuki_ros_interfaces__msg__CliffEvent__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> CliffEvent { CliffEvent { sensor : msg . sensor , state : msg . state , bottom : msg . bottom , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . sensor = self . sensor ; msg . state = self . state ; msg . bottom = self . bottom ; } } impl Default for CliffEvent { fn default () -> Self { let msg_native = WrappedNativeMsg :: < CliffEvent > :: new () ; CliffEvent :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl CliffEvent { pub const CENTER : _bindgen_ty_280 = kobuki_ros_interfaces__msg__CliffEvent__CENTER ; pub const CLIFF : _bindgen_ty_283 = kobuki_ros_interfaces__msg__CliffEvent__CLIFF ; pub const FLOOR : _bindgen_ty_282 = kobuki_ros_interfaces__msg__CliffEvent__FLOOR ; pub const LEFT : _bindgen_ty_279 = kobuki_ros_interfaces__msg__CliffEvent__LEFT ; pub const RIGHT : _bindgen_ty_281 = kobuki_ros_interfaces__msg__CliffEvent__RIGHT ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ControllerInfo { # [serde (rename = "type")] pub type_ : u8 , pub p_gain : f64 , pub i_gain : f64 , pub d_gain : f64 } impl WrappedTypesupport for ControllerInfo { type CStruct = kobuki_ros_interfaces__msg__ControllerInfo ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__kobuki_ros_interfaces__msg__ControllerInfo () } } fn create_msg () -> * mut kobuki_ros_interfaces__msg__ControllerInfo { unsafe { kobuki_ros_interfaces__msg__ControllerInfo__create () } } fn destroy_msg (msg : * mut kobuki_ros_interfaces__msg__ControllerInfo) -> () { unsafe { kobuki_ros_interfaces__msg__ControllerInfo__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ControllerInfo { ControllerInfo { type_ : msg . type_ , p_gain : msg . p_gain , i_gain : msg . i_gain , d_gain : msg . d_gain , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . type_ = self . type_ ; msg . p_gain = self . p_gain ; msg . i_gain = self . i_gain ; msg . d_gain = self . d_gain ; } } impl Default for ControllerInfo { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ControllerInfo > :: new () ; ControllerInfo :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl ControllerInfo { pub const DEFAULT : _bindgen_ty_284 = kobuki_ros_interfaces__msg__ControllerInfo__DEFAULT ; pub const USER_CONFIGURED : _bindgen_ty_285 = kobuki_ros_interfaces__msg__ControllerInfo__USER_CONFIGURED ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct DigitalInputEvent { pub values : Vec < bool > } impl WrappedTypesupport for DigitalInputEvent { type CStruct = kobuki_ros_interfaces__msg__DigitalInputEvent ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__kobuki_ros_interfaces__msg__DigitalInputEvent () } } fn create_msg () -> * mut kobuki_ros_interfaces__msg__DigitalInputEvent { unsafe { kobuki_ros_interfaces__msg__DigitalInputEvent__create () } } fn destroy_msg (msg : * mut kobuki_ros_interfaces__msg__DigitalInputEvent) -> () { unsafe { kobuki_ros_interfaces__msg__DigitalInputEvent__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> DigitalInputEvent { DigitalInputEvent { values : msg . values . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { assert_eq ! (self . values . len () , 4usize , "Field {} is fixed size of {}!" , "values" , 4usize) ; msg . values . copy_from_slice (& self . values [.. 4usize]) ; } } impl Default for DigitalInputEvent { fn default () -> Self { let msg_native = WrappedNativeMsg :: < DigitalInputEvent > :: new () ; DigitalInputEvent :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct DigitalOutput { pub values : Vec < bool > , pub mask : Vec < bool > } impl WrappedTypesupport for DigitalOutput { type CStruct = kobuki_ros_interfaces__msg__DigitalOutput ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__kobuki_ros_interfaces__msg__DigitalOutput () } } fn create_msg () -> * mut kobuki_ros_interfaces__msg__DigitalOutput { unsafe { kobuki_ros_interfaces__msg__DigitalOutput__create () } } fn destroy_msg (msg : * mut kobuki_ros_interfaces__msg__DigitalOutput) -> () { unsafe { kobuki_ros_interfaces__msg__DigitalOutput__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> DigitalOutput { DigitalOutput { values : msg . values . to_vec () , mask : msg . mask . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { assert_eq ! (self . values . len () , 4usize , "Field {} is fixed size of {}!" , "values" , 4usize) ; msg . values . copy_from_slice (& self . values [.. 4usize]) ; assert_eq ! (self . mask . len () , 4usize , "Field {} is fixed size of {}!" , "mask" , 4usize) ; msg . mask . copy_from_slice (& self . mask [.. 4usize]) ; } } impl Default for DigitalOutput { fn default () -> Self { let msg_native = WrappedNativeMsg :: < DigitalOutput > :: new () ; DigitalOutput :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct DockInfraRed { pub header : std_msgs :: msg :: Header , pub data : Vec < u8 > } impl WrappedTypesupport for DockInfraRed { type CStruct = kobuki_ros_interfaces__msg__DockInfraRed ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__kobuki_ros_interfaces__msg__DockInfraRed () } } fn create_msg () -> * mut kobuki_ros_interfaces__msg__DockInfraRed { unsafe { kobuki_ros_interfaces__msg__DockInfraRed__create () } } fn destroy_msg (msg : * mut kobuki_ros_interfaces__msg__DockInfraRed) -> () { unsafe { kobuki_ros_interfaces__msg__DockInfraRed__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> DockInfraRed { DockInfraRed { header : std_msgs :: msg :: Header :: from_native (& msg . header) , data : msg . data . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . data . update (& self . data) ; } } impl Default for DockInfraRed { fn default () -> Self { let msg_native = WrappedNativeMsg :: < DockInfraRed > :: new () ; DockInfraRed :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl DockInfraRed { pub const FAR_CENTER : _bindgen_ty_290 = kobuki_ros_interfaces__msg__DockInfraRed__FAR_CENTER ; pub const FAR_LEFT : _bindgen_ty_289 = kobuki_ros_interfaces__msg__DockInfraRed__FAR_LEFT ; pub const FAR_RIGHT : _bindgen_ty_291 = kobuki_ros_interfaces__msg__DockInfraRed__FAR_RIGHT ; pub const NEAR_CENTER : _bindgen_ty_287 = kobuki_ros_interfaces__msg__DockInfraRed__NEAR_CENTER ; pub const NEAR_LEFT : _bindgen_ty_286 = kobuki_ros_interfaces__msg__DockInfraRed__NEAR_LEFT ; pub const NEAR_RIGHT : _bindgen_ty_288 = kobuki_ros_interfaces__msg__DockInfraRed__NEAR_RIGHT ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ExternalPower { pub source : u8 , pub state : u8 } impl WrappedTypesupport for ExternalPower { type CStruct = kobuki_ros_interfaces__msg__ExternalPower ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__kobuki_ros_interfaces__msg__ExternalPower () } } fn create_msg () -> * mut kobuki_ros_interfaces__msg__ExternalPower { unsafe { kobuki_ros_interfaces__msg__ExternalPower__create () } } fn destroy_msg (msg : * mut kobuki_ros_interfaces__msg__ExternalPower) -> () { unsafe { kobuki_ros_interfaces__msg__ExternalPower__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ExternalPower { ExternalPower { source : msg . source , state : msg . state , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . source = self . source ; msg . state = self . state ; } } impl Default for ExternalPower { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ExternalPower > :: new () ; ExternalPower :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl ExternalPower { pub const OFF : _bindgen_ty_296 = kobuki_ros_interfaces__msg__ExternalPower__OFF ; pub const ON : _bindgen_ty_297 = kobuki_ros_interfaces__msg__ExternalPower__ON ; pub const PWR_12V1_5A : _bindgen_ty_295 = kobuki_ros_interfaces__msg__ExternalPower__PWR_12V1_5A ; pub const PWR_12V5A : _bindgen_ty_294 = kobuki_ros_interfaces__msg__ExternalPower__PWR_12V5A ; pub const PWR_3_3V1A : _bindgen_ty_292 = kobuki_ros_interfaces__msg__ExternalPower__PWR_3_3V1A ; pub const PWR_5V1A : _bindgen_ty_293 = kobuki_ros_interfaces__msg__ExternalPower__PWR_5V1A ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct KeyboardInput { pub pressed_key : u8 } impl WrappedTypesupport for KeyboardInput { type CStruct = kobuki_ros_interfaces__msg__KeyboardInput ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__kobuki_ros_interfaces__msg__KeyboardInput () } } fn create_msg () -> * mut kobuki_ros_interfaces__msg__KeyboardInput { unsafe { kobuki_ros_interfaces__msg__KeyboardInput__create () } } fn destroy_msg (msg : * mut kobuki_ros_interfaces__msg__KeyboardInput) -> () { unsafe { kobuki_ros_interfaces__msg__KeyboardInput__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> KeyboardInput { KeyboardInput { pressed_key : msg . pressed_key , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . pressed_key = self . pressed_key ; } } impl Default for KeyboardInput { fn default () -> Self { let msg_native = WrappedNativeMsg :: < KeyboardInput > :: new () ; KeyboardInput :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl KeyboardInput { pub const KEYCODE_DISABLE : _bindgen_ty_304 = kobuki_ros_interfaces__msg__KeyboardInput__KEYCODE_DISABLE ; pub const KEYCODE_DOWN : _bindgen_ty_301 = kobuki_ros_interfaces__msg__KeyboardInput__KEYCODE_DOWN ; pub const KEYCODE_ENABLE : _bindgen_ty_303 = kobuki_ros_interfaces__msg__KeyboardInput__KEYCODE_ENABLE ; pub const KEYCODE_LEFT : _bindgen_ty_299 = kobuki_ros_interfaces__msg__KeyboardInput__KEYCODE_LEFT ; pub const KEYCODE_RIGHT : _bindgen_ty_298 = kobuki_ros_interfaces__msg__KeyboardInput__KEYCODE_RIGHT ; pub const KEYCODE_SPACE : _bindgen_ty_302 = kobuki_ros_interfaces__msg__KeyboardInput__KEYCODE_SPACE ; pub const KEYCODE_UP : _bindgen_ty_300 = kobuki_ros_interfaces__msg__KeyboardInput__KEYCODE_UP ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Led { pub value : u8 } impl WrappedTypesupport for Led { type CStruct = kobuki_ros_interfaces__msg__Led ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__kobuki_ros_interfaces__msg__Led () } } fn create_msg () -> * mut kobuki_ros_interfaces__msg__Led { unsafe { kobuki_ros_interfaces__msg__Led__create () } } fn destroy_msg (msg : * mut kobuki_ros_interfaces__msg__Led) -> () { unsafe { kobuki_ros_interfaces__msg__Led__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Led { Led { value : msg . value , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . value = self . value ; } } impl Default for Led { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Led > :: new () ; Led :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl Led { pub const BLACK : _bindgen_ty_305 = kobuki_ros_interfaces__msg__Led__BLACK ; pub const GREEN : _bindgen_ty_306 = kobuki_ros_interfaces__msg__Led__GREEN ; pub const ORANGE : _bindgen_ty_307 = kobuki_ros_interfaces__msg__Led__ORANGE ; pub const RED : _bindgen_ty_308 = kobuki_ros_interfaces__msg__Led__RED ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct MotorPower { pub state : u8 } impl WrappedTypesupport for MotorPower { type CStruct = kobuki_ros_interfaces__msg__MotorPower ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__kobuki_ros_interfaces__msg__MotorPower () } } fn create_msg () -> * mut kobuki_ros_interfaces__msg__MotorPower { unsafe { kobuki_ros_interfaces__msg__MotorPower__create () } } fn destroy_msg (msg : * mut kobuki_ros_interfaces__msg__MotorPower) -> () { unsafe { kobuki_ros_interfaces__msg__MotorPower__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> MotorPower { MotorPower { state : msg . state , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . state = self . state ; } } impl Default for MotorPower { fn default () -> Self { let msg_native = WrappedNativeMsg :: < MotorPower > :: new () ; MotorPower :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl MotorPower { pub const OFF : _bindgen_ty_309 = kobuki_ros_interfaces__msg__MotorPower__OFF ; pub const ON : _bindgen_ty_310 = kobuki_ros_interfaces__msg__MotorPower__ON ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct PowerSystemEvent { pub event : u8 } impl WrappedTypesupport for PowerSystemEvent { type CStruct = kobuki_ros_interfaces__msg__PowerSystemEvent ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__kobuki_ros_interfaces__msg__PowerSystemEvent () } } fn create_msg () -> * mut kobuki_ros_interfaces__msg__PowerSystemEvent { unsafe { kobuki_ros_interfaces__msg__PowerSystemEvent__create () } } fn destroy_msg (msg : * mut kobuki_ros_interfaces__msg__PowerSystemEvent) -> () { unsafe { kobuki_ros_interfaces__msg__PowerSystemEvent__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> PowerSystemEvent { PowerSystemEvent { event : msg . event , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . event = self . event ; } } impl Default for PowerSystemEvent { fn default () -> Self { let msg_native = WrappedNativeMsg :: < PowerSystemEvent > :: new () ; PowerSystemEvent :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl PowerSystemEvent { pub const BATTERY_CRITICAL : _bindgen_ty_316 = kobuki_ros_interfaces__msg__PowerSystemEvent__BATTERY_CRITICAL ; pub const BATTERY_LOW : _bindgen_ty_315 = kobuki_ros_interfaces__msg__PowerSystemEvent__BATTERY_LOW ; pub const CHARGE_COMPLETED : _bindgen_ty_314 = kobuki_ros_interfaces__msg__PowerSystemEvent__CHARGE_COMPLETED ; pub const PLUGGED_TO_ADAPTER : _bindgen_ty_312 = kobuki_ros_interfaces__msg__PowerSystemEvent__PLUGGED_TO_ADAPTER ; pub const PLUGGED_TO_DOCKBASE : _bindgen_ty_313 = kobuki_ros_interfaces__msg__PowerSystemEvent__PLUGGED_TO_DOCKBASE ; pub const UNPLUGGED : _bindgen_ty_311 = kobuki_ros_interfaces__msg__PowerSystemEvent__UNPLUGGED ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct RobotStateEvent { pub state : u8 } impl WrappedTypesupport for RobotStateEvent { type CStruct = kobuki_ros_interfaces__msg__RobotStateEvent ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__kobuki_ros_interfaces__msg__RobotStateEvent () } } fn create_msg () -> * mut kobuki_ros_interfaces__msg__RobotStateEvent { unsafe { kobuki_ros_interfaces__msg__RobotStateEvent__create () } } fn destroy_msg (msg : * mut kobuki_ros_interfaces__msg__RobotStateEvent) -> () { unsafe { kobuki_ros_interfaces__msg__RobotStateEvent__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> RobotStateEvent { RobotStateEvent { state : msg . state , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . state = self . state ; } } impl Default for RobotStateEvent { fn default () -> Self { let msg_native = WrappedNativeMsg :: < RobotStateEvent > :: new () ; RobotStateEvent :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl RobotStateEvent { pub const OFFLINE : _bindgen_ty_318 = kobuki_ros_interfaces__msg__RobotStateEvent__OFFLINE ; pub const ONLINE : _bindgen_ty_317 = kobuki_ros_interfaces__msg__RobotStateEvent__ONLINE ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ScanAngle { pub header : std_msgs :: msg :: Header , pub scan_angle : f64 } impl WrappedTypesupport for ScanAngle { type CStruct = kobuki_ros_interfaces__msg__ScanAngle ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__kobuki_ros_interfaces__msg__ScanAngle () } } fn create_msg () -> * mut kobuki_ros_interfaces__msg__ScanAngle { unsafe { kobuki_ros_interfaces__msg__ScanAngle__create () } } fn destroy_msg (msg : * mut kobuki_ros_interfaces__msg__ScanAngle) -> () { unsafe { kobuki_ros_interfaces__msg__ScanAngle__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ScanAngle { ScanAngle { header : std_msgs :: msg :: Header :: from_native (& msg . header) , scan_angle : msg . scan_angle , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . scan_angle = self . scan_angle ; } } impl Default for ScanAngle { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ScanAngle > :: new () ; ScanAngle :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct SensorState { pub header : std_msgs :: msg :: Header , pub time_stamp : u16 , pub bumper : u8 , pub wheel_drop : u8 , pub cliff : u8 , pub left_encoder : u16 , pub right_encoder : u16 , pub left_pwm : i8 , pub right_pwm : i8 , pub buttons : u8 , pub charger : u8 , pub battery : u8 , pub bottom : Vec < u16 > , pub current : Vec < u8 > , pub over_current : u8 , pub digital_input : u16 , pub analog_input : Vec < u16 > } impl WrappedTypesupport for SensorState { type CStruct = kobuki_ros_interfaces__msg__SensorState ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__kobuki_ros_interfaces__msg__SensorState () } } fn create_msg () -> * mut kobuki_ros_interfaces__msg__SensorState { unsafe { kobuki_ros_interfaces__msg__SensorState__create () } } fn destroy_msg (msg : * mut kobuki_ros_interfaces__msg__SensorState) -> () { unsafe { kobuki_ros_interfaces__msg__SensorState__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> SensorState { SensorState { header : std_msgs :: msg :: Header :: from_native (& msg . header) , time_stamp : msg . time_stamp , bumper : msg . bumper , wheel_drop : msg . wheel_drop , cliff : msg . cliff , left_encoder : msg . left_encoder , right_encoder : msg . right_encoder , left_pwm : msg . left_pwm , right_pwm : msg . right_pwm , buttons : msg . buttons , charger : msg . charger , battery : msg . battery , bottom : msg . bottom . to_vec () , current : msg . current . to_vec () , over_current : msg . over_current , digital_input : msg . digital_input , analog_input : msg . analog_input . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . time_stamp = self . time_stamp ; msg . bumper = self . bumper ; msg . wheel_drop = self . wheel_drop ; msg . cliff = self . cliff ; msg . left_encoder = self . left_encoder ; msg . right_encoder = self . right_encoder ; msg . left_pwm = self . left_pwm ; msg . right_pwm = self . right_pwm ; msg . buttons = self . buttons ; msg . charger = self . charger ; msg . battery = self . battery ; msg . bottom . update (& self . bottom) ; msg . current . update (& self . current) ; msg . over_current = self . over_current ; msg . digital_input = self . digital_input ; msg . analog_input . update (& self . analog_input) ; } } impl Default for SensorState { fn default () -> Self { let msg_native = WrappedNativeMsg :: < SensorState > :: new () ; SensorState :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl SensorState { pub const ADAPTER_CHARGED : _bindgen_ty_333 = kobuki_ros_interfaces__msg__SensorState__ADAPTER_CHARGED ; pub const ADAPTER_CHARGING : _bindgen_ty_334 = kobuki_ros_interfaces__msg__SensorState__ADAPTER_CHARGING ; pub const BUMPER_CENTRE : _bindgen_ty_320 = kobuki_ros_interfaces__msg__SensorState__BUMPER_CENTRE ; pub const BUMPER_LEFT : _bindgen_ty_321 = kobuki_ros_interfaces__msg__SensorState__BUMPER_LEFT ; pub const BUMPER_RIGHT : _bindgen_ty_319 = kobuki_ros_interfaces__msg__SensorState__BUMPER_RIGHT ; pub const BUTTON0 : _bindgen_ty_327 = kobuki_ros_interfaces__msg__SensorState__BUTTON0 ; pub const BUTTON1 : _bindgen_ty_328 = kobuki_ros_interfaces__msg__SensorState__BUTTON1 ; pub const BUTTON2 : _bindgen_ty_329 = kobuki_ros_interfaces__msg__SensorState__BUTTON2 ; pub const CLIFF_CENTRE : _bindgen_ty_325 = kobuki_ros_interfaces__msg__SensorState__CLIFF_CENTRE ; pub const CLIFF_LEFT : _bindgen_ty_326 = kobuki_ros_interfaces__msg__SensorState__CLIFF_LEFT ; pub const CLIFF_RIGHT : _bindgen_ty_324 = kobuki_ros_interfaces__msg__SensorState__CLIFF_RIGHT ; pub const DB25_TEST_BOARD_CONNECTED : _bindgen_ty_342 = kobuki_ros_interfaces__msg__SensorState__DB25_TEST_BOARD_CONNECTED ; pub const DIGITAL_INPUT0 : _bindgen_ty_338 = kobuki_ros_interfaces__msg__SensorState__DIGITAL_INPUT0 ; pub const DIGITAL_INPUT1 : _bindgen_ty_339 = kobuki_ros_interfaces__msg__SensorState__DIGITAL_INPUT1 ; pub const DIGITAL_INPUT2 : _bindgen_ty_340 = kobuki_ros_interfaces__msg__SensorState__DIGITAL_INPUT2 ; pub const DIGITAL_INPUT3 : _bindgen_ty_341 = kobuki_ros_interfaces__msg__SensorState__DIGITAL_INPUT3 ; pub const DISCHARGING : _bindgen_ty_330 = kobuki_ros_interfaces__msg__SensorState__DISCHARGING ; pub const DOCKING_CHARGED : _bindgen_ty_331 = kobuki_ros_interfaces__msg__SensorState__DOCKING_CHARGED ; pub const DOCKING_CHARGING : _bindgen_ty_332 = kobuki_ros_interfaces__msg__SensorState__DOCKING_CHARGING ; pub const OVER_CURRENT_BOTH_WHEELS : _bindgen_ty_337 = kobuki_ros_interfaces__msg__SensorState__OVER_CURRENT_BOTH_WHEELS ; pub const OVER_CURRENT_LEFT_WHEEL : _bindgen_ty_335 = kobuki_ros_interfaces__msg__SensorState__OVER_CURRENT_LEFT_WHEEL ; pub const OVER_CURRENT_RIGHT_WHEEL : _bindgen_ty_336 = kobuki_ros_interfaces__msg__SensorState__OVER_CURRENT_RIGHT_WHEEL ; pub const WHEEL_DROP_LEFT : _bindgen_ty_323 = kobuki_ros_interfaces__msg__SensorState__WHEEL_DROP_LEFT ; pub const WHEEL_DROP_RIGHT : _bindgen_ty_322 = kobuki_ros_interfaces__msg__SensorState__WHEEL_DROP_RIGHT ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Sound { pub value : u8 } impl WrappedTypesupport for Sound { type CStruct = kobuki_ros_interfaces__msg__Sound ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__kobuki_ros_interfaces__msg__Sound () } } fn create_msg () -> * mut kobuki_ros_interfaces__msg__Sound { unsafe { kobuki_ros_interfaces__msg__Sound__create () } } fn destroy_msg (msg : * mut kobuki_ros_interfaces__msg__Sound) -> () { unsafe { kobuki_ros_interfaces__msg__Sound__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Sound { Sound { value : msg . value , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . value = self . value ; } } impl Default for Sound { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Sound > :: new () ; Sound :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl Sound { pub const BUTTON : _bindgen_ty_346 = kobuki_ros_interfaces__msg__Sound__BUTTON ; pub const CLEANINGEND : _bindgen_ty_349 = kobuki_ros_interfaces__msg__Sound__CLEANINGEND ; pub const CLEANINGSTART : _bindgen_ty_348 = kobuki_ros_interfaces__msg__Sound__CLEANINGSTART ; pub const ERROR : _bindgen_ty_347 = kobuki_ros_interfaces__msg__Sound__ERROR ; pub const OFF : _bindgen_ty_344 = kobuki_ros_interfaces__msg__Sound__OFF ; pub const ON : _bindgen_ty_343 = kobuki_ros_interfaces__msg__Sound__ON ; pub const RECHARGE : _bindgen_ty_345 = kobuki_ros_interfaces__msg__Sound__RECHARGE ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct VersionInfo { pub hardware : std :: string :: String , pub firmware : std :: string :: String , pub software : std :: string :: String , pub udid : Vec < u32 > , pub features : u64 } impl WrappedTypesupport for VersionInfo { type CStruct = kobuki_ros_interfaces__msg__VersionInfo ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__kobuki_ros_interfaces__msg__VersionInfo () } } fn create_msg () -> * mut kobuki_ros_interfaces__msg__VersionInfo { unsafe { kobuki_ros_interfaces__msg__VersionInfo__create () } } fn destroy_msg (msg : * mut kobuki_ros_interfaces__msg__VersionInfo) -> () { unsafe { kobuki_ros_interfaces__msg__VersionInfo__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> VersionInfo { VersionInfo { hardware : msg . hardware . to_str () . to_owned () , firmware : msg . firmware . to_str () . to_owned () , software : msg . software . to_str () . to_owned () , udid : msg . udid . to_vec () , features : msg . features , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . hardware . assign (& self . hardware) ; msg . firmware . assign (& self . firmware) ; msg . software . assign (& self . software) ; msg . udid . update (& self . udid) ; msg . features = self . features ; } } impl Default for VersionInfo { fn default () -> Self { let msg_native = WrappedNativeMsg :: < VersionInfo > :: new () ; VersionInfo :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl VersionInfo { pub const GYROSCOPE_3D_DATA : _bindgen_ty_351 = kobuki_ros_interfaces__msg__VersionInfo__GYROSCOPE_3D_DATA ; pub const SMOOTH_MOVE_START : _bindgen_ty_350 = kobuki_ros_interfaces__msg__VersionInfo__SMOOTH_MOVE_START ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct WheelDropEvent { pub wheel : u8 , pub state : u8 } impl WrappedTypesupport for WheelDropEvent { type CStruct = kobuki_ros_interfaces__msg__WheelDropEvent ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__kobuki_ros_interfaces__msg__WheelDropEvent () } } fn create_msg () -> * mut kobuki_ros_interfaces__msg__WheelDropEvent { unsafe { kobuki_ros_interfaces__msg__WheelDropEvent__create () } } fn destroy_msg (msg : * mut kobuki_ros_interfaces__msg__WheelDropEvent) -> () { unsafe { kobuki_ros_interfaces__msg__WheelDropEvent__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> WheelDropEvent { WheelDropEvent { wheel : msg . wheel , state : msg . state , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . wheel = self . wheel ; msg . state = self . state ; } } impl Default for WheelDropEvent { fn default () -> Self { let msg_native = WrappedNativeMsg :: < WheelDropEvent > :: new () ; WheelDropEvent :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl WheelDropEvent { pub const DROPPED : _bindgen_ty_355 = kobuki_ros_interfaces__msg__WheelDropEvent__DROPPED ; pub const LEFT : _bindgen_ty_352 = kobuki_ros_interfaces__msg__WheelDropEvent__LEFT ; pub const RAISED : _bindgen_ty_354 = kobuki_ros_interfaces__msg__WheelDropEvent__RAISED ; pub const RIGHT : _bindgen_ty_353 = kobuki_ros_interfaces__msg__WheelDropEvent__RIGHT ; } } pub mod action { # [allow (non_snake_case)] pub mod AutoDocking { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Action () ; impl WrappedActionTypeSupport for Action { type Goal = Goal ; type Result = Result ; type Feedback = Feedback ; type FeedbackMessage = FeedbackMessage ; type SendGoal = SendGoal :: Service ; type GetResult = GetResult :: Service ; fn get_ts () -> & 'static rosidl_action_type_support_t { unsafe { & * rosidl_typesupport_c__get_action_type_support_handle__kobuki_ros_interfaces__action__AutoDocking () } } fn make_goal_request_msg (goal_id : unique_identifier_msgs :: msg :: UUID , goal : Goal) -> SendGoal :: Request { SendGoal :: Request { goal_id , goal } } fn make_goal_response_msg (accepted : bool , stamp : builtin_interfaces :: msg :: Time) -> SendGoal :: Response { SendGoal :: Response { accepted , stamp } } fn make_feedback_msg (goal_id : unique_identifier_msgs :: msg :: UUID , feedback : Feedback) -> FeedbackMessage { FeedbackMessage { goal_id , feedback } } fn make_result_request_msg (goal_id : unique_identifier_msgs :: msg :: UUID) -> GetResult :: Request { GetResult :: Request { goal_id , } } fn make_result_response_msg (status : i8 , result : Result) -> GetResult :: Response { GetResult :: Response { status , result , } } fn destructure_goal_request_msg (msg : SendGoal :: Request) -> (unique_identifier_msgs :: msg :: UUID , Goal) { (msg . goal_id , msg . goal) } fn destructure_goal_response_msg (msg : SendGoal :: Response) -> (bool , builtin_interfaces :: msg :: Time) { (msg . accepted , msg . stamp) } fn destructure_feedback_msg (msg : FeedbackMessage) -> (unique_identifier_msgs :: msg :: UUID , Feedback) { (msg . goal_id , msg . feedback) } fn destructure_result_response_msg (msg : GetResult :: Response) -> (i8 , Result) { (msg . status , msg . result) } fn destructure_result_request_msg (msg : GetResult :: Request) -> unique_identifier_msgs :: msg :: UUID { msg . goal_id } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Goal { } impl WrappedTypesupport for Goal { type CStruct = kobuki_ros_interfaces__action__AutoDocking_Goal ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__kobuki_ros_interfaces__action__AutoDocking_Goal () } } fn create_msg () -> * mut kobuki_ros_interfaces__action__AutoDocking_Goal { unsafe { kobuki_ros_interfaces__action__AutoDocking_Goal__create () } } fn destroy_msg (msg : * mut kobuki_ros_interfaces__action__AutoDocking_Goal) -> () { unsafe { kobuki_ros_interfaces__action__AutoDocking_Goal__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Goal { Goal { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Goal { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Goal > :: new () ; Goal :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Result { pub text : std :: string :: String } impl WrappedTypesupport for Result { type CStruct = kobuki_ros_interfaces__action__AutoDocking_Result ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__kobuki_ros_interfaces__action__AutoDocking_Result () } } fn create_msg () -> * mut kobuki_ros_interfaces__action__AutoDocking_Result { unsafe { kobuki_ros_interfaces__action__AutoDocking_Result__create () } } fn destroy_msg (msg : * mut kobuki_ros_interfaces__action__AutoDocking_Result) -> () { unsafe { kobuki_ros_interfaces__action__AutoDocking_Result__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Result { Result { text : msg . text . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . text . assign (& self . text) ; } } impl Default for Result { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Result > :: new () ; Result :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Feedback { pub state : std :: string :: String , pub text : std :: string :: String } impl WrappedTypesupport for Feedback { type CStruct = kobuki_ros_interfaces__action__AutoDocking_Feedback ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__kobuki_ros_interfaces__action__AutoDocking_Feedback () } } fn create_msg () -> * mut kobuki_ros_interfaces__action__AutoDocking_Feedback { unsafe { kobuki_ros_interfaces__action__AutoDocking_Feedback__create () } } fn destroy_msg (msg : * mut kobuki_ros_interfaces__action__AutoDocking_Feedback) -> () { unsafe { kobuki_ros_interfaces__action__AutoDocking_Feedback__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Feedback { Feedback { state : msg . state . to_str () . to_owned () , text : msg . text . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . state . assign (& self . state) ; msg . text . assign (& self . text) ; } } impl Default for Feedback { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Feedback > :: new () ; Feedback :: from_native (& msg_native) } } # [allow (non_snake_case)] pub mod SendGoal { use super :: super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__kobuki_ros_interfaces__action__AutoDocking_SendGoal () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub goal_id : unique_identifier_msgs :: msg :: UUID , pub goal : kobuki_ros_interfaces :: action :: AutoDocking :: Goal } impl WrappedTypesupport for Request { type CStruct = kobuki_ros_interfaces__action__AutoDocking_SendGoal_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__kobuki_ros_interfaces__action__AutoDocking_SendGoal_Request () } } fn create_msg () -> * mut kobuki_ros_interfaces__action__AutoDocking_SendGoal_Request { unsafe { kobuki_ros_interfaces__action__AutoDocking_SendGoal_Request__create () } } fn destroy_msg (msg : * mut kobuki_ros_interfaces__action__AutoDocking_SendGoal_Request) -> () { unsafe { kobuki_ros_interfaces__action__AutoDocking_SendGoal_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { goal_id : unique_identifier_msgs :: msg :: UUID :: from_native (& msg . goal_id) , goal : kobuki_ros_interfaces :: action :: AutoDocking :: Goal :: from_native (& msg . goal) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . goal_id . copy_to_native (& mut msg . goal_id) ; self . goal . copy_to_native (& mut msg . goal) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub accepted : bool , pub stamp : builtin_interfaces :: msg :: Time } impl WrappedTypesupport for Response { type CStruct = kobuki_ros_interfaces__action__AutoDocking_SendGoal_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__kobuki_ros_interfaces__action__AutoDocking_SendGoal_Response () } } fn create_msg () -> * mut kobuki_ros_interfaces__action__AutoDocking_SendGoal_Response { unsafe { kobuki_ros_interfaces__action__AutoDocking_SendGoal_Response__create () } } fn destroy_msg (msg : * mut kobuki_ros_interfaces__action__AutoDocking_SendGoal_Response) -> () { unsafe { kobuki_ros_interfaces__action__AutoDocking_SendGoal_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { accepted : msg . accepted , stamp : builtin_interfaces :: msg :: Time :: from_native (& msg . stamp) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . accepted = self . accepted ; self . stamp . copy_to_native (& mut msg . stamp) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetResult { use super :: super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__kobuki_ros_interfaces__action__AutoDocking_GetResult () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub goal_id : unique_identifier_msgs :: msg :: UUID } impl WrappedTypesupport for Request { type CStruct = kobuki_ros_interfaces__action__AutoDocking_GetResult_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__kobuki_ros_interfaces__action__AutoDocking_GetResult_Request () } } fn create_msg () -> * mut kobuki_ros_interfaces__action__AutoDocking_GetResult_Request { unsafe { kobuki_ros_interfaces__action__AutoDocking_GetResult_Request__create () } } fn destroy_msg (msg : * mut kobuki_ros_interfaces__action__AutoDocking_GetResult_Request) -> () { unsafe { kobuki_ros_interfaces__action__AutoDocking_GetResult_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { goal_id : unique_identifier_msgs :: msg :: UUID :: from_native (& msg . goal_id) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . goal_id . copy_to_native (& mut msg . goal_id) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub status : i8 , pub result : kobuki_ros_interfaces :: action :: AutoDocking :: Result } impl WrappedTypesupport for Response { type CStruct = kobuki_ros_interfaces__action__AutoDocking_GetResult_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__kobuki_ros_interfaces__action__AutoDocking_GetResult_Response () } } fn create_msg () -> * mut kobuki_ros_interfaces__action__AutoDocking_GetResult_Response { unsafe { kobuki_ros_interfaces__action__AutoDocking_GetResult_Response__create () } } fn destroy_msg (msg : * mut kobuki_ros_interfaces__action__AutoDocking_GetResult_Response) -> () { unsafe { kobuki_ros_interfaces__action__AutoDocking_GetResult_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { status : msg . status , result : kobuki_ros_interfaces :: action :: AutoDocking :: Result :: from_native (& msg . result) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . status = self . status ; self . result . copy_to_native (& mut msg . result) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct FeedbackMessage { pub goal_id : unique_identifier_msgs :: msg :: UUID , pub feedback : kobuki_ros_interfaces :: action :: AutoDocking :: Feedback } impl WrappedTypesupport for FeedbackMessage { type CStruct = kobuki_ros_interfaces__action__AutoDocking_FeedbackMessage ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__kobuki_ros_interfaces__action__AutoDocking_FeedbackMessage () } } fn create_msg () -> * mut kobuki_ros_interfaces__action__AutoDocking_FeedbackMessage { unsafe { kobuki_ros_interfaces__action__AutoDocking_FeedbackMessage__create () } } fn destroy_msg (msg : * mut kobuki_ros_interfaces__action__AutoDocking_FeedbackMessage) -> () { unsafe { kobuki_ros_interfaces__action__AutoDocking_FeedbackMessage__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> FeedbackMessage { FeedbackMessage { goal_id : unique_identifier_msgs :: msg :: UUID :: from_native (& msg . goal_id) , feedback : kobuki_ros_interfaces :: action :: AutoDocking :: Feedback :: from_native (& msg . feedback) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . goal_id . copy_to_native (& mut msg . goal_id) ; self . feedback . copy_to_native (& mut msg . feedback) ; } } impl Default for FeedbackMessage { fn default () -> Self { let msg_native = WrappedNativeMsg :: < FeedbackMessage > :: new () ; FeedbackMessage :: from_native (& msg_native) } } } }