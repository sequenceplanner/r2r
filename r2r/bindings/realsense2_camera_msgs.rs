pub mod srv { # [allow (non_snake_case)] pub mod DeviceInfo { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__realsense2_camera_msgs__srv__DeviceInfo () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { } impl WrappedTypesupport for Request { type CStruct = realsense2_camera_msgs__srv__DeviceInfo_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__realsense2_camera_msgs__srv__DeviceInfo_Request () } } fn create_msg () -> * mut realsense2_camera_msgs__srv__DeviceInfo_Request { unsafe { realsense2_camera_msgs__srv__DeviceInfo_Request__create () } } fn destroy_msg (msg : * mut realsense2_camera_msgs__srv__DeviceInfo_Request) -> () { unsafe { realsense2_camera_msgs__srv__DeviceInfo_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub device_name : std :: string :: String , pub serial_number : std :: string :: String , pub firmware_version : std :: string :: String , pub usb_type_descriptor : std :: string :: String , pub firmware_update_id : std :: string :: String , pub sensors : std :: string :: String } impl WrappedTypesupport for Response { type CStruct = realsense2_camera_msgs__srv__DeviceInfo_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__realsense2_camera_msgs__srv__DeviceInfo_Response () } } fn create_msg () -> * mut realsense2_camera_msgs__srv__DeviceInfo_Response { unsafe { realsense2_camera_msgs__srv__DeviceInfo_Response__create () } } fn destroy_msg (msg : * mut realsense2_camera_msgs__srv__DeviceInfo_Response) -> () { unsafe { realsense2_camera_msgs__srv__DeviceInfo_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { device_name : msg . device_name . to_str () . to_owned () , serial_number : msg . serial_number . to_str () . to_owned () , firmware_version : msg . firmware_version . to_str () . to_owned () , usb_type_descriptor : msg . usb_type_descriptor . to_str () . to_owned () , firmware_update_id : msg . firmware_update_id . to_str () . to_owned () , sensors : msg . sensors . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . device_name . assign (& self . device_name) ; msg . serial_number . assign (& self . serial_number) ; msg . firmware_version . assign (& self . firmware_version) ; msg . usb_type_descriptor . assign (& self . usb_type_descriptor) ; msg . firmware_update_id . assign (& self . firmware_update_id) ; msg . sensors . assign (& self . sensors) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } } pub mod msg { use super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Extrinsics { pub rotation : Vec < f64 > , pub translation : Vec < f64 > } impl WrappedTypesupport for Extrinsics { type CStruct = realsense2_camera_msgs__msg__Extrinsics ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__realsense2_camera_msgs__msg__Extrinsics () } } fn create_msg () -> * mut realsense2_camera_msgs__msg__Extrinsics { unsafe { realsense2_camera_msgs__msg__Extrinsics__create () } } fn destroy_msg (msg : * mut realsense2_camera_msgs__msg__Extrinsics) -> () { unsafe { realsense2_camera_msgs__msg__Extrinsics__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Extrinsics { Extrinsics { rotation : msg . rotation . to_vec () , translation : msg . translation . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { assert_eq ! (self . rotation . len () , 9usize , "Field {} is fixed size of {}!" , "rotation" , 9usize) ; msg . rotation . copy_from_slice (& self . rotation [.. 9usize]) ; assert_eq ! (self . translation . len () , 3usize , "Field {} is fixed size of {}!" , "translation" , 3usize) ; msg . translation . copy_from_slice (& self . translation [.. 3usize]) ; } } impl Default for Extrinsics { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Extrinsics > :: new () ; Extrinsics :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct IMUInfo { pub header : std_msgs :: msg :: Header , pub data : Vec < f64 > , pub noise_variances : Vec < f64 > , pub bias_variances : Vec < f64 > } impl WrappedTypesupport for IMUInfo { type CStruct = realsense2_camera_msgs__msg__IMUInfo ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__realsense2_camera_msgs__msg__IMUInfo () } } fn create_msg () -> * mut realsense2_camera_msgs__msg__IMUInfo { unsafe { realsense2_camera_msgs__msg__IMUInfo__create () } } fn destroy_msg (msg : * mut realsense2_camera_msgs__msg__IMUInfo) -> () { unsafe { realsense2_camera_msgs__msg__IMUInfo__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> IMUInfo { IMUInfo { header : std_msgs :: msg :: Header :: from_native (& msg . header) , data : msg . data . to_vec () , noise_variances : msg . noise_variances . to_vec () , bias_variances : msg . bias_variances . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; assert_eq ! (self . data . len () , 12usize , "Field {} is fixed size of {}!" , "data" , 12usize) ; msg . data . copy_from_slice (& self . data [.. 12usize]) ; assert_eq ! (self . noise_variances . len () , 3usize , "Field {} is fixed size of {}!" , "noise_variances" , 3usize) ; msg . noise_variances . copy_from_slice (& self . noise_variances [.. 3usize]) ; assert_eq ! (self . bias_variances . len () , 3usize , "Field {} is fixed size of {}!" , "bias_variances" , 3usize) ; msg . bias_variances . copy_from_slice (& self . bias_variances [.. 3usize]) ; } } impl Default for IMUInfo { fn default () -> Self { let msg_native = WrappedNativeMsg :: < IMUInfo > :: new () ; IMUInfo :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Metadata { pub header : std_msgs :: msg :: Header , pub json_data : std :: string :: String } impl WrappedTypesupport for Metadata { type CStruct = realsense2_camera_msgs__msg__Metadata ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__realsense2_camera_msgs__msg__Metadata () } } fn create_msg () -> * mut realsense2_camera_msgs__msg__Metadata { unsafe { realsense2_camera_msgs__msg__Metadata__create () } } fn destroy_msg (msg : * mut realsense2_camera_msgs__msg__Metadata) -> () { unsafe { realsense2_camera_msgs__msg__Metadata__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Metadata { Metadata { header : std_msgs :: msg :: Header :: from_native (& msg . header) , json_data : msg . json_data . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . json_data . assign (& self . json_data) ; } } impl Default for Metadata { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Metadata > :: new () ; Metadata :: from_native (& msg_native) } } }