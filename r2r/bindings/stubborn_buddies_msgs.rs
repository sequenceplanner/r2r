pub mod msg { use super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Heartbeat { pub stamp : builtin_interfaces :: msg :: Time , pub checkpoint_id : u16 } impl WrappedTypesupport for Heartbeat { type CStruct = stubborn_buddies_msgs__msg__Heartbeat ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__stubborn_buddies_msgs__msg__Heartbeat () } } fn create_msg () -> * mut stubborn_buddies_msgs__msg__Heartbeat { unsafe { stubborn_buddies_msgs__msg__Heartbeat__create () } } fn destroy_msg (msg : * mut stubborn_buddies_msgs__msg__Heartbeat) -> () { unsafe { stubborn_buddies_msgs__msg__Heartbeat__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Heartbeat { Heartbeat { stamp : builtin_interfaces :: msg :: Time :: from_native (& msg . stamp) , checkpoint_id : msg . checkpoint_id , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . stamp . copy_to_native (& mut msg . stamp) ; msg . checkpoint_id = self . checkpoint_id ; } } impl Default for Heartbeat { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Heartbeat > :: new () ; Heartbeat :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Status { pub stamp : builtin_interfaces :: msg :: Time , pub missed_number : u16 } impl WrappedTypesupport for Status { type CStruct = stubborn_buddies_msgs__msg__Status ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__stubborn_buddies_msgs__msg__Status () } } fn create_msg () -> * mut stubborn_buddies_msgs__msg__Status { unsafe { stubborn_buddies_msgs__msg__Status__create () } } fn destroy_msg (msg : * mut stubborn_buddies_msgs__msg__Status) -> () { unsafe { stubborn_buddies_msgs__msg__Status__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Status { Status { stamp : builtin_interfaces :: msg :: Time :: from_native (& msg . stamp) , missed_number : msg . missed_number , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . stamp . copy_to_native (& mut msg . stamp) ; msg . missed_number = self . missed_number ; } } impl Default for Status { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Status > :: new () ; Status :: from_native (& msg_native) } } }