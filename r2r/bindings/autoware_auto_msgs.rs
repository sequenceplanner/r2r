pub mod msg { use super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct BoundingBox { pub centroid : geometry_msgs :: msg :: Point32 , pub size : geometry_msgs :: msg :: Point32 , pub orientation : autoware_auto_msgs :: msg :: Quaternion32 , pub velocity : f32 , pub heading : f32 , pub heading_rate : f32 , pub corners : Vec < geometry_msgs :: msg :: Point32 > , pub variance : Vec < f32 > , pub value : f32 , pub vehicle_label : u8 , pub signal_label : u8 , pub class_likelihood : f32 } impl WrappedTypesupport for BoundingBox { type CStruct = autoware_auto_msgs__msg__BoundingBox ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__autoware_auto_msgs__msg__BoundingBox () } } fn create_msg () -> * mut autoware_auto_msgs__msg__BoundingBox { unsafe { autoware_auto_msgs__msg__BoundingBox__create () } } fn destroy_msg (msg : * mut autoware_auto_msgs__msg__BoundingBox) -> () { unsafe { autoware_auto_msgs__msg__BoundingBox__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> BoundingBox { BoundingBox { centroid : geometry_msgs :: msg :: Point32 :: from_native (& msg . centroid) , size : geometry_msgs :: msg :: Point32 :: from_native (& msg . size) , orientation : autoware_auto_msgs :: msg :: Quaternion32 :: from_native (& msg . orientation) , velocity : msg . velocity , heading : msg . heading , heading_rate : msg . heading_rate , corners : { let vec : Vec < _ > = msg . corners . iter () . map (| s | geometry_msgs :: msg :: Point32 :: from_native (s)) . collect () ; vec } , variance : msg . variance . to_vec () , value : msg . value , vehicle_label : msg . vehicle_label , signal_label : msg . signal_label , class_likelihood : msg . class_likelihood , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . centroid . copy_to_native (& mut msg . centroid) ; self . size . copy_to_native (& mut msg . size) ; self . orientation . copy_to_native (& mut msg . orientation) ; msg . velocity = self . velocity ; msg . heading = self . heading ; msg . heading_rate = self . heading_rate ; assert_eq ! (self . corners . len () , 4usize , "Field {} is fixed size of {}!" , "corners" , 4usize) ; for (t , s) in msg . corners . iter_mut () . zip (& self . corners) { s . copy_to_native (t) ; } assert_eq ! (self . variance . len () , 8usize , "Field {} is fixed size of {}!" , "variance" , 8usize) ; msg . variance . copy_from_slice (& self . variance [.. 8usize]) ; msg . value = self . value ; msg . vehicle_label = self . vehicle_label ; msg . signal_label = self . signal_label ; msg . class_likelihood = self . class_likelihood ; } } impl Default for BoundingBox { fn default () -> Self { let msg_native = WrappedNativeMsg :: < BoundingBox > :: new () ; BoundingBox :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl BoundingBox { pub const ACCELERATION : _bindgen_ty_64 = autoware_auto_msgs__msg__BoundingBox__ACCELERATION ; pub const BRAKE : _bindgen_ty_56 = autoware_auto_msgs__msg__BoundingBox__BRAKE ; pub const CAR : _bindgen_ty_49 = autoware_auto_msgs__msg__BoundingBox__CAR ; pub const CYCLIST : _bindgen_ty_51 = autoware_auto_msgs__msg__BoundingBox__CYCLIST ; pub const HEADING : _bindgen_ty_60 = autoware_auto_msgs__msg__BoundingBox__HEADING ; pub const LEFT_SIGNAL : _bindgen_ty_54 = autoware_auto_msgs__msg__BoundingBox__LEFT_SIGNAL ; pub const MOTORCYCLE : _bindgen_ty_52 = autoware_auto_msgs__msg__BoundingBox__MOTORCYCLE ; pub const NO_LABEL : _bindgen_ty_48 = autoware_auto_msgs__msg__BoundingBox__NO_LABEL ; pub const NO_SIGNAL : _bindgen_ty_53 = autoware_auto_msgs__msg__BoundingBox__NO_SIGNAL ; pub const PEDESTRIAN : _bindgen_ty_50 = autoware_auto_msgs__msg__BoundingBox__PEDESTRIAN ; pub const POSE_X : _bindgen_ty_57 = autoware_auto_msgs__msg__BoundingBox__POSE_X ; pub const POSE_Y : _bindgen_ty_58 = autoware_auto_msgs__msg__BoundingBox__POSE_Y ; pub const RIGHT_SIGNAL : _bindgen_ty_55 = autoware_auto_msgs__msg__BoundingBox__RIGHT_SIGNAL ; pub const SIZE_X : _bindgen_ty_62 = autoware_auto_msgs__msg__BoundingBox__SIZE_X ; pub const SIZE_Y : _bindgen_ty_63 = autoware_auto_msgs__msg__BoundingBox__SIZE_Y ; pub const TURN_RATE : _bindgen_ty_61 = autoware_auto_msgs__msg__BoundingBox__TURN_RATE ; pub const VELOCITY : _bindgen_ty_59 = autoware_auto_msgs__msg__BoundingBox__VELOCITY ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct BoundingBoxArray { pub header : std_msgs :: msg :: Header , pub boxes : Vec < autoware_auto_msgs :: msg :: BoundingBox > } impl WrappedTypesupport for BoundingBoxArray { type CStruct = autoware_auto_msgs__msg__BoundingBoxArray ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__autoware_auto_msgs__msg__BoundingBoxArray () } } fn create_msg () -> * mut autoware_auto_msgs__msg__BoundingBoxArray { unsafe { autoware_auto_msgs__msg__BoundingBoxArray__create () } } fn destroy_msg (msg : * mut autoware_auto_msgs__msg__BoundingBoxArray) -> () { unsafe { autoware_auto_msgs__msg__BoundingBoxArray__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> BoundingBoxArray { BoundingBoxArray { header : std_msgs :: msg :: Header :: from_native (& msg . header) , boxes : { let mut temp = Vec :: with_capacity (msg . boxes . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . boxes . data , msg . boxes . size) } ; for s in slice { temp . push (autoware_auto_msgs :: msg :: BoundingBox :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; unsafe { autoware_auto_msgs__msg__BoundingBox__Sequence__fini (& mut msg . boxes) ; autoware_auto_msgs__msg__BoundingBox__Sequence__init (& mut msg . boxes , self . boxes . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . boxes . data , msg . boxes . size) ; for (t , s) in slice . iter_mut () . zip (& self . boxes) { s . copy_to_native (t) ; } } } } impl Default for BoundingBoxArray { fn default () -> Self { let msg_native = WrappedNativeMsg :: < BoundingBoxArray > :: new () ; BoundingBoxArray :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl BoundingBoxArray { pub const CAPACITY : _bindgen_ty_65 = autoware_auto_msgs__msg__BoundingBoxArray__CAPACITY ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Complex32 { pub real : f32 , pub imag : f32 } impl WrappedTypesupport for Complex32 { type CStruct = autoware_auto_msgs__msg__Complex32 ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__autoware_auto_msgs__msg__Complex32 () } } fn create_msg () -> * mut autoware_auto_msgs__msg__Complex32 { unsafe { autoware_auto_msgs__msg__Complex32__create () } } fn destroy_msg (msg : * mut autoware_auto_msgs__msg__Complex32) -> () { unsafe { autoware_auto_msgs__msg__Complex32__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Complex32 { Complex32 { real : msg . real , imag : msg . imag , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . real = self . real ; msg . imag = self . imag ; } } impl Default for Complex32 { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Complex32 > :: new () ; Complex32 :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ControlDiagnostic { pub diag_header : autoware_auto_msgs :: msg :: DiagnosticHeader , pub new_trajectory : bool , pub trajectory_source : std :: string :: String , pub pose_source : std :: string :: String , pub lateral_error_m : f32 , pub longitudinal_error_m : f32 , pub velocity_error_mps : f32 , pub acceleration_error_mps2 : f32 , pub yaw_error_rad : f32 , pub yaw_rate_error_rps : f32 } impl WrappedTypesupport for ControlDiagnostic { type CStruct = autoware_auto_msgs__msg__ControlDiagnostic ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__autoware_auto_msgs__msg__ControlDiagnostic () } } fn create_msg () -> * mut autoware_auto_msgs__msg__ControlDiagnostic { unsafe { autoware_auto_msgs__msg__ControlDiagnostic__create () } } fn destroy_msg (msg : * mut autoware_auto_msgs__msg__ControlDiagnostic) -> () { unsafe { autoware_auto_msgs__msg__ControlDiagnostic__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ControlDiagnostic { ControlDiagnostic { diag_header : autoware_auto_msgs :: msg :: DiagnosticHeader :: from_native (& msg . diag_header) , new_trajectory : msg . new_trajectory , trajectory_source : msg . trajectory_source . to_str () . to_owned () , pose_source : msg . pose_source . to_str () . to_owned () , lateral_error_m : msg . lateral_error_m , longitudinal_error_m : msg . longitudinal_error_m , velocity_error_mps : msg . velocity_error_mps , acceleration_error_mps2 : msg . acceleration_error_mps2 , yaw_error_rad : msg . yaw_error_rad , yaw_rate_error_rps : msg . yaw_rate_error_rps , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . diag_header . copy_to_native (& mut msg . diag_header) ; msg . new_trajectory = self . new_trajectory ; msg . trajectory_source . assign (& self . trajectory_source) ; msg . pose_source . assign (& self . pose_source) ; msg . lateral_error_m = self . lateral_error_m ; msg . longitudinal_error_m = self . longitudinal_error_m ; msg . velocity_error_mps = self . velocity_error_mps ; msg . acceleration_error_mps2 = self . acceleration_error_mps2 ; msg . yaw_error_rad = self . yaw_error_rad ; msg . yaw_rate_error_rps = self . yaw_rate_error_rps ; } } impl Default for ControlDiagnostic { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ControlDiagnostic > :: new () ; ControlDiagnostic :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct DiagnosticHeader { pub name : std :: string :: String , pub data_stamp : builtin_interfaces :: msg :: Time , pub computation_start : builtin_interfaces :: msg :: Time , pub runtime : builtin_interfaces :: msg :: Duration , pub iterations : u32 } impl WrappedTypesupport for DiagnosticHeader { type CStruct = autoware_auto_msgs__msg__DiagnosticHeader ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__autoware_auto_msgs__msg__DiagnosticHeader () } } fn create_msg () -> * mut autoware_auto_msgs__msg__DiagnosticHeader { unsafe { autoware_auto_msgs__msg__DiagnosticHeader__create () } } fn destroy_msg (msg : * mut autoware_auto_msgs__msg__DiagnosticHeader) -> () { unsafe { autoware_auto_msgs__msg__DiagnosticHeader__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> DiagnosticHeader { DiagnosticHeader { name : msg . name . to_str () . to_owned () , data_stamp : builtin_interfaces :: msg :: Time :: from_native (& msg . data_stamp) , computation_start : builtin_interfaces :: msg :: Time :: from_native (& msg . computation_start) , runtime : builtin_interfaces :: msg :: Duration :: from_native (& msg . runtime) , iterations : msg . iterations , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . name . assign (& self . name) ; self . data_stamp . copy_to_native (& mut msg . data_stamp) ; self . computation_start . copy_to_native (& mut msg . computation_start) ; self . runtime . copy_to_native (& mut msg . runtime) ; msg . iterations = self . iterations ; } } impl Default for DiagnosticHeader { fn default () -> Self { let msg_native = WrappedNativeMsg :: < DiagnosticHeader > :: new () ; DiagnosticHeader :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct HADMapBin { pub header : std_msgs :: msg :: Header , pub map_format : u8 , pub format_version : std :: string :: String , pub map_version : std :: string :: String , pub data : Vec < u8 > } impl WrappedTypesupport for HADMapBin { type CStruct = autoware_auto_msgs__msg__HADMapBin ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__autoware_auto_msgs__msg__HADMapBin () } } fn create_msg () -> * mut autoware_auto_msgs__msg__HADMapBin { unsafe { autoware_auto_msgs__msg__HADMapBin__create () } } fn destroy_msg (msg : * mut autoware_auto_msgs__msg__HADMapBin) -> () { unsafe { autoware_auto_msgs__msg__HADMapBin__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> HADMapBin { HADMapBin { header : std_msgs :: msg :: Header :: from_native (& msg . header) , map_format : msg . map_format , format_version : msg . format_version . to_str () . to_owned () , map_version : msg . map_version . to_str () . to_owned () , data : msg . data . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . map_format = self . map_format ; msg . format_version . assign (& self . format_version) ; msg . map_version . assign (& self . map_version) ; msg . data . update (& self . data) ; } } impl Default for HADMapBin { fn default () -> Self { let msg_native = WrappedNativeMsg :: < HADMapBin > :: new () ; HADMapBin :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl HADMapBin { pub const MAP_FORMAT_LANELET2 : _bindgen_ty_70 = autoware_auto_msgs__msg__HADMapBin__MAP_FORMAT_LANELET2 ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct HighLevelControlCommand { pub stamp : builtin_interfaces :: msg :: Time , pub velocity_mps : f32 , pub curvature : f32 } impl WrappedTypesupport for HighLevelControlCommand { type CStruct = autoware_auto_msgs__msg__HighLevelControlCommand ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__autoware_auto_msgs__msg__HighLevelControlCommand () } } fn create_msg () -> * mut autoware_auto_msgs__msg__HighLevelControlCommand { unsafe { autoware_auto_msgs__msg__HighLevelControlCommand__create () } } fn destroy_msg (msg : * mut autoware_auto_msgs__msg__HighLevelControlCommand) -> () { unsafe { autoware_auto_msgs__msg__HighLevelControlCommand__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> HighLevelControlCommand { HighLevelControlCommand { stamp : builtin_interfaces :: msg :: Time :: from_native (& msg . stamp) , velocity_mps : msg . velocity_mps , curvature : msg . curvature , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . stamp . copy_to_native (& mut msg . stamp) ; msg . velocity_mps = self . velocity_mps ; msg . curvature = self . curvature ; } } impl Default for HighLevelControlCommand { fn default () -> Self { let msg_native = WrappedNativeMsg :: < HighLevelControlCommand > :: new () ; HighLevelControlCommand :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct MapPrimitive { pub id : i64 , pub primitive_type : std :: string :: String } impl WrappedTypesupport for MapPrimitive { type CStruct = autoware_auto_msgs__msg__MapPrimitive ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__autoware_auto_msgs__msg__MapPrimitive () } } fn create_msg () -> * mut autoware_auto_msgs__msg__MapPrimitive { unsafe { autoware_auto_msgs__msg__MapPrimitive__create () } } fn destroy_msg (msg : * mut autoware_auto_msgs__msg__MapPrimitive) -> () { unsafe { autoware_auto_msgs__msg__MapPrimitive__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> MapPrimitive { MapPrimitive { id : msg . id , primitive_type : msg . primitive_type . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . id = self . id ; msg . primitive_type . assign (& self . primitive_type) ; } } impl Default for MapPrimitive { fn default () -> Self { let msg_native = WrappedNativeMsg :: < MapPrimitive > :: new () ; MapPrimitive :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct PointClusters { pub clusters : Vec < sensor_msgs :: msg :: PointCloud2 > } impl WrappedTypesupport for PointClusters { type CStruct = autoware_auto_msgs__msg__PointClusters ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__autoware_auto_msgs__msg__PointClusters () } } fn create_msg () -> * mut autoware_auto_msgs__msg__PointClusters { unsafe { autoware_auto_msgs__msg__PointClusters__create () } } fn destroy_msg (msg : * mut autoware_auto_msgs__msg__PointClusters) -> () { unsafe { autoware_auto_msgs__msg__PointClusters__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> PointClusters { PointClusters { clusters : { let mut temp = Vec :: with_capacity (msg . clusters . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . clusters . data , msg . clusters . size) } ; for s in slice { temp . push (sensor_msgs :: msg :: PointCloud2 :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { unsafe { sensor_msgs__msg__PointCloud2__Sequence__fini (& mut msg . clusters) ; sensor_msgs__msg__PointCloud2__Sequence__init (& mut msg . clusters , self . clusters . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . clusters . data , msg . clusters . size) ; for (t , s) in slice . iter_mut () . zip (& self . clusters) { s . copy_to_native (t) ; } } } } impl Default for PointClusters { fn default () -> Self { let msg_native = WrappedNativeMsg :: < PointClusters > :: new () ; PointClusters :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Quaternion32 { pub x : f32 , pub y : f32 , pub z : f32 , pub w : f32 } impl WrappedTypesupport for Quaternion32 { type CStruct = autoware_auto_msgs__msg__Quaternion32 ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__autoware_auto_msgs__msg__Quaternion32 () } } fn create_msg () -> * mut autoware_auto_msgs__msg__Quaternion32 { unsafe { autoware_auto_msgs__msg__Quaternion32__create () } } fn destroy_msg (msg : * mut autoware_auto_msgs__msg__Quaternion32) -> () { unsafe { autoware_auto_msgs__msg__Quaternion32__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Quaternion32 { Quaternion32 { x : msg . x , y : msg . y , z : msg . z , w : msg . w , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . x = self . x ; msg . y = self . y ; msg . z = self . z ; msg . w = self . w ; } } impl Default for Quaternion32 { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Quaternion32 > :: new () ; Quaternion32 :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct RawControlCommand { pub stamp : builtin_interfaces :: msg :: Time , pub throttle : u32 , pub brake : u32 , pub front_steer : i32 , pub rear_steer : i32 } impl WrappedTypesupport for RawControlCommand { type CStruct = autoware_auto_msgs__msg__RawControlCommand ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__autoware_auto_msgs__msg__RawControlCommand () } } fn create_msg () -> * mut autoware_auto_msgs__msg__RawControlCommand { unsafe { autoware_auto_msgs__msg__RawControlCommand__create () } } fn destroy_msg (msg : * mut autoware_auto_msgs__msg__RawControlCommand) -> () { unsafe { autoware_auto_msgs__msg__RawControlCommand__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> RawControlCommand { RawControlCommand { stamp : builtin_interfaces :: msg :: Time :: from_native (& msg . stamp) , throttle : msg . throttle , brake : msg . brake , front_steer : msg . front_steer , rear_steer : msg . rear_steer , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . stamp . copy_to_native (& mut msg . stamp) ; msg . throttle = self . throttle ; msg . brake = self . brake ; msg . front_steer = self . front_steer ; msg . rear_steer = self . rear_steer ; } } impl Default for RawControlCommand { fn default () -> Self { let msg_native = WrappedNativeMsg :: < RawControlCommand > :: new () ; RawControlCommand :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Route { pub header : std_msgs :: msg :: Header , pub start_point : autoware_auto_msgs :: msg :: TrajectoryPoint , pub goal_point : autoware_auto_msgs :: msg :: TrajectoryPoint , pub primitives : Vec < autoware_auto_msgs :: msg :: MapPrimitive > } impl WrappedTypesupport for Route { type CStruct = autoware_auto_msgs__msg__Route ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__autoware_auto_msgs__msg__Route () } } fn create_msg () -> * mut autoware_auto_msgs__msg__Route { unsafe { autoware_auto_msgs__msg__Route__create () } } fn destroy_msg (msg : * mut autoware_auto_msgs__msg__Route) -> () { unsafe { autoware_auto_msgs__msg__Route__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Route { Route { header : std_msgs :: msg :: Header :: from_native (& msg . header) , start_point : autoware_auto_msgs :: msg :: TrajectoryPoint :: from_native (& msg . start_point) , goal_point : autoware_auto_msgs :: msg :: TrajectoryPoint :: from_native (& msg . goal_point) , primitives : { let mut temp = Vec :: with_capacity (msg . primitives . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . primitives . data , msg . primitives . size) } ; for s in slice { temp . push (autoware_auto_msgs :: msg :: MapPrimitive :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; self . start_point . copy_to_native (& mut msg . start_point) ; self . goal_point . copy_to_native (& mut msg . goal_point) ; unsafe { autoware_auto_msgs__msg__MapPrimitive__Sequence__fini (& mut msg . primitives) ; autoware_auto_msgs__msg__MapPrimitive__Sequence__init (& mut msg . primitives , self . primitives . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . primitives . data , msg . primitives . size) ; for (t , s) in slice . iter_mut () . zip (& self . primitives) { s . copy_to_native (t) ; } } } } impl Default for Route { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Route > :: new () ; Route :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl Route { pub const CAPACITY : _bindgen_ty_42 = autoware_auto_msgs__msg__Route__CAPACITY ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Trajectory { pub header : std_msgs :: msg :: Header , pub points : Vec < autoware_auto_msgs :: msg :: TrajectoryPoint > } impl WrappedTypesupport for Trajectory { type CStruct = autoware_auto_msgs__msg__Trajectory ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__autoware_auto_msgs__msg__Trajectory () } } fn create_msg () -> * mut autoware_auto_msgs__msg__Trajectory { unsafe { autoware_auto_msgs__msg__Trajectory__create () } } fn destroy_msg (msg : * mut autoware_auto_msgs__msg__Trajectory) -> () { unsafe { autoware_auto_msgs__msg__Trajectory__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Trajectory { Trajectory { header : std_msgs :: msg :: Header :: from_native (& msg . header) , points : { let mut temp = Vec :: with_capacity (msg . points . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . points . data , msg . points . size) } ; for s in slice { temp . push (autoware_auto_msgs :: msg :: TrajectoryPoint :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; unsafe { autoware_auto_msgs__msg__TrajectoryPoint__Sequence__fini (& mut msg . points) ; autoware_auto_msgs__msg__TrajectoryPoint__Sequence__init (& mut msg . points , self . points . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . points . data , msg . points . size) ; for (t , s) in slice . iter_mut () . zip (& self . points) { s . copy_to_native (t) ; } } } } impl Default for Trajectory { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Trajectory > :: new () ; Trajectory :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl Trajectory { pub const CAPACITY : _bindgen_ty_46 = autoware_auto_msgs__msg__Trajectory__CAPACITY ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct TrajectoryPoint { pub time_from_start : builtin_interfaces :: msg :: Duration , pub x : f32 , pub y : f32 , pub heading : autoware_auto_msgs :: msg :: Complex32 , pub longitudinal_velocity_mps : f32 , pub lateral_velocity_mps : f32 , pub acceleration_mps2 : f32 , pub heading_rate_rps : f32 , pub front_wheel_angle_rad : f32 , pub rear_wheel_angle_rad : f32 } impl WrappedTypesupport for TrajectoryPoint { type CStruct = autoware_auto_msgs__msg__TrajectoryPoint ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__autoware_auto_msgs__msg__TrajectoryPoint () } } fn create_msg () -> * mut autoware_auto_msgs__msg__TrajectoryPoint { unsafe { autoware_auto_msgs__msg__TrajectoryPoint__create () } } fn destroy_msg (msg : * mut autoware_auto_msgs__msg__TrajectoryPoint) -> () { unsafe { autoware_auto_msgs__msg__TrajectoryPoint__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> TrajectoryPoint { TrajectoryPoint { time_from_start : builtin_interfaces :: msg :: Duration :: from_native (& msg . time_from_start) , x : msg . x , y : msg . y , heading : autoware_auto_msgs :: msg :: Complex32 :: from_native (& msg . heading) , longitudinal_velocity_mps : msg . longitudinal_velocity_mps , lateral_velocity_mps : msg . lateral_velocity_mps , acceleration_mps2 : msg . acceleration_mps2 , heading_rate_rps : msg . heading_rate_rps , front_wheel_angle_rad : msg . front_wheel_angle_rad , rear_wheel_angle_rad : msg . rear_wheel_angle_rad , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . time_from_start . copy_to_native (& mut msg . time_from_start) ; msg . x = self . x ; msg . y = self . y ; self . heading . copy_to_native (& mut msg . heading) ; msg . longitudinal_velocity_mps = self . longitudinal_velocity_mps ; msg . lateral_velocity_mps = self . lateral_velocity_mps ; msg . acceleration_mps2 = self . acceleration_mps2 ; msg . heading_rate_rps = self . heading_rate_rps ; msg . front_wheel_angle_rad = self . front_wheel_angle_rad ; msg . rear_wheel_angle_rad = self . rear_wheel_angle_rad ; } } impl Default for TrajectoryPoint { fn default () -> Self { let msg_native = WrappedNativeMsg :: < TrajectoryPoint > :: new () ; TrajectoryPoint :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct VehicleControlCommand { pub stamp : builtin_interfaces :: msg :: Time , pub long_accel_mps2 : f32 , pub velocity_mps : f32 , pub front_wheel_angle_rad : f32 , pub rear_wheel_angle_rad : f32 } impl WrappedTypesupport for VehicleControlCommand { type CStruct = autoware_auto_msgs__msg__VehicleControlCommand ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__autoware_auto_msgs__msg__VehicleControlCommand () } } fn create_msg () -> * mut autoware_auto_msgs__msg__VehicleControlCommand { unsafe { autoware_auto_msgs__msg__VehicleControlCommand__create () } } fn destroy_msg (msg : * mut autoware_auto_msgs__msg__VehicleControlCommand) -> () { unsafe { autoware_auto_msgs__msg__VehicleControlCommand__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> VehicleControlCommand { VehicleControlCommand { stamp : builtin_interfaces :: msg :: Time :: from_native (& msg . stamp) , long_accel_mps2 : msg . long_accel_mps2 , velocity_mps : msg . velocity_mps , front_wheel_angle_rad : msg . front_wheel_angle_rad , rear_wheel_angle_rad : msg . rear_wheel_angle_rad , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . stamp . copy_to_native (& mut msg . stamp) ; msg . long_accel_mps2 = self . long_accel_mps2 ; msg . velocity_mps = self . velocity_mps ; msg . front_wheel_angle_rad = self . front_wheel_angle_rad ; msg . rear_wheel_angle_rad = self . rear_wheel_angle_rad ; } } impl Default for VehicleControlCommand { fn default () -> Self { let msg_native = WrappedNativeMsg :: < VehicleControlCommand > :: new () ; VehicleControlCommand :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct VehicleKinematicState { pub header : std_msgs :: msg :: Header , pub state : autoware_auto_msgs :: msg :: TrajectoryPoint , pub delta : geometry_msgs :: msg :: Transform } impl WrappedTypesupport for VehicleKinematicState { type CStruct = autoware_auto_msgs__msg__VehicleKinematicState ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__autoware_auto_msgs__msg__VehicleKinematicState () } } fn create_msg () -> * mut autoware_auto_msgs__msg__VehicleKinematicState { unsafe { autoware_auto_msgs__msg__VehicleKinematicState__create () } } fn destroy_msg (msg : * mut autoware_auto_msgs__msg__VehicleKinematicState) -> () { unsafe { autoware_auto_msgs__msg__VehicleKinematicState__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> VehicleKinematicState { VehicleKinematicState { header : std_msgs :: msg :: Header :: from_native (& msg . header) , state : autoware_auto_msgs :: msg :: TrajectoryPoint :: from_native (& msg . state) , delta : geometry_msgs :: msg :: Transform :: from_native (& msg . delta) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; self . state . copy_to_native (& mut msg . state) ; self . delta . copy_to_native (& mut msg . delta) ; } } impl Default for VehicleKinematicState { fn default () -> Self { let msg_native = WrappedNativeMsg :: < VehicleKinematicState > :: new () ; VehicleKinematicState :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct VehicleOdometry { pub stamp : builtin_interfaces :: msg :: Time , pub velocity_mps : f32 , pub front_wheel_angle_rad : f32 , pub rear_wheel_angle_rad : f32 } impl WrappedTypesupport for VehicleOdometry { type CStruct = autoware_auto_msgs__msg__VehicleOdometry ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__autoware_auto_msgs__msg__VehicleOdometry () } } fn create_msg () -> * mut autoware_auto_msgs__msg__VehicleOdometry { unsafe { autoware_auto_msgs__msg__VehicleOdometry__create () } } fn destroy_msg (msg : * mut autoware_auto_msgs__msg__VehicleOdometry) -> () { unsafe { autoware_auto_msgs__msg__VehicleOdometry__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> VehicleOdometry { VehicleOdometry { stamp : builtin_interfaces :: msg :: Time :: from_native (& msg . stamp) , velocity_mps : msg . velocity_mps , front_wheel_angle_rad : msg . front_wheel_angle_rad , rear_wheel_angle_rad : msg . rear_wheel_angle_rad , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . stamp . copy_to_native (& mut msg . stamp) ; msg . velocity_mps = self . velocity_mps ; msg . front_wheel_angle_rad = self . front_wheel_angle_rad ; msg . rear_wheel_angle_rad = self . rear_wheel_angle_rad ; } } impl Default for VehicleOdometry { fn default () -> Self { let msg_native = WrappedNativeMsg :: < VehicleOdometry > :: new () ; VehicleOdometry :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct VehicleStateCommand { pub stamp : builtin_interfaces :: msg :: Time , pub blinker : u8 , pub headlight : u8 , pub wiper : u8 , pub gear : u8 , pub mode : u8 , pub hand_brake : bool , pub horn : bool } impl WrappedTypesupport for VehicleStateCommand { type CStruct = autoware_auto_msgs__msg__VehicleStateCommand ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__autoware_auto_msgs__msg__VehicleStateCommand () } } fn create_msg () -> * mut autoware_auto_msgs__msg__VehicleStateCommand { unsafe { autoware_auto_msgs__msg__VehicleStateCommand__create () } } fn destroy_msg (msg : * mut autoware_auto_msgs__msg__VehicleStateCommand) -> () { unsafe { autoware_auto_msgs__msg__VehicleStateCommand__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> VehicleStateCommand { VehicleStateCommand { stamp : builtin_interfaces :: msg :: Time :: from_native (& msg . stamp) , blinker : msg . blinker , headlight : msg . headlight , wiper : msg . wiper , gear : msg . gear , mode : msg . mode , hand_brake : msg . hand_brake , horn : msg . horn , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . stamp . copy_to_native (& mut msg . stamp) ; msg . blinker = self . blinker ; msg . headlight = self . headlight ; msg . wiper = self . wiper ; msg . gear = self . gear ; msg . mode = self . mode ; msg . hand_brake = self . hand_brake ; msg . horn = self . horn ; } } impl Default for VehicleStateCommand { fn default () -> Self { let msg_native = WrappedNativeMsg :: < VehicleStateCommand > :: new () ; VehicleStateCommand :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl VehicleStateCommand { pub const BLINKER_HAZARD : _bindgen_ty_83 = autoware_auto_msgs__msg__VehicleStateCommand__BLINKER_HAZARD ; pub const BLINKER_LEFT : _bindgen_ty_81 = autoware_auto_msgs__msg__VehicleStateCommand__BLINKER_LEFT ; pub const BLINKER_NO_COMMAND : _bindgen_ty_79 = autoware_auto_msgs__msg__VehicleStateCommand__BLINKER_NO_COMMAND ; pub const BLINKER_OFF : _bindgen_ty_80 = autoware_auto_msgs__msg__VehicleStateCommand__BLINKER_OFF ; pub const BLINKER_RIGHT : _bindgen_ty_82 = autoware_auto_msgs__msg__VehicleStateCommand__BLINKER_RIGHT ; pub const GEAR_DRIVE : _bindgen_ty_94 = autoware_auto_msgs__msg__VehicleStateCommand__GEAR_DRIVE ; pub const GEAR_LOW : _bindgen_ty_97 = autoware_auto_msgs__msg__VehicleStateCommand__GEAR_LOW ; pub const GEAR_NEUTRAL : _bindgen_ty_98 = autoware_auto_msgs__msg__VehicleStateCommand__GEAR_NEUTRAL ; pub const GEAR_NO_COMMAND : _bindgen_ty_93 = autoware_auto_msgs__msg__VehicleStateCommand__GEAR_NO_COMMAND ; pub const GEAR_PARK : _bindgen_ty_96 = autoware_auto_msgs__msg__VehicleStateCommand__GEAR_PARK ; pub const GEAR_REVERSE : _bindgen_ty_95 = autoware_auto_msgs__msg__VehicleStateCommand__GEAR_REVERSE ; pub const HEADLIGHT_HIGH : _bindgen_ty_87 = autoware_auto_msgs__msg__VehicleStateCommand__HEADLIGHT_HIGH ; pub const HEADLIGHT_NO_COMMAND : _bindgen_ty_84 = autoware_auto_msgs__msg__VehicleStateCommand__HEADLIGHT_NO_COMMAND ; pub const HEADLIGHT_OFF : _bindgen_ty_85 = autoware_auto_msgs__msg__VehicleStateCommand__HEADLIGHT_OFF ; pub const HEADLIGHT_ON : _bindgen_ty_86 = autoware_auto_msgs__msg__VehicleStateCommand__HEADLIGHT_ON ; pub const MODE_AUTONOMOUS : _bindgen_ty_100 = autoware_auto_msgs__msg__VehicleStateCommand__MODE_AUTONOMOUS ; pub const MODE_MANUAL : _bindgen_ty_101 = autoware_auto_msgs__msg__VehicleStateCommand__MODE_MANUAL ; pub const MODE_NO_COMMAND : _bindgen_ty_99 = autoware_auto_msgs__msg__VehicleStateCommand__MODE_NO_COMMAND ; pub const WIPER_CLEAN : _bindgen_ty_92 = autoware_auto_msgs__msg__VehicleStateCommand__WIPER_CLEAN ; pub const WIPER_HIGH : _bindgen_ty_91 = autoware_auto_msgs__msg__VehicleStateCommand__WIPER_HIGH ; pub const WIPER_LOW : _bindgen_ty_90 = autoware_auto_msgs__msg__VehicleStateCommand__WIPER_LOW ; pub const WIPER_NO_COMMAND : _bindgen_ty_88 = autoware_auto_msgs__msg__VehicleStateCommand__WIPER_NO_COMMAND ; pub const WIPER_OFF : _bindgen_ty_89 = autoware_auto_msgs__msg__VehicleStateCommand__WIPER_OFF ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct VehicleStateReport { pub stamp : builtin_interfaces :: msg :: Time , pub fuel : u8 , pub blinker : u8 , pub headlight : u8 , pub wiper : u8 , pub gear : u8 , pub mode : u8 , pub hand_brake : bool , pub horn : bool } impl WrappedTypesupport for VehicleStateReport { type CStruct = autoware_auto_msgs__msg__VehicleStateReport ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__autoware_auto_msgs__msg__VehicleStateReport () } } fn create_msg () -> * mut autoware_auto_msgs__msg__VehicleStateReport { unsafe { autoware_auto_msgs__msg__VehicleStateReport__create () } } fn destroy_msg (msg : * mut autoware_auto_msgs__msg__VehicleStateReport) -> () { unsafe { autoware_auto_msgs__msg__VehicleStateReport__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> VehicleStateReport { VehicleStateReport { stamp : builtin_interfaces :: msg :: Time :: from_native (& msg . stamp) , fuel : msg . fuel , blinker : msg . blinker , headlight : msg . headlight , wiper : msg . wiper , gear : msg . gear , mode : msg . mode , hand_brake : msg . hand_brake , horn : msg . horn , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . stamp . copy_to_native (& mut msg . stamp) ; msg . fuel = self . fuel ; msg . blinker = self . blinker ; msg . headlight = self . headlight ; msg . wiper = self . wiper ; msg . gear = self . gear ; msg . mode = self . mode ; msg . hand_brake = self . hand_brake ; msg . horn = self . horn ; } } impl Default for VehicleStateReport { fn default () -> Self { let msg_native = WrappedNativeMsg :: < VehicleStateReport > :: new () ; VehicleStateReport :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl VehicleStateReport { pub const BLINKER_HAZARD : _bindgen_ty_105 = autoware_auto_msgs__msg__VehicleStateReport__BLINKER_HAZARD ; pub const BLINKER_LEFT : _bindgen_ty_103 = autoware_auto_msgs__msg__VehicleStateReport__BLINKER_LEFT ; pub const BLINKER_OFF : _bindgen_ty_102 = autoware_auto_msgs__msg__VehicleStateReport__BLINKER_OFF ; pub const BLINKER_RIGHT : _bindgen_ty_104 = autoware_auto_msgs__msg__VehicleStateReport__BLINKER_RIGHT ; pub const GEAR_DRIVE : _bindgen_ty_113 = autoware_auto_msgs__msg__VehicleStateReport__GEAR_DRIVE ; pub const GEAR_LOW : _bindgen_ty_116 = autoware_auto_msgs__msg__VehicleStateReport__GEAR_LOW ; pub const GEAR_NEUTRAL : _bindgen_ty_117 = autoware_auto_msgs__msg__VehicleStateReport__GEAR_NEUTRAL ; pub const GEAR_PARK : _bindgen_ty_115 = autoware_auto_msgs__msg__VehicleStateReport__GEAR_PARK ; pub const GEAR_REVERSE : _bindgen_ty_114 = autoware_auto_msgs__msg__VehicleStateReport__GEAR_REVERSE ; pub const HEADLIGHT_HIGH : _bindgen_ty_108 = autoware_auto_msgs__msg__VehicleStateReport__HEADLIGHT_HIGH ; pub const HEADLIGHT_OFF : _bindgen_ty_106 = autoware_auto_msgs__msg__VehicleStateReport__HEADLIGHT_OFF ; pub const HEADLIGHT_ON : _bindgen_ty_107 = autoware_auto_msgs__msg__VehicleStateReport__HEADLIGHT_ON ; pub const MODE_AUTONOMOUS : _bindgen_ty_118 = autoware_auto_msgs__msg__VehicleStateReport__MODE_AUTONOMOUS ; pub const MODE_DISENGAGED : _bindgen_ty_120 = autoware_auto_msgs__msg__VehicleStateReport__MODE_DISENGAGED ; pub const MODE_MANUAL : _bindgen_ty_119 = autoware_auto_msgs__msg__VehicleStateReport__MODE_MANUAL ; pub const MODE_NOT_READY : _bindgen_ty_121 = autoware_auto_msgs__msg__VehicleStateReport__MODE_NOT_READY ; pub const WIPER_CLEAN : _bindgen_ty_112 = autoware_auto_msgs__msg__VehicleStateReport__WIPER_CLEAN ; pub const WIPER_HIGH : _bindgen_ty_111 = autoware_auto_msgs__msg__VehicleStateReport__WIPER_HIGH ; pub const WIPER_LOW : _bindgen_ty_110 = autoware_auto_msgs__msg__VehicleStateReport__WIPER_LOW ; pub const WIPER_OFF : _bindgen_ty_109 = autoware_auto_msgs__msg__VehicleStateReport__WIPER_OFF ; } } pub mod srv { # [allow (non_snake_case)] pub mod AutonomyModeChange { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__autoware_auto_msgs__srv__AutonomyModeChange () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub mode : u8 } impl WrappedTypesupport for Request { type CStruct = autoware_auto_msgs__srv__AutonomyModeChange_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__autoware_auto_msgs__srv__AutonomyModeChange_Request () } } fn create_msg () -> * mut autoware_auto_msgs__srv__AutonomyModeChange_Request { unsafe { autoware_auto_msgs__srv__AutonomyModeChange_Request__create () } } fn destroy_msg (msg : * mut autoware_auto_msgs__srv__AutonomyModeChange_Request) -> () { unsafe { autoware_auto_msgs__srv__AutonomyModeChange_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { mode : msg . mode , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . mode = self . mode ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl Request { pub const MODE_AUTONOMOUS : _bindgen_ty_123 = autoware_auto_msgs__srv__AutonomyModeChange_Request__MODE_AUTONOMOUS ; pub const MODE_MANUAL : _bindgen_ty_122 = autoware_auto_msgs__srv__AutonomyModeChange_Request__MODE_MANUAL ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub empty : std_msgs :: msg :: Empty } impl WrappedTypesupport for Response { type CStruct = autoware_auto_msgs__srv__AutonomyModeChange_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__autoware_auto_msgs__srv__AutonomyModeChange_Response () } } fn create_msg () -> * mut autoware_auto_msgs__srv__AutonomyModeChange_Response { unsafe { autoware_auto_msgs__srv__AutonomyModeChange_Response__create () } } fn destroy_msg (msg : * mut autoware_auto_msgs__srv__AutonomyModeChange_Response) -> () { unsafe { autoware_auto_msgs__srv__AutonomyModeChange_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { empty : std_msgs :: msg :: Empty :: from_native (& msg . empty) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . empty . copy_to_native (& mut msg . empty) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod HADMapService { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__autoware_auto_msgs__srv__HADMapService () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub requested_primitives : Vec < u8 > , pub geom_upper_bound : Vec < f64 > , pub geom_lower_bound : Vec < f64 > } impl WrappedTypesupport for Request { type CStruct = autoware_auto_msgs__srv__HADMapService_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__autoware_auto_msgs__srv__HADMapService_Request () } } fn create_msg () -> * mut autoware_auto_msgs__srv__HADMapService_Request { unsafe { autoware_auto_msgs__srv__HADMapService_Request__create () } } fn destroy_msg (msg : * mut autoware_auto_msgs__srv__HADMapService_Request) -> () { unsafe { autoware_auto_msgs__srv__HADMapService_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { requested_primitives : msg . requested_primitives . to_vec () , geom_upper_bound : msg . geom_upper_bound . to_vec () , geom_lower_bound : msg . geom_lower_bound . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . requested_primitives . update (& self . requested_primitives) ; assert ! (self . geom_upper_bound . len () <= 3usize , "Field {} is upper bounded by {}!" , "geom_upper_bound" , 3usize) ; msg . geom_upper_bound . update (& self . geom_upper_bound) ; assert ! (self . geom_lower_bound . len () <= 3usize , "Field {} is upper bounded by {}!" , "geom_lower_bound" , 3usize) ; msg . geom_lower_bound . update (& self . geom_lower_bound) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl Request { pub const ALL_PRIMITIVES : _bindgen_ty_125 = autoware_auto_msgs__srv__HADMapService_Request__ALL_PRIMITIVES ; pub const DRIVEABLE_GEOMETRY : _bindgen_ty_126 = autoware_auto_msgs__srv__HADMapService_Request__DRIVEABLE_GEOMETRY ; pub const FULL_MAP : _bindgen_ty_124 = autoware_auto_msgs__srv__HADMapService_Request__FULL_MAP ; pub const REGULATORY_ELEMENTS : _bindgen_ty_127 = autoware_auto_msgs__srv__HADMapService_Request__REGULATORY_ELEMENTS ; pub const STATIC_OBJECTS : _bindgen_ty_128 = autoware_auto_msgs__srv__HADMapService_Request__STATIC_OBJECTS ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub map : autoware_auto_msgs :: msg :: HADMapBin , pub answer : i32 } impl WrappedTypesupport for Response { type CStruct = autoware_auto_msgs__srv__HADMapService_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__autoware_auto_msgs__srv__HADMapService_Response () } } fn create_msg () -> * mut autoware_auto_msgs__srv__HADMapService_Response { unsafe { autoware_auto_msgs__srv__HADMapService_Response__create () } } fn destroy_msg (msg : * mut autoware_auto_msgs__srv__HADMapService_Response) -> () { unsafe { autoware_auto_msgs__srv__HADMapService_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { map : autoware_auto_msgs :: msg :: HADMapBin :: from_native (& msg . map) , answer : msg . answer , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . map . copy_to_native (& mut msg . map) ; msg . answer = self . answer ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod ModifyTrajectory { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__autoware_auto_msgs__srv__ModifyTrajectory () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub original_trajectory : autoware_auto_msgs :: msg :: Trajectory } impl WrappedTypesupport for Request { type CStruct = autoware_auto_msgs__srv__ModifyTrajectory_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__autoware_auto_msgs__srv__ModifyTrajectory_Request () } } fn create_msg () -> * mut autoware_auto_msgs__srv__ModifyTrajectory_Request { unsafe { autoware_auto_msgs__srv__ModifyTrajectory_Request__create () } } fn destroy_msg (msg : * mut autoware_auto_msgs__srv__ModifyTrajectory_Request) -> () { unsafe { autoware_auto_msgs__srv__ModifyTrajectory_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { original_trajectory : autoware_auto_msgs :: msg :: Trajectory :: from_native (& msg . original_trajectory) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . original_trajectory . copy_to_native (& mut msg . original_trajectory) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub modified_trajectory : autoware_auto_msgs :: msg :: Trajectory } impl WrappedTypesupport for Response { type CStruct = autoware_auto_msgs__srv__ModifyTrajectory_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__autoware_auto_msgs__srv__ModifyTrajectory_Response () } } fn create_msg () -> * mut autoware_auto_msgs__srv__ModifyTrajectory_Response { unsafe { autoware_auto_msgs__srv__ModifyTrajectory_Response__create () } } fn destroy_msg (msg : * mut autoware_auto_msgs__srv__ModifyTrajectory_Response) -> () { unsafe { autoware_auto_msgs__srv__ModifyTrajectory_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { modified_trajectory : autoware_auto_msgs :: msg :: Trajectory :: from_native (& msg . modified_trajectory) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . modified_trajectory . copy_to_native (& mut msg . modified_trajectory) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } } pub mod action { # [allow (non_snake_case)] pub mod PlanTrajectory { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Action () ; impl WrappedActionTypeSupport for Action { type Goal = Goal ; type Result = Result ; type Feedback = Feedback ; type FeedbackMessage = FeedbackMessage ; type SendGoal = SendGoal :: Service ; type GetResult = GetResult :: Service ; fn get_ts () -> & 'static rosidl_action_type_support_t { unsafe { & * rosidl_typesupport_c__get_action_type_support_handle__autoware_auto_msgs__action__PlanTrajectory () } } fn make_goal_request_msg (goal_id : unique_identifier_msgs :: msg :: UUID , goal : Goal) -> SendGoal :: Request { SendGoal :: Request { goal_id , goal } } fn make_goal_response_msg (accepted : bool , stamp : builtin_interfaces :: msg :: Time) -> SendGoal :: Response { SendGoal :: Response { accepted , stamp } } fn make_feedback_msg (goal_id : unique_identifier_msgs :: msg :: UUID , feedback : Feedback) -> FeedbackMessage { FeedbackMessage { goal_id , feedback } } fn make_result_request_msg (goal_id : unique_identifier_msgs :: msg :: UUID) -> GetResult :: Request { GetResult :: Request { goal_id , } } fn make_result_response_msg (status : i8 , result : Result) -> GetResult :: Response { GetResult :: Response { status , result , } } fn destructure_goal_request_msg (msg : SendGoal :: Request) -> (unique_identifier_msgs :: msg :: UUID , Goal) { (msg . goal_id , msg . goal) } fn destructure_goal_response_msg (msg : SendGoal :: Response) -> (bool , builtin_interfaces :: msg :: Time) { (msg . accepted , msg . stamp) } fn destructure_feedback_msg (msg : FeedbackMessage) -> (unique_identifier_msgs :: msg :: UUID , Feedback) { (msg . goal_id , msg . feedback) } fn destructure_result_response_msg (msg : GetResult :: Response) -> (i8 , Result) { (msg . status , msg . result) } fn destructure_result_request_msg (msg : GetResult :: Request) -> unique_identifier_msgs :: msg :: UUID { msg . goal_id } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Goal { pub sub_route : autoware_auto_msgs :: msg :: Route } impl WrappedTypesupport for Goal { type CStruct = autoware_auto_msgs__action__PlanTrajectory_Goal ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__autoware_auto_msgs__action__PlanTrajectory_Goal () } } fn create_msg () -> * mut autoware_auto_msgs__action__PlanTrajectory_Goal { unsafe { autoware_auto_msgs__action__PlanTrajectory_Goal__create () } } fn destroy_msg (msg : * mut autoware_auto_msgs__action__PlanTrajectory_Goal) -> () { unsafe { autoware_auto_msgs__action__PlanTrajectory_Goal__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Goal { Goal { sub_route : autoware_auto_msgs :: msg :: Route :: from_native (& msg . sub_route) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . sub_route . copy_to_native (& mut msg . sub_route) ; } } impl Default for Goal { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Goal > :: new () ; Goal :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Result { pub result : u8 , pub trajectory : autoware_auto_msgs :: msg :: Trajectory } impl WrappedTypesupport for Result { type CStruct = autoware_auto_msgs__action__PlanTrajectory_Result ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__autoware_auto_msgs__action__PlanTrajectory_Result () } } fn create_msg () -> * mut autoware_auto_msgs__action__PlanTrajectory_Result { unsafe { autoware_auto_msgs__action__PlanTrajectory_Result__create () } } fn destroy_msg (msg : * mut autoware_auto_msgs__action__PlanTrajectory_Result) -> () { unsafe { autoware_auto_msgs__action__PlanTrajectory_Result__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Result { Result { result : msg . result , trajectory : autoware_auto_msgs :: msg :: Trajectory :: from_native (& msg . trajectory) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . result = self . result ; self . trajectory . copy_to_native (& mut msg . trajectory) ; } } impl Default for Result { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Result > :: new () ; Result :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl Result { pub const FAIL : _bindgen_ty_45 = autoware_auto_msgs__action__PlanTrajectory_Result__FAIL ; pub const SUCCESS : _bindgen_ty_44 = autoware_auto_msgs__action__PlanTrajectory_Result__SUCCESS ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Feedback { pub unused_variable : u8 } impl WrappedTypesupport for Feedback { type CStruct = autoware_auto_msgs__action__PlanTrajectory_Feedback ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__autoware_auto_msgs__action__PlanTrajectory_Feedback () } } fn create_msg () -> * mut autoware_auto_msgs__action__PlanTrajectory_Feedback { unsafe { autoware_auto_msgs__action__PlanTrajectory_Feedback__create () } } fn destroy_msg (msg : * mut autoware_auto_msgs__action__PlanTrajectory_Feedback) -> () { unsafe { autoware_auto_msgs__action__PlanTrajectory_Feedback__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Feedback { Feedback { unused_variable : msg . unused_variable , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . unused_variable = self . unused_variable ; } } impl Default for Feedback { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Feedback > :: new () ; Feedback :: from_native (& msg_native) } } # [allow (non_snake_case)] pub mod SendGoal { use super :: super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__autoware_auto_msgs__action__PlanTrajectory_SendGoal () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub goal_id : unique_identifier_msgs :: msg :: UUID , pub goal : autoware_auto_msgs :: action :: PlanTrajectory :: Goal } impl WrappedTypesupport for Request { type CStruct = autoware_auto_msgs__action__PlanTrajectory_SendGoal_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__autoware_auto_msgs__action__PlanTrajectory_SendGoal_Request () } } fn create_msg () -> * mut autoware_auto_msgs__action__PlanTrajectory_SendGoal_Request { unsafe { autoware_auto_msgs__action__PlanTrajectory_SendGoal_Request__create () } } fn destroy_msg (msg : * mut autoware_auto_msgs__action__PlanTrajectory_SendGoal_Request) -> () { unsafe { autoware_auto_msgs__action__PlanTrajectory_SendGoal_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { goal_id : unique_identifier_msgs :: msg :: UUID :: from_native (& msg . goal_id) , goal : autoware_auto_msgs :: action :: PlanTrajectory :: Goal :: from_native (& msg . goal) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . goal_id . copy_to_native (& mut msg . goal_id) ; self . goal . copy_to_native (& mut msg . goal) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub accepted : bool , pub stamp : builtin_interfaces :: msg :: Time } impl WrappedTypesupport for Response { type CStruct = autoware_auto_msgs__action__PlanTrajectory_SendGoal_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__autoware_auto_msgs__action__PlanTrajectory_SendGoal_Response () } } fn create_msg () -> * mut autoware_auto_msgs__action__PlanTrajectory_SendGoal_Response { unsafe { autoware_auto_msgs__action__PlanTrajectory_SendGoal_Response__create () } } fn destroy_msg (msg : * mut autoware_auto_msgs__action__PlanTrajectory_SendGoal_Response) -> () { unsafe { autoware_auto_msgs__action__PlanTrajectory_SendGoal_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { accepted : msg . accepted , stamp : builtin_interfaces :: msg :: Time :: from_native (& msg . stamp) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . accepted = self . accepted ; self . stamp . copy_to_native (& mut msg . stamp) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetResult { use super :: super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__autoware_auto_msgs__action__PlanTrajectory_GetResult () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub goal_id : unique_identifier_msgs :: msg :: UUID } impl WrappedTypesupport for Request { type CStruct = autoware_auto_msgs__action__PlanTrajectory_GetResult_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__autoware_auto_msgs__action__PlanTrajectory_GetResult_Request () } } fn create_msg () -> * mut autoware_auto_msgs__action__PlanTrajectory_GetResult_Request { unsafe { autoware_auto_msgs__action__PlanTrajectory_GetResult_Request__create () } } fn destroy_msg (msg : * mut autoware_auto_msgs__action__PlanTrajectory_GetResult_Request) -> () { unsafe { autoware_auto_msgs__action__PlanTrajectory_GetResult_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { goal_id : unique_identifier_msgs :: msg :: UUID :: from_native (& msg . goal_id) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . goal_id . copy_to_native (& mut msg . goal_id) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub status : i8 , pub result : autoware_auto_msgs :: action :: PlanTrajectory :: Result } impl WrappedTypesupport for Response { type CStruct = autoware_auto_msgs__action__PlanTrajectory_GetResult_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__autoware_auto_msgs__action__PlanTrajectory_GetResult_Response () } } fn create_msg () -> * mut autoware_auto_msgs__action__PlanTrajectory_GetResult_Response { unsafe { autoware_auto_msgs__action__PlanTrajectory_GetResult_Response__create () } } fn destroy_msg (msg : * mut autoware_auto_msgs__action__PlanTrajectory_GetResult_Response) -> () { unsafe { autoware_auto_msgs__action__PlanTrajectory_GetResult_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { status : msg . status , result : autoware_auto_msgs :: action :: PlanTrajectory :: Result :: from_native (& msg . result) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . status = self . status ; self . result . copy_to_native (& mut msg . result) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct FeedbackMessage { pub goal_id : unique_identifier_msgs :: msg :: UUID , pub feedback : autoware_auto_msgs :: action :: PlanTrajectory :: Feedback } impl WrappedTypesupport for FeedbackMessage { type CStruct = autoware_auto_msgs__action__PlanTrajectory_FeedbackMessage ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__autoware_auto_msgs__action__PlanTrajectory_FeedbackMessage () } } fn create_msg () -> * mut autoware_auto_msgs__action__PlanTrajectory_FeedbackMessage { unsafe { autoware_auto_msgs__action__PlanTrajectory_FeedbackMessage__create () } } fn destroy_msg (msg : * mut autoware_auto_msgs__action__PlanTrajectory_FeedbackMessage) -> () { unsafe { autoware_auto_msgs__action__PlanTrajectory_FeedbackMessage__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> FeedbackMessage { FeedbackMessage { goal_id : unique_identifier_msgs :: msg :: UUID :: from_native (& msg . goal_id) , feedback : autoware_auto_msgs :: action :: PlanTrajectory :: Feedback :: from_native (& msg . feedback) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . goal_id . copy_to_native (& mut msg . goal_id) ; self . feedback . copy_to_native (& mut msg . feedback) ; } } impl Default for FeedbackMessage { fn default () -> Self { let msg_native = WrappedNativeMsg :: < FeedbackMessage > :: new () ; FeedbackMessage :: from_native (& msg_native) } } } }