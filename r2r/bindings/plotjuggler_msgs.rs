pub mod msg { use super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct DataPoint { pub name_index : u16 , pub stamp : f64 , pub value : f64 } impl WrappedTypesupport for DataPoint { type CStruct = plotjuggler_msgs__msg__DataPoint ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__plotjuggler_msgs__msg__DataPoint () } } fn create_msg () -> * mut plotjuggler_msgs__msg__DataPoint { unsafe { plotjuggler_msgs__msg__DataPoint__create () } } fn destroy_msg (msg : * mut plotjuggler_msgs__msg__DataPoint) -> () { unsafe { plotjuggler_msgs__msg__DataPoint__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> DataPoint { DataPoint { name_index : msg . name_index , stamp : msg . stamp , value : msg . value , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . name_index = self . name_index ; msg . stamp = self . stamp ; msg . value = self . value ; } } impl Default for DataPoint { fn default () -> Self { let msg_native = WrappedNativeMsg :: < DataPoint > :: new () ; DataPoint :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct DataPoints { pub dictionary_uuid : u32 , pub samples : Vec < plotjuggler_msgs :: msg :: DataPoint > } impl WrappedTypesupport for DataPoints { type CStruct = plotjuggler_msgs__msg__DataPoints ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__plotjuggler_msgs__msg__DataPoints () } } fn create_msg () -> * mut plotjuggler_msgs__msg__DataPoints { unsafe { plotjuggler_msgs__msg__DataPoints__create () } } fn destroy_msg (msg : * mut plotjuggler_msgs__msg__DataPoints) -> () { unsafe { plotjuggler_msgs__msg__DataPoints__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> DataPoints { DataPoints { dictionary_uuid : msg . dictionary_uuid , samples : { let mut temp = Vec :: with_capacity (msg . samples . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . samples . data , msg . samples . size) } ; for s in slice { temp . push (plotjuggler_msgs :: msg :: DataPoint :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . dictionary_uuid = self . dictionary_uuid ; unsafe { plotjuggler_msgs__msg__DataPoint__Sequence__fini (& mut msg . samples) ; plotjuggler_msgs__msg__DataPoint__Sequence__init (& mut msg . samples , self . samples . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . samples . data , msg . samples . size) ; for (t , s) in slice . iter_mut () . zip (& self . samples) { s . copy_to_native (t) ; } } } } impl Default for DataPoints { fn default () -> Self { let msg_native = WrappedNativeMsg :: < DataPoints > :: new () ; DataPoints :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Dictionary { pub dictionary_uuid : u32 , pub names : Vec < std :: string :: String > } impl WrappedTypesupport for Dictionary { type CStruct = plotjuggler_msgs__msg__Dictionary ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__plotjuggler_msgs__msg__Dictionary () } } fn create_msg () -> * mut plotjuggler_msgs__msg__Dictionary { unsafe { plotjuggler_msgs__msg__Dictionary__create () } } fn destroy_msg (msg : * mut plotjuggler_msgs__msg__Dictionary) -> () { unsafe { plotjuggler_msgs__msg__Dictionary__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Dictionary { Dictionary { dictionary_uuid : msg . dictionary_uuid , names : msg . names . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . dictionary_uuid = self . dictionary_uuid ; msg . names . update (& self . names) ; } } impl Default for Dictionary { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Dictionary > :: new () ; Dictionary :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct StatisticsNames { pub header : std_msgs :: msg :: Header , pub names : Vec < std :: string :: String > , pub names_version : u32 } impl WrappedTypesupport for StatisticsNames { type CStruct = plotjuggler_msgs__msg__StatisticsNames ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__plotjuggler_msgs__msg__StatisticsNames () } } fn create_msg () -> * mut plotjuggler_msgs__msg__StatisticsNames { unsafe { plotjuggler_msgs__msg__StatisticsNames__create () } } fn destroy_msg (msg : * mut plotjuggler_msgs__msg__StatisticsNames) -> () { unsafe { plotjuggler_msgs__msg__StatisticsNames__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> StatisticsNames { StatisticsNames { header : std_msgs :: msg :: Header :: from_native (& msg . header) , names : msg . names . to_vec () , names_version : msg . names_version , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . names . update (& self . names) ; msg . names_version = self . names_version ; } } impl Default for StatisticsNames { fn default () -> Self { let msg_native = WrappedNativeMsg :: < StatisticsNames > :: new () ; StatisticsNames :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct StatisticsValues { pub header : std_msgs :: msg :: Header , pub values : Vec < f64 > , pub names_version : u32 } impl WrappedTypesupport for StatisticsValues { type CStruct = plotjuggler_msgs__msg__StatisticsValues ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__plotjuggler_msgs__msg__StatisticsValues () } } fn create_msg () -> * mut plotjuggler_msgs__msg__StatisticsValues { unsafe { plotjuggler_msgs__msg__StatisticsValues__create () } } fn destroy_msg (msg : * mut plotjuggler_msgs__msg__StatisticsValues) -> () { unsafe { plotjuggler_msgs__msg__StatisticsValues__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> StatisticsValues { StatisticsValues { header : std_msgs :: msg :: Header :: from_native (& msg . header) , values : msg . values . to_vec () , names_version : msg . names_version , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . values . update (& self . values) ; msg . names_version = self . names_version ; } } impl Default for StatisticsValues { fn default () -> Self { let msg_native = WrappedNativeMsg :: < StatisticsValues > :: new () ; StatisticsValues :: from_native (& msg_native) } } }