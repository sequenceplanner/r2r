pub mod msg { use super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct BasicIdl { pub x : f32 } impl WrappedTypesupport for BasicIdl { type CStruct = rosbag2_storage_mcap_testdata__msg__BasicIdl ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rosbag2_storage_mcap_testdata__msg__BasicIdl () } } fn create_msg () -> * mut rosbag2_storage_mcap_testdata__msg__BasicIdl { unsafe { rosbag2_storage_mcap_testdata__msg__BasicIdl__create () } } fn destroy_msg (msg : * mut rosbag2_storage_mcap_testdata__msg__BasicIdl) -> () { unsafe { rosbag2_storage_mcap_testdata__msg__BasicIdl__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> BasicIdl { BasicIdl { x : msg . x , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . x = self . x ; } } impl Default for BasicIdl { fn default () -> Self { let msg_native = WrappedNativeMsg :: < BasicIdl > :: new () ; BasicIdl :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct BasicMsg { pub c : f32 } impl WrappedTypesupport for BasicMsg { type CStruct = rosbag2_storage_mcap_testdata__msg__BasicMsg ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rosbag2_storage_mcap_testdata__msg__BasicMsg () } } fn create_msg () -> * mut rosbag2_storage_mcap_testdata__msg__BasicMsg { unsafe { rosbag2_storage_mcap_testdata__msg__BasicMsg__create () } } fn destroy_msg (msg : * mut rosbag2_storage_mcap_testdata__msg__BasicMsg) -> () { unsafe { rosbag2_storage_mcap_testdata__msg__BasicMsg__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> BasicMsg { BasicMsg { c : msg . c , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . c = self . c ; } } impl Default for BasicMsg { fn default () -> Self { let msg_native = WrappedNativeMsg :: < BasicMsg > :: new () ; BasicMsg :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ComplexIdl { pub a : rosbag2_storage_mcap_testdata :: msg :: BasicIdl } impl WrappedTypesupport for ComplexIdl { type CStruct = rosbag2_storage_mcap_testdata__msg__ComplexIdl ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rosbag2_storage_mcap_testdata__msg__ComplexIdl () } } fn create_msg () -> * mut rosbag2_storage_mcap_testdata__msg__ComplexIdl { unsafe { rosbag2_storage_mcap_testdata__msg__ComplexIdl__create () } } fn destroy_msg (msg : * mut rosbag2_storage_mcap_testdata__msg__ComplexIdl) -> () { unsafe { rosbag2_storage_mcap_testdata__msg__ComplexIdl__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ComplexIdl { ComplexIdl { a : rosbag2_storage_mcap_testdata :: msg :: BasicIdl :: from_native (& msg . a) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . a . copy_to_native (& mut msg . a) ; } } impl Default for ComplexIdl { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ComplexIdl > :: new () ; ComplexIdl :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ComplexMsg { pub b : rosbag2_storage_mcap_testdata :: msg :: BasicMsg } impl WrappedTypesupport for ComplexMsg { type CStruct = rosbag2_storage_mcap_testdata__msg__ComplexMsg ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rosbag2_storage_mcap_testdata__msg__ComplexMsg () } } fn create_msg () -> * mut rosbag2_storage_mcap_testdata__msg__ComplexMsg { unsafe { rosbag2_storage_mcap_testdata__msg__ComplexMsg__create () } } fn destroy_msg (msg : * mut rosbag2_storage_mcap_testdata__msg__ComplexMsg) -> () { unsafe { rosbag2_storage_mcap_testdata__msg__ComplexMsg__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ComplexMsg { ComplexMsg { b : rosbag2_storage_mcap_testdata :: msg :: BasicMsg :: from_native (& msg . b) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . b . copy_to_native (& mut msg . b) ; } } impl Default for ComplexMsg { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ComplexMsg > :: new () ; ComplexMsg :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ComplexMsgDependsOnIdl { pub a : rosbag2_storage_mcap_testdata :: msg :: BasicIdl } impl WrappedTypesupport for ComplexMsgDependsOnIdl { type CStruct = rosbag2_storage_mcap_testdata__msg__ComplexMsgDependsOnIdl ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rosbag2_storage_mcap_testdata__msg__ComplexMsgDependsOnIdl () } } fn create_msg () -> * mut rosbag2_storage_mcap_testdata__msg__ComplexMsgDependsOnIdl { unsafe { rosbag2_storage_mcap_testdata__msg__ComplexMsgDependsOnIdl__create () } } fn destroy_msg (msg : * mut rosbag2_storage_mcap_testdata__msg__ComplexMsgDependsOnIdl) -> () { unsafe { rosbag2_storage_mcap_testdata__msg__ComplexMsgDependsOnIdl__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ComplexMsgDependsOnIdl { ComplexMsgDependsOnIdl { a : rosbag2_storage_mcap_testdata :: msg :: BasicIdl :: from_native (& msg . a) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . a . copy_to_native (& mut msg . a) ; } } impl Default for ComplexMsgDependsOnIdl { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ComplexMsgDependsOnIdl > :: new () ; ComplexMsgDependsOnIdl :: from_native (& msg_native) } } }