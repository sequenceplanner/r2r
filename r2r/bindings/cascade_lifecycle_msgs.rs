pub mod msg { use super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Activation { pub operation_type : u8 , pub activator : std :: string :: String , pub activation : std :: string :: String } impl WrappedTypesupport for Activation { type CStruct = cascade_lifecycle_msgs__msg__Activation ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__cascade_lifecycle_msgs__msg__Activation () } } fn create_msg () -> * mut cascade_lifecycle_msgs__msg__Activation { unsafe { cascade_lifecycle_msgs__msg__Activation__create () } } fn destroy_msg (msg : * mut cascade_lifecycle_msgs__msg__Activation) -> () { unsafe { cascade_lifecycle_msgs__msg__Activation__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Activation { Activation { operation_type : msg . operation_type , activator : msg . activator . to_str () . to_owned () , activation : msg . activation . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . operation_type = self . operation_type ; msg . activator . assign (& self . activator) ; msg . activation . assign (& self . activation) ; } } impl Default for Activation { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Activation > :: new () ; Activation :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl Activation { pub const ADD : _bindgen_ty_147 = cascade_lifecycle_msgs__msg__Activation__ADD ; pub const REMOVE : _bindgen_ty_148 = cascade_lifecycle_msgs__msg__Activation__REMOVE ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct State { pub state : u8 , pub node_name : std :: string :: String } impl WrappedTypesupport for State { type CStruct = cascade_lifecycle_msgs__msg__State ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__cascade_lifecycle_msgs__msg__State () } } fn create_msg () -> * mut cascade_lifecycle_msgs__msg__State { unsafe { cascade_lifecycle_msgs__msg__State__create () } } fn destroy_msg (msg : * mut cascade_lifecycle_msgs__msg__State) -> () { unsafe { cascade_lifecycle_msgs__msg__State__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> State { State { state : msg . state , node_name : msg . node_name . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . state = self . state ; msg . node_name . assign (& self . node_name) ; } } impl Default for State { fn default () -> Self { let msg_native = WrappedNativeMsg :: < State > :: new () ; State :: from_native (& msg_native) } } }