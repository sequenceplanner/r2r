pub mod msg { use super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Ball { pub header : std_msgs :: msg :: Header , pub center : geometry_msgs :: msg :: Point } impl WrappedTypesupport for Ball { type CStruct = soccer_object_msgs__msg__Ball ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__soccer_object_msgs__msg__Ball () } } fn create_msg () -> * mut soccer_object_msgs__msg__Ball { unsafe { soccer_object_msgs__msg__Ball__create () } } fn destroy_msg (msg : * mut soccer_object_msgs__msg__Ball) -> () { unsafe { soccer_object_msgs__msg__Ball__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Ball { Ball { header : std_msgs :: msg :: Header :: from_native (& msg . header) , center : geometry_msgs :: msg :: Point :: from_native (& msg . center) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; self . center . copy_to_native (& mut msg . center) ; } } impl Default for Ball { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Ball > :: new () ; Ball :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct FieldLine { pub header : std_msgs :: msg :: Header , pub start : geometry_msgs :: msg :: Point , pub end : geometry_msgs :: msg :: Point } impl WrappedTypesupport for FieldLine { type CStruct = soccer_object_msgs__msg__FieldLine ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__soccer_object_msgs__msg__FieldLine () } } fn create_msg () -> * mut soccer_object_msgs__msg__FieldLine { unsafe { soccer_object_msgs__msg__FieldLine__create () } } fn destroy_msg (msg : * mut soccer_object_msgs__msg__FieldLine) -> () { unsafe { soccer_object_msgs__msg__FieldLine__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> FieldLine { FieldLine { header : std_msgs :: msg :: Header :: from_native (& msg . header) , start : geometry_msgs :: msg :: Point :: from_native (& msg . start) , end : geometry_msgs :: msg :: Point :: from_native (& msg . end) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; self . start . copy_to_native (& mut msg . start) ; self . end . copy_to_native (& mut msg . end) ; } } impl Default for FieldLine { fn default () -> Self { let msg_native = WrappedNativeMsg :: < FieldLine > :: new () ; FieldLine :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct FieldLineArray { pub lines : Vec < soccer_object_msgs :: msg :: FieldLine > } impl WrappedTypesupport for FieldLineArray { type CStruct = soccer_object_msgs__msg__FieldLineArray ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__soccer_object_msgs__msg__FieldLineArray () } } fn create_msg () -> * mut soccer_object_msgs__msg__FieldLineArray { unsafe { soccer_object_msgs__msg__FieldLineArray__create () } } fn destroy_msg (msg : * mut soccer_object_msgs__msg__FieldLineArray) -> () { unsafe { soccer_object_msgs__msg__FieldLineArray__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> FieldLineArray { FieldLineArray { lines : { let mut temp = Vec :: with_capacity (msg . lines . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . lines . data , msg . lines . size) } ; for s in slice { temp . push (soccer_object_msgs :: msg :: FieldLine :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { unsafe { soccer_object_msgs__msg__FieldLine__Sequence__fini (& mut msg . lines) ; soccer_object_msgs__msg__FieldLine__Sequence__init (& mut msg . lines , self . lines . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . lines . data , msg . lines . size) ; for (t , s) in slice . iter_mut () . zip (& self . lines) { s . copy_to_native (t) ; } } } } impl Default for FieldLineArray { fn default () -> Self { let msg_native = WrappedNativeMsg :: < FieldLineArray > :: new () ; FieldLineArray :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Flag { pub header : std_msgs :: msg :: Header , pub base : geometry_msgs :: msg :: Point } impl WrappedTypesupport for Flag { type CStruct = soccer_object_msgs__msg__Flag ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__soccer_object_msgs__msg__Flag () } } fn create_msg () -> * mut soccer_object_msgs__msg__Flag { unsafe { soccer_object_msgs__msg__Flag__create () } } fn destroy_msg (msg : * mut soccer_object_msgs__msg__Flag) -> () { unsafe { soccer_object_msgs__msg__Flag__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Flag { Flag { header : std_msgs :: msg :: Header :: from_native (& msg . header) , base : geometry_msgs :: msg :: Point :: from_native (& msg . base) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; self . base . copy_to_native (& mut msg . base) ; } } impl Default for Flag { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Flag > :: new () ; Flag :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct FlagArray { pub flags : Vec < soccer_object_msgs :: msg :: Flag > } impl WrappedTypesupport for FlagArray { type CStruct = soccer_object_msgs__msg__FlagArray ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__soccer_object_msgs__msg__FlagArray () } } fn create_msg () -> * mut soccer_object_msgs__msg__FlagArray { unsafe { soccer_object_msgs__msg__FlagArray__create () } } fn destroy_msg (msg : * mut soccer_object_msgs__msg__FlagArray) -> () { unsafe { soccer_object_msgs__msg__FlagArray__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> FlagArray { FlagArray { flags : { let mut temp = Vec :: with_capacity (msg . flags . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . flags . data , msg . flags . size) } ; for s in slice { temp . push (soccer_object_msgs :: msg :: Flag :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { unsafe { soccer_object_msgs__msg__Flag__Sequence__fini (& mut msg . flags) ; soccer_object_msgs__msg__Flag__Sequence__init (& mut msg . flags , self . flags . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . flags . data , msg . flags . size) ; for (t , s) in slice . iter_mut () . zip (& self . flags) { s . copy_to_native (t) ; } } } } impl Default for FlagArray { fn default () -> Self { let msg_native = WrappedNativeMsg :: < FlagArray > :: new () ; FlagArray :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Goalpost { pub header : std_msgs :: msg :: Header , pub observed_top : bool , pub point : geometry_msgs :: msg :: Point } impl WrappedTypesupport for Goalpost { type CStruct = soccer_object_msgs__msg__Goalpost ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__soccer_object_msgs__msg__Goalpost () } } fn create_msg () -> * mut soccer_object_msgs__msg__Goalpost { unsafe { soccer_object_msgs__msg__Goalpost__create () } } fn destroy_msg (msg : * mut soccer_object_msgs__msg__Goalpost) -> () { unsafe { soccer_object_msgs__msg__Goalpost__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Goalpost { Goalpost { header : std_msgs :: msg :: Header :: from_native (& msg . header) , observed_top : msg . observed_top , point : geometry_msgs :: msg :: Point :: from_native (& msg . point) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . observed_top = self . observed_top ; self . point . copy_to_native (& mut msg . point) ; } } impl Default for Goalpost { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Goalpost > :: new () ; Goalpost :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct GoalpostArray { pub posts : Vec < soccer_object_msgs :: msg :: Goalpost > } impl WrappedTypesupport for GoalpostArray { type CStruct = soccer_object_msgs__msg__GoalpostArray ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__soccer_object_msgs__msg__GoalpostArray () } } fn create_msg () -> * mut soccer_object_msgs__msg__GoalpostArray { unsafe { soccer_object_msgs__msg__GoalpostArray__create () } } fn destroy_msg (msg : * mut soccer_object_msgs__msg__GoalpostArray) -> () { unsafe { soccer_object_msgs__msg__GoalpostArray__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> GoalpostArray { GoalpostArray { posts : { let mut temp = Vec :: with_capacity (msg . posts . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . posts . data , msg . posts . size) } ; for s in slice { temp . push (soccer_object_msgs :: msg :: Goalpost :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { unsafe { soccer_object_msgs__msg__Goalpost__Sequence__fini (& mut msg . posts) ; soccer_object_msgs__msg__Goalpost__Sequence__init (& mut msg . posts , self . posts . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . posts . data , msg . posts . size) ; for (t , s) in slice . iter_mut () . zip (& self . posts) { s . copy_to_native (t) ; } } } } impl Default for GoalpostArray { fn default () -> Self { let msg_native = WrappedNativeMsg :: < GoalpostArray > :: new () ; GoalpostArray :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Robot { pub header : std_msgs :: msg :: Header , pub head : geometry_msgs :: msg :: Point , pub team : std :: string :: String , pub id : i32 } impl WrappedTypesupport for Robot { type CStruct = soccer_object_msgs__msg__Robot ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__soccer_object_msgs__msg__Robot () } } fn create_msg () -> * mut soccer_object_msgs__msg__Robot { unsafe { soccer_object_msgs__msg__Robot__create () } } fn destroy_msg (msg : * mut soccer_object_msgs__msg__Robot) -> () { unsafe { soccer_object_msgs__msg__Robot__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Robot { Robot { header : std_msgs :: msg :: Header :: from_native (& msg . header) , head : geometry_msgs :: msg :: Point :: from_native (& msg . head) , team : msg . team . to_str () . to_owned () , id : msg . id , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; self . head . copy_to_native (& mut msg . head) ; msg . team . assign (& self . team) ; msg . id = self . id ; } } impl Default for Robot { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Robot > :: new () ; Robot :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct RobotArray { pub robots : Vec < soccer_object_msgs :: msg :: Robot > } impl WrappedTypesupport for RobotArray { type CStruct = soccer_object_msgs__msg__RobotArray ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__soccer_object_msgs__msg__RobotArray () } } fn create_msg () -> * mut soccer_object_msgs__msg__RobotArray { unsafe { soccer_object_msgs__msg__RobotArray__create () } } fn destroy_msg (msg : * mut soccer_object_msgs__msg__RobotArray) -> () { unsafe { soccer_object_msgs__msg__RobotArray__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> RobotArray { RobotArray { robots : { let mut temp = Vec :: with_capacity (msg . robots . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . robots . data , msg . robots . size) } ; for s in slice { temp . push (soccer_object_msgs :: msg :: Robot :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { unsafe { soccer_object_msgs__msg__Robot__Sequence__fini (& mut msg . robots) ; soccer_object_msgs__msg__Robot__Sequence__init (& mut msg . robots , self . robots . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . robots . data , msg . robots . size) ; for (t , s) in slice . iter_mut () . zip (& self . robots) { s . copy_to_native (t) ; } } } } impl Default for RobotArray { fn default () -> Self { let msg_native = WrappedNativeMsg :: < RobotArray > :: new () ; RobotArray :: from_native (& msg_native) } } }