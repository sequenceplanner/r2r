pub mod msg { use super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Action { pub name : std :: string :: String , pub parameters : Vec < plansys2_msgs :: msg :: Param > , pub preconditions : plansys2_msgs :: msg :: Tree , pub effects : plansys2_msgs :: msg :: Tree } impl WrappedTypesupport for Action { type CStruct = plansys2_msgs__msg__Action ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__plansys2_msgs__msg__Action () } } fn create_msg () -> * mut plansys2_msgs__msg__Action { unsafe { plansys2_msgs__msg__Action__create () } } fn destroy_msg (msg : * mut plansys2_msgs__msg__Action) -> () { unsafe { plansys2_msgs__msg__Action__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Action { Action { name : msg . name . to_str () . to_owned () , parameters : { let mut temp = Vec :: with_capacity (msg . parameters . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . parameters . data , msg . parameters . size) } ; for s in slice { temp . push (plansys2_msgs :: msg :: Param :: from_native (s)) ; } temp } , preconditions : plansys2_msgs :: msg :: Tree :: from_native (& msg . preconditions) , effects : plansys2_msgs :: msg :: Tree :: from_native (& msg . effects) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . name . assign (& self . name) ; unsafe { plansys2_msgs__msg__Param__Sequence__fini (& mut msg . parameters) ; plansys2_msgs__msg__Param__Sequence__init (& mut msg . parameters , self . parameters . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . parameters . data , msg . parameters . size) ; for (t , s) in slice . iter_mut () . zip (& self . parameters) { s . copy_to_native (t) ; } } self . preconditions . copy_to_native (& mut msg . preconditions) ; self . effects . copy_to_native (& mut msg . effects) ; } } impl Default for Action { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Action > :: new () ; Action :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ActionExecution { # [serde (rename = "type")] pub type_ : i16 , pub node_id : std :: string :: String , pub action : std :: string :: String , pub arguments : Vec < std :: string :: String > , pub success : bool , pub completion : f32 , pub status : std :: string :: String } impl WrappedTypesupport for ActionExecution { type CStruct = plansys2_msgs__msg__ActionExecution ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__plansys2_msgs__msg__ActionExecution () } } fn create_msg () -> * mut plansys2_msgs__msg__ActionExecution { unsafe { plansys2_msgs__msg__ActionExecution__create () } } fn destroy_msg (msg : * mut plansys2_msgs__msg__ActionExecution) -> () { unsafe { plansys2_msgs__msg__ActionExecution__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ActionExecution { ActionExecution { type_ : msg . type_ , node_id : msg . node_id . to_str () . to_owned () , action : msg . action . to_str () . to_owned () , arguments : msg . arguments . to_vec () , success : msg . success , completion : msg . completion , status : msg . status . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . type_ = self . type_ ; msg . node_id . assign (& self . node_id) ; msg . action . assign (& self . action) ; msg . arguments . update (& self . arguments) ; msg . success = self . success ; msg . completion = self . completion ; msg . status . assign (& self . status) ; } } impl Default for ActionExecution { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ActionExecution > :: new () ; ActionExecution :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl ActionExecution { pub const CANCEL : _bindgen_ty_1410 = plansys2_msgs__msg__ActionExecution__CANCEL ; pub const CONFIRM : _bindgen_ty_1406 = plansys2_msgs__msg__ActionExecution__CONFIRM ; pub const FEEDBACK : _bindgen_ty_1408 = plansys2_msgs__msg__ActionExecution__FEEDBACK ; pub const FINISH : _bindgen_ty_1409 = plansys2_msgs__msg__ActionExecution__FINISH ; pub const REJECT : _bindgen_ty_1407 = plansys2_msgs__msg__ActionExecution__REJECT ; pub const REQUEST : _bindgen_ty_1404 = plansys2_msgs__msg__ActionExecution__REQUEST ; pub const RESPONSE : _bindgen_ty_1405 = plansys2_msgs__msg__ActionExecution__RESPONSE ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ActionExecutionInfo { pub status : i8 , pub start_stamp : builtin_interfaces :: msg :: Time , pub status_stamp : builtin_interfaces :: msg :: Time , pub action_full_name : std :: string :: String , pub action : std :: string :: String , pub arguments : Vec < std :: string :: String > , pub duration : builtin_interfaces :: msg :: Duration , pub completion : f32 , pub message_status : std :: string :: String } impl WrappedTypesupport for ActionExecutionInfo { type CStruct = plansys2_msgs__msg__ActionExecutionInfo ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__plansys2_msgs__msg__ActionExecutionInfo () } } fn create_msg () -> * mut plansys2_msgs__msg__ActionExecutionInfo { unsafe { plansys2_msgs__msg__ActionExecutionInfo__create () } } fn destroy_msg (msg : * mut plansys2_msgs__msg__ActionExecutionInfo) -> () { unsafe { plansys2_msgs__msg__ActionExecutionInfo__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ActionExecutionInfo { ActionExecutionInfo { status : msg . status , start_stamp : builtin_interfaces :: msg :: Time :: from_native (& msg . start_stamp) , status_stamp : builtin_interfaces :: msg :: Time :: from_native (& msg . status_stamp) , action_full_name : msg . action_full_name . to_str () . to_owned () , action : msg . action . to_str () . to_owned () , arguments : msg . arguments . to_vec () , duration : builtin_interfaces :: msg :: Duration :: from_native (& msg . duration) , completion : msg . completion , message_status : msg . message_status . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . status = self . status ; self . start_stamp . copy_to_native (& mut msg . start_stamp) ; self . status_stamp . copy_to_native (& mut msg . status_stamp) ; msg . action_full_name . assign (& self . action_full_name) ; msg . action . assign (& self . action) ; msg . arguments . update (& self . arguments) ; self . duration . copy_to_native (& mut msg . duration) ; msg . completion = self . completion ; msg . message_status . assign (& self . message_status) ; } } impl Default for ActionExecutionInfo { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ActionExecutionInfo > :: new () ; ActionExecutionInfo :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl ActionExecutionInfo { pub const CANCELLED : _bindgen_ty_1379 = plansys2_msgs__msg__ActionExecutionInfo__CANCELLED ; pub const EXECUTING : _bindgen_ty_1376 = plansys2_msgs__msg__ActionExecutionInfo__EXECUTING ; pub const FAILED : _bindgen_ty_1377 = plansys2_msgs__msg__ActionExecutionInfo__FAILED ; pub const NOT_EXECUTED : _bindgen_ty_1375 = plansys2_msgs__msg__ActionExecutionInfo__NOT_EXECUTED ; pub const SUCCEEDED : _bindgen_ty_1378 = plansys2_msgs__msg__ActionExecutionInfo__SUCCEEDED ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ActionPerformerStatus { pub status_stamp : builtin_interfaces :: msg :: Time , pub state : i8 , pub action : std :: string :: String , pub specialized_arguments : Vec < std :: string :: String > , pub node_name : std :: string :: String } impl WrappedTypesupport for ActionPerformerStatus { type CStruct = plansys2_msgs__msg__ActionPerformerStatus ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__plansys2_msgs__msg__ActionPerformerStatus () } } fn create_msg () -> * mut plansys2_msgs__msg__ActionPerformerStatus { unsafe { plansys2_msgs__msg__ActionPerformerStatus__create () } } fn destroy_msg (msg : * mut plansys2_msgs__msg__ActionPerformerStatus) -> () { unsafe { plansys2_msgs__msg__ActionPerformerStatus__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ActionPerformerStatus { ActionPerformerStatus { status_stamp : builtin_interfaces :: msg :: Time :: from_native (& msg . status_stamp) , state : msg . state , action : msg . action . to_str () . to_owned () , specialized_arguments : msg . specialized_arguments . to_vec () , node_name : msg . node_name . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . status_stamp . copy_to_native (& mut msg . status_stamp) ; msg . state = self . state ; msg . action . assign (& self . action) ; msg . specialized_arguments . update (& self . specialized_arguments) ; msg . node_name . assign (& self . node_name) ; } } impl Default for ActionPerformerStatus { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ActionPerformerStatus > :: new () ; ActionPerformerStatus :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl ActionPerformerStatus { pub const FAILURE : _bindgen_ty_1414 = plansys2_msgs__msg__ActionPerformerStatus__FAILURE ; pub const NOT_READY : _bindgen_ty_1411 = plansys2_msgs__msg__ActionPerformerStatus__NOT_READY ; pub const READY : _bindgen_ty_1412 = plansys2_msgs__msg__ActionPerformerStatus__READY ; pub const RUNNING : _bindgen_ty_1413 = plansys2_msgs__msg__ActionPerformerStatus__RUNNING ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct DurativeAction { pub name : std :: string :: String , pub parameters : Vec < plansys2_msgs :: msg :: Param > , pub at_start_requirements : plansys2_msgs :: msg :: Tree , pub over_all_requirements : plansys2_msgs :: msg :: Tree , pub at_end_requirements : plansys2_msgs :: msg :: Tree , pub at_start_effects : plansys2_msgs :: msg :: Tree , pub at_end_effects : plansys2_msgs :: msg :: Tree } impl WrappedTypesupport for DurativeAction { type CStruct = plansys2_msgs__msg__DurativeAction ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__plansys2_msgs__msg__DurativeAction () } } fn create_msg () -> * mut plansys2_msgs__msg__DurativeAction { unsafe { plansys2_msgs__msg__DurativeAction__create () } } fn destroy_msg (msg : * mut plansys2_msgs__msg__DurativeAction) -> () { unsafe { plansys2_msgs__msg__DurativeAction__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> DurativeAction { DurativeAction { name : msg . name . to_str () . to_owned () , parameters : { let mut temp = Vec :: with_capacity (msg . parameters . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . parameters . data , msg . parameters . size) } ; for s in slice { temp . push (plansys2_msgs :: msg :: Param :: from_native (s)) ; } temp } , at_start_requirements : plansys2_msgs :: msg :: Tree :: from_native (& msg . at_start_requirements) , over_all_requirements : plansys2_msgs :: msg :: Tree :: from_native (& msg . over_all_requirements) , at_end_requirements : plansys2_msgs :: msg :: Tree :: from_native (& msg . at_end_requirements) , at_start_effects : plansys2_msgs :: msg :: Tree :: from_native (& msg . at_start_effects) , at_end_effects : plansys2_msgs :: msg :: Tree :: from_native (& msg . at_end_effects) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . name . assign (& self . name) ; unsafe { plansys2_msgs__msg__Param__Sequence__fini (& mut msg . parameters) ; plansys2_msgs__msg__Param__Sequence__init (& mut msg . parameters , self . parameters . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . parameters . data , msg . parameters . size) ; for (t , s) in slice . iter_mut () . zip (& self . parameters) { s . copy_to_native (t) ; } } self . at_start_requirements . copy_to_native (& mut msg . at_start_requirements) ; self . over_all_requirements . copy_to_native (& mut msg . over_all_requirements) ; self . at_end_requirements . copy_to_native (& mut msg . at_end_requirements) ; self . at_start_effects . copy_to_native (& mut msg . at_start_effects) ; self . at_end_effects . copy_to_native (& mut msg . at_end_effects) ; } } impl Default for DurativeAction { fn default () -> Self { let msg_native = WrappedNativeMsg :: < DurativeAction > :: new () ; DurativeAction :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Knowledge { pub instances : Vec < std :: string :: String > , pub predicates : Vec < std :: string :: String > , pub functions : Vec < std :: string :: String > , pub goal : std :: string :: String } impl WrappedTypesupport for Knowledge { type CStruct = plansys2_msgs__msg__Knowledge ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__plansys2_msgs__msg__Knowledge () } } fn create_msg () -> * mut plansys2_msgs__msg__Knowledge { unsafe { plansys2_msgs__msg__Knowledge__create () } } fn destroy_msg (msg : * mut plansys2_msgs__msg__Knowledge) -> () { unsafe { plansys2_msgs__msg__Knowledge__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Knowledge { Knowledge { instances : msg . instances . to_vec () , predicates : msg . predicates . to_vec () , functions : msg . functions . to_vec () , goal : msg . goal . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . instances . update (& self . instances) ; msg . predicates . update (& self . predicates) ; msg . functions . update (& self . functions) ; msg . goal . assign (& self . goal) ; } } impl Default for Knowledge { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Knowledge > :: new () ; Knowledge :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Node { pub node_type : u8 , pub expression_type : u8 , pub modifier_type : u8 , pub node_id : u32 , pub children : Vec < u32 > , pub name : std :: string :: String , pub parameters : Vec < plansys2_msgs :: msg :: Param > , pub value : f64 , pub negate : bool } impl WrappedTypesupport for Node { type CStruct = plansys2_msgs__msg__Node ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__plansys2_msgs__msg__Node () } } fn create_msg () -> * mut plansys2_msgs__msg__Node { unsafe { plansys2_msgs__msg__Node__create () } } fn destroy_msg (msg : * mut plansys2_msgs__msg__Node) -> () { unsafe { plansys2_msgs__msg__Node__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Node { Node { node_type : msg . node_type , expression_type : msg . expression_type , modifier_type : msg . modifier_type , node_id : msg . node_id , children : msg . children . to_vec () , name : msg . name . to_str () . to_owned () , parameters : { let mut temp = Vec :: with_capacity (msg . parameters . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . parameters . data , msg . parameters . size) } ; for s in slice { temp . push (plansys2_msgs :: msg :: Param :: from_native (s)) ; } temp } , value : msg . value , negate : msg . negate , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . node_type = self . node_type ; msg . expression_type = self . expression_type ; msg . modifier_type = self . modifier_type ; msg . node_id = self . node_id ; msg . children . update (& self . children) ; msg . name . assign (& self . name) ; unsafe { plansys2_msgs__msg__Param__Sequence__fini (& mut msg . parameters) ; plansys2_msgs__msg__Param__Sequence__init (& mut msg . parameters , self . parameters . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . parameters . data , msg . parameters . size) ; for (t , s) in slice . iter_mut () . zip (& self . parameters) { s . copy_to_native (t) ; } } msg . value = self . value ; msg . negate = self . negate ; } } impl Default for Node { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Node > :: new () ; Node :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl Node { pub const ACTION : _bindgen_ty_1384 = plansys2_msgs__msg__Node__ACTION ; pub const AND : _bindgen_ty_1381 = plansys2_msgs__msg__Node__AND ; pub const ARITH_ADD : _bindgen_ty_1397 = plansys2_msgs__msg__Node__ARITH_ADD ; pub const ARITH_DIV : _bindgen_ty_1396 = plansys2_msgs__msg__Node__ARITH_DIV ; pub const ARITH_MULT : _bindgen_ty_1395 = plansys2_msgs__msg__Node__ARITH_MULT ; pub const ARITH_SUB : _bindgen_ty_1398 = plansys2_msgs__msg__Node__ARITH_SUB ; pub const ASSIGN : _bindgen_ty_1399 = plansys2_msgs__msg__Node__ASSIGN ; pub const COMP_EQ : _bindgen_ty_1390 = plansys2_msgs__msg__Node__COMP_EQ ; pub const COMP_GE : _bindgen_ty_1391 = plansys2_msgs__msg__Node__COMP_GE ; pub const COMP_GT : _bindgen_ty_1392 = plansys2_msgs__msg__Node__COMP_GT ; pub const COMP_LE : _bindgen_ty_1393 = plansys2_msgs__msg__Node__COMP_LE ; pub const COMP_LT : _bindgen_ty_1394 = plansys2_msgs__msg__Node__COMP_LT ; pub const DECREASE : _bindgen_ty_1401 = plansys2_msgs__msg__Node__DECREASE ; pub const EXPRESSION : _bindgen_ty_1387 = plansys2_msgs__msg__Node__EXPRESSION ; pub const FUNCTION : _bindgen_ty_1386 = plansys2_msgs__msg__Node__FUNCTION ; pub const FUNCTION_MODIFIER : _bindgen_ty_1388 = plansys2_msgs__msg__Node__FUNCTION_MODIFIER ; pub const INCREASE : _bindgen_ty_1400 = plansys2_msgs__msg__Node__INCREASE ; pub const NOT : _bindgen_ty_1383 = plansys2_msgs__msg__Node__NOT ; pub const NUMBER : _bindgen_ty_1389 = plansys2_msgs__msg__Node__NUMBER ; pub const OR : _bindgen_ty_1382 = plansys2_msgs__msg__Node__OR ; pub const PREDICATE : _bindgen_ty_1385 = plansys2_msgs__msg__Node__PREDICATE ; pub const SCALE_DOWN : _bindgen_ty_1403 = plansys2_msgs__msg__Node__SCALE_DOWN ; pub const SCALE_UP : _bindgen_ty_1402 = plansys2_msgs__msg__Node__SCALE_UP ; pub const UNKNOWN : _bindgen_ty_1380 = plansys2_msgs__msg__Node__UNKNOWN ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Param { pub name : std :: string :: String , # [serde (rename = "type")] pub type_ : std :: string :: String , pub sub_types : Vec < std :: string :: String > } impl WrappedTypesupport for Param { type CStruct = plansys2_msgs__msg__Param ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__plansys2_msgs__msg__Param () } } fn create_msg () -> * mut plansys2_msgs__msg__Param { unsafe { plansys2_msgs__msg__Param__create () } } fn destroy_msg (msg : * mut plansys2_msgs__msg__Param) -> () { unsafe { plansys2_msgs__msg__Param__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Param { Param { name : msg . name . to_str () . to_owned () , type_ : msg . type_ . to_str () . to_owned () , sub_types : msg . sub_types . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . name . assign (& self . name) ; msg . type_ . assign (& self . type_) ; msg . sub_types . update (& self . sub_types) ; } } impl Default for Param { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Param > :: new () ; Param :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Plan { pub items : Vec < plansys2_msgs :: msg :: PlanItem > } impl WrappedTypesupport for Plan { type CStruct = plansys2_msgs__msg__Plan ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__plansys2_msgs__msg__Plan () } } fn create_msg () -> * mut plansys2_msgs__msg__Plan { unsafe { plansys2_msgs__msg__Plan__create () } } fn destroy_msg (msg : * mut plansys2_msgs__msg__Plan) -> () { unsafe { plansys2_msgs__msg__Plan__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Plan { Plan { items : { let mut temp = Vec :: with_capacity (msg . items . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . items . data , msg . items . size) } ; for s in slice { temp . push (plansys2_msgs :: msg :: PlanItem :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { unsafe { plansys2_msgs__msg__PlanItem__Sequence__fini (& mut msg . items) ; plansys2_msgs__msg__PlanItem__Sequence__init (& mut msg . items , self . items . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . items . data , msg . items . size) ; for (t , s) in slice . iter_mut () . zip (& self . items) { s . copy_to_native (t) ; } } } } impl Default for Plan { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Plan > :: new () ; Plan :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct PlanItem { pub time : f32 , pub action : std :: string :: String , pub duration : f32 } impl WrappedTypesupport for PlanItem { type CStruct = plansys2_msgs__msg__PlanItem ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__plansys2_msgs__msg__PlanItem () } } fn create_msg () -> * mut plansys2_msgs__msg__PlanItem { unsafe { plansys2_msgs__msg__PlanItem__create () } } fn destroy_msg (msg : * mut plansys2_msgs__msg__PlanItem) -> () { unsafe { plansys2_msgs__msg__PlanItem__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> PlanItem { PlanItem { time : msg . time , action : msg . action . to_str () . to_owned () , duration : msg . duration , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . time = self . time ; msg . action . assign (& self . action) ; msg . duration = self . duration ; } } impl Default for PlanItem { fn default () -> Self { let msg_native = WrappedNativeMsg :: < PlanItem > :: new () ; PlanItem :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Tree { pub nodes : Vec < plansys2_msgs :: msg :: Node > } impl WrappedTypesupport for Tree { type CStruct = plansys2_msgs__msg__Tree ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__plansys2_msgs__msg__Tree () } } fn create_msg () -> * mut plansys2_msgs__msg__Tree { unsafe { plansys2_msgs__msg__Tree__create () } } fn destroy_msg (msg : * mut plansys2_msgs__msg__Tree) -> () { unsafe { plansys2_msgs__msg__Tree__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Tree { Tree { nodes : { let mut temp = Vec :: with_capacity (msg . nodes . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . nodes . data , msg . nodes . size) } ; for s in slice { temp . push (plansys2_msgs :: msg :: Node :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { unsafe { plansys2_msgs__msg__Node__Sequence__fini (& mut msg . nodes) ; plansys2_msgs__msg__Node__Sequence__init (& mut msg . nodes , self . nodes . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . nodes . data , msg . nodes . size) ; for (t , s) in slice . iter_mut () . zip (& self . nodes) { s . copy_to_native (t) ; } } } } impl Default for Tree { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Tree > :: new () ; Tree :: from_native (& msg_native) } } } pub mod srv { # [allow (non_snake_case)] pub mod AddProblem { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__plansys2_msgs__srv__AddProblem () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub problem : std :: string :: String } impl WrappedTypesupport for Request { type CStruct = plansys2_msgs__srv__AddProblem_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__plansys2_msgs__srv__AddProblem_Request () } } fn create_msg () -> * mut plansys2_msgs__srv__AddProblem_Request { unsafe { plansys2_msgs__srv__AddProblem_Request__create () } } fn destroy_msg (msg : * mut plansys2_msgs__srv__AddProblem_Request) -> () { unsafe { plansys2_msgs__srv__AddProblem_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { problem : msg . problem . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . problem . assign (& self . problem) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool , pub error_info : std :: string :: String } impl WrappedTypesupport for Response { type CStruct = plansys2_msgs__srv__AddProblem_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__plansys2_msgs__srv__AddProblem_Response () } } fn create_msg () -> * mut plansys2_msgs__srv__AddProblem_Response { unsafe { plansys2_msgs__srv__AddProblem_Response__create () } } fn destroy_msg (msg : * mut plansys2_msgs__srv__AddProblem_Response) -> () { unsafe { plansys2_msgs__srv__AddProblem_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , error_info : msg . error_info . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; msg . error_info . assign (& self . error_info) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod AddProblemGoal { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__plansys2_msgs__srv__AddProblemGoal () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub tree : plansys2_msgs :: msg :: Tree } impl WrappedTypesupport for Request { type CStruct = plansys2_msgs__srv__AddProblemGoal_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__plansys2_msgs__srv__AddProblemGoal_Request () } } fn create_msg () -> * mut plansys2_msgs__srv__AddProblemGoal_Request { unsafe { plansys2_msgs__srv__AddProblemGoal_Request__create () } } fn destroy_msg (msg : * mut plansys2_msgs__srv__AddProblemGoal_Request) -> () { unsafe { plansys2_msgs__srv__AddProblemGoal_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { tree : plansys2_msgs :: msg :: Tree :: from_native (& msg . tree) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . tree . copy_to_native (& mut msg . tree) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool , pub error_info : std :: string :: String } impl WrappedTypesupport for Response { type CStruct = plansys2_msgs__srv__AddProblemGoal_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__plansys2_msgs__srv__AddProblemGoal_Response () } } fn create_msg () -> * mut plansys2_msgs__srv__AddProblemGoal_Response { unsafe { plansys2_msgs__srv__AddProblemGoal_Response__create () } } fn destroy_msg (msg : * mut plansys2_msgs__srv__AddProblemGoal_Response) -> () { unsafe { plansys2_msgs__srv__AddProblemGoal_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , error_info : msg . error_info . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; msg . error_info . assign (& self . error_info) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod AffectNode { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__plansys2_msgs__srv__AffectNode () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub node : plansys2_msgs :: msg :: Node } impl WrappedTypesupport for Request { type CStruct = plansys2_msgs__srv__AffectNode_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__plansys2_msgs__srv__AffectNode_Request () } } fn create_msg () -> * mut plansys2_msgs__srv__AffectNode_Request { unsafe { plansys2_msgs__srv__AffectNode_Request__create () } } fn destroy_msg (msg : * mut plansys2_msgs__srv__AffectNode_Request) -> () { unsafe { plansys2_msgs__srv__AffectNode_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { node : plansys2_msgs :: msg :: Node :: from_native (& msg . node) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . node . copy_to_native (& mut msg . node) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool , pub error_info : std :: string :: String } impl WrappedTypesupport for Response { type CStruct = plansys2_msgs__srv__AffectNode_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__plansys2_msgs__srv__AffectNode_Response () } } fn create_msg () -> * mut plansys2_msgs__srv__AffectNode_Response { unsafe { plansys2_msgs__srv__AffectNode_Response__create () } } fn destroy_msg (msg : * mut plansys2_msgs__srv__AffectNode_Response) -> () { unsafe { plansys2_msgs__srv__AffectNode_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , error_info : msg . error_info . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; msg . error_info . assign (& self . error_info) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod AffectParam { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__plansys2_msgs__srv__AffectParam () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub param : plansys2_msgs :: msg :: Param } impl WrappedTypesupport for Request { type CStruct = plansys2_msgs__srv__AffectParam_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__plansys2_msgs__srv__AffectParam_Request () } } fn create_msg () -> * mut plansys2_msgs__srv__AffectParam_Request { unsafe { plansys2_msgs__srv__AffectParam_Request__create () } } fn destroy_msg (msg : * mut plansys2_msgs__srv__AffectParam_Request) -> () { unsafe { plansys2_msgs__srv__AffectParam_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { param : plansys2_msgs :: msg :: Param :: from_native (& msg . param) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . param . copy_to_native (& mut msg . param) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool , pub error_info : std :: string :: String } impl WrappedTypesupport for Response { type CStruct = plansys2_msgs__srv__AffectParam_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__plansys2_msgs__srv__AffectParam_Response () } } fn create_msg () -> * mut plansys2_msgs__srv__AffectParam_Response { unsafe { plansys2_msgs__srv__AffectParam_Response__create () } } fn destroy_msg (msg : * mut plansys2_msgs__srv__AffectParam_Response) -> () { unsafe { plansys2_msgs__srv__AffectParam_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , error_info : msg . error_info . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; msg . error_info . assign (& self . error_info) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod ClearProblemKnowledge { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__plansys2_msgs__srv__ClearProblemKnowledge () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub request : std_msgs :: msg :: Empty } impl WrappedTypesupport for Request { type CStruct = plansys2_msgs__srv__ClearProblemKnowledge_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__plansys2_msgs__srv__ClearProblemKnowledge_Request () } } fn create_msg () -> * mut plansys2_msgs__srv__ClearProblemKnowledge_Request { unsafe { plansys2_msgs__srv__ClearProblemKnowledge_Request__create () } } fn destroy_msg (msg : * mut plansys2_msgs__srv__ClearProblemKnowledge_Request) -> () { unsafe { plansys2_msgs__srv__ClearProblemKnowledge_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { request : std_msgs :: msg :: Empty :: from_native (& msg . request) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . request . copy_to_native (& mut msg . request) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool , pub error_info : std :: string :: String } impl WrappedTypesupport for Response { type CStruct = plansys2_msgs__srv__ClearProblemKnowledge_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__plansys2_msgs__srv__ClearProblemKnowledge_Response () } } fn create_msg () -> * mut plansys2_msgs__srv__ClearProblemKnowledge_Response { unsafe { plansys2_msgs__srv__ClearProblemKnowledge_Response__create () } } fn destroy_msg (msg : * mut plansys2_msgs__srv__ClearProblemKnowledge_Response) -> () { unsafe { plansys2_msgs__srv__ClearProblemKnowledge_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , error_info : msg . error_info . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; msg . error_info . assign (& self . error_info) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod ExistNode { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__plansys2_msgs__srv__ExistNode () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub node : plansys2_msgs :: msg :: Node } impl WrappedTypesupport for Request { type CStruct = plansys2_msgs__srv__ExistNode_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__plansys2_msgs__srv__ExistNode_Request () } } fn create_msg () -> * mut plansys2_msgs__srv__ExistNode_Request { unsafe { plansys2_msgs__srv__ExistNode_Request__create () } } fn destroy_msg (msg : * mut plansys2_msgs__srv__ExistNode_Request) -> () { unsafe { plansys2_msgs__srv__ExistNode_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { node : plansys2_msgs :: msg :: Node :: from_native (& msg . node) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . node . copy_to_native (& mut msg . node) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub exist : bool } impl WrappedTypesupport for Response { type CStruct = plansys2_msgs__srv__ExistNode_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__plansys2_msgs__srv__ExistNode_Response () } } fn create_msg () -> * mut plansys2_msgs__srv__ExistNode_Response { unsafe { plansys2_msgs__srv__ExistNode_Response__create () } } fn destroy_msg (msg : * mut plansys2_msgs__srv__ExistNode_Response) -> () { unsafe { plansys2_msgs__srv__ExistNode_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { exist : msg . exist , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . exist = self . exist ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetDomain { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__plansys2_msgs__srv__GetDomain () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub request : std_msgs :: msg :: Empty } impl WrappedTypesupport for Request { type CStruct = plansys2_msgs__srv__GetDomain_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__plansys2_msgs__srv__GetDomain_Request () } } fn create_msg () -> * mut plansys2_msgs__srv__GetDomain_Request { unsafe { plansys2_msgs__srv__GetDomain_Request__create () } } fn destroy_msg (msg : * mut plansys2_msgs__srv__GetDomain_Request) -> () { unsafe { plansys2_msgs__srv__GetDomain_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { request : std_msgs :: msg :: Empty :: from_native (& msg . request) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . request . copy_to_native (& mut msg . request) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool , pub domain : std :: string :: String , pub error_info : std :: string :: String } impl WrappedTypesupport for Response { type CStruct = plansys2_msgs__srv__GetDomain_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__plansys2_msgs__srv__GetDomain_Response () } } fn create_msg () -> * mut plansys2_msgs__srv__GetDomain_Response { unsafe { plansys2_msgs__srv__GetDomain_Response__create () } } fn destroy_msg (msg : * mut plansys2_msgs__srv__GetDomain_Response) -> () { unsafe { plansys2_msgs__srv__GetDomain_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , domain : msg . domain . to_str () . to_owned () , error_info : msg . error_info . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; msg . domain . assign (& self . domain) ; msg . error_info . assign (& self . error_info) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetDomainActionDetails { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__plansys2_msgs__srv__GetDomainActionDetails () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub action : std :: string :: String , pub parameters : Vec < std :: string :: String > } impl WrappedTypesupport for Request { type CStruct = plansys2_msgs__srv__GetDomainActionDetails_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__plansys2_msgs__srv__GetDomainActionDetails_Request () } } fn create_msg () -> * mut plansys2_msgs__srv__GetDomainActionDetails_Request { unsafe { plansys2_msgs__srv__GetDomainActionDetails_Request__create () } } fn destroy_msg (msg : * mut plansys2_msgs__srv__GetDomainActionDetails_Request) -> () { unsafe { plansys2_msgs__srv__GetDomainActionDetails_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { action : msg . action . to_str () . to_owned () , parameters : msg . parameters . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . action . assign (& self . action) ; msg . parameters . update (& self . parameters) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub action : plansys2_msgs :: msg :: Action , pub success : bool , pub error_info : std :: string :: String } impl WrappedTypesupport for Response { type CStruct = plansys2_msgs__srv__GetDomainActionDetails_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__plansys2_msgs__srv__GetDomainActionDetails_Response () } } fn create_msg () -> * mut plansys2_msgs__srv__GetDomainActionDetails_Response { unsafe { plansys2_msgs__srv__GetDomainActionDetails_Response__create () } } fn destroy_msg (msg : * mut plansys2_msgs__srv__GetDomainActionDetails_Response) -> () { unsafe { plansys2_msgs__srv__GetDomainActionDetails_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { action : plansys2_msgs :: msg :: Action :: from_native (& msg . action) , success : msg . success , error_info : msg . error_info . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . action . copy_to_native (& mut msg . action) ; msg . success = self . success ; msg . error_info . assign (& self . error_info) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetDomainActions { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__plansys2_msgs__srv__GetDomainActions () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub request : std_msgs :: msg :: Empty } impl WrappedTypesupport for Request { type CStruct = plansys2_msgs__srv__GetDomainActions_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__plansys2_msgs__srv__GetDomainActions_Request () } } fn create_msg () -> * mut plansys2_msgs__srv__GetDomainActions_Request { unsafe { plansys2_msgs__srv__GetDomainActions_Request__create () } } fn destroy_msg (msg : * mut plansys2_msgs__srv__GetDomainActions_Request) -> () { unsafe { plansys2_msgs__srv__GetDomainActions_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { request : std_msgs :: msg :: Empty :: from_native (& msg . request) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . request . copy_to_native (& mut msg . request) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool , pub actions : Vec < std :: string :: String > , pub error_info : std :: string :: String } impl WrappedTypesupport for Response { type CStruct = plansys2_msgs__srv__GetDomainActions_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__plansys2_msgs__srv__GetDomainActions_Response () } } fn create_msg () -> * mut plansys2_msgs__srv__GetDomainActions_Response { unsafe { plansys2_msgs__srv__GetDomainActions_Response__create () } } fn destroy_msg (msg : * mut plansys2_msgs__srv__GetDomainActions_Response) -> () { unsafe { plansys2_msgs__srv__GetDomainActions_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , actions : msg . actions . to_vec () , error_info : msg . error_info . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; msg . actions . update (& self . actions) ; msg . error_info . assign (& self . error_info) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetDomainConstants { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__plansys2_msgs__srv__GetDomainConstants () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { # [serde (rename = "type")] pub type_ : std :: string :: String } impl WrappedTypesupport for Request { type CStruct = plansys2_msgs__srv__GetDomainConstants_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__plansys2_msgs__srv__GetDomainConstants_Request () } } fn create_msg () -> * mut plansys2_msgs__srv__GetDomainConstants_Request { unsafe { plansys2_msgs__srv__GetDomainConstants_Request__create () } } fn destroy_msg (msg : * mut plansys2_msgs__srv__GetDomainConstants_Request) -> () { unsafe { plansys2_msgs__srv__GetDomainConstants_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { type_ : msg . type_ . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . type_ . assign (& self . type_) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool , pub constants : Vec < std :: string :: String > , pub error_info : std :: string :: String } impl WrappedTypesupport for Response { type CStruct = plansys2_msgs__srv__GetDomainConstants_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__plansys2_msgs__srv__GetDomainConstants_Response () } } fn create_msg () -> * mut plansys2_msgs__srv__GetDomainConstants_Response { unsafe { plansys2_msgs__srv__GetDomainConstants_Response__create () } } fn destroy_msg (msg : * mut plansys2_msgs__srv__GetDomainConstants_Response) -> () { unsafe { plansys2_msgs__srv__GetDomainConstants_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , constants : msg . constants . to_vec () , error_info : msg . error_info . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; msg . constants . update (& self . constants) ; msg . error_info . assign (& self . error_info) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetDomainDurativeActionDetails { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__plansys2_msgs__srv__GetDomainDurativeActionDetails () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub durative_action : std :: string :: String , pub parameters : Vec < std :: string :: String > } impl WrappedTypesupport for Request { type CStruct = plansys2_msgs__srv__GetDomainDurativeActionDetails_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__plansys2_msgs__srv__GetDomainDurativeActionDetails_Request () } } fn create_msg () -> * mut plansys2_msgs__srv__GetDomainDurativeActionDetails_Request { unsafe { plansys2_msgs__srv__GetDomainDurativeActionDetails_Request__create () } } fn destroy_msg (msg : * mut plansys2_msgs__srv__GetDomainDurativeActionDetails_Request) -> () { unsafe { plansys2_msgs__srv__GetDomainDurativeActionDetails_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { durative_action : msg . durative_action . to_str () . to_owned () , parameters : msg . parameters . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . durative_action . assign (& self . durative_action) ; msg . parameters . update (& self . parameters) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool , pub durative_action : plansys2_msgs :: msg :: DurativeAction , pub error_info : std :: string :: String } impl WrappedTypesupport for Response { type CStruct = plansys2_msgs__srv__GetDomainDurativeActionDetails_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__plansys2_msgs__srv__GetDomainDurativeActionDetails_Response () } } fn create_msg () -> * mut plansys2_msgs__srv__GetDomainDurativeActionDetails_Response { unsafe { plansys2_msgs__srv__GetDomainDurativeActionDetails_Response__create () } } fn destroy_msg (msg : * mut plansys2_msgs__srv__GetDomainDurativeActionDetails_Response) -> () { unsafe { plansys2_msgs__srv__GetDomainDurativeActionDetails_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , durative_action : plansys2_msgs :: msg :: DurativeAction :: from_native (& msg . durative_action) , error_info : msg . error_info . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; self . durative_action . copy_to_native (& mut msg . durative_action) ; msg . error_info . assign (& self . error_info) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetDomainName { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__plansys2_msgs__srv__GetDomainName () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub request : std_msgs :: msg :: Empty } impl WrappedTypesupport for Request { type CStruct = plansys2_msgs__srv__GetDomainName_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__plansys2_msgs__srv__GetDomainName_Request () } } fn create_msg () -> * mut plansys2_msgs__srv__GetDomainName_Request { unsafe { plansys2_msgs__srv__GetDomainName_Request__create () } } fn destroy_msg (msg : * mut plansys2_msgs__srv__GetDomainName_Request) -> () { unsafe { plansys2_msgs__srv__GetDomainName_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { request : std_msgs :: msg :: Empty :: from_native (& msg . request) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . request . copy_to_native (& mut msg . request) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool , pub name : std :: string :: String , pub error_info : std :: string :: String } impl WrappedTypesupport for Response { type CStruct = plansys2_msgs__srv__GetDomainName_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__plansys2_msgs__srv__GetDomainName_Response () } } fn create_msg () -> * mut plansys2_msgs__srv__GetDomainName_Response { unsafe { plansys2_msgs__srv__GetDomainName_Response__create () } } fn destroy_msg (msg : * mut plansys2_msgs__srv__GetDomainName_Response) -> () { unsafe { plansys2_msgs__srv__GetDomainName_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , name : msg . name . to_str () . to_owned () , error_info : msg . error_info . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; msg . name . assign (& self . name) ; msg . error_info . assign (& self . error_info) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetDomainTypes { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__plansys2_msgs__srv__GetDomainTypes () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub request : std_msgs :: msg :: Empty } impl WrappedTypesupport for Request { type CStruct = plansys2_msgs__srv__GetDomainTypes_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__plansys2_msgs__srv__GetDomainTypes_Request () } } fn create_msg () -> * mut plansys2_msgs__srv__GetDomainTypes_Request { unsafe { plansys2_msgs__srv__GetDomainTypes_Request__create () } } fn destroy_msg (msg : * mut plansys2_msgs__srv__GetDomainTypes_Request) -> () { unsafe { plansys2_msgs__srv__GetDomainTypes_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { request : std_msgs :: msg :: Empty :: from_native (& msg . request) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . request . copy_to_native (& mut msg . request) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool , pub types : Vec < std :: string :: String > , pub error_info : std :: string :: String } impl WrappedTypesupport for Response { type CStruct = plansys2_msgs__srv__GetDomainTypes_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__plansys2_msgs__srv__GetDomainTypes_Response () } } fn create_msg () -> * mut plansys2_msgs__srv__GetDomainTypes_Response { unsafe { plansys2_msgs__srv__GetDomainTypes_Response__create () } } fn destroy_msg (msg : * mut plansys2_msgs__srv__GetDomainTypes_Response) -> () { unsafe { plansys2_msgs__srv__GetDomainTypes_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , types : msg . types . to_vec () , error_info : msg . error_info . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; msg . types . update (& self . types) ; msg . error_info . assign (& self . error_info) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetNodeDetails { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__plansys2_msgs__srv__GetNodeDetails () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub expression : std :: string :: String } impl WrappedTypesupport for Request { type CStruct = plansys2_msgs__srv__GetNodeDetails_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__plansys2_msgs__srv__GetNodeDetails_Request () } } fn create_msg () -> * mut plansys2_msgs__srv__GetNodeDetails_Request { unsafe { plansys2_msgs__srv__GetNodeDetails_Request__create () } } fn destroy_msg (msg : * mut plansys2_msgs__srv__GetNodeDetails_Request) -> () { unsafe { plansys2_msgs__srv__GetNodeDetails_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { expression : msg . expression . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . expression . assign (& self . expression) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool , pub node : plansys2_msgs :: msg :: Node , pub error_info : std :: string :: String } impl WrappedTypesupport for Response { type CStruct = plansys2_msgs__srv__GetNodeDetails_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__plansys2_msgs__srv__GetNodeDetails_Response () } } fn create_msg () -> * mut plansys2_msgs__srv__GetNodeDetails_Response { unsafe { plansys2_msgs__srv__GetNodeDetails_Response__create () } } fn destroy_msg (msg : * mut plansys2_msgs__srv__GetNodeDetails_Response) -> () { unsafe { plansys2_msgs__srv__GetNodeDetails_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , node : plansys2_msgs :: msg :: Node :: from_native (& msg . node) , error_info : msg . error_info . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; self . node . copy_to_native (& mut msg . node) ; msg . error_info . assign (& self . error_info) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetOrderedSubGoals { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__plansys2_msgs__srv__GetOrderedSubGoals () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub request : std_msgs :: msg :: Empty } impl WrappedTypesupport for Request { type CStruct = plansys2_msgs__srv__GetOrderedSubGoals_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__plansys2_msgs__srv__GetOrderedSubGoals_Request () } } fn create_msg () -> * mut plansys2_msgs__srv__GetOrderedSubGoals_Request { unsafe { plansys2_msgs__srv__GetOrderedSubGoals_Request__create () } } fn destroy_msg (msg : * mut plansys2_msgs__srv__GetOrderedSubGoals_Request) -> () { unsafe { plansys2_msgs__srv__GetOrderedSubGoals_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { request : std_msgs :: msg :: Empty :: from_native (& msg . request) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . request . copy_to_native (& mut msg . request) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool , pub sub_goals : Vec < plansys2_msgs :: msg :: Tree > , pub error_info : std :: string :: String } impl WrappedTypesupport for Response { type CStruct = plansys2_msgs__srv__GetOrderedSubGoals_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__plansys2_msgs__srv__GetOrderedSubGoals_Response () } } fn create_msg () -> * mut plansys2_msgs__srv__GetOrderedSubGoals_Response { unsafe { plansys2_msgs__srv__GetOrderedSubGoals_Response__create () } } fn destroy_msg (msg : * mut plansys2_msgs__srv__GetOrderedSubGoals_Response) -> () { unsafe { plansys2_msgs__srv__GetOrderedSubGoals_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , sub_goals : { let mut temp = Vec :: with_capacity (msg . sub_goals . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . sub_goals . data , msg . sub_goals . size) } ; for s in slice { temp . push (plansys2_msgs :: msg :: Tree :: from_native (s)) ; } temp } , error_info : msg . error_info . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; unsafe { plansys2_msgs__msg__Tree__Sequence__fini (& mut msg . sub_goals) ; plansys2_msgs__msg__Tree__Sequence__init (& mut msg . sub_goals , self . sub_goals . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . sub_goals . data , msg . sub_goals . size) ; for (t , s) in slice . iter_mut () . zip (& self . sub_goals) { s . copy_to_native (t) ; } } msg . error_info . assign (& self . error_info) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetPlan { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__plansys2_msgs__srv__GetPlan () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub domain : std :: string :: String , pub problem : std :: string :: String } impl WrappedTypesupport for Request { type CStruct = plansys2_msgs__srv__GetPlan_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__plansys2_msgs__srv__GetPlan_Request () } } fn create_msg () -> * mut plansys2_msgs__srv__GetPlan_Request { unsafe { plansys2_msgs__srv__GetPlan_Request__create () } } fn destroy_msg (msg : * mut plansys2_msgs__srv__GetPlan_Request) -> () { unsafe { plansys2_msgs__srv__GetPlan_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { domain : msg . domain . to_str () . to_owned () , problem : msg . problem . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . domain . assign (& self . domain) ; msg . problem . assign (& self . problem) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool , pub plan : plansys2_msgs :: msg :: Plan , pub error_info : std :: string :: String } impl WrappedTypesupport for Response { type CStruct = plansys2_msgs__srv__GetPlan_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__plansys2_msgs__srv__GetPlan_Response () } } fn create_msg () -> * mut plansys2_msgs__srv__GetPlan_Response { unsafe { plansys2_msgs__srv__GetPlan_Response__create () } } fn destroy_msg (msg : * mut plansys2_msgs__srv__GetPlan_Response) -> () { unsafe { plansys2_msgs__srv__GetPlan_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , plan : plansys2_msgs :: msg :: Plan :: from_native (& msg . plan) , error_info : msg . error_info . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; self . plan . copy_to_native (& mut msg . plan) ; msg . error_info . assign (& self . error_info) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetProblem { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__plansys2_msgs__srv__GetProblem () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub request : std_msgs :: msg :: Empty } impl WrappedTypesupport for Request { type CStruct = plansys2_msgs__srv__GetProblem_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__plansys2_msgs__srv__GetProblem_Request () } } fn create_msg () -> * mut plansys2_msgs__srv__GetProblem_Request { unsafe { plansys2_msgs__srv__GetProblem_Request__create () } } fn destroy_msg (msg : * mut plansys2_msgs__srv__GetProblem_Request) -> () { unsafe { plansys2_msgs__srv__GetProblem_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { request : std_msgs :: msg :: Empty :: from_native (& msg . request) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . request . copy_to_native (& mut msg . request) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool , pub problem : std :: string :: String , pub error_info : std :: string :: String } impl WrappedTypesupport for Response { type CStruct = plansys2_msgs__srv__GetProblem_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__plansys2_msgs__srv__GetProblem_Response () } } fn create_msg () -> * mut plansys2_msgs__srv__GetProblem_Response { unsafe { plansys2_msgs__srv__GetProblem_Response__create () } } fn destroy_msg (msg : * mut plansys2_msgs__srv__GetProblem_Response) -> () { unsafe { plansys2_msgs__srv__GetProblem_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , problem : msg . problem . to_str () . to_owned () , error_info : msg . error_info . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; msg . problem . assign (& self . problem) ; msg . error_info . assign (& self . error_info) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetProblemGoal { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__plansys2_msgs__srv__GetProblemGoal () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub request : std_msgs :: msg :: Empty } impl WrappedTypesupport for Request { type CStruct = plansys2_msgs__srv__GetProblemGoal_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__plansys2_msgs__srv__GetProblemGoal_Request () } } fn create_msg () -> * mut plansys2_msgs__srv__GetProblemGoal_Request { unsafe { plansys2_msgs__srv__GetProblemGoal_Request__create () } } fn destroy_msg (msg : * mut plansys2_msgs__srv__GetProblemGoal_Request) -> () { unsafe { plansys2_msgs__srv__GetProblemGoal_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { request : std_msgs :: msg :: Empty :: from_native (& msg . request) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . request . copy_to_native (& mut msg . request) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool , pub tree : plansys2_msgs :: msg :: Tree , pub error_info : std :: string :: String } impl WrappedTypesupport for Response { type CStruct = plansys2_msgs__srv__GetProblemGoal_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__plansys2_msgs__srv__GetProblemGoal_Response () } } fn create_msg () -> * mut plansys2_msgs__srv__GetProblemGoal_Response { unsafe { plansys2_msgs__srv__GetProblemGoal_Response__create () } } fn destroy_msg (msg : * mut plansys2_msgs__srv__GetProblemGoal_Response) -> () { unsafe { plansys2_msgs__srv__GetProblemGoal_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , tree : plansys2_msgs :: msg :: Tree :: from_native (& msg . tree) , error_info : msg . error_info . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; self . tree . copy_to_native (& mut msg . tree) ; msg . error_info . assign (& self . error_info) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetProblemInstanceDetails { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__plansys2_msgs__srv__GetProblemInstanceDetails () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub instance : std :: string :: String } impl WrappedTypesupport for Request { type CStruct = plansys2_msgs__srv__GetProblemInstanceDetails_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__plansys2_msgs__srv__GetProblemInstanceDetails_Request () } } fn create_msg () -> * mut plansys2_msgs__srv__GetProblemInstanceDetails_Request { unsafe { plansys2_msgs__srv__GetProblemInstanceDetails_Request__create () } } fn destroy_msg (msg : * mut plansys2_msgs__srv__GetProblemInstanceDetails_Request) -> () { unsafe { plansys2_msgs__srv__GetProblemInstanceDetails_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { instance : msg . instance . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . instance . assign (& self . instance) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool , pub instance : plansys2_msgs :: msg :: Param , pub error_info : std :: string :: String } impl WrappedTypesupport for Response { type CStruct = plansys2_msgs__srv__GetProblemInstanceDetails_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__plansys2_msgs__srv__GetProblemInstanceDetails_Response () } } fn create_msg () -> * mut plansys2_msgs__srv__GetProblemInstanceDetails_Response { unsafe { plansys2_msgs__srv__GetProblemInstanceDetails_Response__create () } } fn destroy_msg (msg : * mut plansys2_msgs__srv__GetProblemInstanceDetails_Response) -> () { unsafe { plansys2_msgs__srv__GetProblemInstanceDetails_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , instance : plansys2_msgs :: msg :: Param :: from_native (& msg . instance) , error_info : msg . error_info . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; self . instance . copy_to_native (& mut msg . instance) ; msg . error_info . assign (& self . error_info) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetProblemInstances { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__plansys2_msgs__srv__GetProblemInstances () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub request : std_msgs :: msg :: Empty } impl WrappedTypesupport for Request { type CStruct = plansys2_msgs__srv__GetProblemInstances_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__plansys2_msgs__srv__GetProblemInstances_Request () } } fn create_msg () -> * mut plansys2_msgs__srv__GetProblemInstances_Request { unsafe { plansys2_msgs__srv__GetProblemInstances_Request__create () } } fn destroy_msg (msg : * mut plansys2_msgs__srv__GetProblemInstances_Request) -> () { unsafe { plansys2_msgs__srv__GetProblemInstances_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { request : std_msgs :: msg :: Empty :: from_native (& msg . request) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . request . copy_to_native (& mut msg . request) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool , pub instances : Vec < plansys2_msgs :: msg :: Param > , pub error_info : std :: string :: String } impl WrappedTypesupport for Response { type CStruct = plansys2_msgs__srv__GetProblemInstances_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__plansys2_msgs__srv__GetProblemInstances_Response () } } fn create_msg () -> * mut plansys2_msgs__srv__GetProblemInstances_Response { unsafe { plansys2_msgs__srv__GetProblemInstances_Response__create () } } fn destroy_msg (msg : * mut plansys2_msgs__srv__GetProblemInstances_Response) -> () { unsafe { plansys2_msgs__srv__GetProblemInstances_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , instances : { let mut temp = Vec :: with_capacity (msg . instances . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . instances . data , msg . instances . size) } ; for s in slice { temp . push (plansys2_msgs :: msg :: Param :: from_native (s)) ; } temp } , error_info : msg . error_info . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; unsafe { plansys2_msgs__msg__Param__Sequence__fini (& mut msg . instances) ; plansys2_msgs__msg__Param__Sequence__init (& mut msg . instances , self . instances . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . instances . data , msg . instances . size) ; for (t , s) in slice . iter_mut () . zip (& self . instances) { s . copy_to_native (t) ; } } msg . error_info . assign (& self . error_info) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetStates { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__plansys2_msgs__srv__GetStates () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub request : std_msgs :: msg :: Empty } impl WrappedTypesupport for Request { type CStruct = plansys2_msgs__srv__GetStates_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__plansys2_msgs__srv__GetStates_Request () } } fn create_msg () -> * mut plansys2_msgs__srv__GetStates_Request { unsafe { plansys2_msgs__srv__GetStates_Request__create () } } fn destroy_msg (msg : * mut plansys2_msgs__srv__GetStates_Request) -> () { unsafe { plansys2_msgs__srv__GetStates_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { request : std_msgs :: msg :: Empty :: from_native (& msg . request) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . request . copy_to_native (& mut msg . request) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool , pub states : Vec < plansys2_msgs :: msg :: Node > , pub error_info : std :: string :: String } impl WrappedTypesupport for Response { type CStruct = plansys2_msgs__srv__GetStates_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__plansys2_msgs__srv__GetStates_Response () } } fn create_msg () -> * mut plansys2_msgs__srv__GetStates_Response { unsafe { plansys2_msgs__srv__GetStates_Response__create () } } fn destroy_msg (msg : * mut plansys2_msgs__srv__GetStates_Response) -> () { unsafe { plansys2_msgs__srv__GetStates_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , states : { let mut temp = Vec :: with_capacity (msg . states . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . states . data , msg . states . size) } ; for s in slice { temp . push (plansys2_msgs :: msg :: Node :: from_native (s)) ; } temp } , error_info : msg . error_info . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; unsafe { plansys2_msgs__msg__Node__Sequence__fini (& mut msg . states) ; plansys2_msgs__msg__Node__Sequence__init (& mut msg . states , self . states . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . states . data , msg . states . size) ; for (t , s) in slice . iter_mut () . zip (& self . states) { s . copy_to_native (t) ; } } msg . error_info . assign (& self . error_info) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod IsProblemGoalSatisfied { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__plansys2_msgs__srv__IsProblemGoalSatisfied () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub tree : plansys2_msgs :: msg :: Tree } impl WrappedTypesupport for Request { type CStruct = plansys2_msgs__srv__IsProblemGoalSatisfied_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__plansys2_msgs__srv__IsProblemGoalSatisfied_Request () } } fn create_msg () -> * mut plansys2_msgs__srv__IsProblemGoalSatisfied_Request { unsafe { plansys2_msgs__srv__IsProblemGoalSatisfied_Request__create () } } fn destroy_msg (msg : * mut plansys2_msgs__srv__IsProblemGoalSatisfied_Request) -> () { unsafe { plansys2_msgs__srv__IsProblemGoalSatisfied_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { tree : plansys2_msgs :: msg :: Tree :: from_native (& msg . tree) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . tree . copy_to_native (& mut msg . tree) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool , pub satisfied : bool , pub error_info : std :: string :: String } impl WrappedTypesupport for Response { type CStruct = plansys2_msgs__srv__IsProblemGoalSatisfied_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__plansys2_msgs__srv__IsProblemGoalSatisfied_Response () } } fn create_msg () -> * mut plansys2_msgs__srv__IsProblemGoalSatisfied_Response { unsafe { plansys2_msgs__srv__IsProblemGoalSatisfied_Response__create () } } fn destroy_msg (msg : * mut plansys2_msgs__srv__IsProblemGoalSatisfied_Response) -> () { unsafe { plansys2_msgs__srv__IsProblemGoalSatisfied_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , satisfied : msg . satisfied , error_info : msg . error_info . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; msg . satisfied = self . satisfied ; msg . error_info . assign (& self . error_info) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod RemoveProblemGoal { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__plansys2_msgs__srv__RemoveProblemGoal () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub request : std_msgs :: msg :: Empty } impl WrappedTypesupport for Request { type CStruct = plansys2_msgs__srv__RemoveProblemGoal_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__plansys2_msgs__srv__RemoveProblemGoal_Request () } } fn create_msg () -> * mut plansys2_msgs__srv__RemoveProblemGoal_Request { unsafe { plansys2_msgs__srv__RemoveProblemGoal_Request__create () } } fn destroy_msg (msg : * mut plansys2_msgs__srv__RemoveProblemGoal_Request) -> () { unsafe { plansys2_msgs__srv__RemoveProblemGoal_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { request : std_msgs :: msg :: Empty :: from_native (& msg . request) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . request . copy_to_native (& mut msg . request) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool , pub error_info : std :: string :: String } impl WrappedTypesupport for Response { type CStruct = plansys2_msgs__srv__RemoveProblemGoal_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__plansys2_msgs__srv__RemoveProblemGoal_Response () } } fn create_msg () -> * mut plansys2_msgs__srv__RemoveProblemGoal_Response { unsafe { plansys2_msgs__srv__RemoveProblemGoal_Response__create () } } fn destroy_msg (msg : * mut plansys2_msgs__srv__RemoveProblemGoal_Response) -> () { unsafe { plansys2_msgs__srv__RemoveProblemGoal_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , error_info : msg . error_info . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; msg . error_info . assign (& self . error_info) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } } pub mod action { # [allow (non_snake_case)] pub mod ExecutePlan { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Action () ; impl WrappedActionTypeSupport for Action { type Goal = Goal ; type Result = Result ; type Feedback = Feedback ; type FeedbackMessage = FeedbackMessage ; type SendGoal = SendGoal :: Service ; type GetResult = GetResult :: Service ; fn get_ts () -> & 'static rosidl_action_type_support_t { unsafe { & * rosidl_typesupport_c__get_action_type_support_handle__plansys2_msgs__action__ExecutePlan () } } fn make_goal_request_msg (goal_id : unique_identifier_msgs :: msg :: UUID , goal : Goal) -> SendGoal :: Request { SendGoal :: Request { goal_id , goal } } fn make_goal_response_msg (accepted : bool , stamp : builtin_interfaces :: msg :: Time) -> SendGoal :: Response { SendGoal :: Response { accepted , stamp } } fn make_feedback_msg (goal_id : unique_identifier_msgs :: msg :: UUID , feedback : Feedback) -> FeedbackMessage { FeedbackMessage { goal_id , feedback } } fn make_result_request_msg (goal_id : unique_identifier_msgs :: msg :: UUID) -> GetResult :: Request { GetResult :: Request { goal_id , } } fn make_result_response_msg (status : i8 , result : Result) -> GetResult :: Response { GetResult :: Response { status , result , } } fn destructure_goal_request_msg (msg : SendGoal :: Request) -> (unique_identifier_msgs :: msg :: UUID , Goal) { (msg . goal_id , msg . goal) } fn destructure_goal_response_msg (msg : SendGoal :: Response) -> (bool , builtin_interfaces :: msg :: Time) { (msg . accepted , msg . stamp) } fn destructure_feedback_msg (msg : FeedbackMessage) -> (unique_identifier_msgs :: msg :: UUID , Feedback) { (msg . goal_id , msg . feedback) } fn destructure_result_response_msg (msg : GetResult :: Response) -> (i8 , Result) { (msg . status , msg . result) } fn destructure_result_request_msg (msg : GetResult :: Request) -> unique_identifier_msgs :: msg :: UUID { msg . goal_id } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Goal { pub plan : plansys2_msgs :: msg :: Plan } impl WrappedTypesupport for Goal { type CStruct = plansys2_msgs__action__ExecutePlan_Goal ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__plansys2_msgs__action__ExecutePlan_Goal () } } fn create_msg () -> * mut plansys2_msgs__action__ExecutePlan_Goal { unsafe { plansys2_msgs__action__ExecutePlan_Goal__create () } } fn destroy_msg (msg : * mut plansys2_msgs__action__ExecutePlan_Goal) -> () { unsafe { plansys2_msgs__action__ExecutePlan_Goal__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Goal { Goal { plan : plansys2_msgs :: msg :: Plan :: from_native (& msg . plan) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . plan . copy_to_native (& mut msg . plan) ; } } impl Default for Goal { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Goal > :: new () ; Goal :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Result { pub success : bool , pub action_execution_status : Vec < plansys2_msgs :: msg :: ActionExecutionInfo > } impl WrappedTypesupport for Result { type CStruct = plansys2_msgs__action__ExecutePlan_Result ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__plansys2_msgs__action__ExecutePlan_Result () } } fn create_msg () -> * mut plansys2_msgs__action__ExecutePlan_Result { unsafe { plansys2_msgs__action__ExecutePlan_Result__create () } } fn destroy_msg (msg : * mut plansys2_msgs__action__ExecutePlan_Result) -> () { unsafe { plansys2_msgs__action__ExecutePlan_Result__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Result { Result { success : msg . success , action_execution_status : { let mut temp = Vec :: with_capacity (msg . action_execution_status . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . action_execution_status . data , msg . action_execution_status . size) } ; for s in slice { temp . push (plansys2_msgs :: msg :: ActionExecutionInfo :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; unsafe { plansys2_msgs__msg__ActionExecutionInfo__Sequence__fini (& mut msg . action_execution_status) ; plansys2_msgs__msg__ActionExecutionInfo__Sequence__init (& mut msg . action_execution_status , self . action_execution_status . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . action_execution_status . data , msg . action_execution_status . size) ; for (t , s) in slice . iter_mut () . zip (& self . action_execution_status) { s . copy_to_native (t) ; } } } } impl Default for Result { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Result > :: new () ; Result :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Feedback { pub action_execution_status : Vec < plansys2_msgs :: msg :: ActionExecutionInfo > } impl WrappedTypesupport for Feedback { type CStruct = plansys2_msgs__action__ExecutePlan_Feedback ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__plansys2_msgs__action__ExecutePlan_Feedback () } } fn create_msg () -> * mut plansys2_msgs__action__ExecutePlan_Feedback { unsafe { plansys2_msgs__action__ExecutePlan_Feedback__create () } } fn destroy_msg (msg : * mut plansys2_msgs__action__ExecutePlan_Feedback) -> () { unsafe { plansys2_msgs__action__ExecutePlan_Feedback__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Feedback { Feedback { action_execution_status : { let mut temp = Vec :: with_capacity (msg . action_execution_status . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . action_execution_status . data , msg . action_execution_status . size) } ; for s in slice { temp . push (plansys2_msgs :: msg :: ActionExecutionInfo :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { unsafe { plansys2_msgs__msg__ActionExecutionInfo__Sequence__fini (& mut msg . action_execution_status) ; plansys2_msgs__msg__ActionExecutionInfo__Sequence__init (& mut msg . action_execution_status , self . action_execution_status . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . action_execution_status . data , msg . action_execution_status . size) ; for (t , s) in slice . iter_mut () . zip (& self . action_execution_status) { s . copy_to_native (t) ; } } } } impl Default for Feedback { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Feedback > :: new () ; Feedback :: from_native (& msg_native) } } # [allow (non_snake_case)] pub mod SendGoal { use super :: super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__plansys2_msgs__action__ExecutePlan_SendGoal () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub goal_id : unique_identifier_msgs :: msg :: UUID , pub goal : plansys2_msgs :: action :: ExecutePlan :: Goal } impl WrappedTypesupport for Request { type CStruct = plansys2_msgs__action__ExecutePlan_SendGoal_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__plansys2_msgs__action__ExecutePlan_SendGoal_Request () } } fn create_msg () -> * mut plansys2_msgs__action__ExecutePlan_SendGoal_Request { unsafe { plansys2_msgs__action__ExecutePlan_SendGoal_Request__create () } } fn destroy_msg (msg : * mut plansys2_msgs__action__ExecutePlan_SendGoal_Request) -> () { unsafe { plansys2_msgs__action__ExecutePlan_SendGoal_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { goal_id : unique_identifier_msgs :: msg :: UUID :: from_native (& msg . goal_id) , goal : plansys2_msgs :: action :: ExecutePlan :: Goal :: from_native (& msg . goal) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . goal_id . copy_to_native (& mut msg . goal_id) ; self . goal . copy_to_native (& mut msg . goal) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub accepted : bool , pub stamp : builtin_interfaces :: msg :: Time } impl WrappedTypesupport for Response { type CStruct = plansys2_msgs__action__ExecutePlan_SendGoal_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__plansys2_msgs__action__ExecutePlan_SendGoal_Response () } } fn create_msg () -> * mut plansys2_msgs__action__ExecutePlan_SendGoal_Response { unsafe { plansys2_msgs__action__ExecutePlan_SendGoal_Response__create () } } fn destroy_msg (msg : * mut plansys2_msgs__action__ExecutePlan_SendGoal_Response) -> () { unsafe { plansys2_msgs__action__ExecutePlan_SendGoal_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { accepted : msg . accepted , stamp : builtin_interfaces :: msg :: Time :: from_native (& msg . stamp) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . accepted = self . accepted ; self . stamp . copy_to_native (& mut msg . stamp) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetResult { use super :: super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__plansys2_msgs__action__ExecutePlan_GetResult () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub goal_id : unique_identifier_msgs :: msg :: UUID } impl WrappedTypesupport for Request { type CStruct = plansys2_msgs__action__ExecutePlan_GetResult_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__plansys2_msgs__action__ExecutePlan_GetResult_Request () } } fn create_msg () -> * mut plansys2_msgs__action__ExecutePlan_GetResult_Request { unsafe { plansys2_msgs__action__ExecutePlan_GetResult_Request__create () } } fn destroy_msg (msg : * mut plansys2_msgs__action__ExecutePlan_GetResult_Request) -> () { unsafe { plansys2_msgs__action__ExecutePlan_GetResult_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { goal_id : unique_identifier_msgs :: msg :: UUID :: from_native (& msg . goal_id) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . goal_id . copy_to_native (& mut msg . goal_id) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub status : i8 , pub result : plansys2_msgs :: action :: ExecutePlan :: Result } impl WrappedTypesupport for Response { type CStruct = plansys2_msgs__action__ExecutePlan_GetResult_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__plansys2_msgs__action__ExecutePlan_GetResult_Response () } } fn create_msg () -> * mut plansys2_msgs__action__ExecutePlan_GetResult_Response { unsafe { plansys2_msgs__action__ExecutePlan_GetResult_Response__create () } } fn destroy_msg (msg : * mut plansys2_msgs__action__ExecutePlan_GetResult_Response) -> () { unsafe { plansys2_msgs__action__ExecutePlan_GetResult_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { status : msg . status , result : plansys2_msgs :: action :: ExecutePlan :: Result :: from_native (& msg . result) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . status = self . status ; self . result . copy_to_native (& mut msg . result) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct FeedbackMessage { pub goal_id : unique_identifier_msgs :: msg :: UUID , pub feedback : plansys2_msgs :: action :: ExecutePlan :: Feedback } impl WrappedTypesupport for FeedbackMessage { type CStruct = plansys2_msgs__action__ExecutePlan_FeedbackMessage ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__plansys2_msgs__action__ExecutePlan_FeedbackMessage () } } fn create_msg () -> * mut plansys2_msgs__action__ExecutePlan_FeedbackMessage { unsafe { plansys2_msgs__action__ExecutePlan_FeedbackMessage__create () } } fn destroy_msg (msg : * mut plansys2_msgs__action__ExecutePlan_FeedbackMessage) -> () { unsafe { plansys2_msgs__action__ExecutePlan_FeedbackMessage__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> FeedbackMessage { FeedbackMessage { goal_id : unique_identifier_msgs :: msg :: UUID :: from_native (& msg . goal_id) , feedback : plansys2_msgs :: action :: ExecutePlan :: Feedback :: from_native (& msg . feedback) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . goal_id . copy_to_native (& mut msg . goal_id) ; self . feedback . copy_to_native (& mut msg . feedback) ; } } impl Default for FeedbackMessage { fn default () -> Self { let msg_native = WrappedNativeMsg :: < FeedbackMessage > :: new () ; FeedbackMessage :: from_native (& msg_native) } } } }