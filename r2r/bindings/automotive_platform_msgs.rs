pub mod msg { use super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct AdaptiveCruiseControlCommand { pub header : std_msgs :: msg :: Header , pub msg_counter : u8 , pub set_speed : f32 , pub set : u16 , pub resume : u16 , pub cancel : u16 , pub speed_up : u16 , pub slow_down : u16 , pub further : u16 , pub closer : u16 } impl WrappedTypesupport for AdaptiveCruiseControlCommand { type CStruct = automotive_platform_msgs__msg__AdaptiveCruiseControlCommand ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__automotive_platform_msgs__msg__AdaptiveCruiseControlCommand () } } fn create_msg () -> * mut automotive_platform_msgs__msg__AdaptiveCruiseControlCommand { unsafe { automotive_platform_msgs__msg__AdaptiveCruiseControlCommand__create () } } fn destroy_msg (msg : * mut automotive_platform_msgs__msg__AdaptiveCruiseControlCommand) -> () { unsafe { automotive_platform_msgs__msg__AdaptiveCruiseControlCommand__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> AdaptiveCruiseControlCommand { AdaptiveCruiseControlCommand { header : std_msgs :: msg :: Header :: from_native (& msg . header) , msg_counter : msg . msg_counter , set_speed : msg . set_speed , set : msg . set , resume : msg . resume , cancel : msg . cancel , speed_up : msg . speed_up , slow_down : msg . slow_down , further : msg . further , closer : msg . closer , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . msg_counter = self . msg_counter ; msg . set_speed = self . set_speed ; msg . set = self . set ; msg . resume = self . resume ; msg . cancel = self . cancel ; msg . speed_up = self . speed_up ; msg . slow_down = self . slow_down ; msg . further = self . further ; msg . closer = self . closer ; } } impl Default for AdaptiveCruiseControlCommand { fn default () -> Self { let msg_native = WrappedNativeMsg :: < AdaptiveCruiseControlCommand > :: new () ; AdaptiveCruiseControlCommand :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct AdaptiveCruiseControlSettings { pub header : std_msgs :: msg :: Header , pub set_speed : f32 , pub following_spot : u16 , pub min_percent : f32 , pub step_percent : f32 , pub cipv_percent : f32 , pub max_distance : f32 } impl WrappedTypesupport for AdaptiveCruiseControlSettings { type CStruct = automotive_platform_msgs__msg__AdaptiveCruiseControlSettings ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__automotive_platform_msgs__msg__AdaptiveCruiseControlSettings () } } fn create_msg () -> * mut automotive_platform_msgs__msg__AdaptiveCruiseControlSettings { unsafe { automotive_platform_msgs__msg__AdaptiveCruiseControlSettings__create () } } fn destroy_msg (msg : * mut automotive_platform_msgs__msg__AdaptiveCruiseControlSettings) -> () { unsafe { automotive_platform_msgs__msg__AdaptiveCruiseControlSettings__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> AdaptiveCruiseControlSettings { AdaptiveCruiseControlSettings { header : std_msgs :: msg :: Header :: from_native (& msg . header) , set_speed : msg . set_speed , following_spot : msg . following_spot , min_percent : msg . min_percent , step_percent : msg . step_percent , cipv_percent : msg . cipv_percent , max_distance : msg . max_distance , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . set_speed = self . set_speed ; msg . following_spot = self . following_spot ; msg . min_percent = self . min_percent ; msg . step_percent = self . step_percent ; msg . cipv_percent = self . cipv_percent ; msg . max_distance = self . max_distance ; } } impl Default for AdaptiveCruiseControlSettings { fn default () -> Self { let msg_native = WrappedNativeMsg :: < AdaptiveCruiseControlSettings > :: new () ; AdaptiveCruiseControlSettings :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct BlindSpotIndicators { pub header : std_msgs :: msg :: Header , pub left : bool , pub right : bool } impl WrappedTypesupport for BlindSpotIndicators { type CStruct = automotive_platform_msgs__msg__BlindSpotIndicators ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__automotive_platform_msgs__msg__BlindSpotIndicators () } } fn create_msg () -> * mut automotive_platform_msgs__msg__BlindSpotIndicators { unsafe { automotive_platform_msgs__msg__BlindSpotIndicators__create () } } fn destroy_msg (msg : * mut automotive_platform_msgs__msg__BlindSpotIndicators) -> () { unsafe { automotive_platform_msgs__msg__BlindSpotIndicators__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> BlindSpotIndicators { BlindSpotIndicators { header : std_msgs :: msg :: Header :: from_native (& msg . header) , left : msg . left , right : msg . right , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . left = self . left ; msg . right = self . right ; } } impl Default for BlindSpotIndicators { fn default () -> Self { let msg_native = WrappedNativeMsg :: < BlindSpotIndicators > :: new () ; BlindSpotIndicators :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct BrakeCommand { pub header : std_msgs :: msg :: Header , pub brake_pedal : f32 } impl WrappedTypesupport for BrakeCommand { type CStruct = automotive_platform_msgs__msg__BrakeCommand ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__automotive_platform_msgs__msg__BrakeCommand () } } fn create_msg () -> * mut automotive_platform_msgs__msg__BrakeCommand { unsafe { automotive_platform_msgs__msg__BrakeCommand__create () } } fn destroy_msg (msg : * mut automotive_platform_msgs__msg__BrakeCommand) -> () { unsafe { automotive_platform_msgs__msg__BrakeCommand__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> BrakeCommand { BrakeCommand { header : std_msgs :: msg :: Header :: from_native (& msg . header) , brake_pedal : msg . brake_pedal , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . brake_pedal = self . brake_pedal ; } } impl Default for BrakeCommand { fn default () -> Self { let msg_native = WrappedNativeMsg :: < BrakeCommand > :: new () ; BrakeCommand :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct BrakeFeedback { pub header : std_msgs :: msg :: Header , pub brake_pedal : f32 } impl WrappedTypesupport for BrakeFeedback { type CStruct = automotive_platform_msgs__msg__BrakeFeedback ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__automotive_platform_msgs__msg__BrakeFeedback () } } fn create_msg () -> * mut automotive_platform_msgs__msg__BrakeFeedback { unsafe { automotive_platform_msgs__msg__BrakeFeedback__create () } } fn destroy_msg (msg : * mut automotive_platform_msgs__msg__BrakeFeedback) -> () { unsafe { automotive_platform_msgs__msg__BrakeFeedback__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> BrakeFeedback { BrakeFeedback { header : std_msgs :: msg :: Header :: from_native (& msg . header) , brake_pedal : msg . brake_pedal , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . brake_pedal = self . brake_pedal ; } } impl Default for BrakeFeedback { fn default () -> Self { let msg_native = WrappedNativeMsg :: < BrakeFeedback > :: new () ; BrakeFeedback :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct CabinReport { pub header : std_msgs :: msg :: Header , pub door_open_front_right : bool , pub door_open_front_left : bool , pub door_open_rear_right : bool , pub door_open_rear_left : bool , pub hood_open : bool , pub trunk_open : bool , pub passenger_present : bool , pub passenger_airbag_enabled : bool , pub seatbelt_engaged_driver : bool , pub seatbelt_engaged_passenger : bool } impl WrappedTypesupport for CabinReport { type CStruct = automotive_platform_msgs__msg__CabinReport ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__automotive_platform_msgs__msg__CabinReport () } } fn create_msg () -> * mut automotive_platform_msgs__msg__CabinReport { unsafe { automotive_platform_msgs__msg__CabinReport__create () } } fn destroy_msg (msg : * mut automotive_platform_msgs__msg__CabinReport) -> () { unsafe { automotive_platform_msgs__msg__CabinReport__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> CabinReport { CabinReport { header : std_msgs :: msg :: Header :: from_native (& msg . header) , door_open_front_right : msg . door_open_front_right , door_open_front_left : msg . door_open_front_left , door_open_rear_right : msg . door_open_rear_right , door_open_rear_left : msg . door_open_rear_left , hood_open : msg . hood_open , trunk_open : msg . trunk_open , passenger_present : msg . passenger_present , passenger_airbag_enabled : msg . passenger_airbag_enabled , seatbelt_engaged_driver : msg . seatbelt_engaged_driver , seatbelt_engaged_passenger : msg . seatbelt_engaged_passenger , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . door_open_front_right = self . door_open_front_right ; msg . door_open_front_left = self . door_open_front_left ; msg . door_open_rear_right = self . door_open_rear_right ; msg . door_open_rear_left = self . door_open_rear_left ; msg . hood_open = self . hood_open ; msg . trunk_open = self . trunk_open ; msg . passenger_present = self . passenger_present ; msg . passenger_airbag_enabled = self . passenger_airbag_enabled ; msg . seatbelt_engaged_driver = self . seatbelt_engaged_driver ; msg . seatbelt_engaged_passenger = self . seatbelt_engaged_passenger ; } } impl Default for CabinReport { fn default () -> Self { let msg_native = WrappedNativeMsg :: < CabinReport > :: new () ; CabinReport :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct CurvatureFeedback { pub header : std_msgs :: msg :: Header , pub curvature : f32 } impl WrappedTypesupport for CurvatureFeedback { type CStruct = automotive_platform_msgs__msg__CurvatureFeedback ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__automotive_platform_msgs__msg__CurvatureFeedback () } } fn create_msg () -> * mut automotive_platform_msgs__msg__CurvatureFeedback { unsafe { automotive_platform_msgs__msg__CurvatureFeedback__create () } } fn destroy_msg (msg : * mut automotive_platform_msgs__msg__CurvatureFeedback) -> () { unsafe { automotive_platform_msgs__msg__CurvatureFeedback__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> CurvatureFeedback { CurvatureFeedback { header : std_msgs :: msg :: Header :: from_native (& msg . header) , curvature : msg . curvature , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . curvature = self . curvature ; } } impl Default for CurvatureFeedback { fn default () -> Self { let msg_native = WrappedNativeMsg :: < CurvatureFeedback > :: new () ; CurvatureFeedback :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct DriverCommands { pub msg_counter : u8 , pub engage : u16 , pub disengage : u16 , pub speed_up : u16 , pub slow_down : u16 , pub further : u16 , pub closer : u16 , pub right_turn : u16 , pub left_turn : u16 } impl WrappedTypesupport for DriverCommands { type CStruct = automotive_platform_msgs__msg__DriverCommands ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__automotive_platform_msgs__msg__DriverCommands () } } fn create_msg () -> * mut automotive_platform_msgs__msg__DriverCommands { unsafe { automotive_platform_msgs__msg__DriverCommands__create () } } fn destroy_msg (msg : * mut automotive_platform_msgs__msg__DriverCommands) -> () { unsafe { automotive_platform_msgs__msg__DriverCommands__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> DriverCommands { DriverCommands { msg_counter : msg . msg_counter , engage : msg . engage , disengage : msg . disengage , speed_up : msg . speed_up , slow_down : msg . slow_down , further : msg . further , closer : msg . closer , right_turn : msg . right_turn , left_turn : msg . left_turn , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . msg_counter = self . msg_counter ; msg . engage = self . engage ; msg . disengage = self . disengage ; msg . speed_up = self . speed_up ; msg . slow_down = self . slow_down ; msg . further = self . further ; msg . closer = self . closer ; msg . right_turn = self . right_turn ; msg . left_turn = self . left_turn ; } } impl Default for DriverCommands { fn default () -> Self { let msg_native = WrappedNativeMsg :: < DriverCommands > :: new () ; DriverCommands :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Gear { pub gear : u8 } impl WrappedTypesupport for Gear { type CStruct = automotive_platform_msgs__msg__Gear ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__automotive_platform_msgs__msg__Gear () } } fn create_msg () -> * mut automotive_platform_msgs__msg__Gear { unsafe { automotive_platform_msgs__msg__Gear__create () } } fn destroy_msg (msg : * mut automotive_platform_msgs__msg__Gear) -> () { unsafe { automotive_platform_msgs__msg__Gear__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Gear { Gear { gear : msg . gear , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . gear = self . gear ; } } impl Default for Gear { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Gear > :: new () ; Gear :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl Gear { pub const DRIVE : _bindgen_ty_37 = automotive_platform_msgs__msg__Gear__DRIVE ; pub const LOW : _bindgen_ty_38 = automotive_platform_msgs__msg__Gear__LOW ; pub const NEUTRAL : _bindgen_ty_36 = automotive_platform_msgs__msg__Gear__NEUTRAL ; pub const NONE : _bindgen_ty_33 = automotive_platform_msgs__msg__Gear__NONE ; pub const PARK : _bindgen_ty_34 = automotive_platform_msgs__msg__Gear__PARK ; pub const REVERSE : _bindgen_ty_35 = automotive_platform_msgs__msg__Gear__REVERSE ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct GearCommand { pub header : std_msgs :: msg :: Header , pub command : automotive_platform_msgs :: msg :: Gear } impl WrappedTypesupport for GearCommand { type CStruct = automotive_platform_msgs__msg__GearCommand ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__automotive_platform_msgs__msg__GearCommand () } } fn create_msg () -> * mut automotive_platform_msgs__msg__GearCommand { unsafe { automotive_platform_msgs__msg__GearCommand__create () } } fn destroy_msg (msg : * mut automotive_platform_msgs__msg__GearCommand) -> () { unsafe { automotive_platform_msgs__msg__GearCommand__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> GearCommand { GearCommand { header : std_msgs :: msg :: Header :: from_native (& msg . header) , command : automotive_platform_msgs :: msg :: Gear :: from_native (& msg . command) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; self . command . copy_to_native (& mut msg . command) ; } } impl Default for GearCommand { fn default () -> Self { let msg_native = WrappedNativeMsg :: < GearCommand > :: new () ; GearCommand :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct GearFeedback { pub header : std_msgs :: msg :: Header , pub current_gear : automotive_platform_msgs :: msg :: Gear } impl WrappedTypesupport for GearFeedback { type CStruct = automotive_platform_msgs__msg__GearFeedback ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__automotive_platform_msgs__msg__GearFeedback () } } fn create_msg () -> * mut automotive_platform_msgs__msg__GearFeedback { unsafe { automotive_platform_msgs__msg__GearFeedback__create () } } fn destroy_msg (msg : * mut automotive_platform_msgs__msg__GearFeedback) -> () { unsafe { automotive_platform_msgs__msg__GearFeedback__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> GearFeedback { GearFeedback { header : std_msgs :: msg :: Header :: from_native (& msg . header) , current_gear : automotive_platform_msgs :: msg :: Gear :: from_native (& msg . current_gear) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; self . current_gear . copy_to_native (& mut msg . current_gear) ; } } impl Default for GearFeedback { fn default () -> Self { let msg_native = WrappedNativeMsg :: < GearFeedback > :: new () ; GearFeedback :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct HillStartAssist { pub header : std_msgs :: msg :: Header , pub active : bool } impl WrappedTypesupport for HillStartAssist { type CStruct = automotive_platform_msgs__msg__HillStartAssist ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__automotive_platform_msgs__msg__HillStartAssist () } } fn create_msg () -> * mut automotive_platform_msgs__msg__HillStartAssist { unsafe { automotive_platform_msgs__msg__HillStartAssist__create () } } fn destroy_msg (msg : * mut automotive_platform_msgs__msg__HillStartAssist) -> () { unsafe { automotive_platform_msgs__msg__HillStartAssist__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> HillStartAssist { HillStartAssist { header : std_msgs :: msg :: Header :: from_native (& msg . header) , active : msg . active , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . active = self . active ; } } impl Default for HillStartAssist { fn default () -> Self { let msg_native = WrappedNativeMsg :: < HillStartAssist > :: new () ; HillStartAssist :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Speed { pub header : std_msgs :: msg :: Header , pub module_name : std :: string :: String , pub speed : f32 , pub acceleration_limit : f32 , pub deceleration_limit : f32 } impl WrappedTypesupport for Speed { type CStruct = automotive_platform_msgs__msg__Speed ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__automotive_platform_msgs__msg__Speed () } } fn create_msg () -> * mut automotive_platform_msgs__msg__Speed { unsafe { automotive_platform_msgs__msg__Speed__create () } } fn destroy_msg (msg : * mut automotive_platform_msgs__msg__Speed) -> () { unsafe { automotive_platform_msgs__msg__Speed__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Speed { Speed { header : std_msgs :: msg :: Header :: from_native (& msg . header) , module_name : msg . module_name . to_str () . to_owned () , speed : msg . speed , acceleration_limit : msg . acceleration_limit , deceleration_limit : msg . deceleration_limit , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . module_name . assign (& self . module_name) ; msg . speed = self . speed ; msg . acceleration_limit = self . acceleration_limit ; msg . deceleration_limit = self . deceleration_limit ; } } impl Default for Speed { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Speed > :: new () ; Speed :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct SpeedMode { pub header : std_msgs :: msg :: Header , pub mode : u16 , pub speed : f32 , pub acceleration_limit : f32 , pub deceleration_limit : f32 } impl WrappedTypesupport for SpeedMode { type CStruct = automotive_platform_msgs__msg__SpeedMode ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__automotive_platform_msgs__msg__SpeedMode () } } fn create_msg () -> * mut automotive_platform_msgs__msg__SpeedMode { unsafe { automotive_platform_msgs__msg__SpeedMode__create () } } fn destroy_msg (msg : * mut automotive_platform_msgs__msg__SpeedMode) -> () { unsafe { automotive_platform_msgs__msg__SpeedMode__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> SpeedMode { SpeedMode { header : std_msgs :: msg :: Header :: from_native (& msg . header) , mode : msg . mode , speed : msg . speed , acceleration_limit : msg . acceleration_limit , deceleration_limit : msg . deceleration_limit , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . mode = self . mode ; msg . speed = self . speed ; msg . acceleration_limit = self . acceleration_limit ; msg . deceleration_limit = self . deceleration_limit ; } } impl Default for SpeedMode { fn default () -> Self { let msg_native = WrappedNativeMsg :: < SpeedMode > :: new () ; SpeedMode :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct SpeedPedals { pub header : std_msgs :: msg :: Header , pub mode : u16 , pub throttle : f32 , pub brake : f32 } impl WrappedTypesupport for SpeedPedals { type CStruct = automotive_platform_msgs__msg__SpeedPedals ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__automotive_platform_msgs__msg__SpeedPedals () } } fn create_msg () -> * mut automotive_platform_msgs__msg__SpeedPedals { unsafe { automotive_platform_msgs__msg__SpeedPedals__create () } } fn destroy_msg (msg : * mut automotive_platform_msgs__msg__SpeedPedals) -> () { unsafe { automotive_platform_msgs__msg__SpeedPedals__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> SpeedPedals { SpeedPedals { header : std_msgs :: msg :: Header :: from_native (& msg . header) , mode : msg . mode , throttle : msg . throttle , brake : msg . brake , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . mode = self . mode ; msg . throttle = self . throttle ; msg . brake = self . brake ; } } impl Default for SpeedPedals { fn default () -> Self { let msg_native = WrappedNativeMsg :: < SpeedPedals > :: new () ; SpeedPedals :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Steer { pub header : std_msgs :: msg :: Header , pub module_name : std :: string :: String , pub curvature : f32 , pub max_curvature_rate : f32 } impl WrappedTypesupport for Steer { type CStruct = automotive_platform_msgs__msg__Steer ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__automotive_platform_msgs__msg__Steer () } } fn create_msg () -> * mut automotive_platform_msgs__msg__Steer { unsafe { automotive_platform_msgs__msg__Steer__create () } } fn destroy_msg (msg : * mut automotive_platform_msgs__msg__Steer) -> () { unsafe { automotive_platform_msgs__msg__Steer__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Steer { Steer { header : std_msgs :: msg :: Header :: from_native (& msg . header) , module_name : msg . module_name . to_str () . to_owned () , curvature : msg . curvature , max_curvature_rate : msg . max_curvature_rate , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . module_name . assign (& self . module_name) ; msg . curvature = self . curvature ; msg . max_curvature_rate = self . max_curvature_rate ; } } impl Default for Steer { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Steer > :: new () ; Steer :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct SteerMode { pub header : std_msgs :: msg :: Header , pub mode : u16 , pub curvature : f32 , pub max_curvature_rate : f32 } impl WrappedTypesupport for SteerMode { type CStruct = automotive_platform_msgs__msg__SteerMode ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__automotive_platform_msgs__msg__SteerMode () } } fn create_msg () -> * mut automotive_platform_msgs__msg__SteerMode { unsafe { automotive_platform_msgs__msg__SteerMode__create () } } fn destroy_msg (msg : * mut automotive_platform_msgs__msg__SteerMode) -> () { unsafe { automotive_platform_msgs__msg__SteerMode__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> SteerMode { SteerMode { header : std_msgs :: msg :: Header :: from_native (& msg . header) , mode : msg . mode , curvature : msg . curvature , max_curvature_rate : msg . max_curvature_rate , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . mode = self . mode ; msg . curvature = self . curvature ; msg . max_curvature_rate = self . max_curvature_rate ; } } impl Default for SteerMode { fn default () -> Self { let msg_native = WrappedNativeMsg :: < SteerMode > :: new () ; SteerMode :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct SteerWheel { pub header : std_msgs :: msg :: Header , pub mode : u16 , pub angle : f32 , pub angle_velocity : f32 } impl WrappedTypesupport for SteerWheel { type CStruct = automotive_platform_msgs__msg__SteerWheel ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__automotive_platform_msgs__msg__SteerWheel () } } fn create_msg () -> * mut automotive_platform_msgs__msg__SteerWheel { unsafe { automotive_platform_msgs__msg__SteerWheel__create () } } fn destroy_msg (msg : * mut automotive_platform_msgs__msg__SteerWheel) -> () { unsafe { automotive_platform_msgs__msg__SteerWheel__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> SteerWheel { SteerWheel { header : std_msgs :: msg :: Header :: from_native (& msg . header) , mode : msg . mode , angle : msg . angle , angle_velocity : msg . angle_velocity , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . mode = self . mode ; msg . angle = self . angle ; msg . angle_velocity = self . angle_velocity ; } } impl Default for SteerWheel { fn default () -> Self { let msg_native = WrappedNativeMsg :: < SteerWheel > :: new () ; SteerWheel :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct SteeringCommand { pub header : std_msgs :: msg :: Header , pub steering_wheel_angle : f32 } impl WrappedTypesupport for SteeringCommand { type CStruct = automotive_platform_msgs__msg__SteeringCommand ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__automotive_platform_msgs__msg__SteeringCommand () } } fn create_msg () -> * mut automotive_platform_msgs__msg__SteeringCommand { unsafe { automotive_platform_msgs__msg__SteeringCommand__create () } } fn destroy_msg (msg : * mut automotive_platform_msgs__msg__SteeringCommand) -> () { unsafe { automotive_platform_msgs__msg__SteeringCommand__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> SteeringCommand { SteeringCommand { header : std_msgs :: msg :: Header :: from_native (& msg . header) , steering_wheel_angle : msg . steering_wheel_angle , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . steering_wheel_angle = self . steering_wheel_angle ; } } impl Default for SteeringCommand { fn default () -> Self { let msg_native = WrappedNativeMsg :: < SteeringCommand > :: new () ; SteeringCommand :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct SteeringFeedback { pub header : std_msgs :: msg :: Header , pub steering_wheel_angle : f32 } impl WrappedTypesupport for SteeringFeedback { type CStruct = automotive_platform_msgs__msg__SteeringFeedback ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__automotive_platform_msgs__msg__SteeringFeedback () } } fn create_msg () -> * mut automotive_platform_msgs__msg__SteeringFeedback { unsafe { automotive_platform_msgs__msg__SteeringFeedback__create () } } fn destroy_msg (msg : * mut automotive_platform_msgs__msg__SteeringFeedback) -> () { unsafe { automotive_platform_msgs__msg__SteeringFeedback__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> SteeringFeedback { SteeringFeedback { header : std_msgs :: msg :: Header :: from_native (& msg . header) , steering_wheel_angle : msg . steering_wheel_angle , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . steering_wheel_angle = self . steering_wheel_angle ; } } impl Default for SteeringFeedback { fn default () -> Self { let msg_native = WrappedNativeMsg :: < SteeringFeedback > :: new () ; SteeringFeedback :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ThrottleCommand { pub header : std_msgs :: msg :: Header , pub throttle_pedal : f32 } impl WrappedTypesupport for ThrottleCommand { type CStruct = automotive_platform_msgs__msg__ThrottleCommand ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__automotive_platform_msgs__msg__ThrottleCommand () } } fn create_msg () -> * mut automotive_platform_msgs__msg__ThrottleCommand { unsafe { automotive_platform_msgs__msg__ThrottleCommand__create () } } fn destroy_msg (msg : * mut automotive_platform_msgs__msg__ThrottleCommand) -> () { unsafe { automotive_platform_msgs__msg__ThrottleCommand__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ThrottleCommand { ThrottleCommand { header : std_msgs :: msg :: Header :: from_native (& msg . header) , throttle_pedal : msg . throttle_pedal , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . throttle_pedal = self . throttle_pedal ; } } impl Default for ThrottleCommand { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ThrottleCommand > :: new () ; ThrottleCommand :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ThrottleFeedback { pub header : std_msgs :: msg :: Header , pub throttle_pedal : f32 } impl WrappedTypesupport for ThrottleFeedback { type CStruct = automotive_platform_msgs__msg__ThrottleFeedback ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__automotive_platform_msgs__msg__ThrottleFeedback () } } fn create_msg () -> * mut automotive_platform_msgs__msg__ThrottleFeedback { unsafe { automotive_platform_msgs__msg__ThrottleFeedback__create () } } fn destroy_msg (msg : * mut automotive_platform_msgs__msg__ThrottleFeedback) -> () { unsafe { automotive_platform_msgs__msg__ThrottleFeedback__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ThrottleFeedback { ThrottleFeedback { header : std_msgs :: msg :: Header :: from_native (& msg . header) , throttle_pedal : msg . throttle_pedal , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . throttle_pedal = self . throttle_pedal ; } } impl Default for ThrottleFeedback { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ThrottleFeedback > :: new () ; ThrottleFeedback :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct TurnSignalCommand { pub header : std_msgs :: msg :: Header , pub mode : u16 , pub turn_signal : u8 } impl WrappedTypesupport for TurnSignalCommand { type CStruct = automotive_platform_msgs__msg__TurnSignalCommand ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__automotive_platform_msgs__msg__TurnSignalCommand () } } fn create_msg () -> * mut automotive_platform_msgs__msg__TurnSignalCommand { unsafe { automotive_platform_msgs__msg__TurnSignalCommand__create () } } fn destroy_msg (msg : * mut automotive_platform_msgs__msg__TurnSignalCommand) -> () { unsafe { automotive_platform_msgs__msg__TurnSignalCommand__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> TurnSignalCommand { TurnSignalCommand { header : std_msgs :: msg :: Header :: from_native (& msg . header) , mode : msg . mode , turn_signal : msg . turn_signal , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . mode = self . mode ; msg . turn_signal = self . turn_signal ; } } impl Default for TurnSignalCommand { fn default () -> Self { let msg_native = WrappedNativeMsg :: < TurnSignalCommand > :: new () ; TurnSignalCommand :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl TurnSignalCommand { pub const LEFT : _bindgen_ty_40 = automotive_platform_msgs__msg__TurnSignalCommand__LEFT ; pub const NONE : _bindgen_ty_39 = automotive_platform_msgs__msg__TurnSignalCommand__NONE ; pub const RIGHT : _bindgen_ty_41 = automotive_platform_msgs__msg__TurnSignalCommand__RIGHT ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct UserInputADAS { pub header : std_msgs :: msg :: Header , pub btn_cc_on : bool , pub btn_cc_off : bool , pub btn_cc_on_off : bool , pub btn_cc_set_inc : bool , pub btn_cc_set_dec : bool , pub btn_cc_res : bool , pub btn_cc_cncl : bool , pub btn_cc_res_cncl : bool , pub btn_acc_gap_inc : bool , pub btn_acc_gap_dec : bool , pub btn_lka_on : bool , pub btn_lka_off : bool , pub btn_lka_on_off : bool } impl WrappedTypesupport for UserInputADAS { type CStruct = automotive_platform_msgs__msg__UserInputADAS ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__automotive_platform_msgs__msg__UserInputADAS () } } fn create_msg () -> * mut automotive_platform_msgs__msg__UserInputADAS { unsafe { automotive_platform_msgs__msg__UserInputADAS__create () } } fn destroy_msg (msg : * mut automotive_platform_msgs__msg__UserInputADAS) -> () { unsafe { automotive_platform_msgs__msg__UserInputADAS__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> UserInputADAS { UserInputADAS { header : std_msgs :: msg :: Header :: from_native (& msg . header) , btn_cc_on : msg . btn_cc_on , btn_cc_off : msg . btn_cc_off , btn_cc_on_off : msg . btn_cc_on_off , btn_cc_set_inc : msg . btn_cc_set_inc , btn_cc_set_dec : msg . btn_cc_set_dec , btn_cc_res : msg . btn_cc_res , btn_cc_cncl : msg . btn_cc_cncl , btn_cc_res_cncl : msg . btn_cc_res_cncl , btn_acc_gap_inc : msg . btn_acc_gap_inc , btn_acc_gap_dec : msg . btn_acc_gap_dec , btn_lka_on : msg . btn_lka_on , btn_lka_off : msg . btn_lka_off , btn_lka_on_off : msg . btn_lka_on_off , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . btn_cc_on = self . btn_cc_on ; msg . btn_cc_off = self . btn_cc_off ; msg . btn_cc_on_off = self . btn_cc_on_off ; msg . btn_cc_set_inc = self . btn_cc_set_inc ; msg . btn_cc_set_dec = self . btn_cc_set_dec ; msg . btn_cc_res = self . btn_cc_res ; msg . btn_cc_cncl = self . btn_cc_cncl ; msg . btn_cc_res_cncl = self . btn_cc_res_cncl ; msg . btn_acc_gap_inc = self . btn_acc_gap_inc ; msg . btn_acc_gap_dec = self . btn_acc_gap_dec ; msg . btn_lka_on = self . btn_lka_on ; msg . btn_lka_off = self . btn_lka_off ; msg . btn_lka_on_off = self . btn_lka_on_off ; } } impl Default for UserInputADAS { fn default () -> Self { let msg_native = WrappedNativeMsg :: < UserInputADAS > :: new () ; UserInputADAS :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct UserInputMedia { pub header : std_msgs :: msg :: Header , pub btn_vol_up : bool , pub btn_vol_down : bool , pub btn_mute : bool , pub btn_next : bool , pub btn_prev : bool , pub btn_next_hang_up : bool , pub btn_prev_answer : bool , pub btn_hang_up : bool , pub btn_answer : bool , pub btn_play : bool , pub btn_pause : bool , pub btn_play_pause : bool , pub btn_mode : bool } impl WrappedTypesupport for UserInputMedia { type CStruct = automotive_platform_msgs__msg__UserInputMedia ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__automotive_platform_msgs__msg__UserInputMedia () } } fn create_msg () -> * mut automotive_platform_msgs__msg__UserInputMedia { unsafe { automotive_platform_msgs__msg__UserInputMedia__create () } } fn destroy_msg (msg : * mut automotive_platform_msgs__msg__UserInputMedia) -> () { unsafe { automotive_platform_msgs__msg__UserInputMedia__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> UserInputMedia { UserInputMedia { header : std_msgs :: msg :: Header :: from_native (& msg . header) , btn_vol_up : msg . btn_vol_up , btn_vol_down : msg . btn_vol_down , btn_mute : msg . btn_mute , btn_next : msg . btn_next , btn_prev : msg . btn_prev , btn_next_hang_up : msg . btn_next_hang_up , btn_prev_answer : msg . btn_prev_answer , btn_hang_up : msg . btn_hang_up , btn_answer : msg . btn_answer , btn_play : msg . btn_play , btn_pause : msg . btn_pause , btn_play_pause : msg . btn_play_pause , btn_mode : msg . btn_mode , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . btn_vol_up = self . btn_vol_up ; msg . btn_vol_down = self . btn_vol_down ; msg . btn_mute = self . btn_mute ; msg . btn_next = self . btn_next ; msg . btn_prev = self . btn_prev ; msg . btn_next_hang_up = self . btn_next_hang_up ; msg . btn_prev_answer = self . btn_prev_answer ; msg . btn_hang_up = self . btn_hang_up ; msg . btn_answer = self . btn_answer ; msg . btn_play = self . btn_play ; msg . btn_pause = self . btn_pause ; msg . btn_play_pause = self . btn_play_pause ; msg . btn_mode = self . btn_mode ; } } impl Default for UserInputMedia { fn default () -> Self { let msg_native = WrappedNativeMsg :: < UserInputMedia > :: new () ; UserInputMedia :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct UserInputMenus { pub header : std_msgs :: msg :: Header , pub str_whl_left_btn_left : bool , pub str_whl_left_btn_down : bool , pub str_whl_left_btn_right : bool , pub str_whl_left_btn_up : bool , pub str_whl_left_btn_ok : bool , pub str_whl_right_btn_left : bool , pub str_whl_right_btn_down : bool , pub str_whl_right_btn_right : bool , pub str_whl_right_btn_up : bool , pub str_whl_right_btn_ok : bool , pub cntr_cons_btn_left : bool , pub cntr_cons_btn_down : bool , pub cntr_cons_btn_right : bool , pub cntr_cons_btn_up : bool , pub cntr_cons_btn_ok : bool } impl WrappedTypesupport for UserInputMenus { type CStruct = automotive_platform_msgs__msg__UserInputMenus ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__automotive_platform_msgs__msg__UserInputMenus () } } fn create_msg () -> * mut automotive_platform_msgs__msg__UserInputMenus { unsafe { automotive_platform_msgs__msg__UserInputMenus__create () } } fn destroy_msg (msg : * mut automotive_platform_msgs__msg__UserInputMenus) -> () { unsafe { automotive_platform_msgs__msg__UserInputMenus__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> UserInputMenus { UserInputMenus { header : std_msgs :: msg :: Header :: from_native (& msg . header) , str_whl_left_btn_left : msg . str_whl_left_btn_left , str_whl_left_btn_down : msg . str_whl_left_btn_down , str_whl_left_btn_right : msg . str_whl_left_btn_right , str_whl_left_btn_up : msg . str_whl_left_btn_up , str_whl_left_btn_ok : msg . str_whl_left_btn_ok , str_whl_right_btn_left : msg . str_whl_right_btn_left , str_whl_right_btn_down : msg . str_whl_right_btn_down , str_whl_right_btn_right : msg . str_whl_right_btn_right , str_whl_right_btn_up : msg . str_whl_right_btn_up , str_whl_right_btn_ok : msg . str_whl_right_btn_ok , cntr_cons_btn_left : msg . cntr_cons_btn_left , cntr_cons_btn_down : msg . cntr_cons_btn_down , cntr_cons_btn_right : msg . cntr_cons_btn_right , cntr_cons_btn_up : msg . cntr_cons_btn_up , cntr_cons_btn_ok : msg . cntr_cons_btn_ok , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . str_whl_left_btn_left = self . str_whl_left_btn_left ; msg . str_whl_left_btn_down = self . str_whl_left_btn_down ; msg . str_whl_left_btn_right = self . str_whl_left_btn_right ; msg . str_whl_left_btn_up = self . str_whl_left_btn_up ; msg . str_whl_left_btn_ok = self . str_whl_left_btn_ok ; msg . str_whl_right_btn_left = self . str_whl_right_btn_left ; msg . str_whl_right_btn_down = self . str_whl_right_btn_down ; msg . str_whl_right_btn_right = self . str_whl_right_btn_right ; msg . str_whl_right_btn_up = self . str_whl_right_btn_up ; msg . str_whl_right_btn_ok = self . str_whl_right_btn_ok ; msg . cntr_cons_btn_left = self . cntr_cons_btn_left ; msg . cntr_cons_btn_down = self . cntr_cons_btn_down ; msg . cntr_cons_btn_right = self . cntr_cons_btn_right ; msg . cntr_cons_btn_up = self . cntr_cons_btn_up ; msg . cntr_cons_btn_ok = self . cntr_cons_btn_ok ; } } impl Default for UserInputMenus { fn default () -> Self { let msg_native = WrappedNativeMsg :: < UserInputMenus > :: new () ; UserInputMenus :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct VelocityAccel { pub header : std_msgs :: msg :: Header , pub velocity : f32 , pub accleration : f32 } impl WrappedTypesupport for VelocityAccel { type CStruct = automotive_platform_msgs__msg__VelocityAccel ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__automotive_platform_msgs__msg__VelocityAccel () } } fn create_msg () -> * mut automotive_platform_msgs__msg__VelocityAccel { unsafe { automotive_platform_msgs__msg__VelocityAccel__create () } } fn destroy_msg (msg : * mut automotive_platform_msgs__msg__VelocityAccel) -> () { unsafe { automotive_platform_msgs__msg__VelocityAccel__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> VelocityAccel { VelocityAccel { header : std_msgs :: msg :: Header :: from_native (& msg . header) , velocity : msg . velocity , accleration : msg . accleration , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . velocity = self . velocity ; msg . accleration = self . accleration ; } } impl Default for VelocityAccel { fn default () -> Self { let msg_native = WrappedNativeMsg :: < VelocityAccel > :: new () ; VelocityAccel :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct VelocityAccelCov { pub header : std_msgs :: msg :: Header , pub velocity : f32 , pub accleration : f32 , pub covariance : f32 } impl WrappedTypesupport for VelocityAccelCov { type CStruct = automotive_platform_msgs__msg__VelocityAccelCov ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__automotive_platform_msgs__msg__VelocityAccelCov () } } fn create_msg () -> * mut automotive_platform_msgs__msg__VelocityAccelCov { unsafe { automotive_platform_msgs__msg__VelocityAccelCov__create () } } fn destroy_msg (msg : * mut automotive_platform_msgs__msg__VelocityAccelCov) -> () { unsafe { automotive_platform_msgs__msg__VelocityAccelCov__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> VelocityAccelCov { VelocityAccelCov { header : std_msgs :: msg :: Header :: from_native (& msg . header) , velocity : msg . velocity , accleration : msg . accleration , covariance : msg . covariance , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . velocity = self . velocity ; msg . accleration = self . accleration ; msg . covariance = self . covariance ; } } impl Default for VelocityAccelCov { fn default () -> Self { let msg_native = WrappedNativeMsg :: < VelocityAccelCov > :: new () ; VelocityAccelCov :: from_native (& msg_native) } } }