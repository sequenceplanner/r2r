pub mod srv { # [allow (non_snake_case)] pub mod CancelTask { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__rmf_task_msgs__srv__CancelTask () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub requester : std :: string :: String , pub task_id : std :: string :: String } impl WrappedTypesupport for Request { type CStruct = rmf_task_msgs__srv__CancelTask_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_task_msgs__srv__CancelTask_Request () } } fn create_msg () -> * mut rmf_task_msgs__srv__CancelTask_Request { unsafe { rmf_task_msgs__srv__CancelTask_Request__create () } } fn destroy_msg (msg : * mut rmf_task_msgs__srv__CancelTask_Request) -> () { unsafe { rmf_task_msgs__srv__CancelTask_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { requester : msg . requester . to_str () . to_owned () , task_id : msg . task_id . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . requester . assign (& self . requester) ; msg . task_id . assign (& self . task_id) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool , pub message : std :: string :: String } impl WrappedTypesupport for Response { type CStruct = rmf_task_msgs__srv__CancelTask_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_task_msgs__srv__CancelTask_Response () } } fn create_msg () -> * mut rmf_task_msgs__srv__CancelTask_Response { unsafe { rmf_task_msgs__srv__CancelTask_Response__create () } } fn destroy_msg (msg : * mut rmf_task_msgs__srv__CancelTask_Response) -> () { unsafe { rmf_task_msgs__srv__CancelTask_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , message : msg . message . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; msg . message . assign (& self . message) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetTaskList { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__rmf_task_msgs__srv__GetTaskList () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub requester : std :: string :: String , pub task_id : Vec < std :: string :: String > } impl WrappedTypesupport for Request { type CStruct = rmf_task_msgs__srv__GetTaskList_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_task_msgs__srv__GetTaskList_Request () } } fn create_msg () -> * mut rmf_task_msgs__srv__GetTaskList_Request { unsafe { rmf_task_msgs__srv__GetTaskList_Request__create () } } fn destroy_msg (msg : * mut rmf_task_msgs__srv__GetTaskList_Request) -> () { unsafe { rmf_task_msgs__srv__GetTaskList_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { requester : msg . requester . to_str () . to_owned () , task_id : msg . task_id . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . requester . assign (& self . requester) ; msg . task_id . update (& self . task_id) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool , pub active_tasks : Vec < rmf_task_msgs :: msg :: TaskSummary > , pub terminated_tasks : Vec < rmf_task_msgs :: msg :: TaskSummary > } impl WrappedTypesupport for Response { type CStruct = rmf_task_msgs__srv__GetTaskList_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_task_msgs__srv__GetTaskList_Response () } } fn create_msg () -> * mut rmf_task_msgs__srv__GetTaskList_Response { unsafe { rmf_task_msgs__srv__GetTaskList_Response__create () } } fn destroy_msg (msg : * mut rmf_task_msgs__srv__GetTaskList_Response) -> () { unsafe { rmf_task_msgs__srv__GetTaskList_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , active_tasks : { let mut temp = Vec :: with_capacity (msg . active_tasks . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . active_tasks . data , msg . active_tasks . size) } ; for s in slice { temp . push (rmf_task_msgs :: msg :: TaskSummary :: from_native (s)) ; } temp } , terminated_tasks : { let mut temp = Vec :: with_capacity (msg . terminated_tasks . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . terminated_tasks . data , msg . terminated_tasks . size) } ; for s in slice { temp . push (rmf_task_msgs :: msg :: TaskSummary :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; unsafe { rmf_task_msgs__msg__TaskSummary__Sequence__fini (& mut msg . active_tasks) ; rmf_task_msgs__msg__TaskSummary__Sequence__init (& mut msg . active_tasks , self . active_tasks . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . active_tasks . data , msg . active_tasks . size) ; for (t , s) in slice . iter_mut () . zip (& self . active_tasks) { s . copy_to_native (t) ; } } unsafe { rmf_task_msgs__msg__TaskSummary__Sequence__fini (& mut msg . terminated_tasks) ; rmf_task_msgs__msg__TaskSummary__Sequence__init (& mut msg . terminated_tasks , self . terminated_tasks . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . terminated_tasks . data , msg . terminated_tasks . size) ; for (t , s) in slice . iter_mut () . zip (& self . terminated_tasks) { s . copy_to_native (t) ; } } } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod ReviveTask { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__rmf_task_msgs__srv__ReviveTask () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub requester : std :: string :: String , pub task_id : std :: string :: String } impl WrappedTypesupport for Request { type CStruct = rmf_task_msgs__srv__ReviveTask_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_task_msgs__srv__ReviveTask_Request () } } fn create_msg () -> * mut rmf_task_msgs__srv__ReviveTask_Request { unsafe { rmf_task_msgs__srv__ReviveTask_Request__create () } } fn destroy_msg (msg : * mut rmf_task_msgs__srv__ReviveTask_Request) -> () { unsafe { rmf_task_msgs__srv__ReviveTask_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { requester : msg . requester . to_str () . to_owned () , task_id : msg . task_id . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . requester . assign (& self . requester) ; msg . task_id . assign (& self . task_id) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool } impl WrappedTypesupport for Response { type CStruct = rmf_task_msgs__srv__ReviveTask_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_task_msgs__srv__ReviveTask_Response () } } fn create_msg () -> * mut rmf_task_msgs__srv__ReviveTask_Response { unsafe { rmf_task_msgs__srv__ReviveTask_Response__create () } } fn destroy_msg (msg : * mut rmf_task_msgs__srv__ReviveTask_Response) -> () { unsafe { rmf_task_msgs__srv__ReviveTask_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod SubmitTask { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__rmf_task_msgs__srv__SubmitTask () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub requester : std :: string :: String , pub description : rmf_task_msgs :: msg :: TaskDescription } impl WrappedTypesupport for Request { type CStruct = rmf_task_msgs__srv__SubmitTask_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_task_msgs__srv__SubmitTask_Request () } } fn create_msg () -> * mut rmf_task_msgs__srv__SubmitTask_Request { unsafe { rmf_task_msgs__srv__SubmitTask_Request__create () } } fn destroy_msg (msg : * mut rmf_task_msgs__srv__SubmitTask_Request) -> () { unsafe { rmf_task_msgs__srv__SubmitTask_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { requester : msg . requester . to_str () . to_owned () , description : rmf_task_msgs :: msg :: TaskDescription :: from_native (& msg . description) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . requester . assign (& self . requester) ; self . description . copy_to_native (& mut msg . description) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool , pub task_id : std :: string :: String , pub message : std :: string :: String } impl WrappedTypesupport for Response { type CStruct = rmf_task_msgs__srv__SubmitTask_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_task_msgs__srv__SubmitTask_Response () } } fn create_msg () -> * mut rmf_task_msgs__srv__SubmitTask_Response { unsafe { rmf_task_msgs__srv__SubmitTask_Response__create () } } fn destroy_msg (msg : * mut rmf_task_msgs__srv__SubmitTask_Response) -> () { unsafe { rmf_task_msgs__srv__SubmitTask_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , task_id : msg . task_id . to_str () . to_owned () , message : msg . message . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; msg . task_id . assign (& self . task_id) ; msg . message . assign (& self . message) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } } pub mod msg { use super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Behavior { pub name : std :: string :: String , pub parameters : Vec < rmf_task_msgs :: msg :: BehaviorParameter > } impl WrappedTypesupport for Behavior { type CStruct = rmf_task_msgs__msg__Behavior ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_task_msgs__msg__Behavior () } } fn create_msg () -> * mut rmf_task_msgs__msg__Behavior { unsafe { rmf_task_msgs__msg__Behavior__create () } } fn destroy_msg (msg : * mut rmf_task_msgs__msg__Behavior) -> () { unsafe { rmf_task_msgs__msg__Behavior__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Behavior { Behavior { name : msg . name . to_str () . to_owned () , parameters : { let mut temp = Vec :: with_capacity (msg . parameters . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . parameters . data , msg . parameters . size) } ; for s in slice { temp . push (rmf_task_msgs :: msg :: BehaviorParameter :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . name . assign (& self . name) ; unsafe { rmf_task_msgs__msg__BehaviorParameter__Sequence__fini (& mut msg . parameters) ; rmf_task_msgs__msg__BehaviorParameter__Sequence__init (& mut msg . parameters , self . parameters . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . parameters . data , msg . parameters . size) ; for (t , s) in slice . iter_mut () . zip (& self . parameters) { s . copy_to_native (t) ; } } } } impl Default for Behavior { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Behavior > :: new () ; Behavior :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct BehaviorParameter { pub name : std :: string :: String , pub value : std :: string :: String } impl WrappedTypesupport for BehaviorParameter { type CStruct = rmf_task_msgs__msg__BehaviorParameter ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_task_msgs__msg__BehaviorParameter () } } fn create_msg () -> * mut rmf_task_msgs__msg__BehaviorParameter { unsafe { rmf_task_msgs__msg__BehaviorParameter__create () } } fn destroy_msg (msg : * mut rmf_task_msgs__msg__BehaviorParameter) -> () { unsafe { rmf_task_msgs__msg__BehaviorParameter__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> BehaviorParameter { BehaviorParameter { name : msg . name . to_str () . to_owned () , value : msg . value . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . name . assign (& self . name) ; msg . value . assign (& self . value) ; } } impl Default for BehaviorParameter { fn default () -> Self { let msg_native = WrappedNativeMsg :: < BehaviorParameter > :: new () ; BehaviorParameter :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct BidNotice { pub task_profile : rmf_task_msgs :: msg :: TaskProfile , pub time_window : builtin_interfaces :: msg :: Duration } impl WrappedTypesupport for BidNotice { type CStruct = rmf_task_msgs__msg__BidNotice ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_task_msgs__msg__BidNotice () } } fn create_msg () -> * mut rmf_task_msgs__msg__BidNotice { unsafe { rmf_task_msgs__msg__BidNotice__create () } } fn destroy_msg (msg : * mut rmf_task_msgs__msg__BidNotice) -> () { unsafe { rmf_task_msgs__msg__BidNotice__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> BidNotice { BidNotice { task_profile : rmf_task_msgs :: msg :: TaskProfile :: from_native (& msg . task_profile) , time_window : builtin_interfaces :: msg :: Duration :: from_native (& msg . time_window) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . task_profile . copy_to_native (& mut msg . task_profile) ; self . time_window . copy_to_native (& mut msg . time_window) ; } } impl Default for BidNotice { fn default () -> Self { let msg_native = WrappedNativeMsg :: < BidNotice > :: new () ; BidNotice :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct BidProposal { pub fleet_name : std :: string :: String , pub task_profile : rmf_task_msgs :: msg :: TaskProfile , pub prev_cost : f64 , pub new_cost : f64 , pub finish_time : builtin_interfaces :: msg :: Time , pub robot_name : std :: string :: String } impl WrappedTypesupport for BidProposal { type CStruct = rmf_task_msgs__msg__BidProposal ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_task_msgs__msg__BidProposal () } } fn create_msg () -> * mut rmf_task_msgs__msg__BidProposal { unsafe { rmf_task_msgs__msg__BidProposal__create () } } fn destroy_msg (msg : * mut rmf_task_msgs__msg__BidProposal) -> () { unsafe { rmf_task_msgs__msg__BidProposal__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> BidProposal { BidProposal { fleet_name : msg . fleet_name . to_str () . to_owned () , task_profile : rmf_task_msgs :: msg :: TaskProfile :: from_native (& msg . task_profile) , prev_cost : msg . prev_cost , new_cost : msg . new_cost , finish_time : builtin_interfaces :: msg :: Time :: from_native (& msg . finish_time) , robot_name : msg . robot_name . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . fleet_name . assign (& self . fleet_name) ; self . task_profile . copy_to_native (& mut msg . task_profile) ; msg . prev_cost = self . prev_cost ; msg . new_cost = self . new_cost ; self . finish_time . copy_to_native (& mut msg . finish_time) ; msg . robot_name . assign (& self . robot_name) ; } } impl Default for BidProposal { fn default () -> Self { let msg_native = WrappedNativeMsg :: < BidProposal > :: new () ; BidProposal :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Clean { pub start_waypoint : std :: string :: String } impl WrappedTypesupport for Clean { type CStruct = rmf_task_msgs__msg__Clean ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_task_msgs__msg__Clean () } } fn create_msg () -> * mut rmf_task_msgs__msg__Clean { unsafe { rmf_task_msgs__msg__Clean__create () } } fn destroy_msg (msg : * mut rmf_task_msgs__msg__Clean) -> () { unsafe { rmf_task_msgs__msg__Clean__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Clean { Clean { start_waypoint : msg . start_waypoint . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . start_waypoint . assign (& self . start_waypoint) ; } } impl Default for Clean { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Clean > :: new () ; Clean :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Delivery { pub task_id : std :: string :: String , pub items : Vec < rmf_dispenser_msgs :: msg :: DispenserRequestItem > , pub pickup_place_name : std :: string :: String , pub pickup_dispenser : std :: string :: String , pub pickup_behavior : rmf_task_msgs :: msg :: Behavior , pub dropoff_place_name : std :: string :: String , pub dropoff_ingestor : std :: string :: String , pub dropoff_behavior : rmf_task_msgs :: msg :: Behavior } impl WrappedTypesupport for Delivery { type CStruct = rmf_task_msgs__msg__Delivery ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_task_msgs__msg__Delivery () } } fn create_msg () -> * mut rmf_task_msgs__msg__Delivery { unsafe { rmf_task_msgs__msg__Delivery__create () } } fn destroy_msg (msg : * mut rmf_task_msgs__msg__Delivery) -> () { unsafe { rmf_task_msgs__msg__Delivery__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Delivery { Delivery { task_id : msg . task_id . to_str () . to_owned () , items : { let mut temp = Vec :: with_capacity (msg . items . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . items . data , msg . items . size) } ; for s in slice { temp . push (rmf_dispenser_msgs :: msg :: DispenserRequestItem :: from_native (s)) ; } temp } , pickup_place_name : msg . pickup_place_name . to_str () . to_owned () , pickup_dispenser : msg . pickup_dispenser . to_str () . to_owned () , pickup_behavior : rmf_task_msgs :: msg :: Behavior :: from_native (& msg . pickup_behavior) , dropoff_place_name : msg . dropoff_place_name . to_str () . to_owned () , dropoff_ingestor : msg . dropoff_ingestor . to_str () . to_owned () , dropoff_behavior : rmf_task_msgs :: msg :: Behavior :: from_native (& msg . dropoff_behavior) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . task_id . assign (& self . task_id) ; unsafe { rmf_dispenser_msgs__msg__DispenserRequestItem__Sequence__fini (& mut msg . items) ; rmf_dispenser_msgs__msg__DispenserRequestItem__Sequence__init (& mut msg . items , self . items . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . items . data , msg . items . size) ; for (t , s) in slice . iter_mut () . zip (& self . items) { s . copy_to_native (t) ; } } msg . pickup_place_name . assign (& self . pickup_place_name) ; msg . pickup_dispenser . assign (& self . pickup_dispenser) ; self . pickup_behavior . copy_to_native (& mut msg . pickup_behavior) ; msg . dropoff_place_name . assign (& self . dropoff_place_name) ; msg . dropoff_ingestor . assign (& self . dropoff_ingestor) ; self . dropoff_behavior . copy_to_native (& mut msg . dropoff_behavior) ; } } impl Default for Delivery { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Delivery > :: new () ; Delivery :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct DispatchAck { pub dispatch_request : rmf_task_msgs :: msg :: DispatchRequest , pub success : bool } impl WrappedTypesupport for DispatchAck { type CStruct = rmf_task_msgs__msg__DispatchAck ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_task_msgs__msg__DispatchAck () } } fn create_msg () -> * mut rmf_task_msgs__msg__DispatchAck { unsafe { rmf_task_msgs__msg__DispatchAck__create () } } fn destroy_msg (msg : * mut rmf_task_msgs__msg__DispatchAck) -> () { unsafe { rmf_task_msgs__msg__DispatchAck__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> DispatchAck { DispatchAck { dispatch_request : rmf_task_msgs :: msg :: DispatchRequest :: from_native (& msg . dispatch_request) , success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . dispatch_request . copy_to_native (& mut msg . dispatch_request) ; msg . success = self . success ; } } impl Default for DispatchAck { fn default () -> Self { let msg_native = WrappedNativeMsg :: < DispatchAck > :: new () ; DispatchAck :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct DispatchRequest { pub fleet_name : std :: string :: String , pub task_profile : rmf_task_msgs :: msg :: TaskProfile , pub method : u8 } impl WrappedTypesupport for DispatchRequest { type CStruct = rmf_task_msgs__msg__DispatchRequest ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_task_msgs__msg__DispatchRequest () } } fn create_msg () -> * mut rmf_task_msgs__msg__DispatchRequest { unsafe { rmf_task_msgs__msg__DispatchRequest__create () } } fn destroy_msg (msg : * mut rmf_task_msgs__msg__DispatchRequest) -> () { unsafe { rmf_task_msgs__msg__DispatchRequest__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> DispatchRequest { DispatchRequest { fleet_name : msg . fleet_name . to_str () . to_owned () , task_profile : rmf_task_msgs :: msg :: TaskProfile :: from_native (& msg . task_profile) , method : msg . method , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . fleet_name . assign (& self . fleet_name) ; self . task_profile . copy_to_native (& mut msg . task_profile) ; msg . method = self . method ; } } impl Default for DispatchRequest { fn default () -> Self { let msg_native = WrappedNativeMsg :: < DispatchRequest > :: new () ; DispatchRequest :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl DispatchRequest { pub const ADD : _bindgen_ty_1576 = rmf_task_msgs__msg__DispatchRequest__ADD ; pub const CANCEL : _bindgen_ty_1577 = rmf_task_msgs__msg__DispatchRequest__CANCEL ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Loop { pub task_id : std :: string :: String , pub robot_type : std :: string :: String , pub num_loops : u32 , pub start_name : std :: string :: String , pub finish_name : std :: string :: String } impl WrappedTypesupport for Loop { type CStruct = rmf_task_msgs__msg__Loop ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_task_msgs__msg__Loop () } } fn create_msg () -> * mut rmf_task_msgs__msg__Loop { unsafe { rmf_task_msgs__msg__Loop__create () } } fn destroy_msg (msg : * mut rmf_task_msgs__msg__Loop) -> () { unsafe { rmf_task_msgs__msg__Loop__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Loop { Loop { task_id : msg . task_id . to_str () . to_owned () , robot_type : msg . robot_type . to_str () . to_owned () , num_loops : msg . num_loops , start_name : msg . start_name . to_str () . to_owned () , finish_name : msg . finish_name . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . task_id . assign (& self . task_id) ; msg . robot_type . assign (& self . robot_type) ; msg . num_loops = self . num_loops ; msg . start_name . assign (& self . start_name) ; msg . finish_name . assign (& self . finish_name) ; } } impl Default for Loop { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Loop > :: new () ; Loop :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Priority { pub value : u64 } impl WrappedTypesupport for Priority { type CStruct = rmf_task_msgs__msg__Priority ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_task_msgs__msg__Priority () } } fn create_msg () -> * mut rmf_task_msgs__msg__Priority { unsafe { rmf_task_msgs__msg__Priority__create () } } fn destroy_msg (msg : * mut rmf_task_msgs__msg__Priority) -> () { unsafe { rmf_task_msgs__msg__Priority__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Priority { Priority { value : msg . value , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . value = self . value ; } } impl Default for Priority { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Priority > :: new () ; Priority :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Station { pub task_id : std :: string :: String , pub robot_type : std :: string :: String , pub place_name : std :: string :: String } impl WrappedTypesupport for Station { type CStruct = rmf_task_msgs__msg__Station ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_task_msgs__msg__Station () } } fn create_msg () -> * mut rmf_task_msgs__msg__Station { unsafe { rmf_task_msgs__msg__Station__create () } } fn destroy_msg (msg : * mut rmf_task_msgs__msg__Station) -> () { unsafe { rmf_task_msgs__msg__Station__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Station { Station { task_id : msg . task_id . to_str () . to_owned () , robot_type : msg . robot_type . to_str () . to_owned () , place_name : msg . place_name . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . task_id . assign (& self . task_id) ; msg . robot_type . assign (& self . robot_type) ; msg . place_name . assign (& self . place_name) ; } } impl Default for Station { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Station > :: new () ; Station :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct TaskDescription { pub start_time : builtin_interfaces :: msg :: Time , pub priority : rmf_task_msgs :: msg :: Priority , pub task_type : rmf_task_msgs :: msg :: TaskType , pub station : rmf_task_msgs :: msg :: Station , # [serde (rename = "loop")] pub loop_ : rmf_task_msgs :: msg :: Loop , pub delivery : rmf_task_msgs :: msg :: Delivery , pub clean : rmf_task_msgs :: msg :: Clean } impl WrappedTypesupport for TaskDescription { type CStruct = rmf_task_msgs__msg__TaskDescription ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_task_msgs__msg__TaskDescription () } } fn create_msg () -> * mut rmf_task_msgs__msg__TaskDescription { unsafe { rmf_task_msgs__msg__TaskDescription__create () } } fn destroy_msg (msg : * mut rmf_task_msgs__msg__TaskDescription) -> () { unsafe { rmf_task_msgs__msg__TaskDescription__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> TaskDescription { TaskDescription { start_time : builtin_interfaces :: msg :: Time :: from_native (& msg . start_time) , priority : rmf_task_msgs :: msg :: Priority :: from_native (& msg . priority) , task_type : rmf_task_msgs :: msg :: TaskType :: from_native (& msg . task_type) , station : rmf_task_msgs :: msg :: Station :: from_native (& msg . station) , loop_ : rmf_task_msgs :: msg :: Loop :: from_native (& msg . loop_) , delivery : rmf_task_msgs :: msg :: Delivery :: from_native (& msg . delivery) , clean : rmf_task_msgs :: msg :: Clean :: from_native (& msg . clean) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . start_time . copy_to_native (& mut msg . start_time) ; self . priority . copy_to_native (& mut msg . priority) ; self . task_type . copy_to_native (& mut msg . task_type) ; self . station . copy_to_native (& mut msg . station) ; self . loop_ . copy_to_native (& mut msg . loop_) ; self . delivery . copy_to_native (& mut msg . delivery) ; self . clean . copy_to_native (& mut msg . clean) ; } } impl Default for TaskDescription { fn default () -> Self { let msg_native = WrappedNativeMsg :: < TaskDescription > :: new () ; TaskDescription :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct TaskProfile { pub task_id : std :: string :: String , pub submission_time : builtin_interfaces :: msg :: Time , pub description : rmf_task_msgs :: msg :: TaskDescription } impl WrappedTypesupport for TaskProfile { type CStruct = rmf_task_msgs__msg__TaskProfile ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_task_msgs__msg__TaskProfile () } } fn create_msg () -> * mut rmf_task_msgs__msg__TaskProfile { unsafe { rmf_task_msgs__msg__TaskProfile__create () } } fn destroy_msg (msg : * mut rmf_task_msgs__msg__TaskProfile) -> () { unsafe { rmf_task_msgs__msg__TaskProfile__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> TaskProfile { TaskProfile { task_id : msg . task_id . to_str () . to_owned () , submission_time : builtin_interfaces :: msg :: Time :: from_native (& msg . submission_time) , description : rmf_task_msgs :: msg :: TaskDescription :: from_native (& msg . description) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . task_id . assign (& self . task_id) ; self . submission_time . copy_to_native (& mut msg . submission_time) ; self . description . copy_to_native (& mut msg . description) ; } } impl Default for TaskProfile { fn default () -> Self { let msg_native = WrappedNativeMsg :: < TaskProfile > :: new () ; TaskProfile :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct TaskSummary { pub fleet_name : std :: string :: String , pub task_id : std :: string :: String , pub task_profile : rmf_task_msgs :: msg :: TaskProfile , pub state : u32 , pub status : std :: string :: String , pub submission_time : builtin_interfaces :: msg :: Time , pub start_time : builtin_interfaces :: msg :: Time , pub end_time : builtin_interfaces :: msg :: Time , pub robot_name : std :: string :: String } impl WrappedTypesupport for TaskSummary { type CStruct = rmf_task_msgs__msg__TaskSummary ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_task_msgs__msg__TaskSummary () } } fn create_msg () -> * mut rmf_task_msgs__msg__TaskSummary { unsafe { rmf_task_msgs__msg__TaskSummary__create () } } fn destroy_msg (msg : * mut rmf_task_msgs__msg__TaskSummary) -> () { unsafe { rmf_task_msgs__msg__TaskSummary__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> TaskSummary { TaskSummary { fleet_name : msg . fleet_name . to_str () . to_owned () , task_id : msg . task_id . to_str () . to_owned () , task_profile : rmf_task_msgs :: msg :: TaskProfile :: from_native (& msg . task_profile) , state : msg . state , status : msg . status . to_str () . to_owned () , submission_time : builtin_interfaces :: msg :: Time :: from_native (& msg . submission_time) , start_time : builtin_interfaces :: msg :: Time :: from_native (& msg . start_time) , end_time : builtin_interfaces :: msg :: Time :: from_native (& msg . end_time) , robot_name : msg . robot_name . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . fleet_name . assign (& self . fleet_name) ; msg . task_id . assign (& self . task_id) ; self . task_profile . copy_to_native (& mut msg . task_profile) ; msg . state = self . state ; msg . status . assign (& self . status) ; self . submission_time . copy_to_native (& mut msg . submission_time) ; self . start_time . copy_to_native (& mut msg . start_time) ; self . end_time . copy_to_native (& mut msg . end_time) ; msg . robot_name . assign (& self . robot_name) ; } } impl Default for TaskSummary { fn default () -> Self { let msg_native = WrappedNativeMsg :: < TaskSummary > :: new () ; TaskSummary :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl TaskSummary { pub const STATE_ACTIVE : _bindgen_ty_1579 = rmf_task_msgs__msg__TaskSummary__STATE_ACTIVE ; pub const STATE_CANCELED : _bindgen_ty_1582 = rmf_task_msgs__msg__TaskSummary__STATE_CANCELED ; pub const STATE_COMPLETED : _bindgen_ty_1580 = rmf_task_msgs__msg__TaskSummary__STATE_COMPLETED ; pub const STATE_FAILED : _bindgen_ty_1581 = rmf_task_msgs__msg__TaskSummary__STATE_FAILED ; pub const STATE_PENDING : _bindgen_ty_1583 = rmf_task_msgs__msg__TaskSummary__STATE_PENDING ; pub const STATE_QUEUED : _bindgen_ty_1578 = rmf_task_msgs__msg__TaskSummary__STATE_QUEUED ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct TaskType { # [serde (rename = "type")] pub type_ : u32 } impl WrappedTypesupport for TaskType { type CStruct = rmf_task_msgs__msg__TaskType ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_task_msgs__msg__TaskType () } } fn create_msg () -> * mut rmf_task_msgs__msg__TaskType { unsafe { rmf_task_msgs__msg__TaskType__create () } } fn destroy_msg (msg : * mut rmf_task_msgs__msg__TaskType) -> () { unsafe { rmf_task_msgs__msg__TaskType__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> TaskType { TaskType { type_ : msg . type_ , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . type_ = self . type_ ; } } impl Default for TaskType { fn default () -> Self { let msg_native = WrappedNativeMsg :: < TaskType > :: new () ; TaskType :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl TaskType { pub const TYPE_CHARGE_BATTERY : _bindgen_ty_1573 = rmf_task_msgs__msg__TaskType__TYPE_CHARGE_BATTERY ; pub const TYPE_CLEAN : _bindgen_ty_1574 = rmf_task_msgs__msg__TaskType__TYPE_CLEAN ; pub const TYPE_DELIVERY : _bindgen_ty_1572 = rmf_task_msgs__msg__TaskType__TYPE_DELIVERY ; pub const TYPE_LOOP : _bindgen_ty_1571 = rmf_task_msgs__msg__TaskType__TYPE_LOOP ; pub const TYPE_PATROL : _bindgen_ty_1575 = rmf_task_msgs__msg__TaskType__TYPE_PATROL ; pub const TYPE_STATION : _bindgen_ty_1570 = rmf_task_msgs__msg__TaskType__TYPE_STATION ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Tasks { pub tasks : Vec < rmf_task_msgs :: msg :: TaskSummary > } impl WrappedTypesupport for Tasks { type CStruct = rmf_task_msgs__msg__Tasks ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_task_msgs__msg__Tasks () } } fn create_msg () -> * mut rmf_task_msgs__msg__Tasks { unsafe { rmf_task_msgs__msg__Tasks__create () } } fn destroy_msg (msg : * mut rmf_task_msgs__msg__Tasks) -> () { unsafe { rmf_task_msgs__msg__Tasks__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Tasks { Tasks { tasks : { let mut temp = Vec :: with_capacity (msg . tasks . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . tasks . data , msg . tasks . size) } ; for s in slice { temp . push (rmf_task_msgs :: msg :: TaskSummary :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { unsafe { rmf_task_msgs__msg__TaskSummary__Sequence__fini (& mut msg . tasks) ; rmf_task_msgs__msg__TaskSummary__Sequence__init (& mut msg . tasks , self . tasks . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . tasks . data , msg . tasks . size) ; for (t , s) in slice . iter_mut () . zip (& self . tasks) { s . copy_to_native (t) ; } } } } impl Default for Tasks { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Tasks > :: new () ; Tasks :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Tow { pub task_id : std :: string :: String , pub object_type : std :: string :: String , pub is_object_id_known : bool , pub object_id : std :: string :: String , pub pickup_place_name : std :: string :: String , pub is_dropoff_place_known : bool , pub dropoff_place_name : std :: string :: String } impl WrappedTypesupport for Tow { type CStruct = rmf_task_msgs__msg__Tow ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_task_msgs__msg__Tow () } } fn create_msg () -> * mut rmf_task_msgs__msg__Tow { unsafe { rmf_task_msgs__msg__Tow__create () } } fn destroy_msg (msg : * mut rmf_task_msgs__msg__Tow) -> () { unsafe { rmf_task_msgs__msg__Tow__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Tow { Tow { task_id : msg . task_id . to_str () . to_owned () , object_type : msg . object_type . to_str () . to_owned () , is_object_id_known : msg . is_object_id_known , object_id : msg . object_id . to_str () . to_owned () , pickup_place_name : msg . pickup_place_name . to_str () . to_owned () , is_dropoff_place_known : msg . is_dropoff_place_known , dropoff_place_name : msg . dropoff_place_name . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . task_id . assign (& self . task_id) ; msg . object_type . assign (& self . object_type) ; msg . is_object_id_known = self . is_object_id_known ; msg . object_id . assign (& self . object_id) ; msg . pickup_place_name . assign (& self . pickup_place_name) ; msg . is_dropoff_place_known = self . is_dropoff_place_known ; msg . dropoff_place_name . assign (& self . dropoff_place_name) ; } } impl Default for Tow { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Tow > :: new () ; Tow :: from_native (& msg_native) } } }