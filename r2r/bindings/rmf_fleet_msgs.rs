pub mod msg { use super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ClosedLanes { pub fleet_name : std :: string :: String , pub closed_lanes : Vec < u64 > } impl WrappedTypesupport for ClosedLanes { type CStruct = rmf_fleet_msgs__msg__ClosedLanes ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_fleet_msgs__msg__ClosedLanes () } } fn create_msg () -> * mut rmf_fleet_msgs__msg__ClosedLanes { unsafe { rmf_fleet_msgs__msg__ClosedLanes__create () } } fn destroy_msg (msg : * mut rmf_fleet_msgs__msg__ClosedLanes) -> () { unsafe { rmf_fleet_msgs__msg__ClosedLanes__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ClosedLanes { ClosedLanes { fleet_name : msg . fleet_name . to_str () . to_owned () , closed_lanes : msg . closed_lanes . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . fleet_name . assign (& self . fleet_name) ; msg . closed_lanes . update (& self . closed_lanes) ; } } impl Default for ClosedLanes { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ClosedLanes > :: new () ; ClosedLanes :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct DestinationRequest { pub fleet_name : std :: string :: String , pub robot_name : std :: string :: String , pub destination : rmf_fleet_msgs :: msg :: Location , pub task_id : std :: string :: String } impl WrappedTypesupport for DestinationRequest { type CStruct = rmf_fleet_msgs__msg__DestinationRequest ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_fleet_msgs__msg__DestinationRequest () } } fn create_msg () -> * mut rmf_fleet_msgs__msg__DestinationRequest { unsafe { rmf_fleet_msgs__msg__DestinationRequest__create () } } fn destroy_msg (msg : * mut rmf_fleet_msgs__msg__DestinationRequest) -> () { unsafe { rmf_fleet_msgs__msg__DestinationRequest__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> DestinationRequest { DestinationRequest { fleet_name : msg . fleet_name . to_str () . to_owned () , robot_name : msg . robot_name . to_str () . to_owned () , destination : rmf_fleet_msgs :: msg :: Location :: from_native (& msg . destination) , task_id : msg . task_id . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . fleet_name . assign (& self . fleet_name) ; msg . robot_name . assign (& self . robot_name) ; self . destination . copy_to_native (& mut msg . destination) ; msg . task_id . assign (& self . task_id) ; } } impl Default for DestinationRequest { fn default () -> Self { let msg_native = WrappedNativeMsg :: < DestinationRequest > :: new () ; DestinationRequest :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Dock { pub fleet_name : std :: string :: String , pub params : Vec < rmf_fleet_msgs :: msg :: DockParameter > } impl WrappedTypesupport for Dock { type CStruct = rmf_fleet_msgs__msg__Dock ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_fleet_msgs__msg__Dock () } } fn create_msg () -> * mut rmf_fleet_msgs__msg__Dock { unsafe { rmf_fleet_msgs__msg__Dock__create () } } fn destroy_msg (msg : * mut rmf_fleet_msgs__msg__Dock) -> () { unsafe { rmf_fleet_msgs__msg__Dock__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Dock { Dock { fleet_name : msg . fleet_name . to_str () . to_owned () , params : { let mut temp = Vec :: with_capacity (msg . params . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . params . data , msg . params . size) } ; for s in slice { temp . push (rmf_fleet_msgs :: msg :: DockParameter :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . fleet_name . assign (& self . fleet_name) ; unsafe { rmf_fleet_msgs__msg__DockParameter__Sequence__fini (& mut msg . params) ; rmf_fleet_msgs__msg__DockParameter__Sequence__init (& mut msg . params , self . params . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . params . data , msg . params . size) ; for (t , s) in slice . iter_mut () . zip (& self . params) { s . copy_to_native (t) ; } } } } impl Default for Dock { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Dock > :: new () ; Dock :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct DockParameter { pub start : std :: string :: String , pub finish : std :: string :: String , pub path : Vec < rmf_fleet_msgs :: msg :: Location > } impl WrappedTypesupport for DockParameter { type CStruct = rmf_fleet_msgs__msg__DockParameter ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_fleet_msgs__msg__DockParameter () } } fn create_msg () -> * mut rmf_fleet_msgs__msg__DockParameter { unsafe { rmf_fleet_msgs__msg__DockParameter__create () } } fn destroy_msg (msg : * mut rmf_fleet_msgs__msg__DockParameter) -> () { unsafe { rmf_fleet_msgs__msg__DockParameter__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> DockParameter { DockParameter { start : msg . start . to_str () . to_owned () , finish : msg . finish . to_str () . to_owned () , path : { let mut temp = Vec :: with_capacity (msg . path . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . path . data , msg . path . size) } ; for s in slice { temp . push (rmf_fleet_msgs :: msg :: Location :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . start . assign (& self . start) ; msg . finish . assign (& self . finish) ; unsafe { rmf_fleet_msgs__msg__Location__Sequence__fini (& mut msg . path) ; rmf_fleet_msgs__msg__Location__Sequence__init (& mut msg . path , self . path . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . path . data , msg . path . size) ; for (t , s) in slice . iter_mut () . zip (& self . path) { s . copy_to_native (t) ; } } } } impl Default for DockParameter { fn default () -> Self { let msg_native = WrappedNativeMsg :: < DockParameter > :: new () ; DockParameter :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct DockSummary { pub docks : Vec < rmf_fleet_msgs :: msg :: Dock > } impl WrappedTypesupport for DockSummary { type CStruct = rmf_fleet_msgs__msg__DockSummary ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_fleet_msgs__msg__DockSummary () } } fn create_msg () -> * mut rmf_fleet_msgs__msg__DockSummary { unsafe { rmf_fleet_msgs__msg__DockSummary__create () } } fn destroy_msg (msg : * mut rmf_fleet_msgs__msg__DockSummary) -> () { unsafe { rmf_fleet_msgs__msg__DockSummary__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> DockSummary { DockSummary { docks : { let mut temp = Vec :: with_capacity (msg . docks . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . docks . data , msg . docks . size) } ; for s in slice { temp . push (rmf_fleet_msgs :: msg :: Dock :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { unsafe { rmf_fleet_msgs__msg__Dock__Sequence__fini (& mut msg . docks) ; rmf_fleet_msgs__msg__Dock__Sequence__init (& mut msg . docks , self . docks . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . docks . data , msg . docks . size) ; for (t , s) in slice . iter_mut () . zip (& self . docks) { s . copy_to_native (t) ; } } } } impl Default for DockSummary { fn default () -> Self { let msg_native = WrappedNativeMsg :: < DockSummary > :: new () ; DockSummary :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct FleetState { pub name : std :: string :: String , pub robots : Vec < rmf_fleet_msgs :: msg :: RobotState > } impl WrappedTypesupport for FleetState { type CStruct = rmf_fleet_msgs__msg__FleetState ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_fleet_msgs__msg__FleetState () } } fn create_msg () -> * mut rmf_fleet_msgs__msg__FleetState { unsafe { rmf_fleet_msgs__msg__FleetState__create () } } fn destroy_msg (msg : * mut rmf_fleet_msgs__msg__FleetState) -> () { unsafe { rmf_fleet_msgs__msg__FleetState__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> FleetState { FleetState { name : msg . name . to_str () . to_owned () , robots : { let mut temp = Vec :: with_capacity (msg . robots . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . robots . data , msg . robots . size) } ; for s in slice { temp . push (rmf_fleet_msgs :: msg :: RobotState :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . name . assign (& self . name) ; unsafe { rmf_fleet_msgs__msg__RobotState__Sequence__fini (& mut msg . robots) ; rmf_fleet_msgs__msg__RobotState__Sequence__init (& mut msg . robots , self . robots . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . robots . data , msg . robots . size) ; for (t , s) in slice . iter_mut () . zip (& self . robots) { s . copy_to_native (t) ; } } } } impl Default for FleetState { fn default () -> Self { let msg_native = WrappedNativeMsg :: < FleetState > :: new () ; FleetState :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct LaneRequest { pub fleet_name : std :: string :: String , pub open_lanes : Vec < u64 > , pub close_lanes : Vec < u64 > } impl WrappedTypesupport for LaneRequest { type CStruct = rmf_fleet_msgs__msg__LaneRequest ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_fleet_msgs__msg__LaneRequest () } } fn create_msg () -> * mut rmf_fleet_msgs__msg__LaneRequest { unsafe { rmf_fleet_msgs__msg__LaneRequest__create () } } fn destroy_msg (msg : * mut rmf_fleet_msgs__msg__LaneRequest) -> () { unsafe { rmf_fleet_msgs__msg__LaneRequest__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> LaneRequest { LaneRequest { fleet_name : msg . fleet_name . to_str () . to_owned () , open_lanes : msg . open_lanes . to_vec () , close_lanes : msg . close_lanes . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . fleet_name . assign (& self . fleet_name) ; msg . open_lanes . update (& self . open_lanes) ; msg . close_lanes . update (& self . close_lanes) ; } } impl Default for LaneRequest { fn default () -> Self { let msg_native = WrappedNativeMsg :: < LaneRequest > :: new () ; LaneRequest :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Location { pub t : builtin_interfaces :: msg :: Time , pub x : f32 , pub y : f32 , pub yaw : f32 , pub level_name : std :: string :: String , pub index : u64 } impl WrappedTypesupport for Location { type CStruct = rmf_fleet_msgs__msg__Location ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_fleet_msgs__msg__Location () } } fn create_msg () -> * mut rmf_fleet_msgs__msg__Location { unsafe { rmf_fleet_msgs__msg__Location__create () } } fn destroy_msg (msg : * mut rmf_fleet_msgs__msg__Location) -> () { unsafe { rmf_fleet_msgs__msg__Location__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Location { Location { t : builtin_interfaces :: msg :: Time :: from_native (& msg . t) , x : msg . x , y : msg . y , yaw : msg . yaw , level_name : msg . level_name . to_str () . to_owned () , index : msg . index , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . t . copy_to_native (& mut msg . t) ; msg . x = self . x ; msg . y = self . y ; msg . yaw = self . yaw ; msg . level_name . assign (& self . level_name) ; msg . index = self . index ; } } impl Default for Location { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Location > :: new () ; Location :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ModeParameter { pub name : std :: string :: String , pub value : std :: string :: String } impl WrappedTypesupport for ModeParameter { type CStruct = rmf_fleet_msgs__msg__ModeParameter ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_fleet_msgs__msg__ModeParameter () } } fn create_msg () -> * mut rmf_fleet_msgs__msg__ModeParameter { unsafe { rmf_fleet_msgs__msg__ModeParameter__create () } } fn destroy_msg (msg : * mut rmf_fleet_msgs__msg__ModeParameter) -> () { unsafe { rmf_fleet_msgs__msg__ModeParameter__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ModeParameter { ModeParameter { name : msg . name . to_str () . to_owned () , value : msg . value . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . name . assign (& self . name) ; msg . value . assign (& self . value) ; } } impl Default for ModeParameter { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ModeParameter > :: new () ; ModeParameter :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ModeRequest { pub fleet_name : std :: string :: String , pub robot_name : std :: string :: String , pub mode : rmf_fleet_msgs :: msg :: RobotMode , pub task_id : std :: string :: String , pub parameters : Vec < rmf_fleet_msgs :: msg :: ModeParameter > } impl WrappedTypesupport for ModeRequest { type CStruct = rmf_fleet_msgs__msg__ModeRequest ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_fleet_msgs__msg__ModeRequest () } } fn create_msg () -> * mut rmf_fleet_msgs__msg__ModeRequest { unsafe { rmf_fleet_msgs__msg__ModeRequest__create () } } fn destroy_msg (msg : * mut rmf_fleet_msgs__msg__ModeRequest) -> () { unsafe { rmf_fleet_msgs__msg__ModeRequest__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ModeRequest { ModeRequest { fleet_name : msg . fleet_name . to_str () . to_owned () , robot_name : msg . robot_name . to_str () . to_owned () , mode : rmf_fleet_msgs :: msg :: RobotMode :: from_native (& msg . mode) , task_id : msg . task_id . to_str () . to_owned () , parameters : { let mut temp = Vec :: with_capacity (msg . parameters . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . parameters . data , msg . parameters . size) } ; for s in slice { temp . push (rmf_fleet_msgs :: msg :: ModeParameter :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . fleet_name . assign (& self . fleet_name) ; msg . robot_name . assign (& self . robot_name) ; self . mode . copy_to_native (& mut msg . mode) ; msg . task_id . assign (& self . task_id) ; unsafe { rmf_fleet_msgs__msg__ModeParameter__Sequence__fini (& mut msg . parameters) ; rmf_fleet_msgs__msg__ModeParameter__Sequence__init (& mut msg . parameters , self . parameters . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . parameters . data , msg . parameters . size) ; for (t , s) in slice . iter_mut () . zip (& self . parameters) { s . copy_to_native (t) ; } } } } impl Default for ModeRequest { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ModeRequest > :: new () ; ModeRequest :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct PathRequest { pub fleet_name : std :: string :: String , pub robot_name : std :: string :: String , pub path : Vec < rmf_fleet_msgs :: msg :: Location > , pub task_id : std :: string :: String } impl WrappedTypesupport for PathRequest { type CStruct = rmf_fleet_msgs__msg__PathRequest ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_fleet_msgs__msg__PathRequest () } } fn create_msg () -> * mut rmf_fleet_msgs__msg__PathRequest { unsafe { rmf_fleet_msgs__msg__PathRequest__create () } } fn destroy_msg (msg : * mut rmf_fleet_msgs__msg__PathRequest) -> () { unsafe { rmf_fleet_msgs__msg__PathRequest__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> PathRequest { PathRequest { fleet_name : msg . fleet_name . to_str () . to_owned () , robot_name : msg . robot_name . to_str () . to_owned () , path : { let mut temp = Vec :: with_capacity (msg . path . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . path . data , msg . path . size) } ; for s in slice { temp . push (rmf_fleet_msgs :: msg :: Location :: from_native (s)) ; } temp } , task_id : msg . task_id . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . fleet_name . assign (& self . fleet_name) ; msg . robot_name . assign (& self . robot_name) ; unsafe { rmf_fleet_msgs__msg__Location__Sequence__fini (& mut msg . path) ; rmf_fleet_msgs__msg__Location__Sequence__init (& mut msg . path , self . path . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . path . data , msg . path . size) ; for (t , s) in slice . iter_mut () . zip (& self . path) { s . copy_to_native (t) ; } } msg . task_id . assign (& self . task_id) ; } } impl Default for PathRequest { fn default () -> Self { let msg_native = WrappedNativeMsg :: < PathRequest > :: new () ; PathRequest :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct PauseRequest { pub fleet_name : std :: string :: String , pub robot_name : std :: string :: String , pub mode_request_id : u64 , # [serde (rename = "type")] pub type_ : u32 , pub at_checkpoint : u32 } impl WrappedTypesupport for PauseRequest { type CStruct = rmf_fleet_msgs__msg__PauseRequest ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_fleet_msgs__msg__PauseRequest () } } fn create_msg () -> * mut rmf_fleet_msgs__msg__PauseRequest { unsafe { rmf_fleet_msgs__msg__PauseRequest__create () } } fn destroy_msg (msg : * mut rmf_fleet_msgs__msg__PauseRequest) -> () { unsafe { rmf_fleet_msgs__msg__PauseRequest__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> PauseRequest { PauseRequest { fleet_name : msg . fleet_name . to_str () . to_owned () , robot_name : msg . robot_name . to_str () . to_owned () , mode_request_id : msg . mode_request_id , type_ : msg . type_ , at_checkpoint : msg . at_checkpoint , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . fleet_name . assign (& self . fleet_name) ; msg . robot_name . assign (& self . robot_name) ; msg . mode_request_id = self . mode_request_id ; msg . type_ = self . type_ ; msg . at_checkpoint = self . at_checkpoint ; } } impl Default for PauseRequest { fn default () -> Self { let msg_native = WrappedNativeMsg :: < PauseRequest > :: new () ; PauseRequest :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl PauseRequest { pub const TYPE_PAUSE_AT_CHECKPOINT : _bindgen_ty_1542 = rmf_fleet_msgs__msg__PauseRequest__TYPE_PAUSE_AT_CHECKPOINT ; pub const TYPE_PAUSE_IMMEDIATELY : _bindgen_ty_1541 = rmf_fleet_msgs__msg__PauseRequest__TYPE_PAUSE_IMMEDIATELY ; pub const TYPE_RESUME : _bindgen_ty_1543 = rmf_fleet_msgs__msg__PauseRequest__TYPE_RESUME ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct RobotMode { pub mode : u32 , pub mode_request_id : u64 } impl WrappedTypesupport for RobotMode { type CStruct = rmf_fleet_msgs__msg__RobotMode ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_fleet_msgs__msg__RobotMode () } } fn create_msg () -> * mut rmf_fleet_msgs__msg__RobotMode { unsafe { rmf_fleet_msgs__msg__RobotMode__create () } } fn destroy_msg (msg : * mut rmf_fleet_msgs__msg__RobotMode) -> () { unsafe { rmf_fleet_msgs__msg__RobotMode__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> RobotMode { RobotMode { mode : msg . mode , mode_request_id : msg . mode_request_id , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . mode = self . mode ; msg . mode_request_id = self . mode_request_id ; } } impl Default for RobotMode { fn default () -> Self { let msg_native = WrappedNativeMsg :: < RobotMode > :: new () ; RobotMode :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl RobotMode { pub const MODE_ADAPTER_ERROR : _bindgen_ty_1539 = rmf_fleet_msgs__msg__RobotMode__MODE_ADAPTER_ERROR ; pub const MODE_CHARGING : _bindgen_ty_1532 = rmf_fleet_msgs__msg__RobotMode__MODE_CHARGING ; pub const MODE_CLEANING : _bindgen_ty_1540 = rmf_fleet_msgs__msg__RobotMode__MODE_CLEANING ; pub const MODE_DOCKING : _bindgen_ty_1538 = rmf_fleet_msgs__msg__RobotMode__MODE_DOCKING ; pub const MODE_EMERGENCY : _bindgen_ty_1536 = rmf_fleet_msgs__msg__RobotMode__MODE_EMERGENCY ; pub const MODE_GOING_HOME : _bindgen_ty_1537 = rmf_fleet_msgs__msg__RobotMode__MODE_GOING_HOME ; pub const MODE_IDLE : _bindgen_ty_1531 = rmf_fleet_msgs__msg__RobotMode__MODE_IDLE ; pub const MODE_MOVING : _bindgen_ty_1533 = rmf_fleet_msgs__msg__RobotMode__MODE_MOVING ; pub const MODE_PAUSED : _bindgen_ty_1534 = rmf_fleet_msgs__msg__RobotMode__MODE_PAUSED ; pub const MODE_WAITING : _bindgen_ty_1535 = rmf_fleet_msgs__msg__RobotMode__MODE_WAITING ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct RobotState { pub name : std :: string :: String , pub model : std :: string :: String , pub task_id : std :: string :: String , pub seq : u64 , pub mode : rmf_fleet_msgs :: msg :: RobotMode , pub battery_percent : f32 , pub location : rmf_fleet_msgs :: msg :: Location , pub path : Vec < rmf_fleet_msgs :: msg :: Location > } impl WrappedTypesupport for RobotState { type CStruct = rmf_fleet_msgs__msg__RobotState ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_fleet_msgs__msg__RobotState () } } fn create_msg () -> * mut rmf_fleet_msgs__msg__RobotState { unsafe { rmf_fleet_msgs__msg__RobotState__create () } } fn destroy_msg (msg : * mut rmf_fleet_msgs__msg__RobotState) -> () { unsafe { rmf_fleet_msgs__msg__RobotState__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> RobotState { RobotState { name : msg . name . to_str () . to_owned () , model : msg . model . to_str () . to_owned () , task_id : msg . task_id . to_str () . to_owned () , seq : msg . seq , mode : rmf_fleet_msgs :: msg :: RobotMode :: from_native (& msg . mode) , battery_percent : msg . battery_percent , location : rmf_fleet_msgs :: msg :: Location :: from_native (& msg . location) , path : { let mut temp = Vec :: with_capacity (msg . path . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . path . data , msg . path . size) } ; for s in slice { temp . push (rmf_fleet_msgs :: msg :: Location :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . name . assign (& self . name) ; msg . model . assign (& self . model) ; msg . task_id . assign (& self . task_id) ; msg . seq = self . seq ; self . mode . copy_to_native (& mut msg . mode) ; msg . battery_percent = self . battery_percent ; self . location . copy_to_native (& mut msg . location) ; unsafe { rmf_fleet_msgs__msg__Location__Sequence__fini (& mut msg . path) ; rmf_fleet_msgs__msg__Location__Sequence__init (& mut msg . path , self . path . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . path . data , msg . path . size) ; for (t , s) in slice . iter_mut () . zip (& self . path) { s . copy_to_native (t) ; } } } } impl Default for RobotState { fn default () -> Self { let msg_native = WrappedNativeMsg :: < RobotState > :: new () ; RobotState :: from_native (& msg_native) } } } pub mod srv { # [allow (non_snake_case)] pub mod LiftClearance { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__rmf_fleet_msgs__srv__LiftClearance () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub robot_name : std :: string :: String , pub lift_name : std :: string :: String } impl WrappedTypesupport for Request { type CStruct = rmf_fleet_msgs__srv__LiftClearance_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_fleet_msgs__srv__LiftClearance_Request () } } fn create_msg () -> * mut rmf_fleet_msgs__srv__LiftClearance_Request { unsafe { rmf_fleet_msgs__srv__LiftClearance_Request__create () } } fn destroy_msg (msg : * mut rmf_fleet_msgs__srv__LiftClearance_Request) -> () { unsafe { rmf_fleet_msgs__srv__LiftClearance_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { robot_name : msg . robot_name . to_str () . to_owned () , lift_name : msg . lift_name . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . robot_name . assign (& self . robot_name) ; msg . lift_name . assign (& self . lift_name) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub decision : u32 } impl WrappedTypesupport for Response { type CStruct = rmf_fleet_msgs__srv__LiftClearance_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_fleet_msgs__srv__LiftClearance_Response () } } fn create_msg () -> * mut rmf_fleet_msgs__srv__LiftClearance_Response { unsafe { rmf_fleet_msgs__srv__LiftClearance_Response__create () } } fn destroy_msg (msg : * mut rmf_fleet_msgs__srv__LiftClearance_Response) -> () { unsafe { rmf_fleet_msgs__srv__LiftClearance_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { decision : msg . decision , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . decision = self . decision ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl Response { pub const DECISION_CLEAR : _bindgen_ty_1544 = rmf_fleet_msgs__srv__LiftClearance_Response__DECISION_CLEAR ; pub const DECISION_CROWDED : _bindgen_ty_1545 = rmf_fleet_msgs__srv__LiftClearance_Response__DECISION_CROWDED ; } } }