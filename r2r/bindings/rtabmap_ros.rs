pub mod msg { use super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct CameraModel { pub camera_info : sensor_msgs :: msg :: CameraInfo , pub local_transform : geometry_msgs :: msg :: Transform } impl WrappedTypesupport for CameraModel { type CStruct = rtabmap_ros__msg__CameraModel ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rtabmap_ros__msg__CameraModel () } } fn create_msg () -> * mut rtabmap_ros__msg__CameraModel { unsafe { rtabmap_ros__msg__CameraModel__create () } } fn destroy_msg (msg : * mut rtabmap_ros__msg__CameraModel) -> () { unsafe { rtabmap_ros__msg__CameraModel__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> CameraModel { CameraModel { camera_info : sensor_msgs :: msg :: CameraInfo :: from_native (& msg . camera_info) , local_transform : geometry_msgs :: msg :: Transform :: from_native (& msg . local_transform) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . camera_info . copy_to_native (& mut msg . camera_info) ; self . local_transform . copy_to_native (& mut msg . local_transform) ; } } impl Default for CameraModel { fn default () -> Self { let msg_native = WrappedNativeMsg :: < CameraModel > :: new () ; CameraModel :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct CameraModels { pub models : Vec < rtabmap_ros :: msg :: CameraModel > } impl WrappedTypesupport for CameraModels { type CStruct = rtabmap_ros__msg__CameraModels ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rtabmap_ros__msg__CameraModels () } } fn create_msg () -> * mut rtabmap_ros__msg__CameraModels { unsafe { rtabmap_ros__msg__CameraModels__create () } } fn destroy_msg (msg : * mut rtabmap_ros__msg__CameraModels) -> () { unsafe { rtabmap_ros__msg__CameraModels__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> CameraModels { CameraModels { models : { let mut temp = Vec :: with_capacity (msg . models . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . models . data , msg . models . size) } ; for s in slice { temp . push (rtabmap_ros :: msg :: CameraModel :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { unsafe { rtabmap_ros__msg__CameraModel__Sequence__fini (& mut msg . models) ; rtabmap_ros__msg__CameraModel__Sequence__init (& mut msg . models , self . models . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . models . data , msg . models . size) ; for (t , s) in slice . iter_mut () . zip (& self . models) { s . copy_to_native (t) ; } } } } impl Default for CameraModels { fn default () -> Self { let msg_native = WrappedNativeMsg :: < CameraModels > :: new () ; CameraModels :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct EnvSensor { pub header : std_msgs :: msg :: Header , # [serde (rename = "type")] pub type_ : i32 , pub value : f64 } impl WrappedTypesupport for EnvSensor { type CStruct = rtabmap_ros__msg__EnvSensor ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rtabmap_ros__msg__EnvSensor () } } fn create_msg () -> * mut rtabmap_ros__msg__EnvSensor { unsafe { rtabmap_ros__msg__EnvSensor__create () } } fn destroy_msg (msg : * mut rtabmap_ros__msg__EnvSensor) -> () { unsafe { rtabmap_ros__msg__EnvSensor__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> EnvSensor { EnvSensor { header : std_msgs :: msg :: Header :: from_native (& msg . header) , type_ : msg . type_ , value : msg . value , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . type_ = self . type_ ; msg . value = self . value ; } } impl Default for EnvSensor { fn default () -> Self { let msg_native = WrappedNativeMsg :: < EnvSensor > :: new () ; EnvSensor :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct GPS { pub stamp : f64 , pub longitude : f64 , pub latitude : f64 , pub altitude : f64 , pub error : f64 , pub bearing : f64 } impl WrappedTypesupport for GPS { type CStruct = rtabmap_ros__msg__GPS ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rtabmap_ros__msg__GPS () } } fn create_msg () -> * mut rtabmap_ros__msg__GPS { unsafe { rtabmap_ros__msg__GPS__create () } } fn destroy_msg (msg : * mut rtabmap_ros__msg__GPS) -> () { unsafe { rtabmap_ros__msg__GPS__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> GPS { GPS { stamp : msg . stamp , longitude : msg . longitude , latitude : msg . latitude , altitude : msg . altitude , error : msg . error , bearing : msg . bearing , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . stamp = self . stamp ; msg . longitude = self . longitude ; msg . latitude = self . latitude ; msg . altitude = self . altitude ; msg . error = self . error ; msg . bearing = self . bearing ; } } impl Default for GPS { fn default () -> Self { let msg_native = WrappedNativeMsg :: < GPS > :: new () ; GPS :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct GlobalDescriptor { pub header : std_msgs :: msg :: Header , # [serde (rename = "type")] pub type_ : i32 , pub info : Vec < u8 > , pub data : Vec < u8 > } impl WrappedTypesupport for GlobalDescriptor { type CStruct = rtabmap_ros__msg__GlobalDescriptor ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rtabmap_ros__msg__GlobalDescriptor () } } fn create_msg () -> * mut rtabmap_ros__msg__GlobalDescriptor { unsafe { rtabmap_ros__msg__GlobalDescriptor__create () } } fn destroy_msg (msg : * mut rtabmap_ros__msg__GlobalDescriptor) -> () { unsafe { rtabmap_ros__msg__GlobalDescriptor__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> GlobalDescriptor { GlobalDescriptor { header : std_msgs :: msg :: Header :: from_native (& msg . header) , type_ : msg . type_ , info : msg . info . to_vec () , data : msg . data . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . type_ = self . type_ ; msg . info . update (& self . info) ; msg . data . update (& self . data) ; } } impl Default for GlobalDescriptor { fn default () -> Self { let msg_native = WrappedNativeMsg :: < GlobalDescriptor > :: new () ; GlobalDescriptor :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Goal { pub header : std_msgs :: msg :: Header , pub node_id : i32 , pub node_label : std :: string :: String , pub frame_id : std :: string :: String } impl WrappedTypesupport for Goal { type CStruct = rtabmap_ros__msg__Goal ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rtabmap_ros__msg__Goal () } } fn create_msg () -> * mut rtabmap_ros__msg__Goal { unsafe { rtabmap_ros__msg__Goal__create () } } fn destroy_msg (msg : * mut rtabmap_ros__msg__Goal) -> () { unsafe { rtabmap_ros__msg__Goal__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Goal { Goal { header : std_msgs :: msg :: Header :: from_native (& msg . header) , node_id : msg . node_id , node_label : msg . node_label . to_str () . to_owned () , frame_id : msg . frame_id . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . node_id = self . node_id ; msg . node_label . assign (& self . node_label) ; msg . frame_id . assign (& self . frame_id) ; } } impl Default for Goal { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Goal > :: new () ; Goal :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Info { pub header : std_msgs :: msg :: Header , pub ref_id : i32 , pub loop_closure_id : i32 , pub proximity_detection_id : i32 , pub landmark_id : i32 , pub loop_closure_transform : geometry_msgs :: msg :: Transform , pub wm_state : Vec < i32 > , pub posterior_keys : Vec < i32 > , pub posterior_values : Vec < f32 > , pub likelihood_keys : Vec < i32 > , pub likelihood_values : Vec < f32 > , pub raw_likelihood_keys : Vec < i32 > , pub raw_likelihood_values : Vec < f32 > , pub weights_keys : Vec < i32 > , pub weights_values : Vec < i32 > , pub labels_keys : Vec < i32 > , pub labels_values : Vec < std :: string :: String > , pub stats_keys : Vec < std :: string :: String > , pub stats_values : Vec < f32 > , pub local_path : Vec < i32 > , pub current_goal_id : i32 , pub odom_cache : rtabmap_ros :: msg :: MapGraph } impl WrappedTypesupport for Info { type CStruct = rtabmap_ros__msg__Info ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rtabmap_ros__msg__Info () } } fn create_msg () -> * mut rtabmap_ros__msg__Info { unsafe { rtabmap_ros__msg__Info__create () } } fn destroy_msg (msg : * mut rtabmap_ros__msg__Info) -> () { unsafe { rtabmap_ros__msg__Info__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Info { Info { header : std_msgs :: msg :: Header :: from_native (& msg . header) , ref_id : msg . ref_id , loop_closure_id : msg . loop_closure_id , proximity_detection_id : msg . proximity_detection_id , landmark_id : msg . landmark_id , loop_closure_transform : geometry_msgs :: msg :: Transform :: from_native (& msg . loop_closure_transform) , wm_state : msg . wm_state . to_vec () , posterior_keys : msg . posterior_keys . to_vec () , posterior_values : msg . posterior_values . to_vec () , likelihood_keys : msg . likelihood_keys . to_vec () , likelihood_values : msg . likelihood_values . to_vec () , raw_likelihood_keys : msg . raw_likelihood_keys . to_vec () , raw_likelihood_values : msg . raw_likelihood_values . to_vec () , weights_keys : msg . weights_keys . to_vec () , weights_values : msg . weights_values . to_vec () , labels_keys : msg . labels_keys . to_vec () , labels_values : msg . labels_values . to_vec () , stats_keys : msg . stats_keys . to_vec () , stats_values : msg . stats_values . to_vec () , local_path : msg . local_path . to_vec () , current_goal_id : msg . current_goal_id , odom_cache : rtabmap_ros :: msg :: MapGraph :: from_native (& msg . odom_cache) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . ref_id = self . ref_id ; msg . loop_closure_id = self . loop_closure_id ; msg . proximity_detection_id = self . proximity_detection_id ; msg . landmark_id = self . landmark_id ; self . loop_closure_transform . copy_to_native (& mut msg . loop_closure_transform) ; msg . wm_state . update (& self . wm_state) ; msg . posterior_keys . update (& self . posterior_keys) ; msg . posterior_values . update (& self . posterior_values) ; msg . likelihood_keys . update (& self . likelihood_keys) ; msg . likelihood_values . update (& self . likelihood_values) ; msg . raw_likelihood_keys . update (& self . raw_likelihood_keys) ; msg . raw_likelihood_values . update (& self . raw_likelihood_values) ; msg . weights_keys . update (& self . weights_keys) ; msg . weights_values . update (& self . weights_values) ; msg . labels_keys . update (& self . labels_keys) ; msg . labels_values . update (& self . labels_values) ; msg . stats_keys . update (& self . stats_keys) ; msg . stats_values . update (& self . stats_values) ; msg . local_path . update (& self . local_path) ; msg . current_goal_id = self . current_goal_id ; self . odom_cache . copy_to_native (& mut msg . odom_cache) ; } } impl Default for Info { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Info > :: new () ; Info :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct KeyPoint { pub pt : rtabmap_ros :: msg :: Point2f , pub size : f32 , pub angle : f32 , pub response : f32 , pub octave : i32 , pub class_id : i32 } impl WrappedTypesupport for KeyPoint { type CStruct = rtabmap_ros__msg__KeyPoint ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rtabmap_ros__msg__KeyPoint () } } fn create_msg () -> * mut rtabmap_ros__msg__KeyPoint { unsafe { rtabmap_ros__msg__KeyPoint__create () } } fn destroy_msg (msg : * mut rtabmap_ros__msg__KeyPoint) -> () { unsafe { rtabmap_ros__msg__KeyPoint__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> KeyPoint { KeyPoint { pt : rtabmap_ros :: msg :: Point2f :: from_native (& msg . pt) , size : msg . size , angle : msg . angle , response : msg . response , octave : msg . octave , class_id : msg . class_id , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . pt . copy_to_native (& mut msg . pt) ; msg . size = self . size ; msg . angle = self . angle ; msg . response = self . response ; msg . octave = self . octave ; msg . class_id = self . class_id ; } } impl Default for KeyPoint { fn default () -> Self { let msg_native = WrappedNativeMsg :: < KeyPoint > :: new () ; KeyPoint :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Link { pub from_id : i32 , pub to_id : i32 , # [serde (rename = "type")] pub type_ : i32 , pub transform : geometry_msgs :: msg :: Transform , pub information : Vec < f64 > } impl WrappedTypesupport for Link { type CStruct = rtabmap_ros__msg__Link ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rtabmap_ros__msg__Link () } } fn create_msg () -> * mut rtabmap_ros__msg__Link { unsafe { rtabmap_ros__msg__Link__create () } } fn destroy_msg (msg : * mut rtabmap_ros__msg__Link) -> () { unsafe { rtabmap_ros__msg__Link__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Link { Link { from_id : msg . from_id , to_id : msg . to_id , type_ : msg . type_ , transform : geometry_msgs :: msg :: Transform :: from_native (& msg . transform) , information : msg . information . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . from_id = self . from_id ; msg . to_id = self . to_id ; msg . type_ = self . type_ ; self . transform . copy_to_native (& mut msg . transform) ; assert_eq ! (self . information . len () , 36usize , "Field {} is fixed size of {}!" , "information" , 36usize) ; msg . information . copy_from_slice (& self . information [.. 36usize]) ; } } impl Default for Link { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Link > :: new () ; Link :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct MapData { pub header : std_msgs :: msg :: Header , pub graph : rtabmap_ros :: msg :: MapGraph , pub nodes : Vec < rtabmap_ros :: msg :: NodeData > } impl WrappedTypesupport for MapData { type CStruct = rtabmap_ros__msg__MapData ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rtabmap_ros__msg__MapData () } } fn create_msg () -> * mut rtabmap_ros__msg__MapData { unsafe { rtabmap_ros__msg__MapData__create () } } fn destroy_msg (msg : * mut rtabmap_ros__msg__MapData) -> () { unsafe { rtabmap_ros__msg__MapData__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> MapData { MapData { header : std_msgs :: msg :: Header :: from_native (& msg . header) , graph : rtabmap_ros :: msg :: MapGraph :: from_native (& msg . graph) , nodes : { let mut temp = Vec :: with_capacity (msg . nodes . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . nodes . data , msg . nodes . size) } ; for s in slice { temp . push (rtabmap_ros :: msg :: NodeData :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; self . graph . copy_to_native (& mut msg . graph) ; unsafe { rtabmap_ros__msg__NodeData__Sequence__fini (& mut msg . nodes) ; rtabmap_ros__msg__NodeData__Sequence__init (& mut msg . nodes , self . nodes . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . nodes . data , msg . nodes . size) ; for (t , s) in slice . iter_mut () . zip (& self . nodes) { s . copy_to_native (t) ; } } } } impl Default for MapData { fn default () -> Self { let msg_native = WrappedNativeMsg :: < MapData > :: new () ; MapData :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct MapGraph { pub header : std_msgs :: msg :: Header , pub map_to_odom : geometry_msgs :: msg :: Transform , pub poses_id : Vec < i32 > , pub poses : Vec < geometry_msgs :: msg :: Pose > , pub links : Vec < rtabmap_ros :: msg :: Link > } impl WrappedTypesupport for MapGraph { type CStruct = rtabmap_ros__msg__MapGraph ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rtabmap_ros__msg__MapGraph () } } fn create_msg () -> * mut rtabmap_ros__msg__MapGraph { unsafe { rtabmap_ros__msg__MapGraph__create () } } fn destroy_msg (msg : * mut rtabmap_ros__msg__MapGraph) -> () { unsafe { rtabmap_ros__msg__MapGraph__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> MapGraph { MapGraph { header : std_msgs :: msg :: Header :: from_native (& msg . header) , map_to_odom : geometry_msgs :: msg :: Transform :: from_native (& msg . map_to_odom) , poses_id : msg . poses_id . to_vec () , poses : { let mut temp = Vec :: with_capacity (msg . poses . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . poses . data , msg . poses . size) } ; for s in slice { temp . push (geometry_msgs :: msg :: Pose :: from_native (s)) ; } temp } , links : { let mut temp = Vec :: with_capacity (msg . links . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . links . data , msg . links . size) } ; for s in slice { temp . push (rtabmap_ros :: msg :: Link :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; self . map_to_odom . copy_to_native (& mut msg . map_to_odom) ; msg . poses_id . update (& self . poses_id) ; unsafe { geometry_msgs__msg__Pose__Sequence__fini (& mut msg . poses) ; geometry_msgs__msg__Pose__Sequence__init (& mut msg . poses , self . poses . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . poses . data , msg . poses . size) ; for (t , s) in slice . iter_mut () . zip (& self . poses) { s . copy_to_native (t) ; } } unsafe { rtabmap_ros__msg__Link__Sequence__fini (& mut msg . links) ; rtabmap_ros__msg__Link__Sequence__init (& mut msg . links , self . links . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . links . data , msg . links . size) ; for (t , s) in slice . iter_mut () . zip (& self . links) { s . copy_to_native (t) ; } } } } impl Default for MapGraph { fn default () -> Self { let msg_native = WrappedNativeMsg :: < MapGraph > :: new () ; MapGraph :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct NodeData { pub id : i32 , pub map_id : i32 , pub weight : i32 , pub stamp : f64 , pub label : std :: string :: String , pub pose : geometry_msgs :: msg :: Pose , pub ground_truth_pose : geometry_msgs :: msg :: Pose , pub gps : rtabmap_ros :: msg :: GPS , pub image : Vec < u8 > , pub depth : Vec < u8 > , pub fx : Vec < f32 > , pub fy : Vec < f32 > , pub cx : Vec < f32 > , pub cy : Vec < f32 > , pub width : Vec < f32 > , pub height : Vec < f32 > , pub baseline : Vec < f32 > , pub local_transform : Vec < geometry_msgs :: msg :: Transform > , pub laser_scan : Vec < u8 > , pub laser_scan_max_pts : i32 , pub laser_scan_max_range : f32 , pub laser_scan_format : i32 , pub laser_scan_local_transform : geometry_msgs :: msg :: Transform , pub user_data : Vec < u8 > , pub grid_ground : Vec < u8 > , pub grid_obstacles : Vec < u8 > , pub grid_empty_cells : Vec < u8 > , pub grid_cell_size : f32 , pub grid_view_point : rtabmap_ros :: msg :: Point3f , pub word_id_keys : Vec < i32 > , pub word_id_values : Vec < i32 > , pub word_kpts : Vec < rtabmap_ros :: msg :: KeyPoint > , pub word_pts : Vec < rtabmap_ros :: msg :: Point3f > , pub word_descriptors : Vec < u8 > , pub global_descriptors : Vec < rtabmap_ros :: msg :: GlobalDescriptor > , pub env_sensors : Vec < rtabmap_ros :: msg :: EnvSensor > } impl WrappedTypesupport for NodeData { type CStruct = rtabmap_ros__msg__NodeData ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rtabmap_ros__msg__NodeData () } } fn create_msg () -> * mut rtabmap_ros__msg__NodeData { unsafe { rtabmap_ros__msg__NodeData__create () } } fn destroy_msg (msg : * mut rtabmap_ros__msg__NodeData) -> () { unsafe { rtabmap_ros__msg__NodeData__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> NodeData { NodeData { id : msg . id , map_id : msg . map_id , weight : msg . weight , stamp : msg . stamp , label : msg . label . to_str () . to_owned () , pose : geometry_msgs :: msg :: Pose :: from_native (& msg . pose) , ground_truth_pose : geometry_msgs :: msg :: Pose :: from_native (& msg . ground_truth_pose) , gps : rtabmap_ros :: msg :: GPS :: from_native (& msg . gps) , image : msg . image . to_vec () , depth : msg . depth . to_vec () , fx : msg . fx . to_vec () , fy : msg . fy . to_vec () , cx : msg . cx . to_vec () , cy : msg . cy . to_vec () , width : msg . width . to_vec () , height : msg . height . to_vec () , baseline : msg . baseline . to_vec () , local_transform : { let mut temp = Vec :: with_capacity (msg . local_transform . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . local_transform . data , msg . local_transform . size) } ; for s in slice { temp . push (geometry_msgs :: msg :: Transform :: from_native (s)) ; } temp } , laser_scan : msg . laser_scan . to_vec () , laser_scan_max_pts : msg . laser_scan_max_pts , laser_scan_max_range : msg . laser_scan_max_range , laser_scan_format : msg . laser_scan_format , laser_scan_local_transform : geometry_msgs :: msg :: Transform :: from_native (& msg . laser_scan_local_transform) , user_data : msg . user_data . to_vec () , grid_ground : msg . grid_ground . to_vec () , grid_obstacles : msg . grid_obstacles . to_vec () , grid_empty_cells : msg . grid_empty_cells . to_vec () , grid_cell_size : msg . grid_cell_size , grid_view_point : rtabmap_ros :: msg :: Point3f :: from_native (& msg . grid_view_point) , word_id_keys : msg . word_id_keys . to_vec () , word_id_values : msg . word_id_values . to_vec () , word_kpts : { let mut temp = Vec :: with_capacity (msg . word_kpts . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . word_kpts . data , msg . word_kpts . size) } ; for s in slice { temp . push (rtabmap_ros :: msg :: KeyPoint :: from_native (s)) ; } temp } , word_pts : { let mut temp = Vec :: with_capacity (msg . word_pts . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . word_pts . data , msg . word_pts . size) } ; for s in slice { temp . push (rtabmap_ros :: msg :: Point3f :: from_native (s)) ; } temp } , word_descriptors : msg . word_descriptors . to_vec () , global_descriptors : { let mut temp = Vec :: with_capacity (msg . global_descriptors . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . global_descriptors . data , msg . global_descriptors . size) } ; for s in slice { temp . push (rtabmap_ros :: msg :: GlobalDescriptor :: from_native (s)) ; } temp } , env_sensors : { let mut temp = Vec :: with_capacity (msg . env_sensors . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . env_sensors . data , msg . env_sensors . size) } ; for s in slice { temp . push (rtabmap_ros :: msg :: EnvSensor :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . id = self . id ; msg . map_id = self . map_id ; msg . weight = self . weight ; msg . stamp = self . stamp ; msg . label . assign (& self . label) ; self . pose . copy_to_native (& mut msg . pose) ; self . ground_truth_pose . copy_to_native (& mut msg . ground_truth_pose) ; self . gps . copy_to_native (& mut msg . gps) ; msg . image . update (& self . image) ; msg . depth . update (& self . depth) ; msg . fx . update (& self . fx) ; msg . fy . update (& self . fy) ; msg . cx . update (& self . cx) ; msg . cy . update (& self . cy) ; msg . width . update (& self . width) ; msg . height . update (& self . height) ; msg . baseline . update (& self . baseline) ; unsafe { geometry_msgs__msg__Transform__Sequence__fini (& mut msg . local_transform) ; geometry_msgs__msg__Transform__Sequence__init (& mut msg . local_transform , self . local_transform . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . local_transform . data , msg . local_transform . size) ; for (t , s) in slice . iter_mut () . zip (& self . local_transform) { s . copy_to_native (t) ; } } msg . laser_scan . update (& self . laser_scan) ; msg . laser_scan_max_pts = self . laser_scan_max_pts ; msg . laser_scan_max_range = self . laser_scan_max_range ; msg . laser_scan_format = self . laser_scan_format ; self . laser_scan_local_transform . copy_to_native (& mut msg . laser_scan_local_transform) ; msg . user_data . update (& self . user_data) ; msg . grid_ground . update (& self . grid_ground) ; msg . grid_obstacles . update (& self . grid_obstacles) ; msg . grid_empty_cells . update (& self . grid_empty_cells) ; msg . grid_cell_size = self . grid_cell_size ; self . grid_view_point . copy_to_native (& mut msg . grid_view_point) ; msg . word_id_keys . update (& self . word_id_keys) ; msg . word_id_values . update (& self . word_id_values) ; unsafe { rtabmap_ros__msg__KeyPoint__Sequence__fini (& mut msg . word_kpts) ; rtabmap_ros__msg__KeyPoint__Sequence__init (& mut msg . word_kpts , self . word_kpts . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . word_kpts . data , msg . word_kpts . size) ; for (t , s) in slice . iter_mut () . zip (& self . word_kpts) { s . copy_to_native (t) ; } } unsafe { rtabmap_ros__msg__Point3f__Sequence__fini (& mut msg . word_pts) ; rtabmap_ros__msg__Point3f__Sequence__init (& mut msg . word_pts , self . word_pts . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . word_pts . data , msg . word_pts . size) ; for (t , s) in slice . iter_mut () . zip (& self . word_pts) { s . copy_to_native (t) ; } } msg . word_descriptors . update (& self . word_descriptors) ; unsafe { rtabmap_ros__msg__GlobalDescriptor__Sequence__fini (& mut msg . global_descriptors) ; rtabmap_ros__msg__GlobalDescriptor__Sequence__init (& mut msg . global_descriptors , self . global_descriptors . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . global_descriptors . data , msg . global_descriptors . size) ; for (t , s) in slice . iter_mut () . zip (& self . global_descriptors) { s . copy_to_native (t) ; } } unsafe { rtabmap_ros__msg__EnvSensor__Sequence__fini (& mut msg . env_sensors) ; rtabmap_ros__msg__EnvSensor__Sequence__init (& mut msg . env_sensors , self . env_sensors . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . env_sensors . data , msg . env_sensors . size) ; for (t , s) in slice . iter_mut () . zip (& self . env_sensors) { s . copy_to_native (t) ; } } } } impl Default for NodeData { fn default () -> Self { let msg_native = WrappedNativeMsg :: < NodeData > :: new () ; NodeData :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct OdomInfo { pub header : std_msgs :: msg :: Header , pub lost : bool , pub matches : i32 , pub inliers : i32 , pub icp_inliers_ratio : f32 , pub icp_rotation : f32 , pub icp_translation : f32 , pub icp_structural_complexity : f32 , pub icp_structural_distribution : f32 , pub icp_correspondences : i32 , pub covariance : Vec < f64 > , pub features : i32 , pub local_map_size : i32 , pub local_scan_map_size : i32 , pub local_key_frames : i32 , pub local_bundle_outliers : i32 , pub local_bundle_constraints : i32 , pub local_bundle_time : f32 , pub key_frame_added : bool , pub time_estimation : f32 , pub time_particle_filtering : f32 , pub stamp : f32 , pub interval : f32 , pub distance_travelled : f32 , pub memory_usage : i32 , pub gravity_roll_error : f32 , pub gravity_pitch_error : f32 , pub local_bundle_ids : Vec < i32 > , pub local_bundle_models : Vec < rtabmap_ros :: msg :: CameraModels > , pub local_bundle_poses : Vec < geometry_msgs :: msg :: Pose > , pub transform : geometry_msgs :: msg :: Transform , pub transform_filtered : geometry_msgs :: msg :: Transform , pub transform_ground_truth : geometry_msgs :: msg :: Transform , pub guess : geometry_msgs :: msg :: Transform , # [serde (rename = "type")] pub type_ : i32 , pub words_keys : Vec < i32 > , pub words_values : Vec < rtabmap_ros :: msg :: KeyPoint > , pub word_matches : Vec < i32 > , pub word_inliers : Vec < i32 > , pub local_map_keys : Vec < i32 > , pub local_map_values : Vec < rtabmap_ros :: msg :: Point3f > , pub local_scan_map : sensor_msgs :: msg :: PointCloud2 , pub ref_corners : Vec < rtabmap_ros :: msg :: Point2f > , pub new_corners : Vec < rtabmap_ros :: msg :: Point2f > , pub corner_inliers : Vec < i32 > } impl WrappedTypesupport for OdomInfo { type CStruct = rtabmap_ros__msg__OdomInfo ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rtabmap_ros__msg__OdomInfo () } } fn create_msg () -> * mut rtabmap_ros__msg__OdomInfo { unsafe { rtabmap_ros__msg__OdomInfo__create () } } fn destroy_msg (msg : * mut rtabmap_ros__msg__OdomInfo) -> () { unsafe { rtabmap_ros__msg__OdomInfo__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> OdomInfo { OdomInfo { header : std_msgs :: msg :: Header :: from_native (& msg . header) , lost : msg . lost , matches : msg . matches , inliers : msg . inliers , icp_inliers_ratio : msg . icp_inliers_ratio , icp_rotation : msg . icp_rotation , icp_translation : msg . icp_translation , icp_structural_complexity : msg . icp_structural_complexity , icp_structural_distribution : msg . icp_structural_distribution , icp_correspondences : msg . icp_correspondences , covariance : msg . covariance . to_vec () , features : msg . features , local_map_size : msg . local_map_size , local_scan_map_size : msg . local_scan_map_size , local_key_frames : msg . local_key_frames , local_bundle_outliers : msg . local_bundle_outliers , local_bundle_constraints : msg . local_bundle_constraints , local_bundle_time : msg . local_bundle_time , key_frame_added : msg . key_frame_added , time_estimation : msg . time_estimation , time_particle_filtering : msg . time_particle_filtering , stamp : msg . stamp , interval : msg . interval , distance_travelled : msg . distance_travelled , memory_usage : msg . memory_usage , gravity_roll_error : msg . gravity_roll_error , gravity_pitch_error : msg . gravity_pitch_error , local_bundle_ids : msg . local_bundle_ids . to_vec () , local_bundle_models : { let mut temp = Vec :: with_capacity (msg . local_bundle_models . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . local_bundle_models . data , msg . local_bundle_models . size) } ; for s in slice { temp . push (rtabmap_ros :: msg :: CameraModels :: from_native (s)) ; } temp } , local_bundle_poses : { let mut temp = Vec :: with_capacity (msg . local_bundle_poses . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . local_bundle_poses . data , msg . local_bundle_poses . size) } ; for s in slice { temp . push (geometry_msgs :: msg :: Pose :: from_native (s)) ; } temp } , transform : geometry_msgs :: msg :: Transform :: from_native (& msg . transform) , transform_filtered : geometry_msgs :: msg :: Transform :: from_native (& msg . transform_filtered) , transform_ground_truth : geometry_msgs :: msg :: Transform :: from_native (& msg . transform_ground_truth) , guess : geometry_msgs :: msg :: Transform :: from_native (& msg . guess) , type_ : msg . type_ , words_keys : msg . words_keys . to_vec () , words_values : { let mut temp = Vec :: with_capacity (msg . words_values . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . words_values . data , msg . words_values . size) } ; for s in slice { temp . push (rtabmap_ros :: msg :: KeyPoint :: from_native (s)) ; } temp } , word_matches : msg . word_matches . to_vec () , word_inliers : msg . word_inliers . to_vec () , local_map_keys : msg . local_map_keys . to_vec () , local_map_values : { let mut temp = Vec :: with_capacity (msg . local_map_values . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . local_map_values . data , msg . local_map_values . size) } ; for s in slice { temp . push (rtabmap_ros :: msg :: Point3f :: from_native (s)) ; } temp } , local_scan_map : sensor_msgs :: msg :: PointCloud2 :: from_native (& msg . local_scan_map) , ref_corners : { let mut temp = Vec :: with_capacity (msg . ref_corners . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . ref_corners . data , msg . ref_corners . size) } ; for s in slice { temp . push (rtabmap_ros :: msg :: Point2f :: from_native (s)) ; } temp } , new_corners : { let mut temp = Vec :: with_capacity (msg . new_corners . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . new_corners . data , msg . new_corners . size) } ; for s in slice { temp . push (rtabmap_ros :: msg :: Point2f :: from_native (s)) ; } temp } , corner_inliers : msg . corner_inliers . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . lost = self . lost ; msg . matches = self . matches ; msg . inliers = self . inliers ; msg . icp_inliers_ratio = self . icp_inliers_ratio ; msg . icp_rotation = self . icp_rotation ; msg . icp_translation = self . icp_translation ; msg . icp_structural_complexity = self . icp_structural_complexity ; msg . icp_structural_distribution = self . icp_structural_distribution ; msg . icp_correspondences = self . icp_correspondences ; assert_eq ! (self . covariance . len () , 36usize , "Field {} is fixed size of {}!" , "covariance" , 36usize) ; msg . covariance . copy_from_slice (& self . covariance [.. 36usize]) ; msg . features = self . features ; msg . local_map_size = self . local_map_size ; msg . local_scan_map_size = self . local_scan_map_size ; msg . local_key_frames = self . local_key_frames ; msg . local_bundle_outliers = self . local_bundle_outliers ; msg . local_bundle_constraints = self . local_bundle_constraints ; msg . local_bundle_time = self . local_bundle_time ; msg . key_frame_added = self . key_frame_added ; msg . time_estimation = self . time_estimation ; msg . time_particle_filtering = self . time_particle_filtering ; msg . stamp = self . stamp ; msg . interval = self . interval ; msg . distance_travelled = self . distance_travelled ; msg . memory_usage = self . memory_usage ; msg . gravity_roll_error = self . gravity_roll_error ; msg . gravity_pitch_error = self . gravity_pitch_error ; msg . local_bundle_ids . update (& self . local_bundle_ids) ; unsafe { rtabmap_ros__msg__CameraModels__Sequence__fini (& mut msg . local_bundle_models) ; rtabmap_ros__msg__CameraModels__Sequence__init (& mut msg . local_bundle_models , self . local_bundle_models . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . local_bundle_models . data , msg . local_bundle_models . size) ; for (t , s) in slice . iter_mut () . zip (& self . local_bundle_models) { s . copy_to_native (t) ; } } unsafe { geometry_msgs__msg__Pose__Sequence__fini (& mut msg . local_bundle_poses) ; geometry_msgs__msg__Pose__Sequence__init (& mut msg . local_bundle_poses , self . local_bundle_poses . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . local_bundle_poses . data , msg . local_bundle_poses . size) ; for (t , s) in slice . iter_mut () . zip (& self . local_bundle_poses) { s . copy_to_native (t) ; } } self . transform . copy_to_native (& mut msg . transform) ; self . transform_filtered . copy_to_native (& mut msg . transform_filtered) ; self . transform_ground_truth . copy_to_native (& mut msg . transform_ground_truth) ; self . guess . copy_to_native (& mut msg . guess) ; msg . type_ = self . type_ ; msg . words_keys . update (& self . words_keys) ; unsafe { rtabmap_ros__msg__KeyPoint__Sequence__fini (& mut msg . words_values) ; rtabmap_ros__msg__KeyPoint__Sequence__init (& mut msg . words_values , self . words_values . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . words_values . data , msg . words_values . size) ; for (t , s) in slice . iter_mut () . zip (& self . words_values) { s . copy_to_native (t) ; } } msg . word_matches . update (& self . word_matches) ; msg . word_inliers . update (& self . word_inliers) ; msg . local_map_keys . update (& self . local_map_keys) ; unsafe { rtabmap_ros__msg__Point3f__Sequence__fini (& mut msg . local_map_values) ; rtabmap_ros__msg__Point3f__Sequence__init (& mut msg . local_map_values , self . local_map_values . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . local_map_values . data , msg . local_map_values . size) ; for (t , s) in slice . iter_mut () . zip (& self . local_map_values) { s . copy_to_native (t) ; } } self . local_scan_map . copy_to_native (& mut msg . local_scan_map) ; unsafe { rtabmap_ros__msg__Point2f__Sequence__fini (& mut msg . ref_corners) ; rtabmap_ros__msg__Point2f__Sequence__init (& mut msg . ref_corners , self . ref_corners . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . ref_corners . data , msg . ref_corners . size) ; for (t , s) in slice . iter_mut () . zip (& self . ref_corners) { s . copy_to_native (t) ; } } unsafe { rtabmap_ros__msg__Point2f__Sequence__fini (& mut msg . new_corners) ; rtabmap_ros__msg__Point2f__Sequence__init (& mut msg . new_corners , self . new_corners . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . new_corners . data , msg . new_corners . size) ; for (t , s) in slice . iter_mut () . zip (& self . new_corners) { s . copy_to_native (t) ; } } msg . corner_inliers . update (& self . corner_inliers) ; } } impl Default for OdomInfo { fn default () -> Self { let msg_native = WrappedNativeMsg :: < OdomInfo > :: new () ; OdomInfo :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Path { pub header : std_msgs :: msg :: Header , pub node_ids : Vec < i32 > , pub poses : Vec < geometry_msgs :: msg :: Pose > } impl WrappedTypesupport for Path { type CStruct = rtabmap_ros__msg__Path ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rtabmap_ros__msg__Path () } } fn create_msg () -> * mut rtabmap_ros__msg__Path { unsafe { rtabmap_ros__msg__Path__create () } } fn destroy_msg (msg : * mut rtabmap_ros__msg__Path) -> () { unsafe { rtabmap_ros__msg__Path__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Path { Path { header : std_msgs :: msg :: Header :: from_native (& msg . header) , node_ids : msg . node_ids . to_vec () , poses : { let mut temp = Vec :: with_capacity (msg . poses . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . poses . data , msg . poses . size) } ; for s in slice { temp . push (geometry_msgs :: msg :: Pose :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . node_ids . update (& self . node_ids) ; unsafe { geometry_msgs__msg__Pose__Sequence__fini (& mut msg . poses) ; geometry_msgs__msg__Pose__Sequence__init (& mut msg . poses , self . poses . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . poses . data , msg . poses . size) ; for (t , s) in slice . iter_mut () . zip (& self . poses) { s . copy_to_native (t) ; } } } } impl Default for Path { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Path > :: new () ; Path :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Point2f { pub x : f32 , pub y : f32 } impl WrappedTypesupport for Point2f { type CStruct = rtabmap_ros__msg__Point2f ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rtabmap_ros__msg__Point2f () } } fn create_msg () -> * mut rtabmap_ros__msg__Point2f { unsafe { rtabmap_ros__msg__Point2f__create () } } fn destroy_msg (msg : * mut rtabmap_ros__msg__Point2f) -> () { unsafe { rtabmap_ros__msg__Point2f__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Point2f { Point2f { x : msg . x , y : msg . y , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . x = self . x ; msg . y = self . y ; } } impl Default for Point2f { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Point2f > :: new () ; Point2f :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Point3f { pub x : f32 , pub y : f32 , pub z : f32 } impl WrappedTypesupport for Point3f { type CStruct = rtabmap_ros__msg__Point3f ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rtabmap_ros__msg__Point3f () } } fn create_msg () -> * mut rtabmap_ros__msg__Point3f { unsafe { rtabmap_ros__msg__Point3f__create () } } fn destroy_msg (msg : * mut rtabmap_ros__msg__Point3f) -> () { unsafe { rtabmap_ros__msg__Point3f__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Point3f { Point3f { x : msg . x , y : msg . y , z : msg . z , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . x = self . x ; msg . y = self . y ; msg . z = self . z ; } } impl Default for Point3f { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Point3f > :: new () ; Point3f :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct RGBDImage { pub header : std_msgs :: msg :: Header , pub rgb_camera_info : sensor_msgs :: msg :: CameraInfo , pub depth_camera_info : sensor_msgs :: msg :: CameraInfo , pub rgb : sensor_msgs :: msg :: Image , pub depth : sensor_msgs :: msg :: Image , pub rgb_compressed : sensor_msgs :: msg :: CompressedImage , pub depth_compressed : sensor_msgs :: msg :: CompressedImage , pub key_points : Vec < rtabmap_ros :: msg :: KeyPoint > , pub points : Vec < rtabmap_ros :: msg :: Point3f > , pub descriptors : Vec < u8 > , pub global_descriptor : rtabmap_ros :: msg :: GlobalDescriptor } impl WrappedTypesupport for RGBDImage { type CStruct = rtabmap_ros__msg__RGBDImage ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rtabmap_ros__msg__RGBDImage () } } fn create_msg () -> * mut rtabmap_ros__msg__RGBDImage { unsafe { rtabmap_ros__msg__RGBDImage__create () } } fn destroy_msg (msg : * mut rtabmap_ros__msg__RGBDImage) -> () { unsafe { rtabmap_ros__msg__RGBDImage__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> RGBDImage { RGBDImage { header : std_msgs :: msg :: Header :: from_native (& msg . header) , rgb_camera_info : sensor_msgs :: msg :: CameraInfo :: from_native (& msg . rgb_camera_info) , depth_camera_info : sensor_msgs :: msg :: CameraInfo :: from_native (& msg . depth_camera_info) , rgb : sensor_msgs :: msg :: Image :: from_native (& msg . rgb) , depth : sensor_msgs :: msg :: Image :: from_native (& msg . depth) , rgb_compressed : sensor_msgs :: msg :: CompressedImage :: from_native (& msg . rgb_compressed) , depth_compressed : sensor_msgs :: msg :: CompressedImage :: from_native (& msg . depth_compressed) , key_points : { let mut temp = Vec :: with_capacity (msg . key_points . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . key_points . data , msg . key_points . size) } ; for s in slice { temp . push (rtabmap_ros :: msg :: KeyPoint :: from_native (s)) ; } temp } , points : { let mut temp = Vec :: with_capacity (msg . points . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . points . data , msg . points . size) } ; for s in slice { temp . push (rtabmap_ros :: msg :: Point3f :: from_native (s)) ; } temp } , descriptors : msg . descriptors . to_vec () , global_descriptor : rtabmap_ros :: msg :: GlobalDescriptor :: from_native (& msg . global_descriptor) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; self . rgb_camera_info . copy_to_native (& mut msg . rgb_camera_info) ; self . depth_camera_info . copy_to_native (& mut msg . depth_camera_info) ; self . rgb . copy_to_native (& mut msg . rgb) ; self . depth . copy_to_native (& mut msg . depth) ; self . rgb_compressed . copy_to_native (& mut msg . rgb_compressed) ; self . depth_compressed . copy_to_native (& mut msg . depth_compressed) ; unsafe { rtabmap_ros__msg__KeyPoint__Sequence__fini (& mut msg . key_points) ; rtabmap_ros__msg__KeyPoint__Sequence__init (& mut msg . key_points , self . key_points . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . key_points . data , msg . key_points . size) ; for (t , s) in slice . iter_mut () . zip (& self . key_points) { s . copy_to_native (t) ; } } unsafe { rtabmap_ros__msg__Point3f__Sequence__fini (& mut msg . points) ; rtabmap_ros__msg__Point3f__Sequence__init (& mut msg . points , self . points . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . points . data , msg . points . size) ; for (t , s) in slice . iter_mut () . zip (& self . points) { s . copy_to_native (t) ; } } msg . descriptors . update (& self . descriptors) ; self . global_descriptor . copy_to_native (& mut msg . global_descriptor) ; } } impl Default for RGBDImage { fn default () -> Self { let msg_native = WrappedNativeMsg :: < RGBDImage > :: new () ; RGBDImage :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct RGBDImages { pub header : std_msgs :: msg :: Header , pub rgbd_images : Vec < rtabmap_ros :: msg :: RGBDImage > } impl WrappedTypesupport for RGBDImages { type CStruct = rtabmap_ros__msg__RGBDImages ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rtabmap_ros__msg__RGBDImages () } } fn create_msg () -> * mut rtabmap_ros__msg__RGBDImages { unsafe { rtabmap_ros__msg__RGBDImages__create () } } fn destroy_msg (msg : * mut rtabmap_ros__msg__RGBDImages) -> () { unsafe { rtabmap_ros__msg__RGBDImages__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> RGBDImages { RGBDImages { header : std_msgs :: msg :: Header :: from_native (& msg . header) , rgbd_images : { let mut temp = Vec :: with_capacity (msg . rgbd_images . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . rgbd_images . data , msg . rgbd_images . size) } ; for s in slice { temp . push (rtabmap_ros :: msg :: RGBDImage :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; unsafe { rtabmap_ros__msg__RGBDImage__Sequence__fini (& mut msg . rgbd_images) ; rtabmap_ros__msg__RGBDImage__Sequence__init (& mut msg . rgbd_images , self . rgbd_images . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . rgbd_images . data , msg . rgbd_images . size) ; for (t , s) in slice . iter_mut () . zip (& self . rgbd_images) { s . copy_to_native (t) ; } } } } impl Default for RGBDImages { fn default () -> Self { let msg_native = WrappedNativeMsg :: < RGBDImages > :: new () ; RGBDImages :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ScanDescriptor { pub header : std_msgs :: msg :: Header , pub scan : sensor_msgs :: msg :: LaserScan , pub scan_cloud : sensor_msgs :: msg :: PointCloud2 , pub global_descriptor : rtabmap_ros :: msg :: GlobalDescriptor } impl WrappedTypesupport for ScanDescriptor { type CStruct = rtabmap_ros__msg__ScanDescriptor ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rtabmap_ros__msg__ScanDescriptor () } } fn create_msg () -> * mut rtabmap_ros__msg__ScanDescriptor { unsafe { rtabmap_ros__msg__ScanDescriptor__create () } } fn destroy_msg (msg : * mut rtabmap_ros__msg__ScanDescriptor) -> () { unsafe { rtabmap_ros__msg__ScanDescriptor__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ScanDescriptor { ScanDescriptor { header : std_msgs :: msg :: Header :: from_native (& msg . header) , scan : sensor_msgs :: msg :: LaserScan :: from_native (& msg . scan) , scan_cloud : sensor_msgs :: msg :: PointCloud2 :: from_native (& msg . scan_cloud) , global_descriptor : rtabmap_ros :: msg :: GlobalDescriptor :: from_native (& msg . global_descriptor) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; self . scan . copy_to_native (& mut msg . scan) ; self . scan_cloud . copy_to_native (& mut msg . scan_cloud) ; self . global_descriptor . copy_to_native (& mut msg . global_descriptor) ; } } impl Default for ScanDescriptor { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ScanDescriptor > :: new () ; ScanDescriptor :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct UserData { pub header : std_msgs :: msg :: Header , pub rows : u32 , pub cols : u32 , # [serde (rename = "type")] pub type_ : u32 , pub data : Vec < u8 > } impl WrappedTypesupport for UserData { type CStruct = rtabmap_ros__msg__UserData ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rtabmap_ros__msg__UserData () } } fn create_msg () -> * mut rtabmap_ros__msg__UserData { unsafe { rtabmap_ros__msg__UserData__create () } } fn destroy_msg (msg : * mut rtabmap_ros__msg__UserData) -> () { unsafe { rtabmap_ros__msg__UserData__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> UserData { UserData { header : std_msgs :: msg :: Header :: from_native (& msg . header) , rows : msg . rows , cols : msg . cols , type_ : msg . type_ , data : msg . data . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . rows = self . rows ; msg . cols = self . cols ; msg . type_ = self . type_ ; msg . data . update (& self . data) ; } } impl Default for UserData { fn default () -> Self { let msg_native = WrappedNativeMsg :: < UserData > :: new () ; UserData :: from_native (& msg_native) } } } pub mod srv { # [allow (non_snake_case)] pub mod AddLink { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__rtabmap_ros__srv__AddLink () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub link : rtabmap_ros :: msg :: Link } impl WrappedTypesupport for Request { type CStruct = rtabmap_ros__srv__AddLink_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rtabmap_ros__srv__AddLink_Request () } } fn create_msg () -> * mut rtabmap_ros__srv__AddLink_Request { unsafe { rtabmap_ros__srv__AddLink_Request__create () } } fn destroy_msg (msg : * mut rtabmap_ros__srv__AddLink_Request) -> () { unsafe { rtabmap_ros__srv__AddLink_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { link : rtabmap_ros :: msg :: Link :: from_native (& msg . link) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . link . copy_to_native (& mut msg . link) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { } impl WrappedTypesupport for Response { type CStruct = rtabmap_ros__srv__AddLink_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rtabmap_ros__srv__AddLink_Response () } } fn create_msg () -> * mut rtabmap_ros__srv__AddLink_Response { unsafe { rtabmap_ros__srv__AddLink_Response__create () } } fn destroy_msg (msg : * mut rtabmap_ros__srv__AddLink_Response) -> () { unsafe { rtabmap_ros__srv__AddLink_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod CleanupLocalGrids { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__rtabmap_ros__srv__CleanupLocalGrids () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub radius : i32 , pub filter_scans : bool } impl WrappedTypesupport for Request { type CStruct = rtabmap_ros__srv__CleanupLocalGrids_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rtabmap_ros__srv__CleanupLocalGrids_Request () } } fn create_msg () -> * mut rtabmap_ros__srv__CleanupLocalGrids_Request { unsafe { rtabmap_ros__srv__CleanupLocalGrids_Request__create () } } fn destroy_msg (msg : * mut rtabmap_ros__srv__CleanupLocalGrids_Request) -> () { unsafe { rtabmap_ros__srv__CleanupLocalGrids_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { radius : msg . radius , filter_scans : msg . filter_scans , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . radius = self . radius ; msg . filter_scans = self . filter_scans ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub modified : i32 } impl WrappedTypesupport for Response { type CStruct = rtabmap_ros__srv__CleanupLocalGrids_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rtabmap_ros__srv__CleanupLocalGrids_Response () } } fn create_msg () -> * mut rtabmap_ros__srv__CleanupLocalGrids_Response { unsafe { rtabmap_ros__srv__CleanupLocalGrids_Response__create () } } fn destroy_msg (msg : * mut rtabmap_ros__srv__CleanupLocalGrids_Response) -> () { unsafe { rtabmap_ros__srv__CleanupLocalGrids_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { modified : msg . modified , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . modified = self . modified ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod DetectMoreLoopClosures { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__rtabmap_ros__srv__DetectMoreLoopClosures () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub cluster_radius_max : f32 , pub cluster_radius_min : f32 , pub cluster_angle : f32 , pub iterations : i32 , pub intra_only : bool , pub inter_only : bool } impl WrappedTypesupport for Request { type CStruct = rtabmap_ros__srv__DetectMoreLoopClosures_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rtabmap_ros__srv__DetectMoreLoopClosures_Request () } } fn create_msg () -> * mut rtabmap_ros__srv__DetectMoreLoopClosures_Request { unsafe { rtabmap_ros__srv__DetectMoreLoopClosures_Request__create () } } fn destroy_msg (msg : * mut rtabmap_ros__srv__DetectMoreLoopClosures_Request) -> () { unsafe { rtabmap_ros__srv__DetectMoreLoopClosures_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { cluster_radius_max : msg . cluster_radius_max , cluster_radius_min : msg . cluster_radius_min , cluster_angle : msg . cluster_angle , iterations : msg . iterations , intra_only : msg . intra_only , inter_only : msg . inter_only , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . cluster_radius_max = self . cluster_radius_max ; msg . cluster_radius_min = self . cluster_radius_min ; msg . cluster_angle = self . cluster_angle ; msg . iterations = self . iterations ; msg . intra_only = self . intra_only ; msg . inter_only = self . inter_only ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub detected : i32 } impl WrappedTypesupport for Response { type CStruct = rtabmap_ros__srv__DetectMoreLoopClosures_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rtabmap_ros__srv__DetectMoreLoopClosures_Response () } } fn create_msg () -> * mut rtabmap_ros__srv__DetectMoreLoopClosures_Response { unsafe { rtabmap_ros__srv__DetectMoreLoopClosures_Response__create () } } fn destroy_msg (msg : * mut rtabmap_ros__srv__DetectMoreLoopClosures_Response) -> () { unsafe { rtabmap_ros__srv__DetectMoreLoopClosures_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { detected : msg . detected , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . detected = self . detected ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetMap { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__rtabmap_ros__srv__GetMap () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub global_map : bool , pub optimized : bool , pub graph_only : bool } impl WrappedTypesupport for Request { type CStruct = rtabmap_ros__srv__GetMap_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rtabmap_ros__srv__GetMap_Request () } } fn create_msg () -> * mut rtabmap_ros__srv__GetMap_Request { unsafe { rtabmap_ros__srv__GetMap_Request__create () } } fn destroy_msg (msg : * mut rtabmap_ros__srv__GetMap_Request) -> () { unsafe { rtabmap_ros__srv__GetMap_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { global_map : msg . global_map , optimized : msg . optimized , graph_only : msg . graph_only , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . global_map = self . global_map ; msg . optimized = self . optimized ; msg . graph_only = self . graph_only ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub data : rtabmap_ros :: msg :: MapData } impl WrappedTypesupport for Response { type CStruct = rtabmap_ros__srv__GetMap_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rtabmap_ros__srv__GetMap_Response () } } fn create_msg () -> * mut rtabmap_ros__srv__GetMap_Response { unsafe { rtabmap_ros__srv__GetMap_Response__create () } } fn destroy_msg (msg : * mut rtabmap_ros__srv__GetMap_Response) -> () { unsafe { rtabmap_ros__srv__GetMap_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { data : rtabmap_ros :: msg :: MapData :: from_native (& msg . data) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . data . copy_to_native (& mut msg . data) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetMap2 { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__rtabmap_ros__srv__GetMap2 () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub global_map : bool , pub optimized : bool , pub with_images : bool , pub with_scans : bool , pub with_user_data : bool , pub with_grids : bool , pub with_words : bool , pub with_global_descriptors : bool } impl WrappedTypesupport for Request { type CStruct = rtabmap_ros__srv__GetMap2_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rtabmap_ros__srv__GetMap2_Request () } } fn create_msg () -> * mut rtabmap_ros__srv__GetMap2_Request { unsafe { rtabmap_ros__srv__GetMap2_Request__create () } } fn destroy_msg (msg : * mut rtabmap_ros__srv__GetMap2_Request) -> () { unsafe { rtabmap_ros__srv__GetMap2_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { global_map : msg . global_map , optimized : msg . optimized , with_images : msg . with_images , with_scans : msg . with_scans , with_user_data : msg . with_user_data , with_grids : msg . with_grids , with_words : msg . with_words , with_global_descriptors : msg . with_global_descriptors , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . global_map = self . global_map ; msg . optimized = self . optimized ; msg . with_images = self . with_images ; msg . with_scans = self . with_scans ; msg . with_user_data = self . with_user_data ; msg . with_grids = self . with_grids ; msg . with_words = self . with_words ; msg . with_global_descriptors = self . with_global_descriptors ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub data : rtabmap_ros :: msg :: MapData } impl WrappedTypesupport for Response { type CStruct = rtabmap_ros__srv__GetMap2_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rtabmap_ros__srv__GetMap2_Response () } } fn create_msg () -> * mut rtabmap_ros__srv__GetMap2_Response { unsafe { rtabmap_ros__srv__GetMap2_Response__create () } } fn destroy_msg (msg : * mut rtabmap_ros__srv__GetMap2_Response) -> () { unsafe { rtabmap_ros__srv__GetMap2_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { data : rtabmap_ros :: msg :: MapData :: from_native (& msg . data) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . data . copy_to_native (& mut msg . data) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetNodeData { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__rtabmap_ros__srv__GetNodeData () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub ids : Vec < i32 > , pub images : bool , pub scan : bool , pub grid : bool , pub user_data : bool } impl WrappedTypesupport for Request { type CStruct = rtabmap_ros__srv__GetNodeData_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rtabmap_ros__srv__GetNodeData_Request () } } fn create_msg () -> * mut rtabmap_ros__srv__GetNodeData_Request { unsafe { rtabmap_ros__srv__GetNodeData_Request__create () } } fn destroy_msg (msg : * mut rtabmap_ros__srv__GetNodeData_Request) -> () { unsafe { rtabmap_ros__srv__GetNodeData_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { ids : msg . ids . to_vec () , images : msg . images , scan : msg . scan , grid : msg . grid , user_data : msg . user_data , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . ids . update (& self . ids) ; msg . images = self . images ; msg . scan = self . scan ; msg . grid = self . grid ; msg . user_data = self . user_data ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub data : Vec < rtabmap_ros :: msg :: NodeData > } impl WrappedTypesupport for Response { type CStruct = rtabmap_ros__srv__GetNodeData_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rtabmap_ros__srv__GetNodeData_Response () } } fn create_msg () -> * mut rtabmap_ros__srv__GetNodeData_Response { unsafe { rtabmap_ros__srv__GetNodeData_Response__create () } } fn destroy_msg (msg : * mut rtabmap_ros__srv__GetNodeData_Response) -> () { unsafe { rtabmap_ros__srv__GetNodeData_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { data : { let mut temp = Vec :: with_capacity (msg . data . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . data . data , msg . data . size) } ; for s in slice { temp . push (rtabmap_ros :: msg :: NodeData :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { unsafe { rtabmap_ros__msg__NodeData__Sequence__fini (& mut msg . data) ; rtabmap_ros__msg__NodeData__Sequence__init (& mut msg . data , self . data . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . data . data , msg . data . size) ; for (t , s) in slice . iter_mut () . zip (& self . data) { s . copy_to_native (t) ; } } } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetNodesInRadius { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__rtabmap_ros__srv__GetNodesInRadius () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub node_id : i32 , pub x : f32 , pub y : f32 , pub z : f32 , pub radius : f32 , pub k : i32 } impl WrappedTypesupport for Request { type CStruct = rtabmap_ros__srv__GetNodesInRadius_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rtabmap_ros__srv__GetNodesInRadius_Request () } } fn create_msg () -> * mut rtabmap_ros__srv__GetNodesInRadius_Request { unsafe { rtabmap_ros__srv__GetNodesInRadius_Request__create () } } fn destroy_msg (msg : * mut rtabmap_ros__srv__GetNodesInRadius_Request) -> () { unsafe { rtabmap_ros__srv__GetNodesInRadius_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { node_id : msg . node_id , x : msg . x , y : msg . y , z : msg . z , radius : msg . radius , k : msg . k , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . node_id = self . node_id ; msg . x = self . x ; msg . y = self . y ; msg . z = self . z ; msg . radius = self . radius ; msg . k = self . k ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub ids : Vec < i32 > , pub poses : Vec < geometry_msgs :: msg :: Pose > , pub dists_sqr : Vec < f32 > } impl WrappedTypesupport for Response { type CStruct = rtabmap_ros__srv__GetNodesInRadius_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rtabmap_ros__srv__GetNodesInRadius_Response () } } fn create_msg () -> * mut rtabmap_ros__srv__GetNodesInRadius_Response { unsafe { rtabmap_ros__srv__GetNodesInRadius_Response__create () } } fn destroy_msg (msg : * mut rtabmap_ros__srv__GetNodesInRadius_Response) -> () { unsafe { rtabmap_ros__srv__GetNodesInRadius_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { ids : msg . ids . to_vec () , poses : { let mut temp = Vec :: with_capacity (msg . poses . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . poses . data , msg . poses . size) } ; for s in slice { temp . push (geometry_msgs :: msg :: Pose :: from_native (s)) ; } temp } , dists_sqr : msg . dists_sqr . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . ids . update (& self . ids) ; unsafe { geometry_msgs__msg__Pose__Sequence__fini (& mut msg . poses) ; geometry_msgs__msg__Pose__Sequence__init (& mut msg . poses , self . poses . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . poses . data , msg . poses . size) ; for (t , s) in slice . iter_mut () . zip (& self . poses) { s . copy_to_native (t) ; } } msg . dists_sqr . update (& self . dists_sqr) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetPlan { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__rtabmap_ros__srv__GetPlan () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub goal_node : i32 , pub goal : geometry_msgs :: msg :: PoseStamped , pub tolerance : f32 } impl WrappedTypesupport for Request { type CStruct = rtabmap_ros__srv__GetPlan_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rtabmap_ros__srv__GetPlan_Request () } } fn create_msg () -> * mut rtabmap_ros__srv__GetPlan_Request { unsafe { rtabmap_ros__srv__GetPlan_Request__create () } } fn destroy_msg (msg : * mut rtabmap_ros__srv__GetPlan_Request) -> () { unsafe { rtabmap_ros__srv__GetPlan_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { goal_node : msg . goal_node , goal : geometry_msgs :: msg :: PoseStamped :: from_native (& msg . goal) , tolerance : msg . tolerance , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . goal_node = self . goal_node ; self . goal . copy_to_native (& mut msg . goal) ; msg . tolerance = self . tolerance ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub plan : rtabmap_ros :: msg :: Path } impl WrappedTypesupport for Response { type CStruct = rtabmap_ros__srv__GetPlan_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rtabmap_ros__srv__GetPlan_Response () } } fn create_msg () -> * mut rtabmap_ros__srv__GetPlan_Response { unsafe { rtabmap_ros__srv__GetPlan_Response__create () } } fn destroy_msg (msg : * mut rtabmap_ros__srv__GetPlan_Response) -> () { unsafe { rtabmap_ros__srv__GetPlan_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { plan : rtabmap_ros :: msg :: Path :: from_native (& msg . plan) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . plan . copy_to_native (& mut msg . plan) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GlobalBundleAdjustment { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__rtabmap_ros__srv__GlobalBundleAdjustment () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { # [serde (rename = "type")] pub type_ : i32 , pub iterations : i32 , pub pixel_variance : f32 , pub voc_matches : bool } impl WrappedTypesupport for Request { type CStruct = rtabmap_ros__srv__GlobalBundleAdjustment_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rtabmap_ros__srv__GlobalBundleAdjustment_Request () } } fn create_msg () -> * mut rtabmap_ros__srv__GlobalBundleAdjustment_Request { unsafe { rtabmap_ros__srv__GlobalBundleAdjustment_Request__create () } } fn destroy_msg (msg : * mut rtabmap_ros__srv__GlobalBundleAdjustment_Request) -> () { unsafe { rtabmap_ros__srv__GlobalBundleAdjustment_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { type_ : msg . type_ , iterations : msg . iterations , pixel_variance : msg . pixel_variance , voc_matches : msg . voc_matches , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . type_ = self . type_ ; msg . iterations = self . iterations ; msg . pixel_variance = self . pixel_variance ; msg . voc_matches = self . voc_matches ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { } impl WrappedTypesupport for Response { type CStruct = rtabmap_ros__srv__GlobalBundleAdjustment_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rtabmap_ros__srv__GlobalBundleAdjustment_Response () } } fn create_msg () -> * mut rtabmap_ros__srv__GlobalBundleAdjustment_Response { unsafe { rtabmap_ros__srv__GlobalBundleAdjustment_Response__create () } } fn destroy_msg (msg : * mut rtabmap_ros__srv__GlobalBundleAdjustment_Response) -> () { unsafe { rtabmap_ros__srv__GlobalBundleAdjustment_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod ListLabels { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__rtabmap_ros__srv__ListLabels () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { } impl WrappedTypesupport for Request { type CStruct = rtabmap_ros__srv__ListLabels_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rtabmap_ros__srv__ListLabels_Request () } } fn create_msg () -> * mut rtabmap_ros__srv__ListLabels_Request { unsafe { rtabmap_ros__srv__ListLabels_Request__create () } } fn destroy_msg (msg : * mut rtabmap_ros__srv__ListLabels_Request) -> () { unsafe { rtabmap_ros__srv__ListLabels_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub ids : Vec < i32 > , pub labels : Vec < std :: string :: String > } impl WrappedTypesupport for Response { type CStruct = rtabmap_ros__srv__ListLabels_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rtabmap_ros__srv__ListLabels_Response () } } fn create_msg () -> * mut rtabmap_ros__srv__ListLabels_Response { unsafe { rtabmap_ros__srv__ListLabels_Response__create () } } fn destroy_msg (msg : * mut rtabmap_ros__srv__ListLabels_Response) -> () { unsafe { rtabmap_ros__srv__ListLabels_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { ids : msg . ids . to_vec () , labels : msg . labels . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . ids . update (& self . ids) ; msg . labels . update (& self . labels) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod LoadDatabase { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__rtabmap_ros__srv__LoadDatabase () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub database_path : std :: string :: String , pub clear : bool } impl WrappedTypesupport for Request { type CStruct = rtabmap_ros__srv__LoadDatabase_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rtabmap_ros__srv__LoadDatabase_Request () } } fn create_msg () -> * mut rtabmap_ros__srv__LoadDatabase_Request { unsafe { rtabmap_ros__srv__LoadDatabase_Request__create () } } fn destroy_msg (msg : * mut rtabmap_ros__srv__LoadDatabase_Request) -> () { unsafe { rtabmap_ros__srv__LoadDatabase_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { database_path : msg . database_path . to_str () . to_owned () , clear : msg . clear , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . database_path . assign (& self . database_path) ; msg . clear = self . clear ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { } impl WrappedTypesupport for Response { type CStruct = rtabmap_ros__srv__LoadDatabase_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rtabmap_ros__srv__LoadDatabase_Response () } } fn create_msg () -> * mut rtabmap_ros__srv__LoadDatabase_Response { unsafe { rtabmap_ros__srv__LoadDatabase_Response__create () } } fn destroy_msg (msg : * mut rtabmap_ros__srv__LoadDatabase_Response) -> () { unsafe { rtabmap_ros__srv__LoadDatabase_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod PublishMap { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__rtabmap_ros__srv__PublishMap () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub global_map : bool , pub optimized : bool , pub graph_only : bool } impl WrappedTypesupport for Request { type CStruct = rtabmap_ros__srv__PublishMap_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rtabmap_ros__srv__PublishMap_Request () } } fn create_msg () -> * mut rtabmap_ros__srv__PublishMap_Request { unsafe { rtabmap_ros__srv__PublishMap_Request__create () } } fn destroy_msg (msg : * mut rtabmap_ros__srv__PublishMap_Request) -> () { unsafe { rtabmap_ros__srv__PublishMap_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { global_map : msg . global_map , optimized : msg . optimized , graph_only : msg . graph_only , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . global_map = self . global_map ; msg . optimized = self . optimized ; msg . graph_only = self . graph_only ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { } impl WrappedTypesupport for Response { type CStruct = rtabmap_ros__srv__PublishMap_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rtabmap_ros__srv__PublishMap_Response () } } fn create_msg () -> * mut rtabmap_ros__srv__PublishMap_Response { unsafe { rtabmap_ros__srv__PublishMap_Response__create () } } fn destroy_msg (msg : * mut rtabmap_ros__srv__PublishMap_Response) -> () { unsafe { rtabmap_ros__srv__PublishMap_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod RemoveLabel { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__rtabmap_ros__srv__RemoveLabel () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub label : std :: string :: String } impl WrappedTypesupport for Request { type CStruct = rtabmap_ros__srv__RemoveLabel_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rtabmap_ros__srv__RemoveLabel_Request () } } fn create_msg () -> * mut rtabmap_ros__srv__RemoveLabel_Request { unsafe { rtabmap_ros__srv__RemoveLabel_Request__create () } } fn destroy_msg (msg : * mut rtabmap_ros__srv__RemoveLabel_Request) -> () { unsafe { rtabmap_ros__srv__RemoveLabel_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { label : msg . label . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . label . assign (& self . label) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { } impl WrappedTypesupport for Response { type CStruct = rtabmap_ros__srv__RemoveLabel_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rtabmap_ros__srv__RemoveLabel_Response () } } fn create_msg () -> * mut rtabmap_ros__srv__RemoveLabel_Response { unsafe { rtabmap_ros__srv__RemoveLabel_Response__create () } } fn destroy_msg (msg : * mut rtabmap_ros__srv__RemoveLabel_Response) -> () { unsafe { rtabmap_ros__srv__RemoveLabel_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod ResetPose { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__rtabmap_ros__srv__ResetPose () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub x : f32 , pub y : f32 , pub z : f32 , pub roll : f32 , pub pitch : f32 , pub yaw : f32 } impl WrappedTypesupport for Request { type CStruct = rtabmap_ros__srv__ResetPose_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rtabmap_ros__srv__ResetPose_Request () } } fn create_msg () -> * mut rtabmap_ros__srv__ResetPose_Request { unsafe { rtabmap_ros__srv__ResetPose_Request__create () } } fn destroy_msg (msg : * mut rtabmap_ros__srv__ResetPose_Request) -> () { unsafe { rtabmap_ros__srv__ResetPose_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { x : msg . x , y : msg . y , z : msg . z , roll : msg . roll , pitch : msg . pitch , yaw : msg . yaw , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . x = self . x ; msg . y = self . y ; msg . z = self . z ; msg . roll = self . roll ; msg . pitch = self . pitch ; msg . yaw = self . yaw ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { } impl WrappedTypesupport for Response { type CStruct = rtabmap_ros__srv__ResetPose_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rtabmap_ros__srv__ResetPose_Response () } } fn create_msg () -> * mut rtabmap_ros__srv__ResetPose_Response { unsafe { rtabmap_ros__srv__ResetPose_Response__create () } } fn destroy_msg (msg : * mut rtabmap_ros__srv__ResetPose_Response) -> () { unsafe { rtabmap_ros__srv__ResetPose_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod SetGoal { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__rtabmap_ros__srv__SetGoal () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub node_id : i32 , pub node_label : std :: string :: String , pub frame_id : std :: string :: String } impl WrappedTypesupport for Request { type CStruct = rtabmap_ros__srv__SetGoal_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rtabmap_ros__srv__SetGoal_Request () } } fn create_msg () -> * mut rtabmap_ros__srv__SetGoal_Request { unsafe { rtabmap_ros__srv__SetGoal_Request__create () } } fn destroy_msg (msg : * mut rtabmap_ros__srv__SetGoal_Request) -> () { unsafe { rtabmap_ros__srv__SetGoal_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { node_id : msg . node_id , node_label : msg . node_label . to_str () . to_owned () , frame_id : msg . frame_id . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . node_id = self . node_id ; msg . node_label . assign (& self . node_label) ; msg . frame_id . assign (& self . frame_id) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub path_ids : Vec < i32 > , pub path_poses : Vec < geometry_msgs :: msg :: Pose > , pub planning_time : f32 } impl WrappedTypesupport for Response { type CStruct = rtabmap_ros__srv__SetGoal_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rtabmap_ros__srv__SetGoal_Response () } } fn create_msg () -> * mut rtabmap_ros__srv__SetGoal_Response { unsafe { rtabmap_ros__srv__SetGoal_Response__create () } } fn destroy_msg (msg : * mut rtabmap_ros__srv__SetGoal_Response) -> () { unsafe { rtabmap_ros__srv__SetGoal_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { path_ids : msg . path_ids . to_vec () , path_poses : { let mut temp = Vec :: with_capacity (msg . path_poses . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . path_poses . data , msg . path_poses . size) } ; for s in slice { temp . push (geometry_msgs :: msg :: Pose :: from_native (s)) ; } temp } , planning_time : msg . planning_time , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . path_ids . update (& self . path_ids) ; unsafe { geometry_msgs__msg__Pose__Sequence__fini (& mut msg . path_poses) ; geometry_msgs__msg__Pose__Sequence__init (& mut msg . path_poses , self . path_poses . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . path_poses . data , msg . path_poses . size) ; for (t , s) in slice . iter_mut () . zip (& self . path_poses) { s . copy_to_native (t) ; } } msg . planning_time = self . planning_time ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod SetLabel { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__rtabmap_ros__srv__SetLabel () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub node_id : i32 , pub node_label : std :: string :: String } impl WrappedTypesupport for Request { type CStruct = rtabmap_ros__srv__SetLabel_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rtabmap_ros__srv__SetLabel_Request () } } fn create_msg () -> * mut rtabmap_ros__srv__SetLabel_Request { unsafe { rtabmap_ros__srv__SetLabel_Request__create () } } fn destroy_msg (msg : * mut rtabmap_ros__srv__SetLabel_Request) -> () { unsafe { rtabmap_ros__srv__SetLabel_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { node_id : msg . node_id , node_label : msg . node_label . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . node_id = self . node_id ; msg . node_label . assign (& self . node_label) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { } impl WrappedTypesupport for Response { type CStruct = rtabmap_ros__srv__SetLabel_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rtabmap_ros__srv__SetLabel_Response () } } fn create_msg () -> * mut rtabmap_ros__srv__SetLabel_Response { unsafe { rtabmap_ros__srv__SetLabel_Response__create () } } fn destroy_msg (msg : * mut rtabmap_ros__srv__SetLabel_Response) -> () { unsafe { rtabmap_ros__srv__SetLabel_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } }