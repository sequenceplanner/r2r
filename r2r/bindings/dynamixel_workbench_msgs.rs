pub mod msg { use super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct AX { pub model_number : u16 , pub firmware_version : u8 , pub model_id : u8 , pub baud_rate : u8 , pub return_delay_time : u8 , pub cw_angle_limit : u16 , pub ccw_angle_limit : u16 , pub temperature_limit : u8 , pub min_voltage_limit : u8 , pub max_voltage_limit : u8 , pub max_torque : u16 , pub status_return_level : u8 , pub alarm_led : u8 , pub shutdown : u8 , pub torque_enable : u8 , pub led : u8 , pub cw_compliance_margin : u8 , pub ccw_compliance_margin : u8 , pub cw_compliance_slope : u8 , pub ccw_compliance_slope : u8 , pub goal_position : u16 , pub moving_speed : u16 , pub torque_limit : u16 , pub present_position : u16 , pub present_speed : u16 , pub present_load : u16 , pub present_voltage : u8 , pub present_temperature : u8 , pub registered : u8 , pub moving : u8 , pub lock : u8 , pub punch : u16 } impl WrappedTypesupport for AX { type CStruct = dynamixel_workbench_msgs__msg__AX ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__dynamixel_workbench_msgs__msg__AX () } } fn create_msg () -> * mut dynamixel_workbench_msgs__msg__AX { unsafe { dynamixel_workbench_msgs__msg__AX__create () } } fn destroy_msg (msg : * mut dynamixel_workbench_msgs__msg__AX) -> () { unsafe { dynamixel_workbench_msgs__msg__AX__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> AX { AX { model_number : msg . model_number , firmware_version : msg . firmware_version , model_id : msg . model_id , baud_rate : msg . baud_rate , return_delay_time : msg . return_delay_time , cw_angle_limit : msg . cw_angle_limit , ccw_angle_limit : msg . ccw_angle_limit , temperature_limit : msg . temperature_limit , min_voltage_limit : msg . min_voltage_limit , max_voltage_limit : msg . max_voltage_limit , max_torque : msg . max_torque , status_return_level : msg . status_return_level , alarm_led : msg . alarm_led , shutdown : msg . shutdown , torque_enable : msg . torque_enable , led : msg . led , cw_compliance_margin : msg . cw_compliance_margin , ccw_compliance_margin : msg . ccw_compliance_margin , cw_compliance_slope : msg . cw_compliance_slope , ccw_compliance_slope : msg . ccw_compliance_slope , goal_position : msg . goal_position , moving_speed : msg . moving_speed , torque_limit : msg . torque_limit , present_position : msg . present_position , present_speed : msg . present_speed , present_load : msg . present_load , present_voltage : msg . present_voltage , present_temperature : msg . present_temperature , registered : msg . registered , moving : msg . moving , lock : msg . lock , punch : msg . punch , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . model_number = self . model_number ; msg . firmware_version = self . firmware_version ; msg . model_id = self . model_id ; msg . baud_rate = self . baud_rate ; msg . return_delay_time = self . return_delay_time ; msg . cw_angle_limit = self . cw_angle_limit ; msg . ccw_angle_limit = self . ccw_angle_limit ; msg . temperature_limit = self . temperature_limit ; msg . min_voltage_limit = self . min_voltage_limit ; msg . max_voltage_limit = self . max_voltage_limit ; msg . max_torque = self . max_torque ; msg . status_return_level = self . status_return_level ; msg . alarm_led = self . alarm_led ; msg . shutdown = self . shutdown ; msg . torque_enable = self . torque_enable ; msg . led = self . led ; msg . cw_compliance_margin = self . cw_compliance_margin ; msg . ccw_compliance_margin = self . ccw_compliance_margin ; msg . cw_compliance_slope = self . cw_compliance_slope ; msg . ccw_compliance_slope = self . ccw_compliance_slope ; msg . goal_position = self . goal_position ; msg . moving_speed = self . moving_speed ; msg . torque_limit = self . torque_limit ; msg . present_position = self . present_position ; msg . present_speed = self . present_speed ; msg . present_load = self . present_load ; msg . present_voltage = self . present_voltage ; msg . present_temperature = self . present_temperature ; msg . registered = self . registered ; msg . moving = self . moving ; msg . lock = self . lock ; msg . punch = self . punch ; } } impl Default for AX { fn default () -> Self { let msg_native = WrappedNativeMsg :: < AX > :: new () ; AX :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct DynamixelInfo { pub load_info : dynamixel_workbench_msgs :: msg :: DynamixelLoadInfo , pub model_name : std :: string :: String , pub model_number : u16 , pub model_id : u8 } impl WrappedTypesupport for DynamixelInfo { type CStruct = dynamixel_workbench_msgs__msg__DynamixelInfo ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__dynamixel_workbench_msgs__msg__DynamixelInfo () } } fn create_msg () -> * mut dynamixel_workbench_msgs__msg__DynamixelInfo { unsafe { dynamixel_workbench_msgs__msg__DynamixelInfo__create () } } fn destroy_msg (msg : * mut dynamixel_workbench_msgs__msg__DynamixelInfo) -> () { unsafe { dynamixel_workbench_msgs__msg__DynamixelInfo__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> DynamixelInfo { DynamixelInfo { load_info : dynamixel_workbench_msgs :: msg :: DynamixelLoadInfo :: from_native (& msg . load_info) , model_name : msg . model_name . to_str () . to_owned () , model_number : msg . model_number , model_id : msg . model_id , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . load_info . copy_to_native (& mut msg . load_info) ; msg . model_name . assign (& self . model_name) ; msg . model_number = self . model_number ; msg . model_id = self . model_id ; } } impl Default for DynamixelInfo { fn default () -> Self { let msg_native = WrappedNativeMsg :: < DynamixelInfo > :: new () ; DynamixelInfo :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct DynamixelLoadInfo { pub device_name : std :: string :: String , pub baud_rate : u64 , pub protocol_version : f32 } impl WrappedTypesupport for DynamixelLoadInfo { type CStruct = dynamixel_workbench_msgs__msg__DynamixelLoadInfo ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__dynamixel_workbench_msgs__msg__DynamixelLoadInfo () } } fn create_msg () -> * mut dynamixel_workbench_msgs__msg__DynamixelLoadInfo { unsafe { dynamixel_workbench_msgs__msg__DynamixelLoadInfo__create () } } fn destroy_msg (msg : * mut dynamixel_workbench_msgs__msg__DynamixelLoadInfo) -> () { unsafe { dynamixel_workbench_msgs__msg__DynamixelLoadInfo__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> DynamixelLoadInfo { DynamixelLoadInfo { device_name : msg . device_name . to_str () . to_owned () , baud_rate : msg . baud_rate , protocol_version : msg . protocol_version , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . device_name . assign (& self . device_name) ; msg . baud_rate = self . baud_rate ; msg . protocol_version = self . protocol_version ; } } impl Default for DynamixelLoadInfo { fn default () -> Self { let msg_native = WrappedNativeMsg :: < DynamixelLoadInfo > :: new () ; DynamixelLoadInfo :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct DynamixelState { pub name : std :: string :: String , pub id : u8 , pub present_position : i32 , pub present_velocity : i32 , pub present_current : i16 } impl WrappedTypesupport for DynamixelState { type CStruct = dynamixel_workbench_msgs__msg__DynamixelState ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__dynamixel_workbench_msgs__msg__DynamixelState () } } fn create_msg () -> * mut dynamixel_workbench_msgs__msg__DynamixelState { unsafe { dynamixel_workbench_msgs__msg__DynamixelState__create () } } fn destroy_msg (msg : * mut dynamixel_workbench_msgs__msg__DynamixelState) -> () { unsafe { dynamixel_workbench_msgs__msg__DynamixelState__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> DynamixelState { DynamixelState { name : msg . name . to_str () . to_owned () , id : msg . id , present_position : msg . present_position , present_velocity : msg . present_velocity , present_current : msg . present_current , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . name . assign (& self . name) ; msg . id = self . id ; msg . present_position = self . present_position ; msg . present_velocity = self . present_velocity ; msg . present_current = self . present_current ; } } impl Default for DynamixelState { fn default () -> Self { let msg_native = WrappedNativeMsg :: < DynamixelState > :: new () ; DynamixelState :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct DynamixelStateList { pub dynamixel_state : Vec < dynamixel_workbench_msgs :: msg :: DynamixelState > } impl WrappedTypesupport for DynamixelStateList { type CStruct = dynamixel_workbench_msgs__msg__DynamixelStateList ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__dynamixel_workbench_msgs__msg__DynamixelStateList () } } fn create_msg () -> * mut dynamixel_workbench_msgs__msg__DynamixelStateList { unsafe { dynamixel_workbench_msgs__msg__DynamixelStateList__create () } } fn destroy_msg (msg : * mut dynamixel_workbench_msgs__msg__DynamixelStateList) -> () { unsafe { dynamixel_workbench_msgs__msg__DynamixelStateList__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> DynamixelStateList { DynamixelStateList { dynamixel_state : { let mut temp = Vec :: with_capacity (msg . dynamixel_state . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . dynamixel_state . data , msg . dynamixel_state . size) } ; for s in slice { temp . push (dynamixel_workbench_msgs :: msg :: DynamixelState :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { unsafe { dynamixel_workbench_msgs__msg__DynamixelState__Sequence__fini (& mut msg . dynamixel_state) ; dynamixel_workbench_msgs__msg__DynamixelState__Sequence__init (& mut msg . dynamixel_state , self . dynamixel_state . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . dynamixel_state . data , msg . dynamixel_state . size) ; for (t , s) in slice . iter_mut () . zip (& self . dynamixel_state) { s . copy_to_native (t) ; } } } } impl Default for DynamixelStateList { fn default () -> Self { let msg_native = WrappedNativeMsg :: < DynamixelStateList > :: new () ; DynamixelStateList :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct EX { pub model_number : u16 , pub firmware_version : u8 , pub model_id : u8 , pub baud_rate : u8 , pub return_delay_time : u8 , pub cw_angle_limit : u16 , pub ccw_angle_limit : u16 , pub drive_mode : u8 , pub temperature_limit : u8 , pub min_voltage_limit : u8 , pub max_voltage_limit : u8 , pub max_torque : u16 , pub status_return_level : u8 , pub alarm_led : u8 , pub shutdown : u8 , pub torque_enable : u8 , pub led : u8 , pub cw_compliance_margin : u8 , pub ccw_compliance_margin : u8 , pub cw_compliance_slope : u8 , pub ccw_compliance_slope : u8 , pub goal_position : u16 , pub moving_speed : u16 , pub torque_limit : u16 , pub present_position : u16 , pub present_speed : u16 , pub present_load : u16 , pub present_voltage : u8 , pub present_temperature : u8 , pub registered : u8 , pub moving : u8 , pub lock : u8 , pub punch : u16 , pub sensored_current : u16 } impl WrappedTypesupport for EX { type CStruct = dynamixel_workbench_msgs__msg__EX ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__dynamixel_workbench_msgs__msg__EX () } } fn create_msg () -> * mut dynamixel_workbench_msgs__msg__EX { unsafe { dynamixel_workbench_msgs__msg__EX__create () } } fn destroy_msg (msg : * mut dynamixel_workbench_msgs__msg__EX) -> () { unsafe { dynamixel_workbench_msgs__msg__EX__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> EX { EX { model_number : msg . model_number , firmware_version : msg . firmware_version , model_id : msg . model_id , baud_rate : msg . baud_rate , return_delay_time : msg . return_delay_time , cw_angle_limit : msg . cw_angle_limit , ccw_angle_limit : msg . ccw_angle_limit , drive_mode : msg . drive_mode , temperature_limit : msg . temperature_limit , min_voltage_limit : msg . min_voltage_limit , max_voltage_limit : msg . max_voltage_limit , max_torque : msg . max_torque , status_return_level : msg . status_return_level , alarm_led : msg . alarm_led , shutdown : msg . shutdown , torque_enable : msg . torque_enable , led : msg . led , cw_compliance_margin : msg . cw_compliance_margin , ccw_compliance_margin : msg . ccw_compliance_margin , cw_compliance_slope : msg . cw_compliance_slope , ccw_compliance_slope : msg . ccw_compliance_slope , goal_position : msg . goal_position , moving_speed : msg . moving_speed , torque_limit : msg . torque_limit , present_position : msg . present_position , present_speed : msg . present_speed , present_load : msg . present_load , present_voltage : msg . present_voltage , present_temperature : msg . present_temperature , registered : msg . registered , moving : msg . moving , lock : msg . lock , punch : msg . punch , sensored_current : msg . sensored_current , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . model_number = self . model_number ; msg . firmware_version = self . firmware_version ; msg . model_id = self . model_id ; msg . baud_rate = self . baud_rate ; msg . return_delay_time = self . return_delay_time ; msg . cw_angle_limit = self . cw_angle_limit ; msg . ccw_angle_limit = self . ccw_angle_limit ; msg . drive_mode = self . drive_mode ; msg . temperature_limit = self . temperature_limit ; msg . min_voltage_limit = self . min_voltage_limit ; msg . max_voltage_limit = self . max_voltage_limit ; msg . max_torque = self . max_torque ; msg . status_return_level = self . status_return_level ; msg . alarm_led = self . alarm_led ; msg . shutdown = self . shutdown ; msg . torque_enable = self . torque_enable ; msg . led = self . led ; msg . cw_compliance_margin = self . cw_compliance_margin ; msg . ccw_compliance_margin = self . ccw_compliance_margin ; msg . cw_compliance_slope = self . cw_compliance_slope ; msg . ccw_compliance_slope = self . ccw_compliance_slope ; msg . goal_position = self . goal_position ; msg . moving_speed = self . moving_speed ; msg . torque_limit = self . torque_limit ; msg . present_position = self . present_position ; msg . present_speed = self . present_speed ; msg . present_load = self . present_load ; msg . present_voltage = self . present_voltage ; msg . present_temperature = self . present_temperature ; msg . registered = self . registered ; msg . moving = self . moving ; msg . lock = self . lock ; msg . punch = self . punch ; msg . sensored_current = self . sensored_current ; } } impl Default for EX { fn default () -> Self { let msg_native = WrappedNativeMsg :: < EX > :: new () ; EX :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct MX { pub model_number : u16 , pub firmware_version : u8 , pub model_id : u8 , pub baud_rate : u8 , pub return_delay_time : u8 , pub cw_angle_limit : u16 , pub ccw_angle_limit : u16 , pub temperature_limit : u8 , pub min_voltage_limit : u8 , pub max_voltage_limit : u8 , pub max_torque : u16 , pub status_return_level : u8 , pub alarm_led : u8 , pub shutdown : u8 , pub multi_turn_offset : u16 , pub resolution_divider : u8 , pub torque_enable : u8 , pub led : u8 , pub d_gain : u8 , pub i_gain : u8 , pub p_gain : u8 , pub goal_position : u16 , pub moving_speed : u16 , pub torque_limit : u16 , pub present_position : u16 , pub present_speed : u16 , pub present_load : u16 , pub present_voltage : u8 , pub present_temperature : u8 , pub registered : u8 , pub moving : u8 , pub lock : u8 , pub punch : u16 , pub goal_acceleration : u8 } impl WrappedTypesupport for MX { type CStruct = dynamixel_workbench_msgs__msg__MX ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__dynamixel_workbench_msgs__msg__MX () } } fn create_msg () -> * mut dynamixel_workbench_msgs__msg__MX { unsafe { dynamixel_workbench_msgs__msg__MX__create () } } fn destroy_msg (msg : * mut dynamixel_workbench_msgs__msg__MX) -> () { unsafe { dynamixel_workbench_msgs__msg__MX__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> MX { MX { model_number : msg . model_number , firmware_version : msg . firmware_version , model_id : msg . model_id , baud_rate : msg . baud_rate , return_delay_time : msg . return_delay_time , cw_angle_limit : msg . cw_angle_limit , ccw_angle_limit : msg . ccw_angle_limit , temperature_limit : msg . temperature_limit , min_voltage_limit : msg . min_voltage_limit , max_voltage_limit : msg . max_voltage_limit , max_torque : msg . max_torque , status_return_level : msg . status_return_level , alarm_led : msg . alarm_led , shutdown : msg . shutdown , multi_turn_offset : msg . multi_turn_offset , resolution_divider : msg . resolution_divider , torque_enable : msg . torque_enable , led : msg . led , d_gain : msg . d_gain , i_gain : msg . i_gain , p_gain : msg . p_gain , goal_position : msg . goal_position , moving_speed : msg . moving_speed , torque_limit : msg . torque_limit , present_position : msg . present_position , present_speed : msg . present_speed , present_load : msg . present_load , present_voltage : msg . present_voltage , present_temperature : msg . present_temperature , registered : msg . registered , moving : msg . moving , lock : msg . lock , punch : msg . punch , goal_acceleration : msg . goal_acceleration , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . model_number = self . model_number ; msg . firmware_version = self . firmware_version ; msg . model_id = self . model_id ; msg . baud_rate = self . baud_rate ; msg . return_delay_time = self . return_delay_time ; msg . cw_angle_limit = self . cw_angle_limit ; msg . ccw_angle_limit = self . ccw_angle_limit ; msg . temperature_limit = self . temperature_limit ; msg . min_voltage_limit = self . min_voltage_limit ; msg . max_voltage_limit = self . max_voltage_limit ; msg . max_torque = self . max_torque ; msg . status_return_level = self . status_return_level ; msg . alarm_led = self . alarm_led ; msg . shutdown = self . shutdown ; msg . multi_turn_offset = self . multi_turn_offset ; msg . resolution_divider = self . resolution_divider ; msg . torque_enable = self . torque_enable ; msg . led = self . led ; msg . d_gain = self . d_gain ; msg . i_gain = self . i_gain ; msg . p_gain = self . p_gain ; msg . goal_position = self . goal_position ; msg . moving_speed = self . moving_speed ; msg . torque_limit = self . torque_limit ; msg . present_position = self . present_position ; msg . present_speed = self . present_speed ; msg . present_load = self . present_load ; msg . present_voltage = self . present_voltage ; msg . present_temperature = self . present_temperature ; msg . registered = self . registered ; msg . moving = self . moving ; msg . lock = self . lock ; msg . punch = self . punch ; msg . goal_acceleration = self . goal_acceleration ; } } impl Default for MX { fn default () -> Self { let msg_native = WrappedNativeMsg :: < MX > :: new () ; MX :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct MX2 { pub model_number : u16 , pub firmware_version : u8 , pub model_id : u8 , pub baud_rate : u8 , pub return_delay_time : u8 , pub drive_mode : u8 , pub operating_mode : u8 , pub secondary_id : u8 , pub protocol_version : u8 , pub homing_offset : i32 , pub moving_threshold : u32 , pub temperature_limit : u8 , pub max_voltage_limit : u16 , pub min_voltage_limit : u16 , pub pwm_limit : u16 , pub acceleration_limit : u32 , pub velocity_limit : u32 , pub max_position_limit : u32 , pub min_position_limit : u32 , pub shutdown : u8 , pub torque_enable : u8 , pub led : u8 , pub status_return_level : u8 , pub registered_instruction : u8 , pub hardware_error_status : u8 , pub velocity_i_gain : u16 , pub velocity_p_gain : u16 , pub position_d_gain : u16 , pub position_i_gain : u16 , pub position_p_gain : u16 , pub feedforward_2nd_gain : u16 , pub feedforward_1st_gain : u16 , pub bus_watchdog : u8 , pub goal_pwm : i16 , pub goal_velocity : i32 , pub profile_acceleration : u32 , pub profile_velocity : u32 , pub goal_position : u32 , pub realtime_tick : u16 , pub moving : u8 , pub moving_status : u8 , pub present_pwm : i16 , pub present_load : i16 , pub present_velocity : i32 , pub present_position : i32 , pub velocity_trajectory : u32 , pub position_trajectory : u32 , pub present_input_voltage : u16 , pub present_temperature : u8 } impl WrappedTypesupport for MX2 { type CStruct = dynamixel_workbench_msgs__msg__MX2 ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__dynamixel_workbench_msgs__msg__MX2 () } } fn create_msg () -> * mut dynamixel_workbench_msgs__msg__MX2 { unsafe { dynamixel_workbench_msgs__msg__MX2__create () } } fn destroy_msg (msg : * mut dynamixel_workbench_msgs__msg__MX2) -> () { unsafe { dynamixel_workbench_msgs__msg__MX2__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> MX2 { MX2 { model_number : msg . model_number , firmware_version : msg . firmware_version , model_id : msg . model_id , baud_rate : msg . baud_rate , return_delay_time : msg . return_delay_time , drive_mode : msg . drive_mode , operating_mode : msg . operating_mode , secondary_id : msg . secondary_id , protocol_version : msg . protocol_version , homing_offset : msg . homing_offset , moving_threshold : msg . moving_threshold , temperature_limit : msg . temperature_limit , max_voltage_limit : msg . max_voltage_limit , min_voltage_limit : msg . min_voltage_limit , pwm_limit : msg . pwm_limit , acceleration_limit : msg . acceleration_limit , velocity_limit : msg . velocity_limit , max_position_limit : msg . max_position_limit , min_position_limit : msg . min_position_limit , shutdown : msg . shutdown , torque_enable : msg . torque_enable , led : msg . led , status_return_level : msg . status_return_level , registered_instruction : msg . registered_instruction , hardware_error_status : msg . hardware_error_status , velocity_i_gain : msg . velocity_i_gain , velocity_p_gain : msg . velocity_p_gain , position_d_gain : msg . position_d_gain , position_i_gain : msg . position_i_gain , position_p_gain : msg . position_p_gain , feedforward_2nd_gain : msg . feedforward_2nd_gain , feedforward_1st_gain : msg . feedforward_1st_gain , bus_watchdog : msg . bus_watchdog , goal_pwm : msg . goal_pwm , goal_velocity : msg . goal_velocity , profile_acceleration : msg . profile_acceleration , profile_velocity : msg . profile_velocity , goal_position : msg . goal_position , realtime_tick : msg . realtime_tick , moving : msg . moving , moving_status : msg . moving_status , present_pwm : msg . present_pwm , present_load : msg . present_load , present_velocity : msg . present_velocity , present_position : msg . present_position , velocity_trajectory : msg . velocity_trajectory , position_trajectory : msg . position_trajectory , present_input_voltage : msg . present_input_voltage , present_temperature : msg . present_temperature , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . model_number = self . model_number ; msg . firmware_version = self . firmware_version ; msg . model_id = self . model_id ; msg . baud_rate = self . baud_rate ; msg . return_delay_time = self . return_delay_time ; msg . drive_mode = self . drive_mode ; msg . operating_mode = self . operating_mode ; msg . secondary_id = self . secondary_id ; msg . protocol_version = self . protocol_version ; msg . homing_offset = self . homing_offset ; msg . moving_threshold = self . moving_threshold ; msg . temperature_limit = self . temperature_limit ; msg . max_voltage_limit = self . max_voltage_limit ; msg . min_voltage_limit = self . min_voltage_limit ; msg . pwm_limit = self . pwm_limit ; msg . acceleration_limit = self . acceleration_limit ; msg . velocity_limit = self . velocity_limit ; msg . max_position_limit = self . max_position_limit ; msg . min_position_limit = self . min_position_limit ; msg . shutdown = self . shutdown ; msg . torque_enable = self . torque_enable ; msg . led = self . led ; msg . status_return_level = self . status_return_level ; msg . registered_instruction = self . registered_instruction ; msg . hardware_error_status = self . hardware_error_status ; msg . velocity_i_gain = self . velocity_i_gain ; msg . velocity_p_gain = self . velocity_p_gain ; msg . position_d_gain = self . position_d_gain ; msg . position_i_gain = self . position_i_gain ; msg . position_p_gain = self . position_p_gain ; msg . feedforward_2nd_gain = self . feedforward_2nd_gain ; msg . feedforward_1st_gain = self . feedforward_1st_gain ; msg . bus_watchdog = self . bus_watchdog ; msg . goal_pwm = self . goal_pwm ; msg . goal_velocity = self . goal_velocity ; msg . profile_acceleration = self . profile_acceleration ; msg . profile_velocity = self . profile_velocity ; msg . goal_position = self . goal_position ; msg . realtime_tick = self . realtime_tick ; msg . moving = self . moving ; msg . moving_status = self . moving_status ; msg . present_pwm = self . present_pwm ; msg . present_load = self . present_load ; msg . present_velocity = self . present_velocity ; msg . present_position = self . present_position ; msg . velocity_trajectory = self . velocity_trajectory ; msg . position_trajectory = self . position_trajectory ; msg . present_input_voltage = self . present_input_voltage ; msg . present_temperature = self . present_temperature ; } } impl Default for MX2 { fn default () -> Self { let msg_native = WrappedNativeMsg :: < MX2 > :: new () ; MX2 :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct MX2Ext { pub model_number : u16 , pub firmware_version : u8 , pub model_id : u8 , pub baud_rate : u8 , pub return_delay_time : u8 , pub drive_mode : u8 , pub operating_mode : u8 , pub secondary_id : u8 , pub protocol_version : u8 , pub homing_offset : i32 , pub moving_threshold : u32 , pub temperature_limit : u8 , pub max_voltage_limit : u16 , pub min_voltage_limit : u16 , pub pwm_limit : u16 , pub current_limit : u16 , pub acceleration_limit : u32 , pub velocity_limit : u32 , pub max_position_limit : u32 , pub min_position_limit : u32 , pub shutdown : u8 , pub torque_enable : u8 , pub led : u8 , pub status_return_level : u8 , pub registered_instruction : u8 , pub hardware_error_status : u8 , pub velocity_i_gain : u16 , pub velocity_p_gain : u16 , pub position_d_gain : u16 , pub position_i_gain : u16 , pub position_p_gain : u16 , pub feedforward_2nd_gain : u16 , pub feedforward_1st_gain : u16 , pub bus_watchdog : u8 , pub goal_pwm : i16 , pub goal_current : i16 , pub goal_velocity : i32 , pub profile_acceleration : u32 , pub profile_velocity : u32 , pub goal_position : u32 , pub realtime_tick : u16 , pub moving : u8 , pub moving_status : u8 , pub present_pwm : i16 , pub present_current : i16 , pub present_velocity : i32 , pub present_position : i32 , pub velocity_trajectory : u32 , pub position_trajectory : u32 , pub present_input_voltage : u16 , pub present_temperature : u8 } impl WrappedTypesupport for MX2Ext { type CStruct = dynamixel_workbench_msgs__msg__MX2Ext ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__dynamixel_workbench_msgs__msg__MX2Ext () } } fn create_msg () -> * mut dynamixel_workbench_msgs__msg__MX2Ext { unsafe { dynamixel_workbench_msgs__msg__MX2Ext__create () } } fn destroy_msg (msg : * mut dynamixel_workbench_msgs__msg__MX2Ext) -> () { unsafe { dynamixel_workbench_msgs__msg__MX2Ext__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> MX2Ext { MX2Ext { model_number : msg . model_number , firmware_version : msg . firmware_version , model_id : msg . model_id , baud_rate : msg . baud_rate , return_delay_time : msg . return_delay_time , drive_mode : msg . drive_mode , operating_mode : msg . operating_mode , secondary_id : msg . secondary_id , protocol_version : msg . protocol_version , homing_offset : msg . homing_offset , moving_threshold : msg . moving_threshold , temperature_limit : msg . temperature_limit , max_voltage_limit : msg . max_voltage_limit , min_voltage_limit : msg . min_voltage_limit , pwm_limit : msg . pwm_limit , current_limit : msg . current_limit , acceleration_limit : msg . acceleration_limit , velocity_limit : msg . velocity_limit , max_position_limit : msg . max_position_limit , min_position_limit : msg . min_position_limit , shutdown : msg . shutdown , torque_enable : msg . torque_enable , led : msg . led , status_return_level : msg . status_return_level , registered_instruction : msg . registered_instruction , hardware_error_status : msg . hardware_error_status , velocity_i_gain : msg . velocity_i_gain , velocity_p_gain : msg . velocity_p_gain , position_d_gain : msg . position_d_gain , position_i_gain : msg . position_i_gain , position_p_gain : msg . position_p_gain , feedforward_2nd_gain : msg . feedforward_2nd_gain , feedforward_1st_gain : msg . feedforward_1st_gain , bus_watchdog : msg . bus_watchdog , goal_pwm : msg . goal_pwm , goal_current : msg . goal_current , goal_velocity : msg . goal_velocity , profile_acceleration : msg . profile_acceleration , profile_velocity : msg . profile_velocity , goal_position : msg . goal_position , realtime_tick : msg . realtime_tick , moving : msg . moving , moving_status : msg . moving_status , present_pwm : msg . present_pwm , present_current : msg . present_current , present_velocity : msg . present_velocity , present_position : msg . present_position , velocity_trajectory : msg . velocity_trajectory , position_trajectory : msg . position_trajectory , present_input_voltage : msg . present_input_voltage , present_temperature : msg . present_temperature , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . model_number = self . model_number ; msg . firmware_version = self . firmware_version ; msg . model_id = self . model_id ; msg . baud_rate = self . baud_rate ; msg . return_delay_time = self . return_delay_time ; msg . drive_mode = self . drive_mode ; msg . operating_mode = self . operating_mode ; msg . secondary_id = self . secondary_id ; msg . protocol_version = self . protocol_version ; msg . homing_offset = self . homing_offset ; msg . moving_threshold = self . moving_threshold ; msg . temperature_limit = self . temperature_limit ; msg . max_voltage_limit = self . max_voltage_limit ; msg . min_voltage_limit = self . min_voltage_limit ; msg . pwm_limit = self . pwm_limit ; msg . current_limit = self . current_limit ; msg . acceleration_limit = self . acceleration_limit ; msg . velocity_limit = self . velocity_limit ; msg . max_position_limit = self . max_position_limit ; msg . min_position_limit = self . min_position_limit ; msg . shutdown = self . shutdown ; msg . torque_enable = self . torque_enable ; msg . led = self . led ; msg . status_return_level = self . status_return_level ; msg . registered_instruction = self . registered_instruction ; msg . hardware_error_status = self . hardware_error_status ; msg . velocity_i_gain = self . velocity_i_gain ; msg . velocity_p_gain = self . velocity_p_gain ; msg . position_d_gain = self . position_d_gain ; msg . position_i_gain = self . position_i_gain ; msg . position_p_gain = self . position_p_gain ; msg . feedforward_2nd_gain = self . feedforward_2nd_gain ; msg . feedforward_1st_gain = self . feedforward_1st_gain ; msg . bus_watchdog = self . bus_watchdog ; msg . goal_pwm = self . goal_pwm ; msg . goal_current = self . goal_current ; msg . goal_velocity = self . goal_velocity ; msg . profile_acceleration = self . profile_acceleration ; msg . profile_velocity = self . profile_velocity ; msg . goal_position = self . goal_position ; msg . realtime_tick = self . realtime_tick ; msg . moving = self . moving ; msg . moving_status = self . moving_status ; msg . present_pwm = self . present_pwm ; msg . present_current = self . present_current ; msg . present_velocity = self . present_velocity ; msg . present_position = self . present_position ; msg . velocity_trajectory = self . velocity_trajectory ; msg . position_trajectory = self . position_trajectory ; msg . present_input_voltage = self . present_input_voltage ; msg . present_temperature = self . present_temperature ; } } impl Default for MX2Ext { fn default () -> Self { let msg_native = WrappedNativeMsg :: < MX2Ext > :: new () ; MX2Ext :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct MXExt { pub model_number : u16 , pub firmware_version : u8 , pub model_id : u8 , pub baud_rate : u8 , pub return_delay_time : u8 , pub cw_angle_limit : u16 , pub ccw_angle_limit : u16 , pub temperature_limit : u8 , pub min_voltage_limit : u8 , pub max_voltage_limit : u8 , pub max_torque : u16 , pub status_return_level : u8 , pub alarm_led : u8 , pub shutdown : u8 , pub multi_turn_offset : u16 , pub resolution_divider : u8 , pub torque_enable : u8 , pub led : u8 , pub d_gain : u8 , pub i_gain : u8 , pub p_gain : u8 , pub goal_position : u16 , pub moving_speed : u16 , pub torque_limit : u16 , pub present_position : u16 , pub present_speed : u16 , pub present_load : u16 , pub present_voltage : u8 , pub present_temperature : u8 , pub registered : u8 , pub moving : u8 , pub lock : u8 , pub punch : u16 , pub current : u16 , pub torque_control_mode_enable : u8 , pub goal_torque : u16 , pub goal_acceleration : u8 } impl WrappedTypesupport for MXExt { type CStruct = dynamixel_workbench_msgs__msg__MXExt ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__dynamixel_workbench_msgs__msg__MXExt () } } fn create_msg () -> * mut dynamixel_workbench_msgs__msg__MXExt { unsafe { dynamixel_workbench_msgs__msg__MXExt__create () } } fn destroy_msg (msg : * mut dynamixel_workbench_msgs__msg__MXExt) -> () { unsafe { dynamixel_workbench_msgs__msg__MXExt__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> MXExt { MXExt { model_number : msg . model_number , firmware_version : msg . firmware_version , model_id : msg . model_id , baud_rate : msg . baud_rate , return_delay_time : msg . return_delay_time , cw_angle_limit : msg . cw_angle_limit , ccw_angle_limit : msg . ccw_angle_limit , temperature_limit : msg . temperature_limit , min_voltage_limit : msg . min_voltage_limit , max_voltage_limit : msg . max_voltage_limit , max_torque : msg . max_torque , status_return_level : msg . status_return_level , alarm_led : msg . alarm_led , shutdown : msg . shutdown , multi_turn_offset : msg . multi_turn_offset , resolution_divider : msg . resolution_divider , torque_enable : msg . torque_enable , led : msg . led , d_gain : msg . d_gain , i_gain : msg . i_gain , p_gain : msg . p_gain , goal_position : msg . goal_position , moving_speed : msg . moving_speed , torque_limit : msg . torque_limit , present_position : msg . present_position , present_speed : msg . present_speed , present_load : msg . present_load , present_voltage : msg . present_voltage , present_temperature : msg . present_temperature , registered : msg . registered , moving : msg . moving , lock : msg . lock , punch : msg . punch , current : msg . current , torque_control_mode_enable : msg . torque_control_mode_enable , goal_torque : msg . goal_torque , goal_acceleration : msg . goal_acceleration , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . model_number = self . model_number ; msg . firmware_version = self . firmware_version ; msg . model_id = self . model_id ; msg . baud_rate = self . baud_rate ; msg . return_delay_time = self . return_delay_time ; msg . cw_angle_limit = self . cw_angle_limit ; msg . ccw_angle_limit = self . ccw_angle_limit ; msg . temperature_limit = self . temperature_limit ; msg . min_voltage_limit = self . min_voltage_limit ; msg . max_voltage_limit = self . max_voltage_limit ; msg . max_torque = self . max_torque ; msg . status_return_level = self . status_return_level ; msg . alarm_led = self . alarm_led ; msg . shutdown = self . shutdown ; msg . multi_turn_offset = self . multi_turn_offset ; msg . resolution_divider = self . resolution_divider ; msg . torque_enable = self . torque_enable ; msg . led = self . led ; msg . d_gain = self . d_gain ; msg . i_gain = self . i_gain ; msg . p_gain = self . p_gain ; msg . goal_position = self . goal_position ; msg . moving_speed = self . moving_speed ; msg . torque_limit = self . torque_limit ; msg . present_position = self . present_position ; msg . present_speed = self . present_speed ; msg . present_load = self . present_load ; msg . present_voltage = self . present_voltage ; msg . present_temperature = self . present_temperature ; msg . registered = self . registered ; msg . moving = self . moving ; msg . lock = self . lock ; msg . punch = self . punch ; msg . current = self . current ; msg . torque_control_mode_enable = self . torque_control_mode_enable ; msg . goal_torque = self . goal_torque ; msg . goal_acceleration = self . goal_acceleration ; } } impl Default for MXExt { fn default () -> Self { let msg_native = WrappedNativeMsg :: < MXExt > :: new () ; MXExt :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct PRO { pub model_number : u16 , pub firmware_version : u8 , pub model_id : u8 , pub baud_rate : u8 , pub return_delay_time : u8 , pub operating_mode : u8 , pub moving_threshold : u32 , pub temperature_limit : u8 , pub max_voltage_limit : u16 , pub min_voltage_limit : u16 , pub acceleration_limit : u32 , pub torque_limit : u16 , pub velocity_limit : u32 , pub max_position_limit : i32 , pub min_position_limit : i32 , pub external_port_mode_1 : u8 , pub external_port_mode_2 : u8 , pub external_port_mode_3 : u8 , pub external_port_mode_4 : u8 , pub shutdown : u8 , pub torque_enable : u8 , pub led_red : u8 , pub led_green : u8 , pub led_blue : u8 , pub velocity_i_gain : u16 , pub velocity_p_gain : u16 , pub position_p_gain : u16 , pub goal_position : i32 , pub goal_velocity : u32 , pub goal_torque : u16 , pub goal_acceleration : i32 , pub moving : u8 , pub present_position : i32 , pub present_velocity : u32 , pub present_current : u16 , pub present_input_voltage : u16 , pub present_temperature : u8 , pub registered_instruction : u8 , pub status_return_level : u8 , pub hardware_error_status : u8 } impl WrappedTypesupport for PRO { type CStruct = dynamixel_workbench_msgs__msg__PRO ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__dynamixel_workbench_msgs__msg__PRO () } } fn create_msg () -> * mut dynamixel_workbench_msgs__msg__PRO { unsafe { dynamixel_workbench_msgs__msg__PRO__create () } } fn destroy_msg (msg : * mut dynamixel_workbench_msgs__msg__PRO) -> () { unsafe { dynamixel_workbench_msgs__msg__PRO__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> PRO { PRO { model_number : msg . model_number , firmware_version : msg . firmware_version , model_id : msg . model_id , baud_rate : msg . baud_rate , return_delay_time : msg . return_delay_time , operating_mode : msg . operating_mode , moving_threshold : msg . moving_threshold , temperature_limit : msg . temperature_limit , max_voltage_limit : msg . max_voltage_limit , min_voltage_limit : msg . min_voltage_limit , acceleration_limit : msg . acceleration_limit , torque_limit : msg . torque_limit , velocity_limit : msg . velocity_limit , max_position_limit : msg . max_position_limit , min_position_limit : msg . min_position_limit , external_port_mode_1 : msg . external_port_mode_1 , external_port_mode_2 : msg . external_port_mode_2 , external_port_mode_3 : msg . external_port_mode_3 , external_port_mode_4 : msg . external_port_mode_4 , shutdown : msg . shutdown , torque_enable : msg . torque_enable , led_red : msg . led_red , led_green : msg . led_green , led_blue : msg . led_blue , velocity_i_gain : msg . velocity_i_gain , velocity_p_gain : msg . velocity_p_gain , position_p_gain : msg . position_p_gain , goal_position : msg . goal_position , goal_velocity : msg . goal_velocity , goal_torque : msg . goal_torque , goal_acceleration : msg . goal_acceleration , moving : msg . moving , present_position : msg . present_position , present_velocity : msg . present_velocity , present_current : msg . present_current , present_input_voltage : msg . present_input_voltage , present_temperature : msg . present_temperature , registered_instruction : msg . registered_instruction , status_return_level : msg . status_return_level , hardware_error_status : msg . hardware_error_status , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . model_number = self . model_number ; msg . firmware_version = self . firmware_version ; msg . model_id = self . model_id ; msg . baud_rate = self . baud_rate ; msg . return_delay_time = self . return_delay_time ; msg . operating_mode = self . operating_mode ; msg . moving_threshold = self . moving_threshold ; msg . temperature_limit = self . temperature_limit ; msg . max_voltage_limit = self . max_voltage_limit ; msg . min_voltage_limit = self . min_voltage_limit ; msg . acceleration_limit = self . acceleration_limit ; msg . torque_limit = self . torque_limit ; msg . velocity_limit = self . velocity_limit ; msg . max_position_limit = self . max_position_limit ; msg . min_position_limit = self . min_position_limit ; msg . external_port_mode_1 = self . external_port_mode_1 ; msg . external_port_mode_2 = self . external_port_mode_2 ; msg . external_port_mode_3 = self . external_port_mode_3 ; msg . external_port_mode_4 = self . external_port_mode_4 ; msg . shutdown = self . shutdown ; msg . torque_enable = self . torque_enable ; msg . led_red = self . led_red ; msg . led_green = self . led_green ; msg . led_blue = self . led_blue ; msg . velocity_i_gain = self . velocity_i_gain ; msg . velocity_p_gain = self . velocity_p_gain ; msg . position_p_gain = self . position_p_gain ; msg . goal_position = self . goal_position ; msg . goal_velocity = self . goal_velocity ; msg . goal_torque = self . goal_torque ; msg . goal_acceleration = self . goal_acceleration ; msg . moving = self . moving ; msg . present_position = self . present_position ; msg . present_velocity = self . present_velocity ; msg . present_current = self . present_current ; msg . present_input_voltage = self . present_input_voltage ; msg . present_temperature = self . present_temperature ; msg . registered_instruction = self . registered_instruction ; msg . status_return_level = self . status_return_level ; msg . hardware_error_status = self . hardware_error_status ; } } impl Default for PRO { fn default () -> Self { let msg_native = WrappedNativeMsg :: < PRO > :: new () ; PRO :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct PROExt { pub model_number : u16 , pub firmware_version : u8 , pub model_id : u8 , pub baud_rate : u8 , pub return_delay_time : u8 , pub operating_mode : u8 , pub homing_offset : i32 , pub moving_threshold : u32 , pub temperature_limit : u8 , pub max_voltage_limit : u16 , pub min_voltage_limit : u16 , pub acceleration_limit : u32 , pub torque_limit : u16 , pub velocity_limit : u32 , pub max_position_limit : i32 , pub min_position_limit : i32 , pub external_port_mode_1 : u8 , pub external_port_mode_2 : u8 , pub external_port_mode_3 : u8 , pub external_port_mode_4 : u8 , pub shutdown : u8 , pub torque_enable : u8 , pub led_red : u8 , pub led_green : u8 , pub led_blue : u8 , pub velocity_i_gain : u16 , pub velocity_p_gain : u16 , pub position_p_gain : u16 , pub goal_position : i32 , pub goal_velocity : u32 , pub goal_torque : u16 , pub goal_acceleration : i32 , pub moving : u8 , pub present_position : i32 , pub present_velocity : u32 , pub present_current : u16 , pub present_input_voltage : u16 , pub present_temperature : u8 , pub registered_instruction : u8 , pub status_return_level : u8 , pub hardware_error_status : u8 } impl WrappedTypesupport for PROExt { type CStruct = dynamixel_workbench_msgs__msg__PROExt ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__dynamixel_workbench_msgs__msg__PROExt () } } fn create_msg () -> * mut dynamixel_workbench_msgs__msg__PROExt { unsafe { dynamixel_workbench_msgs__msg__PROExt__create () } } fn destroy_msg (msg : * mut dynamixel_workbench_msgs__msg__PROExt) -> () { unsafe { dynamixel_workbench_msgs__msg__PROExt__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> PROExt { PROExt { model_number : msg . model_number , firmware_version : msg . firmware_version , model_id : msg . model_id , baud_rate : msg . baud_rate , return_delay_time : msg . return_delay_time , operating_mode : msg . operating_mode , homing_offset : msg . homing_offset , moving_threshold : msg . moving_threshold , temperature_limit : msg . temperature_limit , max_voltage_limit : msg . max_voltage_limit , min_voltage_limit : msg . min_voltage_limit , acceleration_limit : msg . acceleration_limit , torque_limit : msg . torque_limit , velocity_limit : msg . velocity_limit , max_position_limit : msg . max_position_limit , min_position_limit : msg . min_position_limit , external_port_mode_1 : msg . external_port_mode_1 , external_port_mode_2 : msg . external_port_mode_2 , external_port_mode_3 : msg . external_port_mode_3 , external_port_mode_4 : msg . external_port_mode_4 , shutdown : msg . shutdown , torque_enable : msg . torque_enable , led_red : msg . led_red , led_green : msg . led_green , led_blue : msg . led_blue , velocity_i_gain : msg . velocity_i_gain , velocity_p_gain : msg . velocity_p_gain , position_p_gain : msg . position_p_gain , goal_position : msg . goal_position , goal_velocity : msg . goal_velocity , goal_torque : msg . goal_torque , goal_acceleration : msg . goal_acceleration , moving : msg . moving , present_position : msg . present_position , present_velocity : msg . present_velocity , present_current : msg . present_current , present_input_voltage : msg . present_input_voltage , present_temperature : msg . present_temperature , registered_instruction : msg . registered_instruction , status_return_level : msg . status_return_level , hardware_error_status : msg . hardware_error_status , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . model_number = self . model_number ; msg . firmware_version = self . firmware_version ; msg . model_id = self . model_id ; msg . baud_rate = self . baud_rate ; msg . return_delay_time = self . return_delay_time ; msg . operating_mode = self . operating_mode ; msg . homing_offset = self . homing_offset ; msg . moving_threshold = self . moving_threshold ; msg . temperature_limit = self . temperature_limit ; msg . max_voltage_limit = self . max_voltage_limit ; msg . min_voltage_limit = self . min_voltage_limit ; msg . acceleration_limit = self . acceleration_limit ; msg . torque_limit = self . torque_limit ; msg . velocity_limit = self . velocity_limit ; msg . max_position_limit = self . max_position_limit ; msg . min_position_limit = self . min_position_limit ; msg . external_port_mode_1 = self . external_port_mode_1 ; msg . external_port_mode_2 = self . external_port_mode_2 ; msg . external_port_mode_3 = self . external_port_mode_3 ; msg . external_port_mode_4 = self . external_port_mode_4 ; msg . shutdown = self . shutdown ; msg . torque_enable = self . torque_enable ; msg . led_red = self . led_red ; msg . led_green = self . led_green ; msg . led_blue = self . led_blue ; msg . velocity_i_gain = self . velocity_i_gain ; msg . velocity_p_gain = self . velocity_p_gain ; msg . position_p_gain = self . position_p_gain ; msg . goal_position = self . goal_position ; msg . goal_velocity = self . goal_velocity ; msg . goal_torque = self . goal_torque ; msg . goal_acceleration = self . goal_acceleration ; msg . moving = self . moving ; msg . present_position = self . present_position ; msg . present_velocity = self . present_velocity ; msg . present_current = self . present_current ; msg . present_input_voltage = self . present_input_voltage ; msg . present_temperature = self . present_temperature ; msg . registered_instruction = self . registered_instruction ; msg . status_return_level = self . status_return_level ; msg . hardware_error_status = self . hardware_error_status ; } } impl Default for PROExt { fn default () -> Self { let msg_native = WrappedNativeMsg :: < PROExt > :: new () ; PROExt :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct RX { pub model_number : u16 , pub firmware_version : u8 , pub model_id : u8 , pub baud_rate : u8 , pub return_delay_time : u8 , pub cw_angle_limit : u16 , pub ccw_angle_limit : u16 , pub temperature_limit : u8 , pub min_voltage_limit : u8 , pub max_voltage_limit : u8 , pub max_torque : u16 , pub status_return_level : u8 , pub alarm_led : u8 , pub shutdown : u8 , pub torque_enable : u8 , pub led : u8 , pub cw_compliance_margin : u8 , pub ccw_compliance_margin : u8 , pub cw_compliance_slope : u8 , pub ccw_compliance_slope : u8 , pub goal_position : u16 , pub moving_speed : u16 , pub torque_limit : u16 , pub present_position : u16 , pub present_speed : u16 , pub present_load : u16 , pub present_voltage : u8 , pub present_temperature : u8 , pub registered : u8 , pub moving : u8 , pub lock : u8 , pub punch : u16 } impl WrappedTypesupport for RX { type CStruct = dynamixel_workbench_msgs__msg__RX ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__dynamixel_workbench_msgs__msg__RX () } } fn create_msg () -> * mut dynamixel_workbench_msgs__msg__RX { unsafe { dynamixel_workbench_msgs__msg__RX__create () } } fn destroy_msg (msg : * mut dynamixel_workbench_msgs__msg__RX) -> () { unsafe { dynamixel_workbench_msgs__msg__RX__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> RX { RX { model_number : msg . model_number , firmware_version : msg . firmware_version , model_id : msg . model_id , baud_rate : msg . baud_rate , return_delay_time : msg . return_delay_time , cw_angle_limit : msg . cw_angle_limit , ccw_angle_limit : msg . ccw_angle_limit , temperature_limit : msg . temperature_limit , min_voltage_limit : msg . min_voltage_limit , max_voltage_limit : msg . max_voltage_limit , max_torque : msg . max_torque , status_return_level : msg . status_return_level , alarm_led : msg . alarm_led , shutdown : msg . shutdown , torque_enable : msg . torque_enable , led : msg . led , cw_compliance_margin : msg . cw_compliance_margin , ccw_compliance_margin : msg . ccw_compliance_margin , cw_compliance_slope : msg . cw_compliance_slope , ccw_compliance_slope : msg . ccw_compliance_slope , goal_position : msg . goal_position , moving_speed : msg . moving_speed , torque_limit : msg . torque_limit , present_position : msg . present_position , present_speed : msg . present_speed , present_load : msg . present_load , present_voltage : msg . present_voltage , present_temperature : msg . present_temperature , registered : msg . registered , moving : msg . moving , lock : msg . lock , punch : msg . punch , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . model_number = self . model_number ; msg . firmware_version = self . firmware_version ; msg . model_id = self . model_id ; msg . baud_rate = self . baud_rate ; msg . return_delay_time = self . return_delay_time ; msg . cw_angle_limit = self . cw_angle_limit ; msg . ccw_angle_limit = self . ccw_angle_limit ; msg . temperature_limit = self . temperature_limit ; msg . min_voltage_limit = self . min_voltage_limit ; msg . max_voltage_limit = self . max_voltage_limit ; msg . max_torque = self . max_torque ; msg . status_return_level = self . status_return_level ; msg . alarm_led = self . alarm_led ; msg . shutdown = self . shutdown ; msg . torque_enable = self . torque_enable ; msg . led = self . led ; msg . cw_compliance_margin = self . cw_compliance_margin ; msg . ccw_compliance_margin = self . ccw_compliance_margin ; msg . cw_compliance_slope = self . cw_compliance_slope ; msg . ccw_compliance_slope = self . ccw_compliance_slope ; msg . goal_position = self . goal_position ; msg . moving_speed = self . moving_speed ; msg . torque_limit = self . torque_limit ; msg . present_position = self . present_position ; msg . present_speed = self . present_speed ; msg . present_load = self . present_load ; msg . present_voltage = self . present_voltage ; msg . present_temperature = self . present_temperature ; msg . registered = self . registered ; msg . moving = self . moving ; msg . lock = self . lock ; msg . punch = self . punch ; } } impl Default for RX { fn default () -> Self { let msg_native = WrappedNativeMsg :: < RX > :: new () ; RX :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct XH { pub model_number : u16 , pub firmware_version : u8 , pub model_id : u8 , pub baud_rate : u8 , pub return_delay_time : u8 , pub drive_mode : u8 , pub operating_mode : u8 , pub secondary_id : u8 , pub protocol_version : u8 , pub homing_offset : i32 , pub moving_threshold : u32 , pub temperature_limit : u8 , pub max_voltage_limit : u16 , pub min_voltage_limit : u16 , pub pwm_limit : u16 , pub current_limit : u16 , pub acceleration_limit : u32 , pub velocity_limit : u32 , pub max_position_limit : u32 , pub min_position_limit : u32 , pub shutdown : u8 , pub torque_enable : u8 , pub led : u8 , pub status_return_level : u8 , pub registered_instruction : u8 , pub hardware_error_status : u8 , pub velocity_i_gain : u16 , pub velocity_p_gain : u16 , pub position_d_gain : u16 , pub position_i_gain : u16 , pub position_p_gain : u16 , pub feedforward_2nd_gain : u16 , pub feedforward_1st_gain : u16 , pub bus_watchdog : u8 , pub goal_pwm : i16 , pub goal_current : i16 , pub goal_velocity : i32 , pub profile_acceleration : u32 , pub profile_velocity : u32 , pub goal_position : u32 , pub realtime_tick : u16 , pub moving : u8 , pub moving_status : u8 , pub present_pwm : i16 , pub present_current : i16 , pub present_velocity : i32 , pub present_position : i32 , pub velocity_trajectory : u32 , pub position_trajectory : u32 , pub present_input_voltage : u16 , pub present_temperature : u8 } impl WrappedTypesupport for XH { type CStruct = dynamixel_workbench_msgs__msg__XH ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__dynamixel_workbench_msgs__msg__XH () } } fn create_msg () -> * mut dynamixel_workbench_msgs__msg__XH { unsafe { dynamixel_workbench_msgs__msg__XH__create () } } fn destroy_msg (msg : * mut dynamixel_workbench_msgs__msg__XH) -> () { unsafe { dynamixel_workbench_msgs__msg__XH__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> XH { XH { model_number : msg . model_number , firmware_version : msg . firmware_version , model_id : msg . model_id , baud_rate : msg . baud_rate , return_delay_time : msg . return_delay_time , drive_mode : msg . drive_mode , operating_mode : msg . operating_mode , secondary_id : msg . secondary_id , protocol_version : msg . protocol_version , homing_offset : msg . homing_offset , moving_threshold : msg . moving_threshold , temperature_limit : msg . temperature_limit , max_voltage_limit : msg . max_voltage_limit , min_voltage_limit : msg . min_voltage_limit , pwm_limit : msg . pwm_limit , current_limit : msg . current_limit , acceleration_limit : msg . acceleration_limit , velocity_limit : msg . velocity_limit , max_position_limit : msg . max_position_limit , min_position_limit : msg . min_position_limit , shutdown : msg . shutdown , torque_enable : msg . torque_enable , led : msg . led , status_return_level : msg . status_return_level , registered_instruction : msg . registered_instruction , hardware_error_status : msg . hardware_error_status , velocity_i_gain : msg . velocity_i_gain , velocity_p_gain : msg . velocity_p_gain , position_d_gain : msg . position_d_gain , position_i_gain : msg . position_i_gain , position_p_gain : msg . position_p_gain , feedforward_2nd_gain : msg . feedforward_2nd_gain , feedforward_1st_gain : msg . feedforward_1st_gain , bus_watchdog : msg . bus_watchdog , goal_pwm : msg . goal_pwm , goal_current : msg . goal_current , goal_velocity : msg . goal_velocity , profile_acceleration : msg . profile_acceleration , profile_velocity : msg . profile_velocity , goal_position : msg . goal_position , realtime_tick : msg . realtime_tick , moving : msg . moving , moving_status : msg . moving_status , present_pwm : msg . present_pwm , present_current : msg . present_current , present_velocity : msg . present_velocity , present_position : msg . present_position , velocity_trajectory : msg . velocity_trajectory , position_trajectory : msg . position_trajectory , present_input_voltage : msg . present_input_voltage , present_temperature : msg . present_temperature , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . model_number = self . model_number ; msg . firmware_version = self . firmware_version ; msg . model_id = self . model_id ; msg . baud_rate = self . baud_rate ; msg . return_delay_time = self . return_delay_time ; msg . drive_mode = self . drive_mode ; msg . operating_mode = self . operating_mode ; msg . secondary_id = self . secondary_id ; msg . protocol_version = self . protocol_version ; msg . homing_offset = self . homing_offset ; msg . moving_threshold = self . moving_threshold ; msg . temperature_limit = self . temperature_limit ; msg . max_voltage_limit = self . max_voltage_limit ; msg . min_voltage_limit = self . min_voltage_limit ; msg . pwm_limit = self . pwm_limit ; msg . current_limit = self . current_limit ; msg . acceleration_limit = self . acceleration_limit ; msg . velocity_limit = self . velocity_limit ; msg . max_position_limit = self . max_position_limit ; msg . min_position_limit = self . min_position_limit ; msg . shutdown = self . shutdown ; msg . torque_enable = self . torque_enable ; msg . led = self . led ; msg . status_return_level = self . status_return_level ; msg . registered_instruction = self . registered_instruction ; msg . hardware_error_status = self . hardware_error_status ; msg . velocity_i_gain = self . velocity_i_gain ; msg . velocity_p_gain = self . velocity_p_gain ; msg . position_d_gain = self . position_d_gain ; msg . position_i_gain = self . position_i_gain ; msg . position_p_gain = self . position_p_gain ; msg . feedforward_2nd_gain = self . feedforward_2nd_gain ; msg . feedforward_1st_gain = self . feedforward_1st_gain ; msg . bus_watchdog = self . bus_watchdog ; msg . goal_pwm = self . goal_pwm ; msg . goal_current = self . goal_current ; msg . goal_velocity = self . goal_velocity ; msg . profile_acceleration = self . profile_acceleration ; msg . profile_velocity = self . profile_velocity ; msg . goal_position = self . goal_position ; msg . realtime_tick = self . realtime_tick ; msg . moving = self . moving ; msg . moving_status = self . moving_status ; msg . present_pwm = self . present_pwm ; msg . present_current = self . present_current ; msg . present_velocity = self . present_velocity ; msg . present_position = self . present_position ; msg . velocity_trajectory = self . velocity_trajectory ; msg . position_trajectory = self . position_trajectory ; msg . present_input_voltage = self . present_input_voltage ; msg . present_temperature = self . present_temperature ; } } impl Default for XH { fn default () -> Self { let msg_native = WrappedNativeMsg :: < XH > :: new () ; XH :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct XL { pub model_number : u16 , pub firmware_version : u8 , pub model_id : u8 , pub baud_rate : u8 , pub return_delay_time : u8 , pub drive_mode : u8 , pub operating_mode : u8 , pub secondary_id : u8 , pub protocol_version : u8 , pub homing_offset : i32 , pub moving_threshold : u32 , pub temperature_limit : u8 , pub max_voltage_limit : u16 , pub min_voltage_limit : u16 , pub pwm_limit : u16 , pub acceleration_limit : u32 , pub velocity_limit : u32 , pub max_position_limit : u32 , pub min_position_limit : u32 , pub shutdown : u8 , pub torque_enable : u8 , pub led : u8 , pub status_return_level : u8 , pub registered_instruction : u8 , pub hardware_error_status : u8 , pub velocity_i_gain : u16 , pub velocity_p_gain : u16 , pub position_d_gain : u16 , pub position_i_gain : u16 , pub position_p_gain : u16 , pub feedforward_2nd_gain : u16 , pub feedforward_1st_gain : u16 , pub bus_watchdog : u8 , pub goal_pwm : i16 , pub goal_velocity : i32 , pub profile_acceleration : u32 , pub profile_velocity : u32 , pub goal_position : u32 , pub realtime_tick : u16 , pub moving : u8 , pub moving_status : u8 , pub present_pwm : i16 , pub present_load : i16 , pub present_velocity : i32 , pub present_position : i32 , pub velocity_trajectory : u32 , pub position_trajectory : u32 , pub present_input_voltage : u16 , pub present_temperature : u8 } impl WrappedTypesupport for XL { type CStruct = dynamixel_workbench_msgs__msg__XL ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__dynamixel_workbench_msgs__msg__XL () } } fn create_msg () -> * mut dynamixel_workbench_msgs__msg__XL { unsafe { dynamixel_workbench_msgs__msg__XL__create () } } fn destroy_msg (msg : * mut dynamixel_workbench_msgs__msg__XL) -> () { unsafe { dynamixel_workbench_msgs__msg__XL__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> XL { XL { model_number : msg . model_number , firmware_version : msg . firmware_version , model_id : msg . model_id , baud_rate : msg . baud_rate , return_delay_time : msg . return_delay_time , drive_mode : msg . drive_mode , operating_mode : msg . operating_mode , secondary_id : msg . secondary_id , protocol_version : msg . protocol_version , homing_offset : msg . homing_offset , moving_threshold : msg . moving_threshold , temperature_limit : msg . temperature_limit , max_voltage_limit : msg . max_voltage_limit , min_voltage_limit : msg . min_voltage_limit , pwm_limit : msg . pwm_limit , acceleration_limit : msg . acceleration_limit , velocity_limit : msg . velocity_limit , max_position_limit : msg . max_position_limit , min_position_limit : msg . min_position_limit , shutdown : msg . shutdown , torque_enable : msg . torque_enable , led : msg . led , status_return_level : msg . status_return_level , registered_instruction : msg . registered_instruction , hardware_error_status : msg . hardware_error_status , velocity_i_gain : msg . velocity_i_gain , velocity_p_gain : msg . velocity_p_gain , position_d_gain : msg . position_d_gain , position_i_gain : msg . position_i_gain , position_p_gain : msg . position_p_gain , feedforward_2nd_gain : msg . feedforward_2nd_gain , feedforward_1st_gain : msg . feedforward_1st_gain , bus_watchdog : msg . bus_watchdog , goal_pwm : msg . goal_pwm , goal_velocity : msg . goal_velocity , profile_acceleration : msg . profile_acceleration , profile_velocity : msg . profile_velocity , goal_position : msg . goal_position , realtime_tick : msg . realtime_tick , moving : msg . moving , moving_status : msg . moving_status , present_pwm : msg . present_pwm , present_load : msg . present_load , present_velocity : msg . present_velocity , present_position : msg . present_position , velocity_trajectory : msg . velocity_trajectory , position_trajectory : msg . position_trajectory , present_input_voltage : msg . present_input_voltage , present_temperature : msg . present_temperature , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . model_number = self . model_number ; msg . firmware_version = self . firmware_version ; msg . model_id = self . model_id ; msg . baud_rate = self . baud_rate ; msg . return_delay_time = self . return_delay_time ; msg . drive_mode = self . drive_mode ; msg . operating_mode = self . operating_mode ; msg . secondary_id = self . secondary_id ; msg . protocol_version = self . protocol_version ; msg . homing_offset = self . homing_offset ; msg . moving_threshold = self . moving_threshold ; msg . temperature_limit = self . temperature_limit ; msg . max_voltage_limit = self . max_voltage_limit ; msg . min_voltage_limit = self . min_voltage_limit ; msg . pwm_limit = self . pwm_limit ; msg . acceleration_limit = self . acceleration_limit ; msg . velocity_limit = self . velocity_limit ; msg . max_position_limit = self . max_position_limit ; msg . min_position_limit = self . min_position_limit ; msg . shutdown = self . shutdown ; msg . torque_enable = self . torque_enable ; msg . led = self . led ; msg . status_return_level = self . status_return_level ; msg . registered_instruction = self . registered_instruction ; msg . hardware_error_status = self . hardware_error_status ; msg . velocity_i_gain = self . velocity_i_gain ; msg . velocity_p_gain = self . velocity_p_gain ; msg . position_d_gain = self . position_d_gain ; msg . position_i_gain = self . position_i_gain ; msg . position_p_gain = self . position_p_gain ; msg . feedforward_2nd_gain = self . feedforward_2nd_gain ; msg . feedforward_1st_gain = self . feedforward_1st_gain ; msg . bus_watchdog = self . bus_watchdog ; msg . goal_pwm = self . goal_pwm ; msg . goal_velocity = self . goal_velocity ; msg . profile_acceleration = self . profile_acceleration ; msg . profile_velocity = self . profile_velocity ; msg . goal_position = self . goal_position ; msg . realtime_tick = self . realtime_tick ; msg . moving = self . moving ; msg . moving_status = self . moving_status ; msg . present_pwm = self . present_pwm ; msg . present_load = self . present_load ; msg . present_velocity = self . present_velocity ; msg . present_position = self . present_position ; msg . velocity_trajectory = self . velocity_trajectory ; msg . position_trajectory = self . position_trajectory ; msg . present_input_voltage = self . present_input_voltage ; msg . present_temperature = self . present_temperature ; } } impl Default for XL { fn default () -> Self { let msg_native = WrappedNativeMsg :: < XL > :: new () ; XL :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct XL320 { pub model_number : u16 , pub firmware_version : u8 , pub model_id : u8 , pub baud_rate : u8 , pub return_delay_time : u8 , pub cw_angle_limit : u16 , pub ccw_angle_limit : u16 , pub control_mode : u8 , pub temperature_limit : u8 , pub min_voltage_limit : u8 , pub max_voltage_limit : u8 , pub max_torque : u16 , pub status_return_level : u8 , pub shutdown : u8 , pub torque_enable : u8 , pub led : u8 , pub d_gain : u8 , pub i_gain : u8 , pub p_gain : u8 , pub goal_position : u16 , pub moving_speed : u16 , pub torque_limit : u16 , pub present_position : u16 , pub present_speed : u16 , pub present_load : u16 , pub present_voltage : u8 , pub present_temperature : u8 , pub registered : u8 , pub moving : u8 , pub hardware_error_status : u8 , pub punch : u16 } impl WrappedTypesupport for XL320 { type CStruct = dynamixel_workbench_msgs__msg__XL320 ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__dynamixel_workbench_msgs__msg__XL320 () } } fn create_msg () -> * mut dynamixel_workbench_msgs__msg__XL320 { unsafe { dynamixel_workbench_msgs__msg__XL320__create () } } fn destroy_msg (msg : * mut dynamixel_workbench_msgs__msg__XL320) -> () { unsafe { dynamixel_workbench_msgs__msg__XL320__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> XL320 { XL320 { model_number : msg . model_number , firmware_version : msg . firmware_version , model_id : msg . model_id , baud_rate : msg . baud_rate , return_delay_time : msg . return_delay_time , cw_angle_limit : msg . cw_angle_limit , ccw_angle_limit : msg . ccw_angle_limit , control_mode : msg . control_mode , temperature_limit : msg . temperature_limit , min_voltage_limit : msg . min_voltage_limit , max_voltage_limit : msg . max_voltage_limit , max_torque : msg . max_torque , status_return_level : msg . status_return_level , shutdown : msg . shutdown , torque_enable : msg . torque_enable , led : msg . led , d_gain : msg . d_gain , i_gain : msg . i_gain , p_gain : msg . p_gain , goal_position : msg . goal_position , moving_speed : msg . moving_speed , torque_limit : msg . torque_limit , present_position : msg . present_position , present_speed : msg . present_speed , present_load : msg . present_load , present_voltage : msg . present_voltage , present_temperature : msg . present_temperature , registered : msg . registered , moving : msg . moving , hardware_error_status : msg . hardware_error_status , punch : msg . punch , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . model_number = self . model_number ; msg . firmware_version = self . firmware_version ; msg . model_id = self . model_id ; msg . baud_rate = self . baud_rate ; msg . return_delay_time = self . return_delay_time ; msg . cw_angle_limit = self . cw_angle_limit ; msg . ccw_angle_limit = self . ccw_angle_limit ; msg . control_mode = self . control_mode ; msg . temperature_limit = self . temperature_limit ; msg . min_voltage_limit = self . min_voltage_limit ; msg . max_voltage_limit = self . max_voltage_limit ; msg . max_torque = self . max_torque ; msg . status_return_level = self . status_return_level ; msg . shutdown = self . shutdown ; msg . torque_enable = self . torque_enable ; msg . led = self . led ; msg . d_gain = self . d_gain ; msg . i_gain = self . i_gain ; msg . p_gain = self . p_gain ; msg . goal_position = self . goal_position ; msg . moving_speed = self . moving_speed ; msg . torque_limit = self . torque_limit ; msg . present_position = self . present_position ; msg . present_speed = self . present_speed ; msg . present_load = self . present_load ; msg . present_voltage = self . present_voltage ; msg . present_temperature = self . present_temperature ; msg . registered = self . registered ; msg . moving = self . moving ; msg . hardware_error_status = self . hardware_error_status ; msg . punch = self . punch ; } } impl Default for XL320 { fn default () -> Self { let msg_native = WrappedNativeMsg :: < XL320 > :: new () ; XL320 :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct XM { pub model_number : u16 , pub firmware_version : u8 , pub model_id : u8 , pub baud_rate : u8 , pub return_delay_time : u8 , pub drive_mode : u8 , pub operating_mode : u8 , pub secondary_id : u8 , pub protocol_version : u8 , pub homing_offset : i32 , pub moving_threshold : u32 , pub temperature_limit : u8 , pub max_voltage_limit : u16 , pub min_voltage_limit : u16 , pub pwm_limit : u16 , pub current_limit : u16 , pub acceleration_limit : u32 , pub velocity_limit : u32 , pub max_position_limit : u32 , pub min_position_limit : u32 , pub shutdown : u8 , pub torque_enable : u8 , pub led : u8 , pub status_return_level : u8 , pub registered_instruction : u8 , pub hardware_error_status : u8 , pub velocity_i_gain : u16 , pub velocity_p_gain : u16 , pub position_d_gain : u16 , pub position_i_gain : u16 , pub position_p_gain : u16 , pub feedforward_2nd_gain : u16 , pub feedforward_1st_gain : u16 , pub bus_watchdog : u8 , pub goal_pwm : i16 , pub goal_current : i16 , pub goal_velocity : i32 , pub profile_acceleration : u32 , pub profile_velocity : u32 , pub goal_position : u32 , pub realtime_tick : u16 , pub moving : u8 , pub moving_status : u8 , pub present_pwm : i16 , pub present_load : i16 , pub present_current : i16 , pub present_velocity : i32 , pub present_position : i32 , pub velocity_trajectory : u32 , pub position_trajectory : u32 , pub present_input_voltage : u16 , pub present_temperature : u8 } impl WrappedTypesupport for XM { type CStruct = dynamixel_workbench_msgs__msg__XM ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__dynamixel_workbench_msgs__msg__XM () } } fn create_msg () -> * mut dynamixel_workbench_msgs__msg__XM { unsafe { dynamixel_workbench_msgs__msg__XM__create () } } fn destroy_msg (msg : * mut dynamixel_workbench_msgs__msg__XM) -> () { unsafe { dynamixel_workbench_msgs__msg__XM__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> XM { XM { model_number : msg . model_number , firmware_version : msg . firmware_version , model_id : msg . model_id , baud_rate : msg . baud_rate , return_delay_time : msg . return_delay_time , drive_mode : msg . drive_mode , operating_mode : msg . operating_mode , secondary_id : msg . secondary_id , protocol_version : msg . protocol_version , homing_offset : msg . homing_offset , moving_threshold : msg . moving_threshold , temperature_limit : msg . temperature_limit , max_voltage_limit : msg . max_voltage_limit , min_voltage_limit : msg . min_voltage_limit , pwm_limit : msg . pwm_limit , current_limit : msg . current_limit , acceleration_limit : msg . acceleration_limit , velocity_limit : msg . velocity_limit , max_position_limit : msg . max_position_limit , min_position_limit : msg . min_position_limit , shutdown : msg . shutdown , torque_enable : msg . torque_enable , led : msg . led , status_return_level : msg . status_return_level , registered_instruction : msg . registered_instruction , hardware_error_status : msg . hardware_error_status , velocity_i_gain : msg . velocity_i_gain , velocity_p_gain : msg . velocity_p_gain , position_d_gain : msg . position_d_gain , position_i_gain : msg . position_i_gain , position_p_gain : msg . position_p_gain , feedforward_2nd_gain : msg . feedforward_2nd_gain , feedforward_1st_gain : msg . feedforward_1st_gain , bus_watchdog : msg . bus_watchdog , goal_pwm : msg . goal_pwm , goal_current : msg . goal_current , goal_velocity : msg . goal_velocity , profile_acceleration : msg . profile_acceleration , profile_velocity : msg . profile_velocity , goal_position : msg . goal_position , realtime_tick : msg . realtime_tick , moving : msg . moving , moving_status : msg . moving_status , present_pwm : msg . present_pwm , present_load : msg . present_load , present_current : msg . present_current , present_velocity : msg . present_velocity , present_position : msg . present_position , velocity_trajectory : msg . velocity_trajectory , position_trajectory : msg . position_trajectory , present_input_voltage : msg . present_input_voltage , present_temperature : msg . present_temperature , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . model_number = self . model_number ; msg . firmware_version = self . firmware_version ; msg . model_id = self . model_id ; msg . baud_rate = self . baud_rate ; msg . return_delay_time = self . return_delay_time ; msg . drive_mode = self . drive_mode ; msg . operating_mode = self . operating_mode ; msg . secondary_id = self . secondary_id ; msg . protocol_version = self . protocol_version ; msg . homing_offset = self . homing_offset ; msg . moving_threshold = self . moving_threshold ; msg . temperature_limit = self . temperature_limit ; msg . max_voltage_limit = self . max_voltage_limit ; msg . min_voltage_limit = self . min_voltage_limit ; msg . pwm_limit = self . pwm_limit ; msg . current_limit = self . current_limit ; msg . acceleration_limit = self . acceleration_limit ; msg . velocity_limit = self . velocity_limit ; msg . max_position_limit = self . max_position_limit ; msg . min_position_limit = self . min_position_limit ; msg . shutdown = self . shutdown ; msg . torque_enable = self . torque_enable ; msg . led = self . led ; msg . status_return_level = self . status_return_level ; msg . registered_instruction = self . registered_instruction ; msg . hardware_error_status = self . hardware_error_status ; msg . velocity_i_gain = self . velocity_i_gain ; msg . velocity_p_gain = self . velocity_p_gain ; msg . position_d_gain = self . position_d_gain ; msg . position_i_gain = self . position_i_gain ; msg . position_p_gain = self . position_p_gain ; msg . feedforward_2nd_gain = self . feedforward_2nd_gain ; msg . feedforward_1st_gain = self . feedforward_1st_gain ; msg . bus_watchdog = self . bus_watchdog ; msg . goal_pwm = self . goal_pwm ; msg . goal_current = self . goal_current ; msg . goal_velocity = self . goal_velocity ; msg . profile_acceleration = self . profile_acceleration ; msg . profile_velocity = self . profile_velocity ; msg . goal_position = self . goal_position ; msg . realtime_tick = self . realtime_tick ; msg . moving = self . moving ; msg . moving_status = self . moving_status ; msg . present_pwm = self . present_pwm ; msg . present_load = self . present_load ; msg . present_current = self . present_current ; msg . present_velocity = self . present_velocity ; msg . present_position = self . present_position ; msg . velocity_trajectory = self . velocity_trajectory ; msg . position_trajectory = self . position_trajectory ; msg . present_input_voltage = self . present_input_voltage ; msg . present_temperature = self . present_temperature ; } } impl Default for XM { fn default () -> Self { let msg_native = WrappedNativeMsg :: < XM > :: new () ; XM :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct XMExt { pub model_number : u16 , pub firmware_version : u8 , pub model_id : u8 , pub baud_rate : u8 , pub return_delay_time : u8 , pub drive_mode : u8 , pub operating_mode : u8 , pub secondary_id : u8 , pub protocol_version : u8 , pub homing_offset : i32 , pub moving_threshold : u32 , pub temperature_limit : u8 , pub max_voltage_limit : u16 , pub min_voltage_limit : u16 , pub pwm_limit : u16 , pub current_limit : u16 , pub acceleration_limit : u32 , pub velocity_limit : u32 , pub max_position_limit : u32 , pub min_position_limit : u32 , pub external_port_mode_1 : u8 , pub external_port_mode_2 : u8 , pub external_port_mode_3 : u8 , pub shutdown : u8 , pub torque_enable : u8 , pub led : u8 , pub status_return_level : u8 , pub registered_instruction : u8 , pub hardware_error_status : u8 , pub velocity_i_gain : u16 , pub velocity_p_gain : u16 , pub position_d_gain : u16 , pub position_i_gain : u16 , pub position_p_gain : u16 , pub feedforward_2nd_gain : u16 , pub feedforward_1st_gain : u16 , pub bus_watchdog : u8 , pub goal_pwm : i16 , pub goal_current : i16 , pub goal_velocity : i32 , pub profile_acceleration : u32 , pub profile_velocity : u32 , pub goal_position : u32 , pub realtime_tick : u16 , pub moving : u8 , pub moving_status : u8 , pub present_pwm : i16 , pub present_current : i16 , pub present_velocity : i32 , pub present_position : i32 , pub velocity_trajectory : u32 , pub position_trajectory : u32 , pub present_input_voltage : u16 , pub present_temperature : u8 } impl WrappedTypesupport for XMExt { type CStruct = dynamixel_workbench_msgs__msg__XMExt ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__dynamixel_workbench_msgs__msg__XMExt () } } fn create_msg () -> * mut dynamixel_workbench_msgs__msg__XMExt { unsafe { dynamixel_workbench_msgs__msg__XMExt__create () } } fn destroy_msg (msg : * mut dynamixel_workbench_msgs__msg__XMExt) -> () { unsafe { dynamixel_workbench_msgs__msg__XMExt__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> XMExt { XMExt { model_number : msg . model_number , firmware_version : msg . firmware_version , model_id : msg . model_id , baud_rate : msg . baud_rate , return_delay_time : msg . return_delay_time , drive_mode : msg . drive_mode , operating_mode : msg . operating_mode , secondary_id : msg . secondary_id , protocol_version : msg . protocol_version , homing_offset : msg . homing_offset , moving_threshold : msg . moving_threshold , temperature_limit : msg . temperature_limit , max_voltage_limit : msg . max_voltage_limit , min_voltage_limit : msg . min_voltage_limit , pwm_limit : msg . pwm_limit , current_limit : msg . current_limit , acceleration_limit : msg . acceleration_limit , velocity_limit : msg . velocity_limit , max_position_limit : msg . max_position_limit , min_position_limit : msg . min_position_limit , external_port_mode_1 : msg . external_port_mode_1 , external_port_mode_2 : msg . external_port_mode_2 , external_port_mode_3 : msg . external_port_mode_3 , shutdown : msg . shutdown , torque_enable : msg . torque_enable , led : msg . led , status_return_level : msg . status_return_level , registered_instruction : msg . registered_instruction , hardware_error_status : msg . hardware_error_status , velocity_i_gain : msg . velocity_i_gain , velocity_p_gain : msg . velocity_p_gain , position_d_gain : msg . position_d_gain , position_i_gain : msg . position_i_gain , position_p_gain : msg . position_p_gain , feedforward_2nd_gain : msg . feedforward_2nd_gain , feedforward_1st_gain : msg . feedforward_1st_gain , bus_watchdog : msg . bus_watchdog , goal_pwm : msg . goal_pwm , goal_current : msg . goal_current , goal_velocity : msg . goal_velocity , profile_acceleration : msg . profile_acceleration , profile_velocity : msg . profile_velocity , goal_position : msg . goal_position , realtime_tick : msg . realtime_tick , moving : msg . moving , moving_status : msg . moving_status , present_pwm : msg . present_pwm , present_current : msg . present_current , present_velocity : msg . present_velocity , present_position : msg . present_position , velocity_trajectory : msg . velocity_trajectory , position_trajectory : msg . position_trajectory , present_input_voltage : msg . present_input_voltage , present_temperature : msg . present_temperature , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . model_number = self . model_number ; msg . firmware_version = self . firmware_version ; msg . model_id = self . model_id ; msg . baud_rate = self . baud_rate ; msg . return_delay_time = self . return_delay_time ; msg . drive_mode = self . drive_mode ; msg . operating_mode = self . operating_mode ; msg . secondary_id = self . secondary_id ; msg . protocol_version = self . protocol_version ; msg . homing_offset = self . homing_offset ; msg . moving_threshold = self . moving_threshold ; msg . temperature_limit = self . temperature_limit ; msg . max_voltage_limit = self . max_voltage_limit ; msg . min_voltage_limit = self . min_voltage_limit ; msg . pwm_limit = self . pwm_limit ; msg . current_limit = self . current_limit ; msg . acceleration_limit = self . acceleration_limit ; msg . velocity_limit = self . velocity_limit ; msg . max_position_limit = self . max_position_limit ; msg . min_position_limit = self . min_position_limit ; msg . external_port_mode_1 = self . external_port_mode_1 ; msg . external_port_mode_2 = self . external_port_mode_2 ; msg . external_port_mode_3 = self . external_port_mode_3 ; msg . shutdown = self . shutdown ; msg . torque_enable = self . torque_enable ; msg . led = self . led ; msg . status_return_level = self . status_return_level ; msg . registered_instruction = self . registered_instruction ; msg . hardware_error_status = self . hardware_error_status ; msg . velocity_i_gain = self . velocity_i_gain ; msg . velocity_p_gain = self . velocity_p_gain ; msg . position_d_gain = self . position_d_gain ; msg . position_i_gain = self . position_i_gain ; msg . position_p_gain = self . position_p_gain ; msg . feedforward_2nd_gain = self . feedforward_2nd_gain ; msg . feedforward_1st_gain = self . feedforward_1st_gain ; msg . bus_watchdog = self . bus_watchdog ; msg . goal_pwm = self . goal_pwm ; msg . goal_current = self . goal_current ; msg . goal_velocity = self . goal_velocity ; msg . profile_acceleration = self . profile_acceleration ; msg . profile_velocity = self . profile_velocity ; msg . goal_position = self . goal_position ; msg . realtime_tick = self . realtime_tick ; msg . moving = self . moving ; msg . moving_status = self . moving_status ; msg . present_pwm = self . present_pwm ; msg . present_current = self . present_current ; msg . present_velocity = self . present_velocity ; msg . present_position = self . present_position ; msg . velocity_trajectory = self . velocity_trajectory ; msg . position_trajectory = self . position_trajectory ; msg . present_input_voltage = self . present_input_voltage ; msg . present_temperature = self . present_temperature ; } } impl Default for XMExt { fn default () -> Self { let msg_native = WrappedNativeMsg :: < XMExt > :: new () ; XMExt :: from_native (& msg_native) } } } pub mod srv { # [allow (non_snake_case)] pub mod DynamixelCommand { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__dynamixel_workbench_msgs__srv__DynamixelCommand () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub command : std :: string :: String , pub id : u8 , pub addr_name : std :: string :: String , pub value : i32 } impl WrappedTypesupport for Request { type CStruct = dynamixel_workbench_msgs__srv__DynamixelCommand_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__dynamixel_workbench_msgs__srv__DynamixelCommand_Request () } } fn create_msg () -> * mut dynamixel_workbench_msgs__srv__DynamixelCommand_Request { unsafe { dynamixel_workbench_msgs__srv__DynamixelCommand_Request__create () } } fn destroy_msg (msg : * mut dynamixel_workbench_msgs__srv__DynamixelCommand_Request) -> () { unsafe { dynamixel_workbench_msgs__srv__DynamixelCommand_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { command : msg . command . to_str () . to_owned () , id : msg . id , addr_name : msg . addr_name . to_str () . to_owned () , value : msg . value , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . command . assign (& self . command) ; msg . id = self . id ; msg . addr_name . assign (& self . addr_name) ; msg . value = self . value ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub comm_result : bool } impl WrappedTypesupport for Response { type CStruct = dynamixel_workbench_msgs__srv__DynamixelCommand_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__dynamixel_workbench_msgs__srv__DynamixelCommand_Response () } } fn create_msg () -> * mut dynamixel_workbench_msgs__srv__DynamixelCommand_Response { unsafe { dynamixel_workbench_msgs__srv__DynamixelCommand_Response__create () } } fn destroy_msg (msg : * mut dynamixel_workbench_msgs__srv__DynamixelCommand_Response) -> () { unsafe { dynamixel_workbench_msgs__srv__DynamixelCommand_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { comm_result : msg . comm_result , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . comm_result = self . comm_result ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetDynamixelInfo { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__dynamixel_workbench_msgs__srv__GetDynamixelInfo () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { } impl WrappedTypesupport for Request { type CStruct = dynamixel_workbench_msgs__srv__GetDynamixelInfo_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__dynamixel_workbench_msgs__srv__GetDynamixelInfo_Request () } } fn create_msg () -> * mut dynamixel_workbench_msgs__srv__GetDynamixelInfo_Request { unsafe { dynamixel_workbench_msgs__srv__GetDynamixelInfo_Request__create () } } fn destroy_msg (msg : * mut dynamixel_workbench_msgs__srv__GetDynamixelInfo_Request) -> () { unsafe { dynamixel_workbench_msgs__srv__GetDynamixelInfo_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub dynamixel_info : dynamixel_workbench_msgs :: msg :: DynamixelInfo } impl WrappedTypesupport for Response { type CStruct = dynamixel_workbench_msgs__srv__GetDynamixelInfo_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__dynamixel_workbench_msgs__srv__GetDynamixelInfo_Response () } } fn create_msg () -> * mut dynamixel_workbench_msgs__srv__GetDynamixelInfo_Response { unsafe { dynamixel_workbench_msgs__srv__GetDynamixelInfo_Response__create () } } fn destroy_msg (msg : * mut dynamixel_workbench_msgs__srv__GetDynamixelInfo_Response) -> () { unsafe { dynamixel_workbench_msgs__srv__GetDynamixelInfo_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { dynamixel_info : dynamixel_workbench_msgs :: msg :: DynamixelInfo :: from_native (& msg . dynamixel_info) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . dynamixel_info . copy_to_native (& mut msg . dynamixel_info) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } }