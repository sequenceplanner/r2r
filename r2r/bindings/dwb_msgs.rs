pub mod msg { use super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct CriticScore { pub name : std :: string :: String , pub raw_score : f32 , pub scale : f32 } impl WrappedTypesupport for CriticScore { type CStruct = dwb_msgs__msg__CriticScore ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__dwb_msgs__msg__CriticScore () } } fn create_msg () -> * mut dwb_msgs__msg__CriticScore { unsafe { dwb_msgs__msg__CriticScore__create () } } fn destroy_msg (msg : * mut dwb_msgs__msg__CriticScore) -> () { unsafe { dwb_msgs__msg__CriticScore__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> CriticScore { CriticScore { name : msg . name . to_str () . to_owned () , raw_score : msg . raw_score , scale : msg . scale , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . name . assign (& self . name) ; msg . raw_score = self . raw_score ; msg . scale = self . scale ; } } impl Default for CriticScore { fn default () -> Self { let msg_native = WrappedNativeMsg :: < CriticScore > :: new () ; CriticScore :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct LocalPlanEvaluation { pub header : std_msgs :: msg :: Header , pub twists : Vec < dwb_msgs :: msg :: TrajectoryScore > , pub best_index : u16 , pub worst_index : u16 } impl WrappedTypesupport for LocalPlanEvaluation { type CStruct = dwb_msgs__msg__LocalPlanEvaluation ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__dwb_msgs__msg__LocalPlanEvaluation () } } fn create_msg () -> * mut dwb_msgs__msg__LocalPlanEvaluation { unsafe { dwb_msgs__msg__LocalPlanEvaluation__create () } } fn destroy_msg (msg : * mut dwb_msgs__msg__LocalPlanEvaluation) -> () { unsafe { dwb_msgs__msg__LocalPlanEvaluation__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> LocalPlanEvaluation { LocalPlanEvaluation { header : std_msgs :: msg :: Header :: from_native (& msg . header) , twists : { let mut temp = Vec :: with_capacity (msg . twists . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . twists . data , msg . twists . size) } ; for s in slice { temp . push (dwb_msgs :: msg :: TrajectoryScore :: from_native (s)) ; } temp } , best_index : msg . best_index , worst_index : msg . worst_index , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; unsafe { dwb_msgs__msg__TrajectoryScore__Sequence__fini (& mut msg . twists) ; dwb_msgs__msg__TrajectoryScore__Sequence__init (& mut msg . twists , self . twists . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . twists . data , msg . twists . size) ; for (t , s) in slice . iter_mut () . zip (& self . twists) { s . copy_to_native (t) ; } } msg . best_index = self . best_index ; msg . worst_index = self . worst_index ; } } impl Default for LocalPlanEvaluation { fn default () -> Self { let msg_native = WrappedNativeMsg :: < LocalPlanEvaluation > :: new () ; LocalPlanEvaluation :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Trajectory2D { pub velocity : nav_2d_msgs :: msg :: Twist2D , pub time_offsets : Vec < builtin_interfaces :: msg :: Duration > , pub poses : Vec < geometry_msgs :: msg :: Pose2D > } impl WrappedTypesupport for Trajectory2D { type CStruct = dwb_msgs__msg__Trajectory2D ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__dwb_msgs__msg__Trajectory2D () } } fn create_msg () -> * mut dwb_msgs__msg__Trajectory2D { unsafe { dwb_msgs__msg__Trajectory2D__create () } } fn destroy_msg (msg : * mut dwb_msgs__msg__Trajectory2D) -> () { unsafe { dwb_msgs__msg__Trajectory2D__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Trajectory2D { Trajectory2D { velocity : nav_2d_msgs :: msg :: Twist2D :: from_native (& msg . velocity) , time_offsets : { let mut temp = Vec :: with_capacity (msg . time_offsets . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . time_offsets . data , msg . time_offsets . size) } ; for s in slice { temp . push (builtin_interfaces :: msg :: Duration :: from_native (s)) ; } temp } , poses : { let mut temp = Vec :: with_capacity (msg . poses . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . poses . data , msg . poses . size) } ; for s in slice { temp . push (geometry_msgs :: msg :: Pose2D :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . velocity . copy_to_native (& mut msg . velocity) ; unsafe { builtin_interfaces__msg__Duration__Sequence__fini (& mut msg . time_offsets) ; builtin_interfaces__msg__Duration__Sequence__init (& mut msg . time_offsets , self . time_offsets . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . time_offsets . data , msg . time_offsets . size) ; for (t , s) in slice . iter_mut () . zip (& self . time_offsets) { s . copy_to_native (t) ; } } unsafe { geometry_msgs__msg__Pose2D__Sequence__fini (& mut msg . poses) ; geometry_msgs__msg__Pose2D__Sequence__init (& mut msg . poses , self . poses . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . poses . data , msg . poses . size) ; for (t , s) in slice . iter_mut () . zip (& self . poses) { s . copy_to_native (t) ; } } } } impl Default for Trajectory2D { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Trajectory2D > :: new () ; Trajectory2D :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct TrajectoryScore { pub traj : dwb_msgs :: msg :: Trajectory2D , pub scores : Vec < dwb_msgs :: msg :: CriticScore > , pub total : f32 } impl WrappedTypesupport for TrajectoryScore { type CStruct = dwb_msgs__msg__TrajectoryScore ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__dwb_msgs__msg__TrajectoryScore () } } fn create_msg () -> * mut dwb_msgs__msg__TrajectoryScore { unsafe { dwb_msgs__msg__TrajectoryScore__create () } } fn destroy_msg (msg : * mut dwb_msgs__msg__TrajectoryScore) -> () { unsafe { dwb_msgs__msg__TrajectoryScore__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> TrajectoryScore { TrajectoryScore { traj : dwb_msgs :: msg :: Trajectory2D :: from_native (& msg . traj) , scores : { let mut temp = Vec :: with_capacity (msg . scores . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . scores . data , msg . scores . size) } ; for s in slice { temp . push (dwb_msgs :: msg :: CriticScore :: from_native (s)) ; } temp } , total : msg . total , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . traj . copy_to_native (& mut msg . traj) ; unsafe { dwb_msgs__msg__CriticScore__Sequence__fini (& mut msg . scores) ; dwb_msgs__msg__CriticScore__Sequence__init (& mut msg . scores , self . scores . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . scores . data , msg . scores . size) ; for (t , s) in slice . iter_mut () . zip (& self . scores) { s . copy_to_native (t) ; } } msg . total = self . total ; } } impl Default for TrajectoryScore { fn default () -> Self { let msg_native = WrappedNativeMsg :: < TrajectoryScore > :: new () ; TrajectoryScore :: from_native (& msg_native) } } } pub mod srv { # [allow (non_snake_case)] pub mod DebugLocalPlan { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__dwb_msgs__srv__DebugLocalPlan () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub pose : nav_2d_msgs :: msg :: Pose2DStamped , pub velocity : nav_2d_msgs :: msg :: Twist2D , pub global_plan : nav_2d_msgs :: msg :: Path2D } impl WrappedTypesupport for Request { type CStruct = dwb_msgs__srv__DebugLocalPlan_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__dwb_msgs__srv__DebugLocalPlan_Request () } } fn create_msg () -> * mut dwb_msgs__srv__DebugLocalPlan_Request { unsafe { dwb_msgs__srv__DebugLocalPlan_Request__create () } } fn destroy_msg (msg : * mut dwb_msgs__srv__DebugLocalPlan_Request) -> () { unsafe { dwb_msgs__srv__DebugLocalPlan_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { pose : nav_2d_msgs :: msg :: Pose2DStamped :: from_native (& msg . pose) , velocity : nav_2d_msgs :: msg :: Twist2D :: from_native (& msg . velocity) , global_plan : nav_2d_msgs :: msg :: Path2D :: from_native (& msg . global_plan) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . pose . copy_to_native (& mut msg . pose) ; self . velocity . copy_to_native (& mut msg . velocity) ; self . global_plan . copy_to_native (& mut msg . global_plan) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub results : dwb_msgs :: msg :: LocalPlanEvaluation } impl WrappedTypesupport for Response { type CStruct = dwb_msgs__srv__DebugLocalPlan_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__dwb_msgs__srv__DebugLocalPlan_Response () } } fn create_msg () -> * mut dwb_msgs__srv__DebugLocalPlan_Response { unsafe { dwb_msgs__srv__DebugLocalPlan_Response__create () } } fn destroy_msg (msg : * mut dwb_msgs__srv__DebugLocalPlan_Response) -> () { unsafe { dwb_msgs__srv__DebugLocalPlan_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { results : dwb_msgs :: msg :: LocalPlanEvaluation :: from_native (& msg . results) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . results . copy_to_native (& mut msg . results) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GenerateTrajectory { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__dwb_msgs__srv__GenerateTrajectory () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub start_pose : geometry_msgs :: msg :: Pose2D , pub start_vel : nav_2d_msgs :: msg :: Twist2D , pub cmd_vel : nav_2d_msgs :: msg :: Twist2D } impl WrappedTypesupport for Request { type CStruct = dwb_msgs__srv__GenerateTrajectory_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__dwb_msgs__srv__GenerateTrajectory_Request () } } fn create_msg () -> * mut dwb_msgs__srv__GenerateTrajectory_Request { unsafe { dwb_msgs__srv__GenerateTrajectory_Request__create () } } fn destroy_msg (msg : * mut dwb_msgs__srv__GenerateTrajectory_Request) -> () { unsafe { dwb_msgs__srv__GenerateTrajectory_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { start_pose : geometry_msgs :: msg :: Pose2D :: from_native (& msg . start_pose) , start_vel : nav_2d_msgs :: msg :: Twist2D :: from_native (& msg . start_vel) , cmd_vel : nav_2d_msgs :: msg :: Twist2D :: from_native (& msg . cmd_vel) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . start_pose . copy_to_native (& mut msg . start_pose) ; self . start_vel . copy_to_native (& mut msg . start_vel) ; self . cmd_vel . copy_to_native (& mut msg . cmd_vel) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub traj : dwb_msgs :: msg :: Trajectory2D } impl WrappedTypesupport for Response { type CStruct = dwb_msgs__srv__GenerateTrajectory_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__dwb_msgs__srv__GenerateTrajectory_Response () } } fn create_msg () -> * mut dwb_msgs__srv__GenerateTrajectory_Response { unsafe { dwb_msgs__srv__GenerateTrajectory_Response__create () } } fn destroy_msg (msg : * mut dwb_msgs__srv__GenerateTrajectory_Response) -> () { unsafe { dwb_msgs__srv__GenerateTrajectory_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { traj : dwb_msgs :: msg :: Trajectory2D :: from_native (& msg . traj) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . traj . copy_to_native (& mut msg . traj) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GenerateTwists { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__dwb_msgs__srv__GenerateTwists () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub current_vel : nav_2d_msgs :: msg :: Twist2D } impl WrappedTypesupport for Request { type CStruct = dwb_msgs__srv__GenerateTwists_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__dwb_msgs__srv__GenerateTwists_Request () } } fn create_msg () -> * mut dwb_msgs__srv__GenerateTwists_Request { unsafe { dwb_msgs__srv__GenerateTwists_Request__create () } } fn destroy_msg (msg : * mut dwb_msgs__srv__GenerateTwists_Request) -> () { unsafe { dwb_msgs__srv__GenerateTwists_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { current_vel : nav_2d_msgs :: msg :: Twist2D :: from_native (& msg . current_vel) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . current_vel . copy_to_native (& mut msg . current_vel) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub twists : Vec < nav_2d_msgs :: msg :: Twist2D > } impl WrappedTypesupport for Response { type CStruct = dwb_msgs__srv__GenerateTwists_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__dwb_msgs__srv__GenerateTwists_Response () } } fn create_msg () -> * mut dwb_msgs__srv__GenerateTwists_Response { unsafe { dwb_msgs__srv__GenerateTwists_Response__create () } } fn destroy_msg (msg : * mut dwb_msgs__srv__GenerateTwists_Response) -> () { unsafe { dwb_msgs__srv__GenerateTwists_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { twists : { let mut temp = Vec :: with_capacity (msg . twists . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . twists . data , msg . twists . size) } ; for s in slice { temp . push (nav_2d_msgs :: msg :: Twist2D :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { unsafe { nav_2d_msgs__msg__Twist2D__Sequence__fini (& mut msg . twists) ; nav_2d_msgs__msg__Twist2D__Sequence__init (& mut msg . twists , self . twists . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . twists . data , msg . twists . size) ; for (t , s) in slice . iter_mut () . zip (& self . twists) { s . copy_to_native (t) ; } } } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetCriticScore { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__dwb_msgs__srv__GetCriticScore () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub pose : nav_2d_msgs :: msg :: Pose2DStamped , pub velocity : nav_2d_msgs :: msg :: Twist2D , pub global_plan : nav_2d_msgs :: msg :: Path2D , pub traj : dwb_msgs :: msg :: Trajectory2D , pub critic_name : std :: string :: String } impl WrappedTypesupport for Request { type CStruct = dwb_msgs__srv__GetCriticScore_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__dwb_msgs__srv__GetCriticScore_Request () } } fn create_msg () -> * mut dwb_msgs__srv__GetCriticScore_Request { unsafe { dwb_msgs__srv__GetCriticScore_Request__create () } } fn destroy_msg (msg : * mut dwb_msgs__srv__GetCriticScore_Request) -> () { unsafe { dwb_msgs__srv__GetCriticScore_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { pose : nav_2d_msgs :: msg :: Pose2DStamped :: from_native (& msg . pose) , velocity : nav_2d_msgs :: msg :: Twist2D :: from_native (& msg . velocity) , global_plan : nav_2d_msgs :: msg :: Path2D :: from_native (& msg . global_plan) , traj : dwb_msgs :: msg :: Trajectory2D :: from_native (& msg . traj) , critic_name : msg . critic_name . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . pose . copy_to_native (& mut msg . pose) ; self . velocity . copy_to_native (& mut msg . velocity) ; self . global_plan . copy_to_native (& mut msg . global_plan) ; self . traj . copy_to_native (& mut msg . traj) ; msg . critic_name . assign (& self . critic_name) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub score : dwb_msgs :: msg :: CriticScore } impl WrappedTypesupport for Response { type CStruct = dwb_msgs__srv__GetCriticScore_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__dwb_msgs__srv__GetCriticScore_Response () } } fn create_msg () -> * mut dwb_msgs__srv__GetCriticScore_Response { unsafe { dwb_msgs__srv__GetCriticScore_Response__create () } } fn destroy_msg (msg : * mut dwb_msgs__srv__GetCriticScore_Response) -> () { unsafe { dwb_msgs__srv__GetCriticScore_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { score : dwb_msgs :: msg :: CriticScore :: from_native (& msg . score) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . score . copy_to_native (& mut msg . score) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod ScoreTrajectory { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__dwb_msgs__srv__ScoreTrajectory () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub pose : nav_2d_msgs :: msg :: Pose2DStamped , pub velocity : nav_2d_msgs :: msg :: Twist2D , pub global_plan : nav_2d_msgs :: msg :: Path2D , pub traj : dwb_msgs :: msg :: Trajectory2D } impl WrappedTypesupport for Request { type CStruct = dwb_msgs__srv__ScoreTrajectory_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__dwb_msgs__srv__ScoreTrajectory_Request () } } fn create_msg () -> * mut dwb_msgs__srv__ScoreTrajectory_Request { unsafe { dwb_msgs__srv__ScoreTrajectory_Request__create () } } fn destroy_msg (msg : * mut dwb_msgs__srv__ScoreTrajectory_Request) -> () { unsafe { dwb_msgs__srv__ScoreTrajectory_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { pose : nav_2d_msgs :: msg :: Pose2DStamped :: from_native (& msg . pose) , velocity : nav_2d_msgs :: msg :: Twist2D :: from_native (& msg . velocity) , global_plan : nav_2d_msgs :: msg :: Path2D :: from_native (& msg . global_plan) , traj : dwb_msgs :: msg :: Trajectory2D :: from_native (& msg . traj) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . pose . copy_to_native (& mut msg . pose) ; self . velocity . copy_to_native (& mut msg . velocity) ; self . global_plan . copy_to_native (& mut msg . global_plan) ; self . traj . copy_to_native (& mut msg . traj) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub score : dwb_msgs :: msg :: TrajectoryScore } impl WrappedTypesupport for Response { type CStruct = dwb_msgs__srv__ScoreTrajectory_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__dwb_msgs__srv__ScoreTrajectory_Response () } } fn create_msg () -> * mut dwb_msgs__srv__ScoreTrajectory_Response { unsafe { dwb_msgs__srv__ScoreTrajectory_Response__create () } } fn destroy_msg (msg : * mut dwb_msgs__srv__ScoreTrajectory_Response) -> () { unsafe { dwb_msgs__srv__ScoreTrajectory_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { score : dwb_msgs :: msg :: TrajectoryScore :: from_native (& msg . score) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . score . copy_to_native (& mut msg . score) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } }