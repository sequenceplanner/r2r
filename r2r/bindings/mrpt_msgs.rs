pub mod msg { use super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct GenericObservation { pub header : std_msgs :: msg :: Header , pub data : Vec < u8 > } impl WrappedTypesupport for GenericObservation { type CStruct = mrpt_msgs__msg__GenericObservation ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mrpt_msgs__msg__GenericObservation () } } fn create_msg () -> * mut mrpt_msgs__msg__GenericObservation { unsafe { mrpt_msgs__msg__GenericObservation__create () } } fn destroy_msg (msg : * mut mrpt_msgs__msg__GenericObservation) -> () { unsafe { mrpt_msgs__msg__GenericObservation__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> GenericObservation { GenericObservation { header : std_msgs :: msg :: Header :: from_native (& msg . header) , data : msg . data . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . data . update (& self . data) ; } } impl Default for GenericObservation { fn default () -> Self { let msg_native = WrappedNativeMsg :: < GenericObservation > :: new () ; GenericObservation :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct GraphConstraint { pub node_id_from : u64 , pub node_id_to : u64 , pub constraint : geometry_msgs :: msg :: PoseWithCovariance } impl WrappedTypesupport for GraphConstraint { type CStruct = mrpt_msgs__msg__GraphConstraint ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mrpt_msgs__msg__GraphConstraint () } } fn create_msg () -> * mut mrpt_msgs__msg__GraphConstraint { unsafe { mrpt_msgs__msg__GraphConstraint__create () } } fn destroy_msg (msg : * mut mrpt_msgs__msg__GraphConstraint) -> () { unsafe { mrpt_msgs__msg__GraphConstraint__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> GraphConstraint { GraphConstraint { node_id_from : msg . node_id_from , node_id_to : msg . node_id_to , constraint : geometry_msgs :: msg :: PoseWithCovariance :: from_native (& msg . constraint) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . node_id_from = self . node_id_from ; msg . node_id_to = self . node_id_to ; self . constraint . copy_to_native (& mut msg . constraint) ; } } impl Default for GraphConstraint { fn default () -> Self { let msg_native = WrappedNativeMsg :: < GraphConstraint > :: new () ; GraphConstraint :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct GraphSlamAgent { pub name : std_msgs :: msg :: String , pub hostname : std_msgs :: msg :: String , pub ip_addr : std_msgs :: msg :: String , pub port : u16 , pub is_online : std_msgs :: msg :: Bool , pub last_seen_time : builtin_interfaces :: msg :: Time , pub topic_namespace : std_msgs :: msg :: String , pub agent_id : i32 } impl WrappedTypesupport for GraphSlamAgent { type CStruct = mrpt_msgs__msg__GraphSlamAgent ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mrpt_msgs__msg__GraphSlamAgent () } } fn create_msg () -> * mut mrpt_msgs__msg__GraphSlamAgent { unsafe { mrpt_msgs__msg__GraphSlamAgent__create () } } fn destroy_msg (msg : * mut mrpt_msgs__msg__GraphSlamAgent) -> () { unsafe { mrpt_msgs__msg__GraphSlamAgent__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> GraphSlamAgent { GraphSlamAgent { name : std_msgs :: msg :: String :: from_native (& msg . name) , hostname : std_msgs :: msg :: String :: from_native (& msg . hostname) , ip_addr : std_msgs :: msg :: String :: from_native (& msg . ip_addr) , port : msg . port , is_online : std_msgs :: msg :: Bool :: from_native (& msg . is_online) , last_seen_time : builtin_interfaces :: msg :: Time :: from_native (& msg . last_seen_time) , topic_namespace : std_msgs :: msg :: String :: from_native (& msg . topic_namespace) , agent_id : msg . agent_id , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . name . copy_to_native (& mut msg . name) ; self . hostname . copy_to_native (& mut msg . hostname) ; self . ip_addr . copy_to_native (& mut msg . ip_addr) ; msg . port = self . port ; self . is_online . copy_to_native (& mut msg . is_online) ; self . last_seen_time . copy_to_native (& mut msg . last_seen_time) ; self . topic_namespace . copy_to_native (& mut msg . topic_namespace) ; msg . agent_id = self . agent_id ; } } impl Default for GraphSlamAgent { fn default () -> Self { let msg_native = WrappedNativeMsg :: < GraphSlamAgent > :: new () ; GraphSlamAgent :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct GraphSlamAgents { pub list : Vec < mrpt_msgs :: msg :: GraphSlamAgent > } impl WrappedTypesupport for GraphSlamAgents { type CStruct = mrpt_msgs__msg__GraphSlamAgents ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mrpt_msgs__msg__GraphSlamAgents () } } fn create_msg () -> * mut mrpt_msgs__msg__GraphSlamAgents { unsafe { mrpt_msgs__msg__GraphSlamAgents__create () } } fn destroy_msg (msg : * mut mrpt_msgs__msg__GraphSlamAgents) -> () { unsafe { mrpt_msgs__msg__GraphSlamAgents__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> GraphSlamAgents { GraphSlamAgents { list : { let mut temp = Vec :: with_capacity (msg . list . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . list . data , msg . list . size) } ; for s in slice { temp . push (mrpt_msgs :: msg :: GraphSlamAgent :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { unsafe { mrpt_msgs__msg__GraphSlamAgent__Sequence__fini (& mut msg . list) ; mrpt_msgs__msg__GraphSlamAgent__Sequence__init (& mut msg . list , self . list . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . list . data , msg . list . size) ; for (t , s) in slice . iter_mut () . zip (& self . list) { s . copy_to_native (t) ; } } } } impl Default for GraphSlamAgents { fn default () -> Self { let msg_native = WrappedNativeMsg :: < GraphSlamAgents > :: new () ; GraphSlamAgents :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct GraphSlamStats { pub header : std_msgs :: msg :: Header , pub nodes_total : i32 , pub edges_total : i32 , pub edges_icp_2d : i32 , pub edges_icp_3d : i32 , pub edges_odom : i32 , pub loop_closures : i32 , pub slam_evaluation_metric : Vec < f64 > } impl WrappedTypesupport for GraphSlamStats { type CStruct = mrpt_msgs__msg__GraphSlamStats ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mrpt_msgs__msg__GraphSlamStats () } } fn create_msg () -> * mut mrpt_msgs__msg__GraphSlamStats { unsafe { mrpt_msgs__msg__GraphSlamStats__create () } } fn destroy_msg (msg : * mut mrpt_msgs__msg__GraphSlamStats) -> () { unsafe { mrpt_msgs__msg__GraphSlamStats__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> GraphSlamStats { GraphSlamStats { header : std_msgs :: msg :: Header :: from_native (& msg . header) , nodes_total : msg . nodes_total , edges_total : msg . edges_total , edges_icp_2d : msg . edges_icp_2d , edges_icp_3d : msg . edges_icp_3d , edges_odom : msg . edges_odom , loop_closures : msg . loop_closures , slam_evaluation_metric : msg . slam_evaluation_metric . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . nodes_total = self . nodes_total ; msg . edges_total = self . edges_total ; msg . edges_icp_2d = self . edges_icp_2d ; msg . edges_icp_3d = self . edges_icp_3d ; msg . edges_odom = self . edges_odom ; msg . loop_closures = self . loop_closures ; msg . slam_evaluation_metric . update (& self . slam_evaluation_metric) ; } } impl Default for GraphSlamStats { fn default () -> Self { let msg_native = WrappedNativeMsg :: < GraphSlamStats > :: new () ; GraphSlamStats :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct NetworkOfPoses { pub root : u64 , pub nodes : mrpt_msgs :: msg :: NodeIDWithPoseVec , pub constraints : Vec < mrpt_msgs :: msg :: GraphConstraint > } impl WrappedTypesupport for NetworkOfPoses { type CStruct = mrpt_msgs__msg__NetworkOfPoses ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mrpt_msgs__msg__NetworkOfPoses () } } fn create_msg () -> * mut mrpt_msgs__msg__NetworkOfPoses { unsafe { mrpt_msgs__msg__NetworkOfPoses__create () } } fn destroy_msg (msg : * mut mrpt_msgs__msg__NetworkOfPoses) -> () { unsafe { mrpt_msgs__msg__NetworkOfPoses__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> NetworkOfPoses { NetworkOfPoses { root : msg . root , nodes : mrpt_msgs :: msg :: NodeIDWithPoseVec :: from_native (& msg . nodes) , constraints : { let mut temp = Vec :: with_capacity (msg . constraints . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . constraints . data , msg . constraints . size) } ; for s in slice { temp . push (mrpt_msgs :: msg :: GraphConstraint :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . root = self . root ; self . nodes . copy_to_native (& mut msg . nodes) ; unsafe { mrpt_msgs__msg__GraphConstraint__Sequence__fini (& mut msg . constraints) ; mrpt_msgs__msg__GraphConstraint__Sequence__init (& mut msg . constraints , self . constraints . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . constraints . data , msg . constraints . size) ; for (t , s) in slice . iter_mut () . zip (& self . constraints) { s . copy_to_native (t) ; } } } } impl Default for NetworkOfPoses { fn default () -> Self { let msg_native = WrappedNativeMsg :: < NetworkOfPoses > :: new () ; NetworkOfPoses :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct NodeIDWithLaserScan { pub node_id : u64 , pub scan : sensor_msgs :: msg :: LaserScan } impl WrappedTypesupport for NodeIDWithLaserScan { type CStruct = mrpt_msgs__msg__NodeIDWithLaserScan ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mrpt_msgs__msg__NodeIDWithLaserScan () } } fn create_msg () -> * mut mrpt_msgs__msg__NodeIDWithLaserScan { unsafe { mrpt_msgs__msg__NodeIDWithLaserScan__create () } } fn destroy_msg (msg : * mut mrpt_msgs__msg__NodeIDWithLaserScan) -> () { unsafe { mrpt_msgs__msg__NodeIDWithLaserScan__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> NodeIDWithLaserScan { NodeIDWithLaserScan { node_id : msg . node_id , scan : sensor_msgs :: msg :: LaserScan :: from_native (& msg . scan) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . node_id = self . node_id ; self . scan . copy_to_native (& mut msg . scan) ; } } impl Default for NodeIDWithLaserScan { fn default () -> Self { let msg_native = WrappedNativeMsg :: < NodeIDWithLaserScan > :: new () ; NodeIDWithLaserScan :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct NodeIDWithPose { pub node_id : u64 , pub pose : geometry_msgs :: msg :: Pose , pub str_id : std_msgs :: msg :: String , pub node_id_loc : u64 } impl WrappedTypesupport for NodeIDWithPose { type CStruct = mrpt_msgs__msg__NodeIDWithPose ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mrpt_msgs__msg__NodeIDWithPose () } } fn create_msg () -> * mut mrpt_msgs__msg__NodeIDWithPose { unsafe { mrpt_msgs__msg__NodeIDWithPose__create () } } fn destroy_msg (msg : * mut mrpt_msgs__msg__NodeIDWithPose) -> () { unsafe { mrpt_msgs__msg__NodeIDWithPose__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> NodeIDWithPose { NodeIDWithPose { node_id : msg . node_id , pose : geometry_msgs :: msg :: Pose :: from_native (& msg . pose) , str_id : std_msgs :: msg :: String :: from_native (& msg . str_id) , node_id_loc : msg . node_id_loc , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . node_id = self . node_id ; self . pose . copy_to_native (& mut msg . pose) ; self . str_id . copy_to_native (& mut msg . str_id) ; msg . node_id_loc = self . node_id_loc ; } } impl Default for NodeIDWithPose { fn default () -> Self { let msg_native = WrappedNativeMsg :: < NodeIDWithPose > :: new () ; NodeIDWithPose :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct NodeIDWithPoseVec { pub vec : Vec < mrpt_msgs :: msg :: NodeIDWithPose > } impl WrappedTypesupport for NodeIDWithPoseVec { type CStruct = mrpt_msgs__msg__NodeIDWithPoseVec ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mrpt_msgs__msg__NodeIDWithPoseVec () } } fn create_msg () -> * mut mrpt_msgs__msg__NodeIDWithPoseVec { unsafe { mrpt_msgs__msg__NodeIDWithPoseVec__create () } } fn destroy_msg (msg : * mut mrpt_msgs__msg__NodeIDWithPoseVec) -> () { unsafe { mrpt_msgs__msg__NodeIDWithPoseVec__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> NodeIDWithPoseVec { NodeIDWithPoseVec { vec : { let mut temp = Vec :: with_capacity (msg . vec . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . vec . data , msg . vec . size) } ; for s in slice { temp . push (mrpt_msgs :: msg :: NodeIDWithPose :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { unsafe { mrpt_msgs__msg__NodeIDWithPose__Sequence__fini (& mut msg . vec) ; mrpt_msgs__msg__NodeIDWithPose__Sequence__init (& mut msg . vec , self . vec . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . vec . data , msg . vec . size) ; for (t , s) in slice . iter_mut () . zip (& self . vec) { s . copy_to_native (t) ; } } } } impl Default for NodeIDWithPoseVec { fn default () -> Self { let msg_native = WrappedNativeMsg :: < NodeIDWithPoseVec > :: new () ; NodeIDWithPoseVec :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ObservationObject { pub header : std_msgs :: msg :: Header , pub sensor_pose_on_robot : geometry_msgs :: msg :: Pose , pub min_sensor_distance : f64 , pub max_sensor_distance : f64 , pub sensor_std_range : f64 , pub sensor_std_yaw : f64 , pub sensor_std_pitch : f64 , pub sensed_data : Vec < mrpt_msgs :: msg :: SingleObjectObservation > } impl WrappedTypesupport for ObservationObject { type CStruct = mrpt_msgs__msg__ObservationObject ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mrpt_msgs__msg__ObservationObject () } } fn create_msg () -> * mut mrpt_msgs__msg__ObservationObject { unsafe { mrpt_msgs__msg__ObservationObject__create () } } fn destroy_msg (msg : * mut mrpt_msgs__msg__ObservationObject) -> () { unsafe { mrpt_msgs__msg__ObservationObject__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ObservationObject { ObservationObject { header : std_msgs :: msg :: Header :: from_native (& msg . header) , sensor_pose_on_robot : geometry_msgs :: msg :: Pose :: from_native (& msg . sensor_pose_on_robot) , min_sensor_distance : msg . min_sensor_distance , max_sensor_distance : msg . max_sensor_distance , sensor_std_range : msg . sensor_std_range , sensor_std_yaw : msg . sensor_std_yaw , sensor_std_pitch : msg . sensor_std_pitch , sensed_data : { let mut temp = Vec :: with_capacity (msg . sensed_data . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . sensed_data . data , msg . sensed_data . size) } ; for s in slice { temp . push (mrpt_msgs :: msg :: SingleObjectObservation :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; self . sensor_pose_on_robot . copy_to_native (& mut msg . sensor_pose_on_robot) ; msg . min_sensor_distance = self . min_sensor_distance ; msg . max_sensor_distance = self . max_sensor_distance ; msg . sensor_std_range = self . sensor_std_range ; msg . sensor_std_yaw = self . sensor_std_yaw ; msg . sensor_std_pitch = self . sensor_std_pitch ; unsafe { mrpt_msgs__msg__SingleObjectObservation__Sequence__fini (& mut msg . sensed_data) ; mrpt_msgs__msg__SingleObjectObservation__Sequence__init (& mut msg . sensed_data , self . sensed_data . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . sensed_data . data , msg . sensed_data . size) ; for (t , s) in slice . iter_mut () . zip (& self . sensed_data) { s . copy_to_native (t) ; } } } } impl Default for ObservationObject { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ObservationObject > :: new () ; ObservationObject :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ObservationRangeBeacon { pub header : std_msgs :: msg :: Header , pub sensor_pose_on_robot : geometry_msgs :: msg :: Pose , pub min_sensor_distance : f64 , pub max_sensor_distance : f64 , pub sensor_std_range : f64 , pub sensed_data : Vec < mrpt_msgs :: msg :: SingleRangeBeaconObservation > } impl WrappedTypesupport for ObservationRangeBeacon { type CStruct = mrpt_msgs__msg__ObservationRangeBeacon ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mrpt_msgs__msg__ObservationRangeBeacon () } } fn create_msg () -> * mut mrpt_msgs__msg__ObservationRangeBeacon { unsafe { mrpt_msgs__msg__ObservationRangeBeacon__create () } } fn destroy_msg (msg : * mut mrpt_msgs__msg__ObservationRangeBeacon) -> () { unsafe { mrpt_msgs__msg__ObservationRangeBeacon__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ObservationRangeBeacon { ObservationRangeBeacon { header : std_msgs :: msg :: Header :: from_native (& msg . header) , sensor_pose_on_robot : geometry_msgs :: msg :: Pose :: from_native (& msg . sensor_pose_on_robot) , min_sensor_distance : msg . min_sensor_distance , max_sensor_distance : msg . max_sensor_distance , sensor_std_range : msg . sensor_std_range , sensed_data : { let mut temp = Vec :: with_capacity (msg . sensed_data . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . sensed_data . data , msg . sensed_data . size) } ; for s in slice { temp . push (mrpt_msgs :: msg :: SingleRangeBeaconObservation :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; self . sensor_pose_on_robot . copy_to_native (& mut msg . sensor_pose_on_robot) ; msg . min_sensor_distance = self . min_sensor_distance ; msg . max_sensor_distance = self . max_sensor_distance ; msg . sensor_std_range = self . sensor_std_range ; unsafe { mrpt_msgs__msg__SingleRangeBeaconObservation__Sequence__fini (& mut msg . sensed_data) ; mrpt_msgs__msg__SingleRangeBeaconObservation__Sequence__init (& mut msg . sensed_data , self . sensed_data . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . sensed_data . data , msg . sensed_data . size) ; for (t , s) in slice . iter_mut () . zip (& self . sensed_data) { s . copy_to_native (t) ; } } } } impl Default for ObservationRangeBeacon { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ObservationRangeBeacon > :: new () ; ObservationRangeBeacon :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ObservationRangeBearing { pub header : std_msgs :: msg :: Header , pub sensor_pose_on_robot : geometry_msgs :: msg :: Pose , pub min_sensor_distance : f64 , pub max_sensor_distance : f64 , pub sensor_std_range : f64 , pub sensor_std_yaw : f64 , pub sensor_std_pitch : f64 , pub sensed_data : Vec < mrpt_msgs :: msg :: SingleRangeBearingObservation > } impl WrappedTypesupport for ObservationRangeBearing { type CStruct = mrpt_msgs__msg__ObservationRangeBearing ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mrpt_msgs__msg__ObservationRangeBearing () } } fn create_msg () -> * mut mrpt_msgs__msg__ObservationRangeBearing { unsafe { mrpt_msgs__msg__ObservationRangeBearing__create () } } fn destroy_msg (msg : * mut mrpt_msgs__msg__ObservationRangeBearing) -> () { unsafe { mrpt_msgs__msg__ObservationRangeBearing__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ObservationRangeBearing { ObservationRangeBearing { header : std_msgs :: msg :: Header :: from_native (& msg . header) , sensor_pose_on_robot : geometry_msgs :: msg :: Pose :: from_native (& msg . sensor_pose_on_robot) , min_sensor_distance : msg . min_sensor_distance , max_sensor_distance : msg . max_sensor_distance , sensor_std_range : msg . sensor_std_range , sensor_std_yaw : msg . sensor_std_yaw , sensor_std_pitch : msg . sensor_std_pitch , sensed_data : { let mut temp = Vec :: with_capacity (msg . sensed_data . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . sensed_data . data , msg . sensed_data . size) } ; for s in slice { temp . push (mrpt_msgs :: msg :: SingleRangeBearingObservation :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; self . sensor_pose_on_robot . copy_to_native (& mut msg . sensor_pose_on_robot) ; msg . min_sensor_distance = self . min_sensor_distance ; msg . max_sensor_distance = self . max_sensor_distance ; msg . sensor_std_range = self . sensor_std_range ; msg . sensor_std_yaw = self . sensor_std_yaw ; msg . sensor_std_pitch = self . sensor_std_pitch ; unsafe { mrpt_msgs__msg__SingleRangeBearingObservation__Sequence__fini (& mut msg . sensed_data) ; mrpt_msgs__msg__SingleRangeBearingObservation__Sequence__init (& mut msg . sensed_data , self . sensed_data . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . sensed_data . data , msg . sensed_data . size) ; for (t , s) in slice . iter_mut () . zip (& self . sensed_data) { s . copy_to_native (t) ; } } } } impl Default for ObservationRangeBearing { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ObservationRangeBearing > :: new () ; ObservationRangeBearing :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct SingleObjectObservation { pub range : f64 , pub yaw : f64 , pub pitch : f64 , pub pose_wo : geometry_msgs :: msg :: Pose , pub pose_so : geometry_msgs :: msg :: Pose , pub shape_variables : Vec < f32 > , pub id : i32 } impl WrappedTypesupport for SingleObjectObservation { type CStruct = mrpt_msgs__msg__SingleObjectObservation ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mrpt_msgs__msg__SingleObjectObservation () } } fn create_msg () -> * mut mrpt_msgs__msg__SingleObjectObservation { unsafe { mrpt_msgs__msg__SingleObjectObservation__create () } } fn destroy_msg (msg : * mut mrpt_msgs__msg__SingleObjectObservation) -> () { unsafe { mrpt_msgs__msg__SingleObjectObservation__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> SingleObjectObservation { SingleObjectObservation { range : msg . range , yaw : msg . yaw , pitch : msg . pitch , pose_wo : geometry_msgs :: msg :: Pose :: from_native (& msg . pose_wo) , pose_so : geometry_msgs :: msg :: Pose :: from_native (& msg . pose_so) , shape_variables : msg . shape_variables . to_vec () , id : msg . id , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . range = self . range ; msg . yaw = self . yaw ; msg . pitch = self . pitch ; self . pose_wo . copy_to_native (& mut msg . pose_wo) ; self . pose_so . copy_to_native (& mut msg . pose_so) ; msg . shape_variables . update (& self . shape_variables) ; msg . id = self . id ; } } impl Default for SingleObjectObservation { fn default () -> Self { let msg_native = WrappedNativeMsg :: < SingleObjectObservation > :: new () ; SingleObjectObservation :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct SingleRangeBeaconObservation { pub range : f64 , pub id : i32 } impl WrappedTypesupport for SingleRangeBeaconObservation { type CStruct = mrpt_msgs__msg__SingleRangeBeaconObservation ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mrpt_msgs__msg__SingleRangeBeaconObservation () } } fn create_msg () -> * mut mrpt_msgs__msg__SingleRangeBeaconObservation { unsafe { mrpt_msgs__msg__SingleRangeBeaconObservation__create () } } fn destroy_msg (msg : * mut mrpt_msgs__msg__SingleRangeBeaconObservation) -> () { unsafe { mrpt_msgs__msg__SingleRangeBeaconObservation__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> SingleRangeBeaconObservation { SingleRangeBeaconObservation { range : msg . range , id : msg . id , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . range = self . range ; msg . id = self . id ; } } impl Default for SingleRangeBeaconObservation { fn default () -> Self { let msg_native = WrappedNativeMsg :: < SingleRangeBeaconObservation > :: new () ; SingleRangeBeaconObservation :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct SingleRangeBearingObservation { pub range : f64 , pub yaw : f64 , pub pitch : f64 , pub id : i32 } impl WrappedTypesupport for SingleRangeBearingObservation { type CStruct = mrpt_msgs__msg__SingleRangeBearingObservation ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mrpt_msgs__msg__SingleRangeBearingObservation () } } fn create_msg () -> * mut mrpt_msgs__msg__SingleRangeBearingObservation { unsafe { mrpt_msgs__msg__SingleRangeBearingObservation__create () } } fn destroy_msg (msg : * mut mrpt_msgs__msg__SingleRangeBearingObservation) -> () { unsafe { mrpt_msgs__msg__SingleRangeBearingObservation__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> SingleRangeBearingObservation { SingleRangeBearingObservation { range : msg . range , yaw : msg . yaw , pitch : msg . pitch , id : msg . id , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . range = self . range ; msg . yaw = self . yaw ; msg . pitch = self . pitch ; msg . id = self . id ; } } impl Default for SingleRangeBearingObservation { fn default () -> Self { let msg_native = WrappedNativeMsg :: < SingleRangeBearingObservation > :: new () ; SingleRangeBearingObservation :: from_native (& msg_native) } } } pub mod srv { # [allow (non_snake_case)] pub mod GetCMGraph { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__mrpt_msgs__srv__GetCMGraph () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub node_ids : Vec < u64 > } impl WrappedTypesupport for Request { type CStruct = mrpt_msgs__srv__GetCMGraph_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mrpt_msgs__srv__GetCMGraph_Request () } } fn create_msg () -> * mut mrpt_msgs__srv__GetCMGraph_Request { unsafe { mrpt_msgs__srv__GetCMGraph_Request__create () } } fn destroy_msg (msg : * mut mrpt_msgs__srv__GetCMGraph_Request) -> () { unsafe { mrpt_msgs__srv__GetCMGraph_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { node_ids : msg . node_ids . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . node_ids . update (& self . node_ids) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub cm_graph : mrpt_msgs :: msg :: NetworkOfPoses } impl WrappedTypesupport for Response { type CStruct = mrpt_msgs__srv__GetCMGraph_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mrpt_msgs__srv__GetCMGraph_Response () } } fn create_msg () -> * mut mrpt_msgs__srv__GetCMGraph_Response { unsafe { mrpt_msgs__srv__GetCMGraph_Response__create () } } fn destroy_msg (msg : * mut mrpt_msgs__srv__GetCMGraph_Response) -> () { unsafe { mrpt_msgs__srv__GetCMGraph_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { cm_graph : mrpt_msgs :: msg :: NetworkOfPoses :: from_native (& msg . cm_graph) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . cm_graph . copy_to_native (& mut msg . cm_graph) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } }