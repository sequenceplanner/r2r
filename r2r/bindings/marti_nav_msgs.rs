pub mod srv { # [allow (non_snake_case)] pub mod DeleteRoute { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__marti_nav_msgs__srv__DeleteRoute () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub guid : std :: string :: String } impl WrappedTypesupport for Request { type CStruct = marti_nav_msgs__srv__DeleteRoute_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__marti_nav_msgs__srv__DeleteRoute_Request () } } fn create_msg () -> * mut marti_nav_msgs__srv__DeleteRoute_Request { unsafe { marti_nav_msgs__srv__DeleteRoute_Request__create () } } fn destroy_msg (msg : * mut marti_nav_msgs__srv__DeleteRoute_Request) -> () { unsafe { marti_nav_msgs__srv__DeleteRoute_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { guid : msg . guid . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . guid . assign (& self . guid) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool , pub message : std :: string :: String } impl WrappedTypesupport for Response { type CStruct = marti_nav_msgs__srv__DeleteRoute_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__marti_nav_msgs__srv__DeleteRoute_Response () } } fn create_msg () -> * mut marti_nav_msgs__srv__DeleteRoute_Response { unsafe { marti_nav_msgs__srv__DeleteRoute_Response__create () } } fn destroy_msg (msg : * mut marti_nav_msgs__srv__DeleteRoute_Response) -> () { unsafe { marti_nav_msgs__srv__DeleteRoute_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , message : msg . message . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; msg . message . assign (& self . message) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetRoute { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__marti_nav_msgs__srv__GetRoute () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub guid : std :: string :: String } impl WrappedTypesupport for Request { type CStruct = marti_nav_msgs__srv__GetRoute_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__marti_nav_msgs__srv__GetRoute_Request () } } fn create_msg () -> * mut marti_nav_msgs__srv__GetRoute_Request { unsafe { marti_nav_msgs__srv__GetRoute_Request__create () } } fn destroy_msg (msg : * mut marti_nav_msgs__srv__GetRoute_Request) -> () { unsafe { marti_nav_msgs__srv__GetRoute_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { guid : msg . guid . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . guid . assign (& self . guid) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub route : marti_nav_msgs :: msg :: Route , pub success : bool , pub message : std :: string :: String } impl WrappedTypesupport for Response { type CStruct = marti_nav_msgs__srv__GetRoute_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__marti_nav_msgs__srv__GetRoute_Response () } } fn create_msg () -> * mut marti_nav_msgs__srv__GetRoute_Response { unsafe { marti_nav_msgs__srv__GetRoute_Response__create () } } fn destroy_msg (msg : * mut marti_nav_msgs__srv__GetRoute_Response) -> () { unsafe { marti_nav_msgs__srv__GetRoute_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { route : marti_nav_msgs :: msg :: Route :: from_native (& msg . route) , success : msg . success , message : msg . message . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . route . copy_to_native (& mut msg . route) ; msg . success = self . success ; msg . message . assign (& self . message) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetRouteList { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__marti_nav_msgs__srv__GetRouteList () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { } impl WrappedTypesupport for Request { type CStruct = marti_nav_msgs__srv__GetRouteList_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__marti_nav_msgs__srv__GetRouteList_Request () } } fn create_msg () -> * mut marti_nav_msgs__srv__GetRouteList_Request { unsafe { marti_nav_msgs__srv__GetRouteList_Request__create () } } fn destroy_msg (msg : * mut marti_nav_msgs__srv__GetRouteList_Request) -> () { unsafe { marti_nav_msgs__srv__GetRouteList_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub routes : Vec < marti_nav_msgs :: msg :: Route > , pub success : bool , pub message : std :: string :: String } impl WrappedTypesupport for Response { type CStruct = marti_nav_msgs__srv__GetRouteList_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__marti_nav_msgs__srv__GetRouteList_Response () } } fn create_msg () -> * mut marti_nav_msgs__srv__GetRouteList_Response { unsafe { marti_nav_msgs__srv__GetRouteList_Response__create () } } fn destroy_msg (msg : * mut marti_nav_msgs__srv__GetRouteList_Response) -> () { unsafe { marti_nav_msgs__srv__GetRouteList_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { routes : { let mut temp = Vec :: with_capacity (msg . routes . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . routes . data , msg . routes . size) } ; for s in slice { temp . push (marti_nav_msgs :: msg :: Route :: from_native (s)) ; } temp } , success : msg . success , message : msg . message . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { unsafe { marti_nav_msgs__msg__Route__Sequence__fini (& mut msg . routes) ; marti_nav_msgs__msg__Route__Sequence__init (& mut msg . routes , self . routes . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . routes . data , msg . routes . size) ; for (t , s) in slice . iter_mut () . zip (& self . routes) { s . copy_to_native (t) ; } } msg . success = self . success ; msg . message . assign (& self . message) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod PlanRoute { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__marti_nav_msgs__srv__PlanRoute () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub header : std_msgs :: msg :: Header , pub waypoints : Vec < geometry_msgs :: msg :: Pose > , pub plan_from_vehicle : bool } impl WrappedTypesupport for Request { type CStruct = marti_nav_msgs__srv__PlanRoute_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__marti_nav_msgs__srv__PlanRoute_Request () } } fn create_msg () -> * mut marti_nav_msgs__srv__PlanRoute_Request { unsafe { marti_nav_msgs__srv__PlanRoute_Request__create () } } fn destroy_msg (msg : * mut marti_nav_msgs__srv__PlanRoute_Request) -> () { unsafe { marti_nav_msgs__srv__PlanRoute_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { header : std_msgs :: msg :: Header :: from_native (& msg . header) , waypoints : { let mut temp = Vec :: with_capacity (msg . waypoints . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . waypoints . data , msg . waypoints . size) } ; for s in slice { temp . push (geometry_msgs :: msg :: Pose :: from_native (s)) ; } temp } , plan_from_vehicle : msg . plan_from_vehicle , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; unsafe { geometry_msgs__msg__Pose__Sequence__fini (& mut msg . waypoints) ; geometry_msgs__msg__Pose__Sequence__init (& mut msg . waypoints , self . waypoints . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . waypoints . data , msg . waypoints . size) ; for (t , s) in slice . iter_mut () . zip (& self . waypoints) { s . copy_to_native (t) ; } } msg . plan_from_vehicle = self . plan_from_vehicle ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub route : marti_nav_msgs :: msg :: Route , pub success : bool , pub message : std :: string :: String } impl WrappedTypesupport for Response { type CStruct = marti_nav_msgs__srv__PlanRoute_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__marti_nav_msgs__srv__PlanRoute_Response () } } fn create_msg () -> * mut marti_nav_msgs__srv__PlanRoute_Response { unsafe { marti_nav_msgs__srv__PlanRoute_Response__create () } } fn destroy_msg (msg : * mut marti_nav_msgs__srv__PlanRoute_Response) -> () { unsafe { marti_nav_msgs__srv__PlanRoute_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { route : marti_nav_msgs :: msg :: Route :: from_native (& msg . route) , success : msg . success , message : msg . message . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . route . copy_to_native (& mut msg . route) ; msg . success = self . success ; msg . message . assign (& self . message) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod SaveRecordedRoute { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__marti_nav_msgs__srv__SaveRecordedRoute () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub name : std :: string :: String , pub thumbnail : std :: string :: String } impl WrappedTypesupport for Request { type CStruct = marti_nav_msgs__srv__SaveRecordedRoute_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__marti_nav_msgs__srv__SaveRecordedRoute_Request () } } fn create_msg () -> * mut marti_nav_msgs__srv__SaveRecordedRoute_Request { unsafe { marti_nav_msgs__srv__SaveRecordedRoute_Request__create () } } fn destroy_msg (msg : * mut marti_nav_msgs__srv__SaveRecordedRoute_Request) -> () { unsafe { marti_nav_msgs__srv__SaveRecordedRoute_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { name : msg . name . to_str () . to_owned () , thumbnail : msg . thumbnail . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . name . assign (& self . name) ; msg . thumbnail . assign (& self . thumbnail) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool , pub message : std :: string :: String } impl WrappedTypesupport for Response { type CStruct = marti_nav_msgs__srv__SaveRecordedRoute_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__marti_nav_msgs__srv__SaveRecordedRoute_Response () } } fn create_msg () -> * mut marti_nav_msgs__srv__SaveRecordedRoute_Response { unsafe { marti_nav_msgs__srv__SaveRecordedRoute_Response__create () } } fn destroy_msg (msg : * mut marti_nav_msgs__srv__SaveRecordedRoute_Response) -> () { unsafe { marti_nav_msgs__srv__SaveRecordedRoute_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , message : msg . message . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; msg . message . assign (& self . message) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod SaveRoute { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__marti_nav_msgs__srv__SaveRoute () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub name : std :: string :: String , pub guid : std :: string :: String , pub route : marti_nav_msgs :: msg :: Route , pub thumbnail : std :: string :: String } impl WrappedTypesupport for Request { type CStruct = marti_nav_msgs__srv__SaveRoute_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__marti_nav_msgs__srv__SaveRoute_Request () } } fn create_msg () -> * mut marti_nav_msgs__srv__SaveRoute_Request { unsafe { marti_nav_msgs__srv__SaveRoute_Request__create () } } fn destroy_msg (msg : * mut marti_nav_msgs__srv__SaveRoute_Request) -> () { unsafe { marti_nav_msgs__srv__SaveRoute_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { name : msg . name . to_str () . to_owned () , guid : msg . guid . to_str () . to_owned () , route : marti_nav_msgs :: msg :: Route :: from_native (& msg . route) , thumbnail : msg . thumbnail . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . name . assign (& self . name) ; msg . guid . assign (& self . guid) ; self . route . copy_to_native (& mut msg . route) ; msg . thumbnail . assign (& self . thumbnail) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool , pub message : std :: string :: String } impl WrappedTypesupport for Response { type CStruct = marti_nav_msgs__srv__SaveRoute_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__marti_nav_msgs__srv__SaveRoute_Response () } } fn create_msg () -> * mut marti_nav_msgs__srv__SaveRoute_Response { unsafe { marti_nav_msgs__srv__SaveRoute_Response__create () } } fn destroy_msg (msg : * mut marti_nav_msgs__srv__SaveRoute_Response) -> () { unsafe { marti_nav_msgs__srv__SaveRoute_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , message : msg . message . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; msg . message . assign (& self . message) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod SetRoute { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__marti_nav_msgs__srv__SetRoute () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub guid : std :: string :: String , pub repeat : bool } impl WrappedTypesupport for Request { type CStruct = marti_nav_msgs__srv__SetRoute_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__marti_nav_msgs__srv__SetRoute_Request () } } fn create_msg () -> * mut marti_nav_msgs__srv__SetRoute_Request { unsafe { marti_nav_msgs__srv__SetRoute_Request__create () } } fn destroy_msg (msg : * mut marti_nav_msgs__srv__SetRoute_Request) -> () { unsafe { marti_nav_msgs__srv__SetRoute_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { guid : msg . guid . to_str () . to_owned () , repeat : msg . repeat , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . guid . assign (& self . guid) ; msg . repeat = self . repeat ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool , pub message : std :: string :: String } impl WrappedTypesupport for Response { type CStruct = marti_nav_msgs__srv__SetRoute_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__marti_nav_msgs__srv__SetRoute_Response () } } fn create_msg () -> * mut marti_nav_msgs__srv__SetRoute_Response { unsafe { marti_nav_msgs__srv__SetRoute_Response__create () } } fn destroy_msg (msg : * mut marti_nav_msgs__srv__SetRoute_Response) -> () { unsafe { marti_nav_msgs__srv__SetRoute_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , message : msg . message . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; msg . message . assign (& self . message) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod UpdateRouteMetadata { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__marti_nav_msgs__srv__UpdateRouteMetadata () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub route_guid : std :: string :: String , pub metadata_points : Vec < marti_nav_msgs :: msg :: RoutePoint > } impl WrappedTypesupport for Request { type CStruct = marti_nav_msgs__srv__UpdateRouteMetadata_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__marti_nav_msgs__srv__UpdateRouteMetadata_Request () } } fn create_msg () -> * mut marti_nav_msgs__srv__UpdateRouteMetadata_Request { unsafe { marti_nav_msgs__srv__UpdateRouteMetadata_Request__create () } } fn destroy_msg (msg : * mut marti_nav_msgs__srv__UpdateRouteMetadata_Request) -> () { unsafe { marti_nav_msgs__srv__UpdateRouteMetadata_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { route_guid : msg . route_guid . to_str () . to_owned () , metadata_points : { let mut temp = Vec :: with_capacity (msg . metadata_points . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . metadata_points . data , msg . metadata_points . size) } ; for s in slice { temp . push (marti_nav_msgs :: msg :: RoutePoint :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . route_guid . assign (& self . route_guid) ; unsafe { marti_nav_msgs__msg__RoutePoint__Sequence__fini (& mut msg . metadata_points) ; marti_nav_msgs__msg__RoutePoint__Sequence__init (& mut msg . metadata_points , self . metadata_points . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . metadata_points . data , msg . metadata_points . size) ; for (t , s) in slice . iter_mut () . zip (& self . metadata_points) { s . copy_to_native (t) ; } } } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool , pub message : std :: string :: String } impl WrappedTypesupport for Response { type CStruct = marti_nav_msgs__srv__UpdateRouteMetadata_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__marti_nav_msgs__srv__UpdateRouteMetadata_Response () } } fn create_msg () -> * mut marti_nav_msgs__srv__UpdateRouteMetadata_Response { unsafe { marti_nav_msgs__srv__UpdateRouteMetadata_Response__create () } } fn destroy_msg (msg : * mut marti_nav_msgs__srv__UpdateRouteMetadata_Response) -> () { unsafe { marti_nav_msgs__srv__UpdateRouteMetadata_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , message : msg . message . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; msg . message . assign (& self . message) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } } pub mod msg { use super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Command { pub header : std_msgs :: msg :: Header , pub startstop : Vec < i32 > } impl WrappedTypesupport for Command { type CStruct = marti_nav_msgs__msg__Command ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__marti_nav_msgs__msg__Command () } } fn create_msg () -> * mut marti_nav_msgs__msg__Command { unsafe { marti_nav_msgs__msg__Command__create () } } fn destroy_msg (msg : * mut marti_nav_msgs__msg__Command) -> () { unsafe { marti_nav_msgs__msg__Command__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Command { Command { header : std_msgs :: msg :: Header :: from_native (& msg . header) , startstop : msg . startstop . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . startstop . update (& self . startstop) ; } } impl Default for Command { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Command > :: new () ; Command :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct GridMap { pub header : std_msgs :: msg :: Header , pub top_left : geometry_msgs :: msg :: Point , pub top_right : geometry_msgs :: msg :: Point , pub bottom_right : geometry_msgs :: msg :: Point , pub bottom_left : geometry_msgs :: msg :: Point , pub map_names : Vec < std :: string :: String > , pub map_data : Vec < sensor_msgs :: msg :: Image > } impl WrappedTypesupport for GridMap { type CStruct = marti_nav_msgs__msg__GridMap ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__marti_nav_msgs__msg__GridMap () } } fn create_msg () -> * mut marti_nav_msgs__msg__GridMap { unsafe { marti_nav_msgs__msg__GridMap__create () } } fn destroy_msg (msg : * mut marti_nav_msgs__msg__GridMap) -> () { unsafe { marti_nav_msgs__msg__GridMap__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> GridMap { GridMap { header : std_msgs :: msg :: Header :: from_native (& msg . header) , top_left : geometry_msgs :: msg :: Point :: from_native (& msg . top_left) , top_right : geometry_msgs :: msg :: Point :: from_native (& msg . top_right) , bottom_right : geometry_msgs :: msg :: Point :: from_native (& msg . bottom_right) , bottom_left : geometry_msgs :: msg :: Point :: from_native (& msg . bottom_left) , map_names : msg . map_names . to_vec () , map_data : { let mut temp = Vec :: with_capacity (msg . map_data . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . map_data . data , msg . map_data . size) } ; for s in slice { temp . push (sensor_msgs :: msg :: Image :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; self . top_left . copy_to_native (& mut msg . top_left) ; self . top_right . copy_to_native (& mut msg . top_right) ; self . bottom_right . copy_to_native (& mut msg . bottom_right) ; self . bottom_left . copy_to_native (& mut msg . bottom_left) ; msg . map_names . update (& self . map_names) ; unsafe { sensor_msgs__msg__Image__Sequence__fini (& mut msg . map_data) ; sensor_msgs__msg__Image__Sequence__init (& mut msg . map_data , self . map_data . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . map_data . data , msg . map_data . size) ; for (t , s) in slice . iter_mut () . zip (& self . map_data) { s . copy_to_native (t) ; } } } } impl Default for GridMap { fn default () -> Self { let msg_native = WrappedNativeMsg :: < GridMap > :: new () ; GridMap :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct LeadVehicle { pub header : std_msgs :: msg :: Header , pub headway_distance : f32 , pub speed : f32 , pub heading : f32 , pub x_pos : f32 , pub y_pos : f32 , pub classification : i8 , # [serde (rename = "type")] pub type_ : i8 } impl WrappedTypesupport for LeadVehicle { type CStruct = marti_nav_msgs__msg__LeadVehicle ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__marti_nav_msgs__msg__LeadVehicle () } } fn create_msg () -> * mut marti_nav_msgs__msg__LeadVehicle { unsafe { marti_nav_msgs__msg__LeadVehicle__create () } } fn destroy_msg (msg : * mut marti_nav_msgs__msg__LeadVehicle) -> () { unsafe { marti_nav_msgs__msg__LeadVehicle__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> LeadVehicle { LeadVehicle { header : std_msgs :: msg :: Header :: from_native (& msg . header) , headway_distance : msg . headway_distance , speed : msg . speed , heading : msg . heading , x_pos : msg . x_pos , y_pos : msg . y_pos , classification : msg . classification , type_ : msg . type_ , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . headway_distance = self . headway_distance ; msg . speed = self . speed ; msg . heading = self . heading ; msg . x_pos = self . x_pos ; msg . y_pos = self . y_pos ; msg . classification = self . classification ; msg . type_ = self . type_ ; } } impl Default for LeadVehicle { fn default () -> Self { let msg_native = WrappedNativeMsg :: < LeadVehicle > :: new () ; LeadVehicle :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Obstacle { pub id : std :: string :: String , pub pose : geometry_msgs :: msg :: Pose , pub polygon : Vec < geometry_msgs :: msg :: Point > } impl WrappedTypesupport for Obstacle { type CStruct = marti_nav_msgs__msg__Obstacle ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__marti_nav_msgs__msg__Obstacle () } } fn create_msg () -> * mut marti_nav_msgs__msg__Obstacle { unsafe { marti_nav_msgs__msg__Obstacle__create () } } fn destroy_msg (msg : * mut marti_nav_msgs__msg__Obstacle) -> () { unsafe { marti_nav_msgs__msg__Obstacle__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Obstacle { Obstacle { id : msg . id . to_str () . to_owned () , pose : geometry_msgs :: msg :: Pose :: from_native (& msg . pose) , polygon : { let mut temp = Vec :: with_capacity (msg . polygon . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . polygon . data , msg . polygon . size) } ; for s in slice { temp . push (geometry_msgs :: msg :: Point :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . id . assign (& self . id) ; self . pose . copy_to_native (& mut msg . pose) ; unsafe { geometry_msgs__msg__Point__Sequence__fini (& mut msg . polygon) ; geometry_msgs__msg__Point__Sequence__init (& mut msg . polygon , self . polygon . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . polygon . data , msg . polygon . size) ; for (t , s) in slice . iter_mut () . zip (& self . polygon) { s . copy_to_native (t) ; } } } } impl Default for Obstacle { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Obstacle > :: new () ; Obstacle :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ObstacleArray { pub header : std_msgs :: msg :: Header , pub obstacles : Vec < marti_nav_msgs :: msg :: Obstacle > } impl WrappedTypesupport for ObstacleArray { type CStruct = marti_nav_msgs__msg__ObstacleArray ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__marti_nav_msgs__msg__ObstacleArray () } } fn create_msg () -> * mut marti_nav_msgs__msg__ObstacleArray { unsafe { marti_nav_msgs__msg__ObstacleArray__create () } } fn destroy_msg (msg : * mut marti_nav_msgs__msg__ObstacleArray) -> () { unsafe { marti_nav_msgs__msg__ObstacleArray__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ObstacleArray { ObstacleArray { header : std_msgs :: msg :: Header :: from_native (& msg . header) , obstacles : { let mut temp = Vec :: with_capacity (msg . obstacles . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . obstacles . data , msg . obstacles . size) } ; for s in slice { temp . push (marti_nav_msgs :: msg :: Obstacle :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; unsafe { marti_nav_msgs__msg__Obstacle__Sequence__fini (& mut msg . obstacles) ; marti_nav_msgs__msg__Obstacle__Sequence__init (& mut msg . obstacles , self . obstacles . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . obstacles . data , msg . obstacles . size) ; for (t , s) in slice . iter_mut () . zip (& self . obstacles) { s . copy_to_native (t) ; } } } } impl Default for ObstacleArray { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ObstacleArray > :: new () ; ObstacleArray :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Path { pub header : std_msgs :: msg :: Header , pub points : Vec < marti_nav_msgs :: msg :: PathPoint > , pub in_reverse : bool } impl WrappedTypesupport for Path { type CStruct = marti_nav_msgs__msg__Path ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__marti_nav_msgs__msg__Path () } } fn create_msg () -> * mut marti_nav_msgs__msg__Path { unsafe { marti_nav_msgs__msg__Path__create () } } fn destroy_msg (msg : * mut marti_nav_msgs__msg__Path) -> () { unsafe { marti_nav_msgs__msg__Path__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Path { Path { header : std_msgs :: msg :: Header :: from_native (& msg . header) , points : { let mut temp = Vec :: with_capacity (msg . points . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . points . data , msg . points . size) } ; for s in slice { temp . push (marti_nav_msgs :: msg :: PathPoint :: from_native (s)) ; } temp } , in_reverse : msg . in_reverse , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; unsafe { marti_nav_msgs__msg__PathPoint__Sequence__fini (& mut msg . points) ; marti_nav_msgs__msg__PathPoint__Sequence__init (& mut msg . points , self . points . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . points . data , msg . points . size) ; for (t , s) in slice . iter_mut () . zip (& self . points) { s . copy_to_native (t) ; } } msg . in_reverse = self . in_reverse ; } } impl Default for Path { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Path > :: new () ; Path :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct PathPlanning { pub header : std_msgs :: msg :: Header , pub segment_type : i32 , pub length : f32 , pub start_speed : f32 , pub end_speed : f32 , pub startx : f32 , pub starty : f32 , pub endx : f32 , pub endy : f32 , pub theta0 : f32 , pub a1 : f32 , pub a2 : f32 , pub k0 : f32 , pub c1 : f32 , pub c2 : f32 , pub behavior : i32 , pub creep : i32 , pub acc : i32 , pub reverse : i32 , pub vehicle_track : i32 , pub transmitted : bool , pub aux_transmitted : bool , pub theta_end : f32 , pub k_end : f32 , pub seg_len : i32 , pub speed_limit : f32 , pub max_error : f32 , pub max_smooth : f32 , pub max_curv : f32 , pub possible_points : i32 , pub exit_segment : bool } impl WrappedTypesupport for PathPlanning { type CStruct = marti_nav_msgs__msg__PathPlanning ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__marti_nav_msgs__msg__PathPlanning () } } fn create_msg () -> * mut marti_nav_msgs__msg__PathPlanning { unsafe { marti_nav_msgs__msg__PathPlanning__create () } } fn destroy_msg (msg : * mut marti_nav_msgs__msg__PathPlanning) -> () { unsafe { marti_nav_msgs__msg__PathPlanning__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> PathPlanning { PathPlanning { header : std_msgs :: msg :: Header :: from_native (& msg . header) , segment_type : msg . segment_type , length : msg . length , start_speed : msg . start_speed , end_speed : msg . end_speed , startx : msg . startx , starty : msg . starty , endx : msg . endx , endy : msg . endy , theta0 : msg . theta0 , a1 : msg . a1 , a2 : msg . a2 , k0 : msg . k0 , c1 : msg . c1 , c2 : msg . c2 , behavior : msg . behavior , creep : msg . creep , acc : msg . acc , reverse : msg . reverse , vehicle_track : msg . vehicle_track , transmitted : msg . transmitted , aux_transmitted : msg . aux_transmitted , theta_end : msg . theta_end , k_end : msg . k_end , seg_len : msg . seg_len , speed_limit : msg . speed_limit , max_error : msg . max_error , max_smooth : msg . max_smooth , max_curv : msg . max_curv , possible_points : msg . possible_points , exit_segment : msg . exit_segment , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . segment_type = self . segment_type ; msg . length = self . length ; msg . start_speed = self . start_speed ; msg . end_speed = self . end_speed ; msg . startx = self . startx ; msg . starty = self . starty ; msg . endx = self . endx ; msg . endy = self . endy ; msg . theta0 = self . theta0 ; msg . a1 = self . a1 ; msg . a2 = self . a2 ; msg . k0 = self . k0 ; msg . c1 = self . c1 ; msg . c2 = self . c2 ; msg . behavior = self . behavior ; msg . creep = self . creep ; msg . acc = self . acc ; msg . reverse = self . reverse ; msg . vehicle_track = self . vehicle_track ; msg . transmitted = self . transmitted ; msg . aux_transmitted = self . aux_transmitted ; msg . theta_end = self . theta_end ; msg . k_end = self . k_end ; msg . seg_len = self . seg_len ; msg . speed_limit = self . speed_limit ; msg . max_error = self . max_error ; msg . max_smooth = self . max_smooth ; msg . max_curv = self . max_curv ; msg . possible_points = self . possible_points ; msg . exit_segment = self . exit_segment ; } } impl Default for PathPlanning { fn default () -> Self { let msg_native = WrappedNativeMsg :: < PathPlanning > :: new () ; PathPlanning :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct PathPoint { pub x : f64 , pub y : f64 , pub yaw : f32 , pub speed : f32 } impl WrappedTypesupport for PathPoint { type CStruct = marti_nav_msgs__msg__PathPoint ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__marti_nav_msgs__msg__PathPoint () } } fn create_msg () -> * mut marti_nav_msgs__msg__PathPoint { unsafe { marti_nav_msgs__msg__PathPoint__create () } } fn destroy_msg (msg : * mut marti_nav_msgs__msg__PathPoint) -> () { unsafe { marti_nav_msgs__msg__PathPoint__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> PathPoint { PathPoint { x : msg . x , y : msg . y , yaw : msg . yaw , speed : msg . speed , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . x = self . x ; msg . y = self . y ; msg . yaw = self . yaw ; msg . speed = self . speed ; } } impl Default for PathPoint { fn default () -> Self { let msg_native = WrappedNativeMsg :: < PathPoint > :: new () ; PathPoint :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Route { pub header : std_msgs :: msg :: Header , pub route_points : Vec < marti_nav_msgs :: msg :: RoutePoint > , pub properties : Vec < marti_common_msgs :: msg :: KeyValue > } impl WrappedTypesupport for Route { type CStruct = marti_nav_msgs__msg__Route ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__marti_nav_msgs__msg__Route () } } fn create_msg () -> * mut marti_nav_msgs__msg__Route { unsafe { marti_nav_msgs__msg__Route__create () } } fn destroy_msg (msg : * mut marti_nav_msgs__msg__Route) -> () { unsafe { marti_nav_msgs__msg__Route__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Route { Route { header : std_msgs :: msg :: Header :: from_native (& msg . header) , route_points : { let mut temp = Vec :: with_capacity (msg . route_points . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . route_points . data , msg . route_points . size) } ; for s in slice { temp . push (marti_nav_msgs :: msg :: RoutePoint :: from_native (s)) ; } temp } , properties : { let mut temp = Vec :: with_capacity (msg . properties . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . properties . data , msg . properties . size) } ; for s in slice { temp . push (marti_common_msgs :: msg :: KeyValue :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; unsafe { marti_nav_msgs__msg__RoutePoint__Sequence__fini (& mut msg . route_points) ; marti_nav_msgs__msg__RoutePoint__Sequence__init (& mut msg . route_points , self . route_points . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . route_points . data , msg . route_points . size) ; for (t , s) in slice . iter_mut () . zip (& self . route_points) { s . copy_to_native (t) ; } } unsafe { marti_common_msgs__msg__KeyValue__Sequence__fini (& mut msg . properties) ; marti_common_msgs__msg__KeyValue__Sequence__init (& mut msg . properties , self . properties . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . properties . data , msg . properties . size) ; for (t , s) in slice . iter_mut () . zip (& self . properties) { s . copy_to_native (t) ; } } } } impl Default for Route { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Route > :: new () ; Route :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct RouteArray { pub header : std_msgs :: msg :: Header , pub routes : Vec < marti_nav_msgs :: msg :: Route > , pub properties : Vec < marti_common_msgs :: msg :: KeyValue > } impl WrappedTypesupport for RouteArray { type CStruct = marti_nav_msgs__msg__RouteArray ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__marti_nav_msgs__msg__RouteArray () } } fn create_msg () -> * mut marti_nav_msgs__msg__RouteArray { unsafe { marti_nav_msgs__msg__RouteArray__create () } } fn destroy_msg (msg : * mut marti_nav_msgs__msg__RouteArray) -> () { unsafe { marti_nav_msgs__msg__RouteArray__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> RouteArray { RouteArray { header : std_msgs :: msg :: Header :: from_native (& msg . header) , routes : { let mut temp = Vec :: with_capacity (msg . routes . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . routes . data , msg . routes . size) } ; for s in slice { temp . push (marti_nav_msgs :: msg :: Route :: from_native (s)) ; } temp } , properties : { let mut temp = Vec :: with_capacity (msg . properties . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . properties . data , msg . properties . size) } ; for s in slice { temp . push (marti_common_msgs :: msg :: KeyValue :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; unsafe { marti_nav_msgs__msg__Route__Sequence__fini (& mut msg . routes) ; marti_nav_msgs__msg__Route__Sequence__init (& mut msg . routes , self . routes . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . routes . data , msg . routes . size) ; for (t , s) in slice . iter_mut () . zip (& self . routes) { s . copy_to_native (t) ; } } unsafe { marti_common_msgs__msg__KeyValue__Sequence__fini (& mut msg . properties) ; marti_common_msgs__msg__KeyValue__Sequence__init (& mut msg . properties , self . properties . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . properties . data , msg . properties . size) ; for (t , s) in slice . iter_mut () . zip (& self . properties) { s . copy_to_native (t) ; } } } } impl Default for RouteArray { fn default () -> Self { let msg_native = WrappedNativeMsg :: < RouteArray > :: new () ; RouteArray :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct RouteOffset { pub header : std_msgs :: msg :: Header , pub relative_pose : geometry_msgs :: msg :: Pose , pub route_position : marti_nav_msgs :: msg :: RoutePosition } impl WrappedTypesupport for RouteOffset { type CStruct = marti_nav_msgs__msg__RouteOffset ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__marti_nav_msgs__msg__RouteOffset () } } fn create_msg () -> * mut marti_nav_msgs__msg__RouteOffset { unsafe { marti_nav_msgs__msg__RouteOffset__create () } } fn destroy_msg (msg : * mut marti_nav_msgs__msg__RouteOffset) -> () { unsafe { marti_nav_msgs__msg__RouteOffset__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> RouteOffset { RouteOffset { header : std_msgs :: msg :: Header :: from_native (& msg . header) , relative_pose : geometry_msgs :: msg :: Pose :: from_native (& msg . relative_pose) , route_position : marti_nav_msgs :: msg :: RoutePosition :: from_native (& msg . route_position) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; self . relative_pose . copy_to_native (& mut msg . relative_pose) ; self . route_position . copy_to_native (& mut msg . route_position) ; } } impl Default for RouteOffset { fn default () -> Self { let msg_native = WrappedNativeMsg :: < RouteOffset > :: new () ; RouteOffset :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct RoutePoint { pub pose : geometry_msgs :: msg :: Pose , pub id : std :: string :: String , pub properties : Vec < marti_common_msgs :: msg :: KeyValue > } impl WrappedTypesupport for RoutePoint { type CStruct = marti_nav_msgs__msg__RoutePoint ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__marti_nav_msgs__msg__RoutePoint () } } fn create_msg () -> * mut marti_nav_msgs__msg__RoutePoint { unsafe { marti_nav_msgs__msg__RoutePoint__create () } } fn destroy_msg (msg : * mut marti_nav_msgs__msg__RoutePoint) -> () { unsafe { marti_nav_msgs__msg__RoutePoint__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> RoutePoint { RoutePoint { pose : geometry_msgs :: msg :: Pose :: from_native (& msg . pose) , id : msg . id . to_str () . to_owned () , properties : { let mut temp = Vec :: with_capacity (msg . properties . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . properties . data , msg . properties . size) } ; for s in slice { temp . push (marti_common_msgs :: msg :: KeyValue :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . pose . copy_to_native (& mut msg . pose) ; msg . id . assign (& self . id) ; unsafe { marti_common_msgs__msg__KeyValue__Sequence__fini (& mut msg . properties) ; marti_common_msgs__msg__KeyValue__Sequence__init (& mut msg . properties , self . properties . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . properties . data , msg . properties . size) ; for (t , s) in slice . iter_mut () . zip (& self . properties) { s . copy_to_native (t) ; } } } } impl Default for RoutePoint { fn default () -> Self { let msg_native = WrappedNativeMsg :: < RoutePoint > :: new () ; RoutePoint :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct RoutePosition { pub header : std_msgs :: msg :: Header , pub route_id : std :: string :: String , pub id : std :: string :: String , pub distance : f32 } impl WrappedTypesupport for RoutePosition { type CStruct = marti_nav_msgs__msg__RoutePosition ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__marti_nav_msgs__msg__RoutePosition () } } fn create_msg () -> * mut marti_nav_msgs__msg__RoutePosition { unsafe { marti_nav_msgs__msg__RoutePosition__create () } } fn destroy_msg (msg : * mut marti_nav_msgs__msg__RoutePosition) -> () { unsafe { marti_nav_msgs__msg__RoutePosition__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> RoutePosition { RoutePosition { header : std_msgs :: msg :: Header :: from_native (& msg . header) , route_id : msg . route_id . to_str () . to_owned () , id : msg . id . to_str () . to_owned () , distance : msg . distance , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . route_id . assign (& self . route_id) ; msg . id . assign (& self . id) ; msg . distance = self . distance ; } } impl Default for RoutePosition { fn default () -> Self { let msg_native = WrappedNativeMsg :: < RoutePosition > :: new () ; RoutePosition :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct RouteSpeed { pub header : std_msgs :: msg :: Header , pub id : std :: string :: String , pub distance : f32 , pub speed : f32 } impl WrappedTypesupport for RouteSpeed { type CStruct = marti_nav_msgs__msg__RouteSpeed ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__marti_nav_msgs__msg__RouteSpeed () } } fn create_msg () -> * mut marti_nav_msgs__msg__RouteSpeed { unsafe { marti_nav_msgs__msg__RouteSpeed__create () } } fn destroy_msg (msg : * mut marti_nav_msgs__msg__RouteSpeed) -> () { unsafe { marti_nav_msgs__msg__RouteSpeed__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> RouteSpeed { RouteSpeed { header : std_msgs :: msg :: Header :: from_native (& msg . header) , id : msg . id . to_str () . to_owned () , distance : msg . distance , speed : msg . speed , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . id . assign (& self . id) ; msg . distance = self . distance ; msg . speed = self . speed ; } } impl Default for RouteSpeed { fn default () -> Self { let msg_native = WrappedNativeMsg :: < RouteSpeed > :: new () ; RouteSpeed :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct RouteSpeedArray { pub header : std_msgs :: msg :: Header , pub speeds : Vec < marti_nav_msgs :: msg :: RouteSpeed > } impl WrappedTypesupport for RouteSpeedArray { type CStruct = marti_nav_msgs__msg__RouteSpeedArray ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__marti_nav_msgs__msg__RouteSpeedArray () } } fn create_msg () -> * mut marti_nav_msgs__msg__RouteSpeedArray { unsafe { marti_nav_msgs__msg__RouteSpeedArray__create () } } fn destroy_msg (msg : * mut marti_nav_msgs__msg__RouteSpeedArray) -> () { unsafe { marti_nav_msgs__msg__RouteSpeedArray__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> RouteSpeedArray { RouteSpeedArray { header : std_msgs :: msg :: Header :: from_native (& msg . header) , speeds : { let mut temp = Vec :: with_capacity (msg . speeds . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . speeds . data , msg . speeds . size) } ; for s in slice { temp . push (marti_nav_msgs :: msg :: RouteSpeed :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; unsafe { marti_nav_msgs__msg__RouteSpeed__Sequence__fini (& mut msg . speeds) ; marti_nav_msgs__msg__RouteSpeed__Sequence__init (& mut msg . speeds , self . speeds . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . speeds . data , msg . speeds . size) ; for (t , s) in slice . iter_mut () . zip (& self . speeds) { s . copy_to_native (t) ; } } } } impl Default for RouteSpeedArray { fn default () -> Self { let msg_native = WrappedNativeMsg :: < RouteSpeedArray > :: new () ; RouteSpeedArray :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct TeleopState { pub header : std_msgs :: msg :: Header , pub teleop_signals : Vec < i32 > } impl WrappedTypesupport for TeleopState { type CStruct = marti_nav_msgs__msg__TeleopState ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__marti_nav_msgs__msg__TeleopState () } } fn create_msg () -> * mut marti_nav_msgs__msg__TeleopState { unsafe { marti_nav_msgs__msg__TeleopState__create () } } fn destroy_msg (msg : * mut marti_nav_msgs__msg__TeleopState) -> () { unsafe { marti_nav_msgs__msg__TeleopState__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> TeleopState { TeleopState { header : std_msgs :: msg :: Header :: from_native (& msg . header) , teleop_signals : msg . teleop_signals . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . teleop_signals . update (& self . teleop_signals) ; } } impl Default for TeleopState { fn default () -> Self { let msg_native = WrappedNativeMsg :: < TeleopState > :: new () ; TeleopState :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct TrackedObject { pub header : std_msgs :: msg :: Header , pub id : u16 , pub pose : geometry_msgs :: msg :: PoseWithCovariance , pub velocity : geometry_msgs :: msg :: TwistWithCovariance , pub linear_acceleration : geometry_msgs :: msg :: Vector3 , pub linear_acceleration_covariance : Vec < f64 > , pub polygon : Vec < geometry_msgs :: msg :: Point > , pub length : f32 , pub length_quality : f32 , pub width : f32 , pub width_quality : f32 , pub classification : u8 , pub classification_quality : f32 , pub existence_probability : f32 , pub age_duration : builtin_interfaces :: msg :: Duration , pub prediction_duration : builtin_interfaces :: msg :: Duration , pub active : bool } impl WrappedTypesupport for TrackedObject { type CStruct = marti_nav_msgs__msg__TrackedObject ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__marti_nav_msgs__msg__TrackedObject () } } fn create_msg () -> * mut marti_nav_msgs__msg__TrackedObject { unsafe { marti_nav_msgs__msg__TrackedObject__create () } } fn destroy_msg (msg : * mut marti_nav_msgs__msg__TrackedObject) -> () { unsafe { marti_nav_msgs__msg__TrackedObject__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> TrackedObject { TrackedObject { header : std_msgs :: msg :: Header :: from_native (& msg . header) , id : msg . id , pose : geometry_msgs :: msg :: PoseWithCovariance :: from_native (& msg . pose) , velocity : geometry_msgs :: msg :: TwistWithCovariance :: from_native (& msg . velocity) , linear_acceleration : geometry_msgs :: msg :: Vector3 :: from_native (& msg . linear_acceleration) , linear_acceleration_covariance : msg . linear_acceleration_covariance . to_vec () , polygon : { let mut temp = Vec :: with_capacity (msg . polygon . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . polygon . data , msg . polygon . size) } ; for s in slice { temp . push (geometry_msgs :: msg :: Point :: from_native (s)) ; } temp } , length : msg . length , length_quality : msg . length_quality , width : msg . width , width_quality : msg . width_quality , classification : msg . classification , classification_quality : msg . classification_quality , existence_probability : msg . existence_probability , age_duration : builtin_interfaces :: msg :: Duration :: from_native (& msg . age_duration) , prediction_duration : builtin_interfaces :: msg :: Duration :: from_native (& msg . prediction_duration) , active : msg . active , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . id = self . id ; self . pose . copy_to_native (& mut msg . pose) ; self . velocity . copy_to_native (& mut msg . velocity) ; self . linear_acceleration . copy_to_native (& mut msg . linear_acceleration) ; assert_eq ! (self . linear_acceleration_covariance . len () , 9usize , "Field {} is fixed size of {}!" , "linear_acceleration_covariance" , 9usize) ; msg . linear_acceleration_covariance . copy_from_slice (& self . linear_acceleration_covariance [.. 9usize]) ; unsafe { geometry_msgs__msg__Point__Sequence__fini (& mut msg . polygon) ; geometry_msgs__msg__Point__Sequence__init (& mut msg . polygon , self . polygon . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . polygon . data , msg . polygon . size) ; for (t , s) in slice . iter_mut () . zip (& self . polygon) { s . copy_to_native (t) ; } } msg . length = self . length ; msg . length_quality = self . length_quality ; msg . width = self . width ; msg . width_quality = self . width_quality ; msg . classification = self . classification ; msg . classification_quality = self . classification_quality ; msg . existence_probability = self . existence_probability ; self . age_duration . copy_to_native (& mut msg . age_duration) ; self . prediction_duration . copy_to_native (& mut msg . prediction_duration) ; msg . active = self . active ; } } impl Default for TrackedObject { fn default () -> Self { let msg_native = WrappedNativeMsg :: < TrackedObject > :: new () ; TrackedObject :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl TrackedObject { pub const PEDESTRIAN : _bindgen_ty_447 = marti_nav_msgs__msg__TrackedObject__PEDESTRIAN ; pub const UNKNOWN : _bindgen_ty_448 = marti_nav_msgs__msg__TrackedObject__UNKNOWN ; pub const VEHICLE : _bindgen_ty_446 = marti_nav_msgs__msg__TrackedObject__VEHICLE ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct TrackedObjectArray { pub header : std_msgs :: msg :: Header , pub objects : Vec < marti_nav_msgs :: msg :: TrackedObject > } impl WrappedTypesupport for TrackedObjectArray { type CStruct = marti_nav_msgs__msg__TrackedObjectArray ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__marti_nav_msgs__msg__TrackedObjectArray () } } fn create_msg () -> * mut marti_nav_msgs__msg__TrackedObjectArray { unsafe { marti_nav_msgs__msg__TrackedObjectArray__create () } } fn destroy_msg (msg : * mut marti_nav_msgs__msg__TrackedObjectArray) -> () { unsafe { marti_nav_msgs__msg__TrackedObjectArray__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> TrackedObjectArray { TrackedObjectArray { header : std_msgs :: msg :: Header :: from_native (& msg . header) , objects : { let mut temp = Vec :: with_capacity (msg . objects . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . objects . data , msg . objects . size) } ; for s in slice { temp . push (marti_nav_msgs :: msg :: TrackedObject :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; unsafe { marti_nav_msgs__msg__TrackedObject__Sequence__fini (& mut msg . objects) ; marti_nav_msgs__msg__TrackedObject__Sequence__init (& mut msg . objects , self . objects . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . objects . data , msg . objects . size) ; for (t , s) in slice . iter_mut () . zip (& self . objects) { s . copy_to_native (t) ; } } } } impl Default for TrackedObjectArray { fn default () -> Self { let msg_native = WrappedNativeMsg :: < TrackedObjectArray > :: new () ; TrackedObjectArray :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct VehicleControl { pub header : std_msgs :: msg :: Header , pub engine : i32 , pub gear : i32 , pub steering : f64 , pub throttle : f64 , pub brake : f64 , pub steering_position : i16 , pub gb_position : i16 } impl WrappedTypesupport for VehicleControl { type CStruct = marti_nav_msgs__msg__VehicleControl ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__marti_nav_msgs__msg__VehicleControl () } } fn create_msg () -> * mut marti_nav_msgs__msg__VehicleControl { unsafe { marti_nav_msgs__msg__VehicleControl__create () } } fn destroy_msg (msg : * mut marti_nav_msgs__msg__VehicleControl) -> () { unsafe { marti_nav_msgs__msg__VehicleControl__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> VehicleControl { VehicleControl { header : std_msgs :: msg :: Header :: from_native (& msg . header) , engine : msg . engine , gear : msg . gear , steering : msg . steering , throttle : msg . throttle , brake : msg . brake , steering_position : msg . steering_position , gb_position : msg . gb_position , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . engine = self . engine ; msg . gear = self . gear ; msg . steering = self . steering ; msg . throttle = self . throttle ; msg . brake = self . brake ; msg . steering_position = self . steering_position ; msg . gb_position = self . gb_position ; } } impl Default for VehicleControl { fn default () -> Self { let msg_native = WrappedNativeMsg :: < VehicleControl > :: new () ; VehicleControl :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Wgs84Sample { pub header : std_msgs :: msg :: Header , pub odom : geometry_msgs :: msg :: Point , pub wgs84 : geometry_msgs :: msg :: Point , pub wgs84_covariance : Vec < f64 > } impl WrappedTypesupport for Wgs84Sample { type CStruct = marti_nav_msgs__msg__Wgs84Sample ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__marti_nav_msgs__msg__Wgs84Sample () } } fn create_msg () -> * mut marti_nav_msgs__msg__Wgs84Sample { unsafe { marti_nav_msgs__msg__Wgs84Sample__create () } } fn destroy_msg (msg : * mut marti_nav_msgs__msg__Wgs84Sample) -> () { unsafe { marti_nav_msgs__msg__Wgs84Sample__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Wgs84Sample { Wgs84Sample { header : std_msgs :: msg :: Header :: from_native (& msg . header) , odom : geometry_msgs :: msg :: Point :: from_native (& msg . odom) , wgs84 : geometry_msgs :: msg :: Point :: from_native (& msg . wgs84) , wgs84_covariance : msg . wgs84_covariance . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; self . odom . copy_to_native (& mut msg . odom) ; self . wgs84 . copy_to_native (& mut msg . wgs84) ; assert_eq ! (self . wgs84_covariance . len () , 9usize , "Field {} is fixed size of {}!" , "wgs84_covariance" , 9usize) ; msg . wgs84_covariance . copy_from_slice (& self . wgs84_covariance [.. 9usize]) ; } } impl Default for Wgs84Sample { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Wgs84Sample > :: new () ; Wgs84Sample :: from_native (& msg_native) } } }