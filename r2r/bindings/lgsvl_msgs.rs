pub mod msg { use super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct BoundingBox2D { pub x : f32 , pub y : f32 , pub width : f32 , pub height : f32 } impl WrappedTypesupport for BoundingBox2D { type CStruct = lgsvl_msgs__msg__BoundingBox2D ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__lgsvl_msgs__msg__BoundingBox2D () } } fn create_msg () -> * mut lgsvl_msgs__msg__BoundingBox2D { unsafe { lgsvl_msgs__msg__BoundingBox2D__create () } } fn destroy_msg (msg : * mut lgsvl_msgs__msg__BoundingBox2D) -> () { unsafe { lgsvl_msgs__msg__BoundingBox2D__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> BoundingBox2D { BoundingBox2D { x : msg . x , y : msg . y , width : msg . width , height : msg . height , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . x = self . x ; msg . y = self . y ; msg . width = self . width ; msg . height = self . height ; } } impl Default for BoundingBox2D { fn default () -> Self { let msg_native = WrappedNativeMsg :: < BoundingBox2D > :: new () ; BoundingBox2D :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct BoundingBox3D { pub position : geometry_msgs :: msg :: Pose , pub size : geometry_msgs :: msg :: Vector3 } impl WrappedTypesupport for BoundingBox3D { type CStruct = lgsvl_msgs__msg__BoundingBox3D ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__lgsvl_msgs__msg__BoundingBox3D () } } fn create_msg () -> * mut lgsvl_msgs__msg__BoundingBox3D { unsafe { lgsvl_msgs__msg__BoundingBox3D__create () } } fn destroy_msg (msg : * mut lgsvl_msgs__msg__BoundingBox3D) -> () { unsafe { lgsvl_msgs__msg__BoundingBox3D__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> BoundingBox3D { BoundingBox3D { position : geometry_msgs :: msg :: Pose :: from_native (& msg . position) , size : geometry_msgs :: msg :: Vector3 :: from_native (& msg . size) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . position . copy_to_native (& mut msg . position) ; self . size . copy_to_native (& mut msg . size) ; } } impl Default for BoundingBox3D { fn default () -> Self { let msg_native = WrappedNativeMsg :: < BoundingBox3D > :: new () ; BoundingBox3D :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct CanBusData { pub header : std_msgs :: msg :: Header , pub speed_mps : f32 , pub throttle_pct : f32 , pub brake_pct : f32 , pub steer_pct : f32 , pub parking_brake_active : bool , pub high_beams_active : bool , pub low_beams_active : bool , pub hazard_lights_active : bool , pub fog_lights_active : bool , pub left_turn_signal_active : bool , pub right_turn_signal_active : bool , pub wipers_active : bool , pub reverse_gear_active : bool , pub selected_gear : i8 , pub engine_active : bool , pub engine_rpm : f32 , pub gps_latitude : f64 , pub gps_longitude : f64 , pub gps_altitude : f64 , pub orientation : geometry_msgs :: msg :: Quaternion , pub linear_velocities : geometry_msgs :: msg :: Vector3 } impl WrappedTypesupport for CanBusData { type CStruct = lgsvl_msgs__msg__CanBusData ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__lgsvl_msgs__msg__CanBusData () } } fn create_msg () -> * mut lgsvl_msgs__msg__CanBusData { unsafe { lgsvl_msgs__msg__CanBusData__create () } } fn destroy_msg (msg : * mut lgsvl_msgs__msg__CanBusData) -> () { unsafe { lgsvl_msgs__msg__CanBusData__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> CanBusData { CanBusData { header : std_msgs :: msg :: Header :: from_native (& msg . header) , speed_mps : msg . speed_mps , throttle_pct : msg . throttle_pct , brake_pct : msg . brake_pct , steer_pct : msg . steer_pct , parking_brake_active : msg . parking_brake_active , high_beams_active : msg . high_beams_active , low_beams_active : msg . low_beams_active , hazard_lights_active : msg . hazard_lights_active , fog_lights_active : msg . fog_lights_active , left_turn_signal_active : msg . left_turn_signal_active , right_turn_signal_active : msg . right_turn_signal_active , wipers_active : msg . wipers_active , reverse_gear_active : msg . reverse_gear_active , selected_gear : msg . selected_gear , engine_active : msg . engine_active , engine_rpm : msg . engine_rpm , gps_latitude : msg . gps_latitude , gps_longitude : msg . gps_longitude , gps_altitude : msg . gps_altitude , orientation : geometry_msgs :: msg :: Quaternion :: from_native (& msg . orientation) , linear_velocities : geometry_msgs :: msg :: Vector3 :: from_native (& msg . linear_velocities) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . speed_mps = self . speed_mps ; msg . throttle_pct = self . throttle_pct ; msg . brake_pct = self . brake_pct ; msg . steer_pct = self . steer_pct ; msg . parking_brake_active = self . parking_brake_active ; msg . high_beams_active = self . high_beams_active ; msg . low_beams_active = self . low_beams_active ; msg . hazard_lights_active = self . hazard_lights_active ; msg . fog_lights_active = self . fog_lights_active ; msg . left_turn_signal_active = self . left_turn_signal_active ; msg . right_turn_signal_active = self . right_turn_signal_active ; msg . wipers_active = self . wipers_active ; msg . reverse_gear_active = self . reverse_gear_active ; msg . selected_gear = self . selected_gear ; msg . engine_active = self . engine_active ; msg . engine_rpm = self . engine_rpm ; msg . gps_latitude = self . gps_latitude ; msg . gps_longitude = self . gps_longitude ; msg . gps_altitude = self . gps_altitude ; self . orientation . copy_to_native (& mut msg . orientation) ; self . linear_velocities . copy_to_native (& mut msg . linear_velocities) ; } } impl Default for CanBusData { fn default () -> Self { let msg_native = WrappedNativeMsg :: < CanBusData > :: new () ; CanBusData :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl CanBusData { pub const GEAR_DRIVE : _bindgen_ty_357 = lgsvl_msgs__msg__CanBusData__GEAR_DRIVE ; pub const GEAR_LOW : _bindgen_ty_360 = lgsvl_msgs__msg__CanBusData__GEAR_LOW ; pub const GEAR_NEUTRAL : _bindgen_ty_356 = lgsvl_msgs__msg__CanBusData__GEAR_NEUTRAL ; pub const GEAR_PARKING : _bindgen_ty_359 = lgsvl_msgs__msg__CanBusData__GEAR_PARKING ; pub const GEAR_REVERSE : _bindgen_ty_358 = lgsvl_msgs__msg__CanBusData__GEAR_REVERSE ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct DetectedRadarObject { pub id : i32 , pub sensor_aim : geometry_msgs :: msg :: Vector3 , pub sensor_right : geometry_msgs :: msg :: Vector3 , pub sensor_position : geometry_msgs :: msg :: Point , pub sensor_velocity : geometry_msgs :: msg :: Vector3 , pub sensor_angle : f64 , pub object_position : geometry_msgs :: msg :: Point , pub object_velocity : geometry_msgs :: msg :: Vector3 , pub object_relative_position : geometry_msgs :: msg :: Point , pub object_relative_velocity : geometry_msgs :: msg :: Vector3 , pub object_collider_size : geometry_msgs :: msg :: Vector3 , pub object_state : u8 , pub new_detection : bool } impl WrappedTypesupport for DetectedRadarObject { type CStruct = lgsvl_msgs__msg__DetectedRadarObject ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__lgsvl_msgs__msg__DetectedRadarObject () } } fn create_msg () -> * mut lgsvl_msgs__msg__DetectedRadarObject { unsafe { lgsvl_msgs__msg__DetectedRadarObject__create () } } fn destroy_msg (msg : * mut lgsvl_msgs__msg__DetectedRadarObject) -> () { unsafe { lgsvl_msgs__msg__DetectedRadarObject__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> DetectedRadarObject { DetectedRadarObject { id : msg . id , sensor_aim : geometry_msgs :: msg :: Vector3 :: from_native (& msg . sensor_aim) , sensor_right : geometry_msgs :: msg :: Vector3 :: from_native (& msg . sensor_right) , sensor_position : geometry_msgs :: msg :: Point :: from_native (& msg . sensor_position) , sensor_velocity : geometry_msgs :: msg :: Vector3 :: from_native (& msg . sensor_velocity) , sensor_angle : msg . sensor_angle , object_position : geometry_msgs :: msg :: Point :: from_native (& msg . object_position) , object_velocity : geometry_msgs :: msg :: Vector3 :: from_native (& msg . object_velocity) , object_relative_position : geometry_msgs :: msg :: Point :: from_native (& msg . object_relative_position) , object_relative_velocity : geometry_msgs :: msg :: Vector3 :: from_native (& msg . object_relative_velocity) , object_collider_size : geometry_msgs :: msg :: Vector3 :: from_native (& msg . object_collider_size) , object_state : msg . object_state , new_detection : msg . new_detection , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . id = self . id ; self . sensor_aim . copy_to_native (& mut msg . sensor_aim) ; self . sensor_right . copy_to_native (& mut msg . sensor_right) ; self . sensor_position . copy_to_native (& mut msg . sensor_position) ; self . sensor_velocity . copy_to_native (& mut msg . sensor_velocity) ; msg . sensor_angle = self . sensor_angle ; self . object_position . copy_to_native (& mut msg . object_position) ; self . object_velocity . copy_to_native (& mut msg . object_velocity) ; self . object_relative_position . copy_to_native (& mut msg . object_relative_position) ; self . object_relative_velocity . copy_to_native (& mut msg . object_relative_velocity) ; self . object_collider_size . copy_to_native (& mut msg . object_collider_size) ; msg . object_state = self . object_state ; msg . new_detection = self . new_detection ; } } impl Default for DetectedRadarObject { fn default () -> Self { let msg_native = WrappedNativeMsg :: < DetectedRadarObject > :: new () ; DetectedRadarObject :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl DetectedRadarObject { pub const STATE_MOVING : _bindgen_ty_361 = lgsvl_msgs__msg__DetectedRadarObject__STATE_MOVING ; pub const STATE_STATIONARY : _bindgen_ty_362 = lgsvl_msgs__msg__DetectedRadarObject__STATE_STATIONARY ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct DetectedRadarObjectArray { pub header : std_msgs :: msg :: Header , pub objects : Vec < lgsvl_msgs :: msg :: DetectedRadarObject > } impl WrappedTypesupport for DetectedRadarObjectArray { type CStruct = lgsvl_msgs__msg__DetectedRadarObjectArray ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__lgsvl_msgs__msg__DetectedRadarObjectArray () } } fn create_msg () -> * mut lgsvl_msgs__msg__DetectedRadarObjectArray { unsafe { lgsvl_msgs__msg__DetectedRadarObjectArray__create () } } fn destroy_msg (msg : * mut lgsvl_msgs__msg__DetectedRadarObjectArray) -> () { unsafe { lgsvl_msgs__msg__DetectedRadarObjectArray__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> DetectedRadarObjectArray { DetectedRadarObjectArray { header : std_msgs :: msg :: Header :: from_native (& msg . header) , objects : { let mut temp = Vec :: with_capacity (msg . objects . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . objects . data , msg . objects . size) } ; for s in slice { temp . push (lgsvl_msgs :: msg :: DetectedRadarObject :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; unsafe { lgsvl_msgs__msg__DetectedRadarObject__Sequence__fini (& mut msg . objects) ; lgsvl_msgs__msg__DetectedRadarObject__Sequence__init (& mut msg . objects , self . objects . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . objects . data , msg . objects . size) ; for (t , s) in slice . iter_mut () . zip (& self . objects) { s . copy_to_native (t) ; } } } } impl Default for DetectedRadarObjectArray { fn default () -> Self { let msg_native = WrappedNativeMsg :: < DetectedRadarObjectArray > :: new () ; DetectedRadarObjectArray :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Detection2D { pub header : std_msgs :: msg :: Header , pub id : u32 , pub label : std :: string :: String , pub score : f32 , pub bbox : lgsvl_msgs :: msg :: BoundingBox2D , pub velocity : geometry_msgs :: msg :: Twist } impl WrappedTypesupport for Detection2D { type CStruct = lgsvl_msgs__msg__Detection2D ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__lgsvl_msgs__msg__Detection2D () } } fn create_msg () -> * mut lgsvl_msgs__msg__Detection2D { unsafe { lgsvl_msgs__msg__Detection2D__create () } } fn destroy_msg (msg : * mut lgsvl_msgs__msg__Detection2D) -> () { unsafe { lgsvl_msgs__msg__Detection2D__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Detection2D { Detection2D { header : std_msgs :: msg :: Header :: from_native (& msg . header) , id : msg . id , label : msg . label . to_str () . to_owned () , score : msg . score , bbox : lgsvl_msgs :: msg :: BoundingBox2D :: from_native (& msg . bbox) , velocity : geometry_msgs :: msg :: Twist :: from_native (& msg . velocity) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . id = self . id ; msg . label . assign (& self . label) ; msg . score = self . score ; self . bbox . copy_to_native (& mut msg . bbox) ; self . velocity . copy_to_native (& mut msg . velocity) ; } } impl Default for Detection2D { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Detection2D > :: new () ; Detection2D :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Detection2DArray { pub header : std_msgs :: msg :: Header , pub detections : Vec < lgsvl_msgs :: msg :: Detection2D > } impl WrappedTypesupport for Detection2DArray { type CStruct = lgsvl_msgs__msg__Detection2DArray ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__lgsvl_msgs__msg__Detection2DArray () } } fn create_msg () -> * mut lgsvl_msgs__msg__Detection2DArray { unsafe { lgsvl_msgs__msg__Detection2DArray__create () } } fn destroy_msg (msg : * mut lgsvl_msgs__msg__Detection2DArray) -> () { unsafe { lgsvl_msgs__msg__Detection2DArray__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Detection2DArray { Detection2DArray { header : std_msgs :: msg :: Header :: from_native (& msg . header) , detections : { let mut temp = Vec :: with_capacity (msg . detections . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . detections . data , msg . detections . size) } ; for s in slice { temp . push (lgsvl_msgs :: msg :: Detection2D :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; unsafe { lgsvl_msgs__msg__Detection2D__Sequence__fini (& mut msg . detections) ; lgsvl_msgs__msg__Detection2D__Sequence__init (& mut msg . detections , self . detections . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . detections . data , msg . detections . size) ; for (t , s) in slice . iter_mut () . zip (& self . detections) { s . copy_to_native (t) ; } } } } impl Default for Detection2DArray { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Detection2DArray > :: new () ; Detection2DArray :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Detection3D { pub header : std_msgs :: msg :: Header , pub id : u32 , pub label : std :: string :: String , pub score : f32 , pub bbox : lgsvl_msgs :: msg :: BoundingBox3D , pub velocity : geometry_msgs :: msg :: Twist } impl WrappedTypesupport for Detection3D { type CStruct = lgsvl_msgs__msg__Detection3D ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__lgsvl_msgs__msg__Detection3D () } } fn create_msg () -> * mut lgsvl_msgs__msg__Detection3D { unsafe { lgsvl_msgs__msg__Detection3D__create () } } fn destroy_msg (msg : * mut lgsvl_msgs__msg__Detection3D) -> () { unsafe { lgsvl_msgs__msg__Detection3D__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Detection3D { Detection3D { header : std_msgs :: msg :: Header :: from_native (& msg . header) , id : msg . id , label : msg . label . to_str () . to_owned () , score : msg . score , bbox : lgsvl_msgs :: msg :: BoundingBox3D :: from_native (& msg . bbox) , velocity : geometry_msgs :: msg :: Twist :: from_native (& msg . velocity) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . id = self . id ; msg . label . assign (& self . label) ; msg . score = self . score ; self . bbox . copy_to_native (& mut msg . bbox) ; self . velocity . copy_to_native (& mut msg . velocity) ; } } impl Default for Detection3D { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Detection3D > :: new () ; Detection3D :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Detection3DArray { pub header : std_msgs :: msg :: Header , pub detections : Vec < lgsvl_msgs :: msg :: Detection3D > } impl WrappedTypesupport for Detection3DArray { type CStruct = lgsvl_msgs__msg__Detection3DArray ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__lgsvl_msgs__msg__Detection3DArray () } } fn create_msg () -> * mut lgsvl_msgs__msg__Detection3DArray { unsafe { lgsvl_msgs__msg__Detection3DArray__create () } } fn destroy_msg (msg : * mut lgsvl_msgs__msg__Detection3DArray) -> () { unsafe { lgsvl_msgs__msg__Detection3DArray__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Detection3DArray { Detection3DArray { header : std_msgs :: msg :: Header :: from_native (& msg . header) , detections : { let mut temp = Vec :: with_capacity (msg . detections . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . detections . data , msg . detections . size) } ; for s in slice { temp . push (lgsvl_msgs :: msg :: Detection3D :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; unsafe { lgsvl_msgs__msg__Detection3D__Sequence__fini (& mut msg . detections) ; lgsvl_msgs__msg__Detection3D__Sequence__init (& mut msg . detections , self . detections . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . detections . data , msg . detections . size) ; for (t , s) in slice . iter_mut () . zip (& self . detections) { s . copy_to_native (t) ; } } } } impl Default for Detection3DArray { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Detection3DArray > :: new () ; Detection3DArray :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Signal { pub header : std_msgs :: msg :: Header , pub id : u32 , pub label : std :: string :: String , pub score : f32 , pub bbox : lgsvl_msgs :: msg :: BoundingBox3D } impl WrappedTypesupport for Signal { type CStruct = lgsvl_msgs__msg__Signal ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__lgsvl_msgs__msg__Signal () } } fn create_msg () -> * mut lgsvl_msgs__msg__Signal { unsafe { lgsvl_msgs__msg__Signal__create () } } fn destroy_msg (msg : * mut lgsvl_msgs__msg__Signal) -> () { unsafe { lgsvl_msgs__msg__Signal__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Signal { Signal { header : std_msgs :: msg :: Header :: from_native (& msg . header) , id : msg . id , label : msg . label . to_str () . to_owned () , score : msg . score , bbox : lgsvl_msgs :: msg :: BoundingBox3D :: from_native (& msg . bbox) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . id = self . id ; msg . label . assign (& self . label) ; msg . score = self . score ; self . bbox . copy_to_native (& mut msg . bbox) ; } } impl Default for Signal { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Signal > :: new () ; Signal :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct SignalArray { pub header : std_msgs :: msg :: Header , pub signals : Vec < lgsvl_msgs :: msg :: Signal > } impl WrappedTypesupport for SignalArray { type CStruct = lgsvl_msgs__msg__SignalArray ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__lgsvl_msgs__msg__SignalArray () } } fn create_msg () -> * mut lgsvl_msgs__msg__SignalArray { unsafe { lgsvl_msgs__msg__SignalArray__create () } } fn destroy_msg (msg : * mut lgsvl_msgs__msg__SignalArray) -> () { unsafe { lgsvl_msgs__msg__SignalArray__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> SignalArray { SignalArray { header : std_msgs :: msg :: Header :: from_native (& msg . header) , signals : { let mut temp = Vec :: with_capacity (msg . signals . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . signals . data , msg . signals . size) } ; for s in slice { temp . push (lgsvl_msgs :: msg :: Signal :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; unsafe { lgsvl_msgs__msg__Signal__Sequence__fini (& mut msg . signals) ; lgsvl_msgs__msg__Signal__Sequence__init (& mut msg . signals , self . signals . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . signals . data , msg . signals . size) ; for (t , s) in slice . iter_mut () . zip (& self . signals) { s . copy_to_native (t) ; } } } } impl Default for SignalArray { fn default () -> Self { let msg_native = WrappedNativeMsg :: < SignalArray > :: new () ; SignalArray :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Ultrasonic { pub header : std_msgs :: msg :: Header , pub minimum_distance : f32 } impl WrappedTypesupport for Ultrasonic { type CStruct = lgsvl_msgs__msg__Ultrasonic ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__lgsvl_msgs__msg__Ultrasonic () } } fn create_msg () -> * mut lgsvl_msgs__msg__Ultrasonic { unsafe { lgsvl_msgs__msg__Ultrasonic__create () } } fn destroy_msg (msg : * mut lgsvl_msgs__msg__Ultrasonic) -> () { unsafe { lgsvl_msgs__msg__Ultrasonic__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Ultrasonic { Ultrasonic { header : std_msgs :: msg :: Header :: from_native (& msg . header) , minimum_distance : msg . minimum_distance , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . minimum_distance = self . minimum_distance ; } } impl Default for Ultrasonic { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Ultrasonic > :: new () ; Ultrasonic :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct VehicleControlData { pub header : std_msgs :: msg :: Header , pub acceleration_pct : f32 , pub braking_pct : f32 , pub target_wheel_angle : f32 , pub target_wheel_angular_rate : f32 , pub target_gear : u8 } impl WrappedTypesupport for VehicleControlData { type CStruct = lgsvl_msgs__msg__VehicleControlData ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__lgsvl_msgs__msg__VehicleControlData () } } fn create_msg () -> * mut lgsvl_msgs__msg__VehicleControlData { unsafe { lgsvl_msgs__msg__VehicleControlData__create () } } fn destroy_msg (msg : * mut lgsvl_msgs__msg__VehicleControlData) -> () { unsafe { lgsvl_msgs__msg__VehicleControlData__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> VehicleControlData { VehicleControlData { header : std_msgs :: msg :: Header :: from_native (& msg . header) , acceleration_pct : msg . acceleration_pct , braking_pct : msg . braking_pct , target_wheel_angle : msg . target_wheel_angle , target_wheel_angular_rate : msg . target_wheel_angular_rate , target_gear : msg . target_gear , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . acceleration_pct = self . acceleration_pct ; msg . braking_pct = self . braking_pct ; msg . target_wheel_angle = self . target_wheel_angle ; msg . target_wheel_angular_rate = self . target_wheel_angular_rate ; msg . target_gear = self . target_gear ; } } impl Default for VehicleControlData { fn default () -> Self { let msg_native = WrappedNativeMsg :: < VehicleControlData > :: new () ; VehicleControlData :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl VehicleControlData { pub const GEAR_DRIVE : _bindgen_ty_364 = lgsvl_msgs__msg__VehicleControlData__GEAR_DRIVE ; pub const GEAR_LOW : _bindgen_ty_367 = lgsvl_msgs__msg__VehicleControlData__GEAR_LOW ; pub const GEAR_NEUTRAL : _bindgen_ty_363 = lgsvl_msgs__msg__VehicleControlData__GEAR_NEUTRAL ; pub const GEAR_PARKING : _bindgen_ty_366 = lgsvl_msgs__msg__VehicleControlData__GEAR_PARKING ; pub const GEAR_REVERSE : _bindgen_ty_365 = lgsvl_msgs__msg__VehicleControlData__GEAR_REVERSE ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct VehicleOdometry { pub header : std_msgs :: msg :: Header , pub velocity : f32 , pub front_wheel_angle : f32 , pub rear_wheel_angle : f32 } impl WrappedTypesupport for VehicleOdometry { type CStruct = lgsvl_msgs__msg__VehicleOdometry ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__lgsvl_msgs__msg__VehicleOdometry () } } fn create_msg () -> * mut lgsvl_msgs__msg__VehicleOdometry { unsafe { lgsvl_msgs__msg__VehicleOdometry__create () } } fn destroy_msg (msg : * mut lgsvl_msgs__msg__VehicleOdometry) -> () { unsafe { lgsvl_msgs__msg__VehicleOdometry__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> VehicleOdometry { VehicleOdometry { header : std_msgs :: msg :: Header :: from_native (& msg . header) , velocity : msg . velocity , front_wheel_angle : msg . front_wheel_angle , rear_wheel_angle : msg . rear_wheel_angle , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . velocity = self . velocity ; msg . front_wheel_angle = self . front_wheel_angle ; msg . rear_wheel_angle = self . rear_wheel_angle ; } } impl Default for VehicleOdometry { fn default () -> Self { let msg_native = WrappedNativeMsg :: < VehicleOdometry > :: new () ; VehicleOdometry :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct VehicleStateData { pub header : std_msgs :: msg :: Header , pub blinker_state : u8 , pub headlight_state : u8 , pub wiper_state : u8 , pub current_gear : u8 , pub vehicle_mode : u8 , pub hand_brake_active : bool , pub horn_active : bool , pub autonomous_mode_active : bool } impl WrappedTypesupport for VehicleStateData { type CStruct = lgsvl_msgs__msg__VehicleStateData ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__lgsvl_msgs__msg__VehicleStateData () } } fn create_msg () -> * mut lgsvl_msgs__msg__VehicleStateData { unsafe { lgsvl_msgs__msg__VehicleStateData__create () } } fn destroy_msg (msg : * mut lgsvl_msgs__msg__VehicleStateData) -> () { unsafe { lgsvl_msgs__msg__VehicleStateData__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> VehicleStateData { VehicleStateData { header : std_msgs :: msg :: Header :: from_native (& msg . header) , blinker_state : msg . blinker_state , headlight_state : msg . headlight_state , wiper_state : msg . wiper_state , current_gear : msg . current_gear , vehicle_mode : msg . vehicle_mode , hand_brake_active : msg . hand_brake_active , horn_active : msg . horn_active , autonomous_mode_active : msg . autonomous_mode_active , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . blinker_state = self . blinker_state ; msg . headlight_state = self . headlight_state ; msg . wiper_state = self . wiper_state ; msg . current_gear = self . current_gear ; msg . vehicle_mode = self . vehicle_mode ; msg . hand_brake_active = self . hand_brake_active ; msg . horn_active = self . horn_active ; msg . autonomous_mode_active = self . autonomous_mode_active ; } } impl Default for VehicleStateData { fn default () -> Self { let msg_native = WrappedNativeMsg :: < VehicleStateData > :: new () ; VehicleStateData :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl VehicleStateData { pub const BLINKERS_HAZARD : _bindgen_ty_371 = lgsvl_msgs__msg__VehicleStateData__BLINKERS_HAZARD ; pub const BLINKERS_LEFT : _bindgen_ty_369 = lgsvl_msgs__msg__VehicleStateData__BLINKERS_LEFT ; pub const BLINKERS_OFF : _bindgen_ty_368 = lgsvl_msgs__msg__VehicleStateData__BLINKERS_OFF ; pub const BLINKERS_RIGHT : _bindgen_ty_370 = lgsvl_msgs__msg__VehicleStateData__BLINKERS_RIGHT ; pub const GEAR_DRIVE : _bindgen_ty_380 = lgsvl_msgs__msg__VehicleStateData__GEAR_DRIVE ; pub const GEAR_LOW : _bindgen_ty_383 = lgsvl_msgs__msg__VehicleStateData__GEAR_LOW ; pub const GEAR_NEUTRAL : _bindgen_ty_379 = lgsvl_msgs__msg__VehicleStateData__GEAR_NEUTRAL ; pub const GEAR_PARKING : _bindgen_ty_382 = lgsvl_msgs__msg__VehicleStateData__GEAR_PARKING ; pub const GEAR_REVERSE : _bindgen_ty_381 = lgsvl_msgs__msg__VehicleStateData__GEAR_REVERSE ; pub const HEADLIGHTS_HIGH : _bindgen_ty_374 = lgsvl_msgs__msg__VehicleStateData__HEADLIGHTS_HIGH ; pub const HEADLIGHTS_LOW : _bindgen_ty_373 = lgsvl_msgs__msg__VehicleStateData__HEADLIGHTS_LOW ; pub const HEADLIGHTS_OFF : _bindgen_ty_372 = lgsvl_msgs__msg__VehicleStateData__HEADLIGHTS_OFF ; pub const VEHICLE_MODE_AUTO_SPEED_ONLY : _bindgen_ty_387 = lgsvl_msgs__msg__VehicleStateData__VEHICLE_MODE_AUTO_SPEED_ONLY ; pub const VEHICLE_MODE_AUTO_STEER_ONLY : _bindgen_ty_386 = lgsvl_msgs__msg__VehicleStateData__VEHICLE_MODE_AUTO_STEER_ONLY ; pub const VEHICLE_MODE_COMPLETE_AUTO_DRIVE : _bindgen_ty_385 = lgsvl_msgs__msg__VehicleStateData__VEHICLE_MODE_COMPLETE_AUTO_DRIVE ; pub const VEHICLE_MODE_COMPLETE_MANUAL : _bindgen_ty_384 = lgsvl_msgs__msg__VehicleStateData__VEHICLE_MODE_COMPLETE_MANUAL ; pub const VEHICLE_MODE_EMERGENCY_MODE : _bindgen_ty_388 = lgsvl_msgs__msg__VehicleStateData__VEHICLE_MODE_EMERGENCY_MODE ; pub const WIPERS_HIGH : _bindgen_ty_378 = lgsvl_msgs__msg__VehicleStateData__WIPERS_HIGH ; pub const WIPERS_LOW : _bindgen_ty_376 = lgsvl_msgs__msg__VehicleStateData__WIPERS_LOW ; pub const WIPERS_MED : _bindgen_ty_377 = lgsvl_msgs__msg__VehicleStateData__WIPERS_MED ; pub const WIPERS_OFF : _bindgen_ty_375 = lgsvl_msgs__msg__VehicleStateData__WIPERS_OFF ; } }