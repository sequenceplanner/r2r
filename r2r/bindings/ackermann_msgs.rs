pub mod msg { use super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct AckermannDrive { pub steering_angle : f32 , pub steering_angle_velocity : f32 , pub speed : f32 , pub acceleration : f32 , pub jerk : f32 } impl WrappedTypesupport for AckermannDrive { type CStruct = ackermann_msgs__msg__AckermannDrive ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ackermann_msgs__msg__AckermannDrive () } } fn create_msg () -> * mut ackermann_msgs__msg__AckermannDrive { unsafe { ackermann_msgs__msg__AckermannDrive__create () } } fn destroy_msg (msg : * mut ackermann_msgs__msg__AckermannDrive) -> () { unsafe { ackermann_msgs__msg__AckermannDrive__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> AckermannDrive { AckermannDrive { steering_angle : msg . steering_angle , steering_angle_velocity : msg . steering_angle_velocity , speed : msg . speed , acceleration : msg . acceleration , jerk : msg . jerk , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . steering_angle = self . steering_angle ; msg . steering_angle_velocity = self . steering_angle_velocity ; msg . speed = self . speed ; msg . acceleration = self . acceleration ; msg . jerk = self . jerk ; } } impl Default for AckermannDrive { fn default () -> Self { let msg_native = WrappedNativeMsg :: < AckermannDrive > :: new () ; AckermannDrive :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct AckermannDriveStamped { pub header : std_msgs :: msg :: Header , pub drive : ackermann_msgs :: msg :: AckermannDrive } impl WrappedTypesupport for AckermannDriveStamped { type CStruct = ackermann_msgs__msg__AckermannDriveStamped ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ackermann_msgs__msg__AckermannDriveStamped () } } fn create_msg () -> * mut ackermann_msgs__msg__AckermannDriveStamped { unsafe { ackermann_msgs__msg__AckermannDriveStamped__create () } } fn destroy_msg (msg : * mut ackermann_msgs__msg__AckermannDriveStamped) -> () { unsafe { ackermann_msgs__msg__AckermannDriveStamped__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> AckermannDriveStamped { AckermannDriveStamped { header : std_msgs :: msg :: Header :: from_native (& msg . header) , drive : ackermann_msgs :: msg :: AckermannDrive :: from_native (& msg . drive) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; self . drive . copy_to_native (& mut msg . drive) ; } } impl Default for AckermannDriveStamped { fn default () -> Self { let msg_native = WrappedNativeMsg :: < AckermannDriveStamped > :: new () ; AckermannDriveStamped :: from_native (& msg_native) } } }