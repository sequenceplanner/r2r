pub mod msg { use super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct UdpPacket { pub header : std_msgs :: msg :: Header , pub address : std :: string :: String , pub src_port : u16 , pub data : Vec < u8 > } impl WrappedTypesupport for UdpPacket { type CStruct = udp_msgs__msg__UdpPacket ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__udp_msgs__msg__UdpPacket () } } fn create_msg () -> * mut udp_msgs__msg__UdpPacket { unsafe { udp_msgs__msg__UdpPacket__create () } } fn destroy_msg (msg : * mut udp_msgs__msg__UdpPacket) -> () { unsafe { udp_msgs__msg__UdpPacket__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> UdpPacket { UdpPacket { header : std_msgs :: msg :: Header :: from_native (& msg . header) , address : msg . address . to_str () . to_owned () , src_port : msg . src_port , data : msg . data . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . address . assign (& self . address) ; msg . src_port = self . src_port ; msg . data . update (& self . data) ; } } impl Default for UdpPacket { fn default () -> Self { let msg_native = WrappedNativeMsg :: < UdpPacket > :: new () ; UdpPacket :: from_native (& msg_native) } } } pub mod srv { # [allow (non_snake_case)] pub mod UdpSend { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__udp_msgs__srv__UdpSend () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub local_address : std :: string :: String , pub local_port : u16 , pub remote_address : std :: string :: String , pub remote_port : u16 , pub data : Vec < u8 > } impl WrappedTypesupport for Request { type CStruct = udp_msgs__srv__UdpSend_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__udp_msgs__srv__UdpSend_Request () } } fn create_msg () -> * mut udp_msgs__srv__UdpSend_Request { unsafe { udp_msgs__srv__UdpSend_Request__create () } } fn destroy_msg (msg : * mut udp_msgs__srv__UdpSend_Request) -> () { unsafe { udp_msgs__srv__UdpSend_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { local_address : msg . local_address . to_str () . to_owned () , local_port : msg . local_port , remote_address : msg . remote_address . to_str () . to_owned () , remote_port : msg . remote_port , data : msg . data . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . local_address . assign (& self . local_address) ; msg . local_port = self . local_port ; msg . remote_address . assign (& self . remote_address) ; msg . remote_port = self . remote_port ; msg . data . update (& self . data) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub sent : bool } impl WrappedTypesupport for Response { type CStruct = udp_msgs__srv__UdpSend_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__udp_msgs__srv__UdpSend_Response () } } fn create_msg () -> * mut udp_msgs__srv__UdpSend_Response { unsafe { udp_msgs__srv__UdpSend_Response__create () } } fn destroy_msg (msg : * mut udp_msgs__srv__UdpSend_Response) -> () { unsafe { udp_msgs__srv__UdpSend_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { sent : msg . sent , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . sent = self . sent ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod UdpSocket { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__udp_msgs__srv__UdpSocket () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub local_address : std :: string :: String , pub local_port : u16 , pub remote_address : std :: string :: String , pub remote_port : u16 , pub is_broadcast : bool } impl WrappedTypesupport for Request { type CStruct = udp_msgs__srv__UdpSocket_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__udp_msgs__srv__UdpSocket_Request () } } fn create_msg () -> * mut udp_msgs__srv__UdpSocket_Request { unsafe { udp_msgs__srv__UdpSocket_Request__create () } } fn destroy_msg (msg : * mut udp_msgs__srv__UdpSocket_Request) -> () { unsafe { udp_msgs__srv__UdpSocket_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { local_address : msg . local_address . to_str () . to_owned () , local_port : msg . local_port , remote_address : msg . remote_address . to_str () . to_owned () , remote_port : msg . remote_port , is_broadcast : msg . is_broadcast , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . local_address . assign (& self . local_address) ; msg . local_port = self . local_port ; msg . remote_address . assign (& self . remote_address) ; msg . remote_port = self . remote_port ; msg . is_broadcast = self . is_broadcast ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub socket_created : bool } impl WrappedTypesupport for Response { type CStruct = udp_msgs__srv__UdpSocket_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__udp_msgs__srv__UdpSocket_Response () } } fn create_msg () -> * mut udp_msgs__srv__UdpSocket_Response { unsafe { udp_msgs__srv__UdpSocket_Response__create () } } fn destroy_msg (msg : * mut udp_msgs__srv__UdpSocket_Response) -> () { unsafe { udp_msgs__srv__UdpSocket_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { socket_created : msg . socket_created , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . socket_created = self . socket_created ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } }