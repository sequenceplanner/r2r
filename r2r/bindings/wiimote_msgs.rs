pub mod msg { use super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct IrSourceInfo { pub x : f64 , pub y : f64 , pub ir_size : i64 } impl WrappedTypesupport for IrSourceInfo { type CStruct = wiimote_msgs__msg__IrSourceInfo ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__wiimote_msgs__msg__IrSourceInfo () } } fn create_msg () -> * mut wiimote_msgs__msg__IrSourceInfo { unsafe { wiimote_msgs__msg__IrSourceInfo__create () } } fn destroy_msg (msg : * mut wiimote_msgs__msg__IrSourceInfo) -> () { unsafe { wiimote_msgs__msg__IrSourceInfo__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> IrSourceInfo { IrSourceInfo { x : msg . x , y : msg . y , ir_size : msg . ir_size , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . x = self . x ; msg . y = self . y ; msg . ir_size = self . ir_size ; } } impl Default for IrSourceInfo { fn default () -> Self { let msg_native = WrappedNativeMsg :: < IrSourceInfo > :: new () ; IrSourceInfo :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct State { pub header : std_msgs :: msg :: Header , pub angular_velocity_zeroed : geometry_msgs :: msg :: Vector3 , pub angular_velocity_raw : geometry_msgs :: msg :: Vector3 , pub angular_velocity_covariance : Vec < f64 > , pub linear_acceleration_zeroed : geometry_msgs :: msg :: Vector3 , pub linear_acceleration_raw : geometry_msgs :: msg :: Vector3 , pub linear_acceleration_covariance : Vec < f64 > , pub nunchuk_acceleration_zeroed : geometry_msgs :: msg :: Vector3 , pub nunchuk_acceleration_raw : geometry_msgs :: msg :: Vector3 , pub nunchuk_joystick_zeroed : Vec < f32 > , pub nunchuk_joystick_raw : Vec < f32 > , pub buttons : Vec < bool > , pub nunchuk_buttons : Vec < bool > , pub leds : Vec < bool > , pub rumble : bool , pub ir_tracking : Vec < wiimote_msgs :: msg :: IrSourceInfo > , pub raw_battery : f32 , pub percent_battery : f32 , pub zeroing_time : builtin_interfaces :: msg :: Time , pub errors : u64 } impl WrappedTypesupport for State { type CStruct = wiimote_msgs__msg__State ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__wiimote_msgs__msg__State () } } fn create_msg () -> * mut wiimote_msgs__msg__State { unsafe { wiimote_msgs__msg__State__create () } } fn destroy_msg (msg : * mut wiimote_msgs__msg__State) -> () { unsafe { wiimote_msgs__msg__State__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> State { State { header : std_msgs :: msg :: Header :: from_native (& msg . header) , angular_velocity_zeroed : geometry_msgs :: msg :: Vector3 :: from_native (& msg . angular_velocity_zeroed) , angular_velocity_raw : geometry_msgs :: msg :: Vector3 :: from_native (& msg . angular_velocity_raw) , angular_velocity_covariance : msg . angular_velocity_covariance . to_vec () , linear_acceleration_zeroed : geometry_msgs :: msg :: Vector3 :: from_native (& msg . linear_acceleration_zeroed) , linear_acceleration_raw : geometry_msgs :: msg :: Vector3 :: from_native (& msg . linear_acceleration_raw) , linear_acceleration_covariance : msg . linear_acceleration_covariance . to_vec () , nunchuk_acceleration_zeroed : geometry_msgs :: msg :: Vector3 :: from_native (& msg . nunchuk_acceleration_zeroed) , nunchuk_acceleration_raw : geometry_msgs :: msg :: Vector3 :: from_native (& msg . nunchuk_acceleration_raw) , nunchuk_joystick_zeroed : msg . nunchuk_joystick_zeroed . to_vec () , nunchuk_joystick_raw : msg . nunchuk_joystick_raw . to_vec () , buttons : msg . buttons . to_vec () , nunchuk_buttons : msg . nunchuk_buttons . to_vec () , leds : msg . leds . to_vec () , rumble : msg . rumble , ir_tracking : { let mut temp = Vec :: with_capacity (msg . ir_tracking . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . ir_tracking . data , msg . ir_tracking . size) } ; for s in slice { temp . push (wiimote_msgs :: msg :: IrSourceInfo :: from_native (s)) ; } temp } , raw_battery : msg . raw_battery , percent_battery : msg . percent_battery , zeroing_time : builtin_interfaces :: msg :: Time :: from_native (& msg . zeroing_time) , errors : msg . errors , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; self . angular_velocity_zeroed . copy_to_native (& mut msg . angular_velocity_zeroed) ; self . angular_velocity_raw . copy_to_native (& mut msg . angular_velocity_raw) ; assert_eq ! (self . angular_velocity_covariance . len () , 9usize , "Field {} is fixed size of {}!" , "angular_velocity_covariance" , 9usize) ; msg . angular_velocity_covariance . copy_from_slice (& self . angular_velocity_covariance [.. 9usize]) ; self . linear_acceleration_zeroed . copy_to_native (& mut msg . linear_acceleration_zeroed) ; self . linear_acceleration_raw . copy_to_native (& mut msg . linear_acceleration_raw) ; assert_eq ! (self . linear_acceleration_covariance . len () , 9usize , "Field {} is fixed size of {}!" , "linear_acceleration_covariance" , 9usize) ; msg . linear_acceleration_covariance . copy_from_slice (& self . linear_acceleration_covariance [.. 9usize]) ; self . nunchuk_acceleration_zeroed . copy_to_native (& mut msg . nunchuk_acceleration_zeroed) ; self . nunchuk_acceleration_raw . copy_to_native (& mut msg . nunchuk_acceleration_raw) ; assert_eq ! (self . nunchuk_joystick_zeroed . len () , 2usize , "Field {} is fixed size of {}!" , "nunchuk_joystick_zeroed" , 2usize) ; msg . nunchuk_joystick_zeroed . copy_from_slice (& self . nunchuk_joystick_zeroed [.. 2usize]) ; assert_eq ! (self . nunchuk_joystick_raw . len () , 2usize , "Field {} is fixed size of {}!" , "nunchuk_joystick_raw" , 2usize) ; msg . nunchuk_joystick_raw . copy_from_slice (& self . nunchuk_joystick_raw [.. 2usize]) ; assert_eq ! (self . buttons . len () , 11usize , "Field {} is fixed size of {}!" , "buttons" , 11usize) ; msg . buttons . copy_from_slice (& self . buttons [.. 11usize]) ; assert_eq ! (self . nunchuk_buttons . len () , 2usize , "Field {} is fixed size of {}!" , "nunchuk_buttons" , 2usize) ; msg . nunchuk_buttons . copy_from_slice (& self . nunchuk_buttons [.. 2usize]) ; assert_eq ! (self . leds . len () , 4usize , "Field {} is fixed size of {}!" , "leds" , 4usize) ; msg . leds . copy_from_slice (& self . leds [.. 4usize]) ; msg . rumble = self . rumble ; unsafe { wiimote_msgs__msg__IrSourceInfo__Sequence__fini (& mut msg . ir_tracking) ; wiimote_msgs__msg__IrSourceInfo__Sequence__init (& mut msg . ir_tracking , self . ir_tracking . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . ir_tracking . data , msg . ir_tracking . size) ; for (t , s) in slice . iter_mut () . zip (& self . ir_tracking) { s . copy_to_native (t) ; } } msg . raw_battery = self . raw_battery ; msg . percent_battery = self . percent_battery ; self . zeroing_time . copy_to_native (& mut msg . zeroing_time) ; msg . errors = self . errors ; } } impl Default for State { fn default () -> Self { let msg_native = WrappedNativeMsg :: < State > :: new () ; State :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl State { pub const INVALID : _bindgen_ty_2587 = wiimote_msgs__msg__State__INVALID ; pub const INVALID_FLOAT : f32 = wiimote_msgs__msg__State__INVALID_FLOAT ; pub const MSG_BTN_1 : _bindgen_ty_2588 = wiimote_msgs__msg__State__MSG_BTN_1 ; pub const MSG_BTN_2 : _bindgen_ty_2589 = wiimote_msgs__msg__State__MSG_BTN_2 ; pub const MSG_BTN_A : _bindgen_ty_2590 = wiimote_msgs__msg__State__MSG_BTN_A ; pub const MSG_BTN_B : _bindgen_ty_2591 = wiimote_msgs__msg__State__MSG_BTN_B ; pub const MSG_BTN_C : _bindgen_ty_2600 = wiimote_msgs__msg__State__MSG_BTN_C ; pub const MSG_BTN_DOWN : _bindgen_ty_2597 = wiimote_msgs__msg__State__MSG_BTN_DOWN ; pub const MSG_BTN_HOME : _bindgen_ty_2598 = wiimote_msgs__msg__State__MSG_BTN_HOME ; pub const MSG_BTN_LEFT : _bindgen_ty_2594 = wiimote_msgs__msg__State__MSG_BTN_LEFT ; pub const MSG_BTN_MINUS : _bindgen_ty_2593 = wiimote_msgs__msg__State__MSG_BTN_MINUS ; pub const MSG_BTN_PLUS : _bindgen_ty_2592 = wiimote_msgs__msg__State__MSG_BTN_PLUS ; pub const MSG_BTN_RIGHT : _bindgen_ty_2595 = wiimote_msgs__msg__State__MSG_BTN_RIGHT ; pub const MSG_BTN_UP : _bindgen_ty_2596 = wiimote_msgs__msg__State__MSG_BTN_UP ; pub const MSG_BTN_Z : _bindgen_ty_2599 = wiimote_msgs__msg__State__MSG_BTN_Z ; pub const MSG_CLASSIC_BTN_A : _bindgen_ty_2603 = wiimote_msgs__msg__State__MSG_CLASSIC_BTN_A ; pub const MSG_CLASSIC_BTN_B : _bindgen_ty_2604 = wiimote_msgs__msg__State__MSG_CLASSIC_BTN_B ; pub const MSG_CLASSIC_BTN_DOWN : _bindgen_ty_2610 = wiimote_msgs__msg__State__MSG_CLASSIC_BTN_DOWN ; pub const MSG_CLASSIC_BTN_HOME : _bindgen_ty_2611 = wiimote_msgs__msg__State__MSG_CLASSIC_BTN_HOME ; pub const MSG_CLASSIC_BTN_L : _bindgen_ty_2612 = wiimote_msgs__msg__State__MSG_CLASSIC_BTN_L ; pub const MSG_CLASSIC_BTN_LEFT : _bindgen_ty_2607 = wiimote_msgs__msg__State__MSG_CLASSIC_BTN_LEFT ; pub const MSG_CLASSIC_BTN_MINUS : _bindgen_ty_2606 = wiimote_msgs__msg__State__MSG_CLASSIC_BTN_MINUS ; pub const MSG_CLASSIC_BTN_PLUS : _bindgen_ty_2605 = wiimote_msgs__msg__State__MSG_CLASSIC_BTN_PLUS ; pub const MSG_CLASSIC_BTN_R : _bindgen_ty_2613 = wiimote_msgs__msg__State__MSG_CLASSIC_BTN_R ; pub const MSG_CLASSIC_BTN_RIGHT : _bindgen_ty_2608 = wiimote_msgs__msg__State__MSG_CLASSIC_BTN_RIGHT ; pub const MSG_CLASSIC_BTN_UP : _bindgen_ty_2609 = wiimote_msgs__msg__State__MSG_CLASSIC_BTN_UP ; pub const MSG_CLASSIC_BTN_X : _bindgen_ty_2601 = wiimote_msgs__msg__State__MSG_CLASSIC_BTN_X ; pub const MSG_CLASSIC_BTN_Y : _bindgen_ty_2602 = wiimote_msgs__msg__State__MSG_CLASSIC_BTN_Y ; pub const MSG_CLASSIC_BTN_ZL : _bindgen_ty_2614 = wiimote_msgs__msg__State__MSG_CLASSIC_BTN_ZL ; pub const MSG_CLASSIC_BTN_ZR : _bindgen_ty_2615 = wiimote_msgs__msg__State__MSG_CLASSIC_BTN_ZR ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct TimedSwitch { pub switch_mode : i8 , pub num_cycles : i32 , pub pulse_pattern : Vec < f32 > } impl WrappedTypesupport for TimedSwitch { type CStruct = wiimote_msgs__msg__TimedSwitch ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__wiimote_msgs__msg__TimedSwitch () } } fn create_msg () -> * mut wiimote_msgs__msg__TimedSwitch { unsafe { wiimote_msgs__msg__TimedSwitch__create () } } fn destroy_msg (msg : * mut wiimote_msgs__msg__TimedSwitch) -> () { unsafe { wiimote_msgs__msg__TimedSwitch__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> TimedSwitch { TimedSwitch { switch_mode : msg . switch_mode , num_cycles : msg . num_cycles , pulse_pattern : msg . pulse_pattern . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . switch_mode = self . switch_mode ; msg . num_cycles = self . num_cycles ; msg . pulse_pattern . update (& self . pulse_pattern) ; } } impl Default for TimedSwitch { fn default () -> Self { let msg_native = WrappedNativeMsg :: < TimedSwitch > :: new () ; TimedSwitch :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl TimedSwitch { pub const FOREVER : _bindgen_ty_2620 = wiimote_msgs__msg__TimedSwitch__FOREVER ; pub const NO_CHANGE : _bindgen_ty_2618 = wiimote_msgs__msg__TimedSwitch__NO_CHANGE ; pub const OFF : _bindgen_ty_2617 = wiimote_msgs__msg__TimedSwitch__OFF ; pub const ON : _bindgen_ty_2616 = wiimote_msgs__msg__TimedSwitch__ON ; pub const REPEAT : _bindgen_ty_2619 = wiimote_msgs__msg__TimedSwitch__REPEAT ; } }