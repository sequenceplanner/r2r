pub mod srv { # [allow (non_snake_case)] pub mod SmaccGetTransitionHistory { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__smacc2_msgs__srv__SmaccGetTransitionHistory () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { } impl WrappedTypesupport for Request { type CStruct = smacc2_msgs__srv__SmaccGetTransitionHistory_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__smacc2_msgs__srv__SmaccGetTransitionHistory_Request () } } fn create_msg () -> * mut smacc2_msgs__srv__SmaccGetTransitionHistory_Request { unsafe { smacc2_msgs__srv__SmaccGetTransitionHistory_Request__create () } } fn destroy_msg (msg : * mut smacc2_msgs__srv__SmaccGetTransitionHistory_Request) -> () { unsafe { smacc2_msgs__srv__SmaccGetTransitionHistory_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub history : Vec < smacc2_msgs :: msg :: SmaccTransitionLogEntry > } impl WrappedTypesupport for Response { type CStruct = smacc2_msgs__srv__SmaccGetTransitionHistory_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__smacc2_msgs__srv__SmaccGetTransitionHistory_Response () } } fn create_msg () -> * mut smacc2_msgs__srv__SmaccGetTransitionHistory_Response { unsafe { smacc2_msgs__srv__SmaccGetTransitionHistory_Response__create () } } fn destroy_msg (msg : * mut smacc2_msgs__srv__SmaccGetTransitionHistory_Response) -> () { unsafe { smacc2_msgs__srv__SmaccGetTransitionHistory_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { history : { let mut temp = Vec :: with_capacity (msg . history . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . history . data , msg . history . size) } ; for s in slice { temp . push (smacc2_msgs :: msg :: SmaccTransitionLogEntry :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { unsafe { smacc2_msgs__msg__SmaccTransitionLogEntry__Sequence__fini (& mut msg . history) ; smacc2_msgs__msg__SmaccTransitionLogEntry__Sequence__init (& mut msg . history , self . history . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . history . data , msg . history . size) ; for (t , s) in slice . iter_mut () . zip (& self . history) { s . copy_to_native (t) ; } } } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } } pub mod msg { use super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct SmaccContainerInitialStatusCmd { pub path : std :: string :: String , pub initial_states : Vec < std :: string :: String > , pub local_data : std :: string :: String } impl WrappedTypesupport for SmaccContainerInitialStatusCmd { type CStruct = smacc2_msgs__msg__SmaccContainerInitialStatusCmd ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__smacc2_msgs__msg__SmaccContainerInitialStatusCmd () } } fn create_msg () -> * mut smacc2_msgs__msg__SmaccContainerInitialStatusCmd { unsafe { smacc2_msgs__msg__SmaccContainerInitialStatusCmd__create () } } fn destroy_msg (msg : * mut smacc2_msgs__msg__SmaccContainerInitialStatusCmd) -> () { unsafe { smacc2_msgs__msg__SmaccContainerInitialStatusCmd__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> SmaccContainerInitialStatusCmd { SmaccContainerInitialStatusCmd { path : msg . path . to_str () . to_owned () , initial_states : msg . initial_states . to_vec () , local_data : msg . local_data . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . path . assign (& self . path) ; msg . initial_states . update (& self . initial_states) ; msg . local_data . assign (& self . local_data) ; } } impl Default for SmaccContainerInitialStatusCmd { fn default () -> Self { let msg_native = WrappedNativeMsg :: < SmaccContainerInitialStatusCmd > :: new () ; SmaccContainerInitialStatusCmd :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct SmaccContainerStatus { pub header : std_msgs :: msg :: Header , pub path : std :: string :: String , pub initial_states : Vec < std :: string :: String > , pub active_states : Vec < std :: string :: String > , pub local_data : std :: string :: String , pub info : std :: string :: String } impl WrappedTypesupport for SmaccContainerStatus { type CStruct = smacc2_msgs__msg__SmaccContainerStatus ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__smacc2_msgs__msg__SmaccContainerStatus () } } fn create_msg () -> * mut smacc2_msgs__msg__SmaccContainerStatus { unsafe { smacc2_msgs__msg__SmaccContainerStatus__create () } } fn destroy_msg (msg : * mut smacc2_msgs__msg__SmaccContainerStatus) -> () { unsafe { smacc2_msgs__msg__SmaccContainerStatus__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> SmaccContainerStatus { SmaccContainerStatus { header : std_msgs :: msg :: Header :: from_native (& msg . header) , path : msg . path . to_str () . to_owned () , initial_states : msg . initial_states . to_vec () , active_states : msg . active_states . to_vec () , local_data : msg . local_data . to_str () . to_owned () , info : msg . info . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . path . assign (& self . path) ; msg . initial_states . update (& self . initial_states) ; msg . active_states . update (& self . active_states) ; msg . local_data . assign (& self . local_data) ; msg . info . assign (& self . info) ; } } impl Default for SmaccContainerStatus { fn default () -> Self { let msg_native = WrappedNativeMsg :: < SmaccContainerStatus > :: new () ; SmaccContainerStatus :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct SmaccContainerStructure { pub header : std_msgs :: msg :: Header , pub path : std :: string :: String , pub children : Vec < std :: string :: String > , pub internal_outcomes : Vec < std :: string :: String > , pub outcomes_from : Vec < std :: string :: String > , pub outcomes_to : Vec < std :: string :: String > , pub container_outcomes : Vec < std :: string :: String > } impl WrappedTypesupport for SmaccContainerStructure { type CStruct = smacc2_msgs__msg__SmaccContainerStructure ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__smacc2_msgs__msg__SmaccContainerStructure () } } fn create_msg () -> * mut smacc2_msgs__msg__SmaccContainerStructure { unsafe { smacc2_msgs__msg__SmaccContainerStructure__create () } } fn destroy_msg (msg : * mut smacc2_msgs__msg__SmaccContainerStructure) -> () { unsafe { smacc2_msgs__msg__SmaccContainerStructure__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> SmaccContainerStructure { SmaccContainerStructure { header : std_msgs :: msg :: Header :: from_native (& msg . header) , path : msg . path . to_str () . to_owned () , children : msg . children . to_vec () , internal_outcomes : msg . internal_outcomes . to_vec () , outcomes_from : msg . outcomes_from . to_vec () , outcomes_to : msg . outcomes_to . to_vec () , container_outcomes : msg . container_outcomes . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . path . assign (& self . path) ; msg . children . update (& self . children) ; msg . internal_outcomes . update (& self . internal_outcomes) ; msg . outcomes_from . update (& self . outcomes_from) ; msg . outcomes_to . update (& self . outcomes_to) ; msg . container_outcomes . update (& self . container_outcomes) ; } } impl Default for SmaccContainerStructure { fn default () -> Self { let msg_native = WrappedNativeMsg :: < SmaccContainerStructure > :: new () ; SmaccContainerStructure :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct SmaccEvent { pub event_type : std :: string :: String , pub event_object_tag : std :: string :: String , pub event_source : std :: string :: String , pub label : std :: string :: String } impl WrappedTypesupport for SmaccEvent { type CStruct = smacc2_msgs__msg__SmaccEvent ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__smacc2_msgs__msg__SmaccEvent () } } fn create_msg () -> * mut smacc2_msgs__msg__SmaccEvent { unsafe { smacc2_msgs__msg__SmaccEvent__create () } } fn destroy_msg (msg : * mut smacc2_msgs__msg__SmaccEvent) -> () { unsafe { smacc2_msgs__msg__SmaccEvent__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> SmaccEvent { SmaccEvent { event_type : msg . event_type . to_str () . to_owned () , event_object_tag : msg . event_object_tag . to_str () . to_owned () , event_source : msg . event_source . to_str () . to_owned () , label : msg . label . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . event_type . assign (& self . event_type) ; msg . event_object_tag . assign (& self . event_object_tag) ; msg . event_source . assign (& self . event_source) ; msg . label . assign (& self . label) ; } } impl Default for SmaccEvent { fn default () -> Self { let msg_native = WrappedNativeMsg :: < SmaccEvent > :: new () ; SmaccEvent :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct SmaccEventGenerator { pub index : i32 , pub type_name : std :: string :: String , pub object_tag : std :: string :: String } impl WrappedTypesupport for SmaccEventGenerator { type CStruct = smacc2_msgs__msg__SmaccEventGenerator ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__smacc2_msgs__msg__SmaccEventGenerator () } } fn create_msg () -> * mut smacc2_msgs__msg__SmaccEventGenerator { unsafe { smacc2_msgs__msg__SmaccEventGenerator__create () } } fn destroy_msg (msg : * mut smacc2_msgs__msg__SmaccEventGenerator) -> () { unsafe { smacc2_msgs__msg__SmaccEventGenerator__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> SmaccEventGenerator { SmaccEventGenerator { index : msg . index , type_name : msg . type_name . to_str () . to_owned () , object_tag : msg . object_tag . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . index = self . index ; msg . type_name . assign (& self . type_name) ; msg . object_tag . assign (& self . object_tag) ; } } impl Default for SmaccEventGenerator { fn default () -> Self { let msg_native = WrappedNativeMsg :: < SmaccEventGenerator > :: new () ; SmaccEventGenerator :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct SmaccOrthogonal { pub name : std :: string :: String , pub client_behavior_names : Vec < std :: string :: String > , pub client_names : Vec < std :: string :: String > } impl WrappedTypesupport for SmaccOrthogonal { type CStruct = smacc2_msgs__msg__SmaccOrthogonal ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__smacc2_msgs__msg__SmaccOrthogonal () } } fn create_msg () -> * mut smacc2_msgs__msg__SmaccOrthogonal { unsafe { smacc2_msgs__msg__SmaccOrthogonal__create () } } fn destroy_msg (msg : * mut smacc2_msgs__msg__SmaccOrthogonal) -> () { unsafe { smacc2_msgs__msg__SmaccOrthogonal__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> SmaccOrthogonal { SmaccOrthogonal { name : msg . name . to_str () . to_owned () , client_behavior_names : msg . client_behavior_names . to_vec () , client_names : msg . client_names . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . name . assign (& self . name) ; msg . client_behavior_names . update (& self . client_behavior_names) ; msg . client_names . update (& self . client_names) ; } } impl Default for SmaccOrthogonal { fn default () -> Self { let msg_native = WrappedNativeMsg :: < SmaccOrthogonal > :: new () ; SmaccOrthogonal :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct SmaccSMCommand { pub command : i8 } impl WrappedTypesupport for SmaccSMCommand { type CStruct = smacc2_msgs__msg__SmaccSMCommand ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__smacc2_msgs__msg__SmaccSMCommand () } } fn create_msg () -> * mut smacc2_msgs__msg__SmaccSMCommand { unsafe { smacc2_msgs__msg__SmaccSMCommand__create () } } fn destroy_msg (msg : * mut smacc2_msgs__msg__SmaccSMCommand) -> () { unsafe { smacc2_msgs__msg__SmaccSMCommand__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> SmaccSMCommand { SmaccSMCommand { command : msg . command , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . command = self . command ; } } impl Default for SmaccSMCommand { fn default () -> Self { let msg_native = WrappedNativeMsg :: < SmaccSMCommand > :: new () ; SmaccSMCommand :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl SmaccSMCommand { pub const E_STOP : _bindgen_ty_1664 = smacc2_msgs__msg__SmaccSMCommand__E_STOP ; pub const SM_RESET : _bindgen_ty_1665 = smacc2_msgs__msg__SmaccSMCommand__SM_RESET ; pub const SM_STOP : _bindgen_ty_1663 = smacc2_msgs__msg__SmaccSMCommand__SM_STOP ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct SmaccState { pub index : i32 , pub name : std :: string :: String , pub children_states : Vec < std :: string :: String > , pub level : i8 , pub transitions : Vec < smacc2_msgs :: msg :: SmaccTransition > , pub orthogonals : Vec < smacc2_msgs :: msg :: SmaccOrthogonal > , pub state_reactors : Vec < smacc2_msgs :: msg :: SmaccStateReactor > , pub event_generators : Vec < smacc2_msgs :: msg :: SmaccEventGenerator > } impl WrappedTypesupport for SmaccState { type CStruct = smacc2_msgs__msg__SmaccState ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__smacc2_msgs__msg__SmaccState () } } fn create_msg () -> * mut smacc2_msgs__msg__SmaccState { unsafe { smacc2_msgs__msg__SmaccState__create () } } fn destroy_msg (msg : * mut smacc2_msgs__msg__SmaccState) -> () { unsafe { smacc2_msgs__msg__SmaccState__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> SmaccState { SmaccState { index : msg . index , name : msg . name . to_str () . to_owned () , children_states : msg . children_states . to_vec () , level : msg . level , transitions : { let mut temp = Vec :: with_capacity (msg . transitions . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . transitions . data , msg . transitions . size) } ; for s in slice { temp . push (smacc2_msgs :: msg :: SmaccTransition :: from_native (s)) ; } temp } , orthogonals : { let mut temp = Vec :: with_capacity (msg . orthogonals . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . orthogonals . data , msg . orthogonals . size) } ; for s in slice { temp . push (smacc2_msgs :: msg :: SmaccOrthogonal :: from_native (s)) ; } temp } , state_reactors : { let mut temp = Vec :: with_capacity (msg . state_reactors . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . state_reactors . data , msg . state_reactors . size) } ; for s in slice { temp . push (smacc2_msgs :: msg :: SmaccStateReactor :: from_native (s)) ; } temp } , event_generators : { let mut temp = Vec :: with_capacity (msg . event_generators . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . event_generators . data , msg . event_generators . size) } ; for s in slice { temp . push (smacc2_msgs :: msg :: SmaccEventGenerator :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . index = self . index ; msg . name . assign (& self . name) ; msg . children_states . update (& self . children_states) ; msg . level = self . level ; unsafe { smacc2_msgs__msg__SmaccTransition__Sequence__fini (& mut msg . transitions) ; smacc2_msgs__msg__SmaccTransition__Sequence__init (& mut msg . transitions , self . transitions . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . transitions . data , msg . transitions . size) ; for (t , s) in slice . iter_mut () . zip (& self . transitions) { s . copy_to_native (t) ; } } unsafe { smacc2_msgs__msg__SmaccOrthogonal__Sequence__fini (& mut msg . orthogonals) ; smacc2_msgs__msg__SmaccOrthogonal__Sequence__init (& mut msg . orthogonals , self . orthogonals . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . orthogonals . data , msg . orthogonals . size) ; for (t , s) in slice . iter_mut () . zip (& self . orthogonals) { s . copy_to_native (t) ; } } unsafe { smacc2_msgs__msg__SmaccStateReactor__Sequence__fini (& mut msg . state_reactors) ; smacc2_msgs__msg__SmaccStateReactor__Sequence__init (& mut msg . state_reactors , self . state_reactors . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . state_reactors . data , msg . state_reactors . size) ; for (t , s) in slice . iter_mut () . zip (& self . state_reactors) { s . copy_to_native (t) ; } } unsafe { smacc2_msgs__msg__SmaccEventGenerator__Sequence__fini (& mut msg . event_generators) ; smacc2_msgs__msg__SmaccEventGenerator__Sequence__init (& mut msg . event_generators , self . event_generators . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . event_generators . data , msg . event_generators . size) ; for (t , s) in slice . iter_mut () . zip (& self . event_generators) { s . copy_to_native (t) ; } } } } impl Default for SmaccState { fn default () -> Self { let msg_native = WrappedNativeMsg :: < SmaccState > :: new () ; SmaccState :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct SmaccStateMachine { pub states : Vec < smacc2_msgs :: msg :: SmaccState > } impl WrappedTypesupport for SmaccStateMachine { type CStruct = smacc2_msgs__msg__SmaccStateMachine ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__smacc2_msgs__msg__SmaccStateMachine () } } fn create_msg () -> * mut smacc2_msgs__msg__SmaccStateMachine { unsafe { smacc2_msgs__msg__SmaccStateMachine__create () } } fn destroy_msg (msg : * mut smacc2_msgs__msg__SmaccStateMachine) -> () { unsafe { smacc2_msgs__msg__SmaccStateMachine__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> SmaccStateMachine { SmaccStateMachine { states : { let mut temp = Vec :: with_capacity (msg . states . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . states . data , msg . states . size) } ; for s in slice { temp . push (smacc2_msgs :: msg :: SmaccState :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { unsafe { smacc2_msgs__msg__SmaccState__Sequence__fini (& mut msg . states) ; smacc2_msgs__msg__SmaccState__Sequence__init (& mut msg . states , self . states . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . states . data , msg . states . size) ; for (t , s) in slice . iter_mut () . zip (& self . states) { s . copy_to_native (t) ; } } } } impl Default for SmaccStateMachine { fn default () -> Self { let msg_native = WrappedNativeMsg :: < SmaccStateMachine > :: new () ; SmaccStateMachine :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct SmaccStateReactor { pub index : i32 , pub type_name : std :: string :: String , pub object_tag : std :: string :: String , pub event_sources : Vec < smacc2_msgs :: msg :: SmaccEvent > } impl WrappedTypesupport for SmaccStateReactor { type CStruct = smacc2_msgs__msg__SmaccStateReactor ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__smacc2_msgs__msg__SmaccStateReactor () } } fn create_msg () -> * mut smacc2_msgs__msg__SmaccStateReactor { unsafe { smacc2_msgs__msg__SmaccStateReactor__create () } } fn destroy_msg (msg : * mut smacc2_msgs__msg__SmaccStateReactor) -> () { unsafe { smacc2_msgs__msg__SmaccStateReactor__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> SmaccStateReactor { SmaccStateReactor { index : msg . index , type_name : msg . type_name . to_str () . to_owned () , object_tag : msg . object_tag . to_str () . to_owned () , event_sources : { let mut temp = Vec :: with_capacity (msg . event_sources . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . event_sources . data , msg . event_sources . size) } ; for s in slice { temp . push (smacc2_msgs :: msg :: SmaccEvent :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . index = self . index ; msg . type_name . assign (& self . type_name) ; msg . object_tag . assign (& self . object_tag) ; unsafe { smacc2_msgs__msg__SmaccEvent__Sequence__fini (& mut msg . event_sources) ; smacc2_msgs__msg__SmaccEvent__Sequence__init (& mut msg . event_sources , self . event_sources . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . event_sources . data , msg . event_sources . size) ; for (t , s) in slice . iter_mut () . zip (& self . event_sources) { s . copy_to_native (t) ; } } } } impl Default for SmaccStateReactor { fn default () -> Self { let msg_native = WrappedNativeMsg :: < SmaccStateReactor > :: new () ; SmaccStateReactor :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct SmaccStatus { pub header : std_msgs :: msg :: Header , pub current_states : Vec < std :: string :: String > , pub global_variable_names : Vec < std :: string :: String > , pub global_variable_values : Vec < std :: string :: String > } impl WrappedTypesupport for SmaccStatus { type CStruct = smacc2_msgs__msg__SmaccStatus ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__smacc2_msgs__msg__SmaccStatus () } } fn create_msg () -> * mut smacc2_msgs__msg__SmaccStatus { unsafe { smacc2_msgs__msg__SmaccStatus__create () } } fn destroy_msg (msg : * mut smacc2_msgs__msg__SmaccStatus) -> () { unsafe { smacc2_msgs__msg__SmaccStatus__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> SmaccStatus { SmaccStatus { header : std_msgs :: msg :: Header :: from_native (& msg . header) , current_states : msg . current_states . to_vec () , global_variable_names : msg . global_variable_names . to_vec () , global_variable_values : msg . global_variable_values . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . current_states . update (& self . current_states) ; msg . global_variable_names . update (& self . global_variable_names) ; msg . global_variable_values . update (& self . global_variable_values) ; } } impl Default for SmaccStatus { fn default () -> Self { let msg_native = WrappedNativeMsg :: < SmaccStatus > :: new () ; SmaccStatus :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct SmaccTransition { pub index : i32 , pub transition_name : std :: string :: String , pub transition_type : std :: string :: String , pub destiny_state_name : std :: string :: String , pub source_state_name : std :: string :: String , pub history_node : bool , pub event : smacc2_msgs :: msg :: SmaccEvent } impl WrappedTypesupport for SmaccTransition { type CStruct = smacc2_msgs__msg__SmaccTransition ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__smacc2_msgs__msg__SmaccTransition () } } fn create_msg () -> * mut smacc2_msgs__msg__SmaccTransition { unsafe { smacc2_msgs__msg__SmaccTransition__create () } } fn destroy_msg (msg : * mut smacc2_msgs__msg__SmaccTransition) -> () { unsafe { smacc2_msgs__msg__SmaccTransition__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> SmaccTransition { SmaccTransition { index : msg . index , transition_name : msg . transition_name . to_str () . to_owned () , transition_type : msg . transition_type . to_str () . to_owned () , destiny_state_name : msg . destiny_state_name . to_str () . to_owned () , source_state_name : msg . source_state_name . to_str () . to_owned () , history_node : msg . history_node , event : smacc2_msgs :: msg :: SmaccEvent :: from_native (& msg . event) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . index = self . index ; msg . transition_name . assign (& self . transition_name) ; msg . transition_type . assign (& self . transition_type) ; msg . destiny_state_name . assign (& self . destiny_state_name) ; msg . source_state_name . assign (& self . source_state_name) ; msg . history_node = self . history_node ; self . event . copy_to_native (& mut msg . event) ; } } impl Default for SmaccTransition { fn default () -> Self { let msg_native = WrappedNativeMsg :: < SmaccTransition > :: new () ; SmaccTransition :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct SmaccTransitionLogEntry { pub timestamp : builtin_interfaces :: msg :: Time , pub transition : smacc2_msgs :: msg :: SmaccTransition } impl WrappedTypesupport for SmaccTransitionLogEntry { type CStruct = smacc2_msgs__msg__SmaccTransitionLogEntry ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__smacc2_msgs__msg__SmaccTransitionLogEntry () } } fn create_msg () -> * mut smacc2_msgs__msg__SmaccTransitionLogEntry { unsafe { smacc2_msgs__msg__SmaccTransitionLogEntry__create () } } fn destroy_msg (msg : * mut smacc2_msgs__msg__SmaccTransitionLogEntry) -> () { unsafe { smacc2_msgs__msg__SmaccTransitionLogEntry__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> SmaccTransitionLogEntry { SmaccTransitionLogEntry { timestamp : builtin_interfaces :: msg :: Time :: from_native (& msg . timestamp) , transition : smacc2_msgs :: msg :: SmaccTransition :: from_native (& msg . transition) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . timestamp . copy_to_native (& mut msg . timestamp) ; self . transition . copy_to_native (& mut msg . transition) ; } } impl Default for SmaccTransitionLogEntry { fn default () -> Self { let msg_native = WrappedNativeMsg :: < SmaccTransitionLogEntry > :: new () ; SmaccTransitionLogEntry :: from_native (& msg_native) } } }