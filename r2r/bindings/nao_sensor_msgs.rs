pub mod msg { use super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Accelerometer { pub x : f32 , pub y : f32 , pub z : f32 } impl WrappedTypesupport for Accelerometer { type CStruct = nao_sensor_msgs__msg__Accelerometer ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__nao_sensor_msgs__msg__Accelerometer () } } fn create_msg () -> * mut nao_sensor_msgs__msg__Accelerometer { unsafe { nao_sensor_msgs__msg__Accelerometer__create () } } fn destroy_msg (msg : * mut nao_sensor_msgs__msg__Accelerometer) -> () { unsafe { nao_sensor_msgs__msg__Accelerometer__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Accelerometer { Accelerometer { x : msg . x , y : msg . y , z : msg . z , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . x = self . x ; msg . y = self . y ; msg . z = self . z ; } } impl Default for Accelerometer { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Accelerometer > :: new () ; Accelerometer :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Angle { pub x : f32 , pub y : f32 } impl WrappedTypesupport for Angle { type CStruct = nao_sensor_msgs__msg__Angle ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__nao_sensor_msgs__msg__Angle () } } fn create_msg () -> * mut nao_sensor_msgs__msg__Angle { unsafe { nao_sensor_msgs__msg__Angle__create () } } fn destroy_msg (msg : * mut nao_sensor_msgs__msg__Angle) -> () { unsafe { nao_sensor_msgs__msg__Angle__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Angle { Angle { x : msg . x , y : msg . y , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . x = self . x ; msg . y = self . y ; } } impl Default for Angle { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Angle > :: new () ; Angle :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Battery { pub charge : f32 , pub charging : bool , pub current : f32 , pub temperature : f32 } impl WrappedTypesupport for Battery { type CStruct = nao_sensor_msgs__msg__Battery ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__nao_sensor_msgs__msg__Battery () } } fn create_msg () -> * mut nao_sensor_msgs__msg__Battery { unsafe { nao_sensor_msgs__msg__Battery__create () } } fn destroy_msg (msg : * mut nao_sensor_msgs__msg__Battery) -> () { unsafe { nao_sensor_msgs__msg__Battery__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Battery { Battery { charge : msg . charge , charging : msg . charging , current : msg . current , temperature : msg . temperature , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . charge = self . charge ; msg . charging = self . charging ; msg . current = self . current ; msg . temperature = self . temperature ; } } impl Default for Battery { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Battery > :: new () ; Battery :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Buttons { pub chest : bool , pub l_foot_bumper_left : bool , pub l_foot_bumper_right : bool , pub r_foot_bumper_left : bool , pub r_foot_bumper_right : bool } impl WrappedTypesupport for Buttons { type CStruct = nao_sensor_msgs__msg__Buttons ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__nao_sensor_msgs__msg__Buttons () } } fn create_msg () -> * mut nao_sensor_msgs__msg__Buttons { unsafe { nao_sensor_msgs__msg__Buttons__create () } } fn destroy_msg (msg : * mut nao_sensor_msgs__msg__Buttons) -> () { unsafe { nao_sensor_msgs__msg__Buttons__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Buttons { Buttons { chest : msg . chest , l_foot_bumper_left : msg . l_foot_bumper_left , l_foot_bumper_right : msg . l_foot_bumper_right , r_foot_bumper_left : msg . r_foot_bumper_left , r_foot_bumper_right : msg . r_foot_bumper_right , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . chest = self . chest ; msg . l_foot_bumper_left = self . l_foot_bumper_left ; msg . l_foot_bumper_right = self . l_foot_bumper_right ; msg . r_foot_bumper_left = self . r_foot_bumper_left ; msg . r_foot_bumper_right = self . r_foot_bumper_right ; } } impl Default for Buttons { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Buttons > :: new () ; Buttons :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct FSR { pub l_foot_front_left : f32 , pub l_foot_front_right : f32 , pub l_foot_back_left : f32 , pub l_foot_back_right : f32 , pub r_foot_front_left : f32 , pub r_foot_front_right : f32 , pub r_foot_back_left : f32 , pub r_foot_back_right : f32 } impl WrappedTypesupport for FSR { type CStruct = nao_sensor_msgs__msg__FSR ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__nao_sensor_msgs__msg__FSR () } } fn create_msg () -> * mut nao_sensor_msgs__msg__FSR { unsafe { nao_sensor_msgs__msg__FSR__create () } } fn destroy_msg (msg : * mut nao_sensor_msgs__msg__FSR) -> () { unsafe { nao_sensor_msgs__msg__FSR__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> FSR { FSR { l_foot_front_left : msg . l_foot_front_left , l_foot_front_right : msg . l_foot_front_right , l_foot_back_left : msg . l_foot_back_left , l_foot_back_right : msg . l_foot_back_right , r_foot_front_left : msg . r_foot_front_left , r_foot_front_right : msg . r_foot_front_right , r_foot_back_left : msg . r_foot_back_left , r_foot_back_right : msg . r_foot_back_right , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . l_foot_front_left = self . l_foot_front_left ; msg . l_foot_front_right = self . l_foot_front_right ; msg . l_foot_back_left = self . l_foot_back_left ; msg . l_foot_back_right = self . l_foot_back_right ; msg . r_foot_front_left = self . r_foot_front_left ; msg . r_foot_front_right = self . r_foot_front_right ; msg . r_foot_back_left = self . r_foot_back_left ; msg . r_foot_back_right = self . r_foot_back_right ; } } impl Default for FSR { fn default () -> Self { let msg_native = WrappedNativeMsg :: < FSR > :: new () ; FSR :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Gyroscope { pub x : f32 , pub y : f32 , pub z : f32 } impl WrappedTypesupport for Gyroscope { type CStruct = nao_sensor_msgs__msg__Gyroscope ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__nao_sensor_msgs__msg__Gyroscope () } } fn create_msg () -> * mut nao_sensor_msgs__msg__Gyroscope { unsafe { nao_sensor_msgs__msg__Gyroscope__create () } } fn destroy_msg (msg : * mut nao_sensor_msgs__msg__Gyroscope) -> () { unsafe { nao_sensor_msgs__msg__Gyroscope__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Gyroscope { Gyroscope { x : msg . x , y : msg . y , z : msg . z , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . x = self . x ; msg . y = self . y ; msg . z = self . z ; } } impl Default for Gyroscope { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Gyroscope > :: new () ; Gyroscope :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct JointCurrents { pub currents : Vec < f32 > } impl WrappedTypesupport for JointCurrents { type CStruct = nao_sensor_msgs__msg__JointCurrents ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__nao_sensor_msgs__msg__JointCurrents () } } fn create_msg () -> * mut nao_sensor_msgs__msg__JointCurrents { unsafe { nao_sensor_msgs__msg__JointCurrents__create () } } fn destroy_msg (msg : * mut nao_sensor_msgs__msg__JointCurrents) -> () { unsafe { nao_sensor_msgs__msg__JointCurrents__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> JointCurrents { JointCurrents { currents : msg . currents . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { assert_eq ! (self . currents . len () , 25usize , "Field {} is fixed size of {}!" , "currents" , 25usize) ; msg . currents . copy_from_slice (& self . currents [.. 25usize]) ; } } impl Default for JointCurrents { fn default () -> Self { let msg_native = WrappedNativeMsg :: < JointCurrents > :: new () ; JointCurrents :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct JointIndexes { } impl WrappedTypesupport for JointIndexes { type CStruct = nao_sensor_msgs__msg__JointIndexes ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__nao_sensor_msgs__msg__JointIndexes () } } fn create_msg () -> * mut nao_sensor_msgs__msg__JointIndexes { unsafe { nao_sensor_msgs__msg__JointIndexes__create () } } fn destroy_msg (msg : * mut nao_sensor_msgs__msg__JointIndexes) -> () { unsafe { nao_sensor_msgs__msg__JointIndexes__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> JointIndexes { JointIndexes { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for JointIndexes { fn default () -> Self { let msg_native = WrappedNativeMsg :: < JointIndexes > :: new () ; JointIndexes :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl JointIndexes { pub const HEADPITCH : _bindgen_ty_1054 = nao_sensor_msgs__msg__JointIndexes__HEADPITCH ; pub const HEADYAW : _bindgen_ty_1053 = nao_sensor_msgs__msg__JointIndexes__HEADYAW ; pub const LANKLEPITCH : _bindgen_ty_1064 = nao_sensor_msgs__msg__JointIndexes__LANKLEPITCH ; pub const LANKLEROLL : _bindgen_ty_1065 = nao_sensor_msgs__msg__JointIndexes__LANKLEROLL ; pub const LELBOWROLL : _bindgen_ty_1058 = nao_sensor_msgs__msg__JointIndexes__LELBOWROLL ; pub const LELBOWYAW : _bindgen_ty_1057 = nao_sensor_msgs__msg__JointIndexes__LELBOWYAW ; pub const LHAND : _bindgen_ty_1076 = nao_sensor_msgs__msg__JointIndexes__LHAND ; pub const LHIPPITCH : _bindgen_ty_1062 = nao_sensor_msgs__msg__JointIndexes__LHIPPITCH ; pub const LHIPROLL : _bindgen_ty_1061 = nao_sensor_msgs__msg__JointIndexes__LHIPROLL ; pub const LHIPYAWPITCH : _bindgen_ty_1060 = nao_sensor_msgs__msg__JointIndexes__LHIPYAWPITCH ; pub const LKNEEPITCH : _bindgen_ty_1063 = nao_sensor_msgs__msg__JointIndexes__LKNEEPITCH ; pub const LSHOULDERPITCH : _bindgen_ty_1055 = nao_sensor_msgs__msg__JointIndexes__LSHOULDERPITCH ; pub const LSHOULDERROLL : _bindgen_ty_1056 = nao_sensor_msgs__msg__JointIndexes__LSHOULDERROLL ; pub const LWRISTYAW : _bindgen_ty_1059 = nao_sensor_msgs__msg__JointIndexes__LWRISTYAW ; pub const NUMJOINTS : _bindgen_ty_1078 = nao_sensor_msgs__msg__JointIndexes__NUMJOINTS ; pub const RANKLEPITCH : _bindgen_ty_1069 = nao_sensor_msgs__msg__JointIndexes__RANKLEPITCH ; pub const RANKLEROLL : _bindgen_ty_1070 = nao_sensor_msgs__msg__JointIndexes__RANKLEROLL ; pub const RELBOWROLL : _bindgen_ty_1074 = nao_sensor_msgs__msg__JointIndexes__RELBOWROLL ; pub const RELBOWYAW : _bindgen_ty_1073 = nao_sensor_msgs__msg__JointIndexes__RELBOWYAW ; pub const RHAND : _bindgen_ty_1077 = nao_sensor_msgs__msg__JointIndexes__RHAND ; pub const RHIPPITCH : _bindgen_ty_1067 = nao_sensor_msgs__msg__JointIndexes__RHIPPITCH ; pub const RHIPROLL : _bindgen_ty_1066 = nao_sensor_msgs__msg__JointIndexes__RHIPROLL ; pub const RKNEEPITCH : _bindgen_ty_1068 = nao_sensor_msgs__msg__JointIndexes__RKNEEPITCH ; pub const RSHOULDERPITCH : _bindgen_ty_1071 = nao_sensor_msgs__msg__JointIndexes__RSHOULDERPITCH ; pub const RSHOULDERROLL : _bindgen_ty_1072 = nao_sensor_msgs__msg__JointIndexes__RSHOULDERROLL ; pub const RWRISTYAW : _bindgen_ty_1075 = nao_sensor_msgs__msg__JointIndexes__RWRISTYAW ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct JointPositions { pub positions : Vec < f32 > } impl WrappedTypesupport for JointPositions { type CStruct = nao_sensor_msgs__msg__JointPositions ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__nao_sensor_msgs__msg__JointPositions () } } fn create_msg () -> * mut nao_sensor_msgs__msg__JointPositions { unsafe { nao_sensor_msgs__msg__JointPositions__create () } } fn destroy_msg (msg : * mut nao_sensor_msgs__msg__JointPositions) -> () { unsafe { nao_sensor_msgs__msg__JointPositions__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> JointPositions { JointPositions { positions : msg . positions . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { assert_eq ! (self . positions . len () , 25usize , "Field {} is fixed size of {}!" , "positions" , 25usize) ; msg . positions . copy_from_slice (& self . positions [.. 25usize]) ; } } impl Default for JointPositions { fn default () -> Self { let msg_native = WrappedNativeMsg :: < JointPositions > :: new () ; JointPositions :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct JointStatuses { pub statuses : Vec < i32 > } impl WrappedTypesupport for JointStatuses { type CStruct = nao_sensor_msgs__msg__JointStatuses ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__nao_sensor_msgs__msg__JointStatuses () } } fn create_msg () -> * mut nao_sensor_msgs__msg__JointStatuses { unsafe { nao_sensor_msgs__msg__JointStatuses__create () } } fn destroy_msg (msg : * mut nao_sensor_msgs__msg__JointStatuses) -> () { unsafe { nao_sensor_msgs__msg__JointStatuses__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> JointStatuses { JointStatuses { statuses : msg . statuses . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { assert_eq ! (self . statuses . len () , 25usize , "Field {} is fixed size of {}!" , "statuses" , 25usize) ; msg . statuses . copy_from_slice (& self . statuses [.. 25usize]) ; } } impl Default for JointStatuses { fn default () -> Self { let msg_native = WrappedNativeMsg :: < JointStatuses > :: new () ; JointStatuses :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl JointStatuses { pub const STATUS_CRITICALLY_HOT : _bindgen_ty_1082 = nao_sensor_msgs__msg__JointStatuses__STATUS_CRITICALLY_HOT ; pub const STATUS_HOT : _bindgen_ty_1080 = nao_sensor_msgs__msg__JointStatuses__STATUS_HOT ; pub const STATUS_NORMAL : _bindgen_ty_1079 = nao_sensor_msgs__msg__JointStatuses__STATUS_NORMAL ; pub const STATUS_VERY_HOT : _bindgen_ty_1081 = nao_sensor_msgs__msg__JointStatuses__STATUS_VERY_HOT ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct JointStiffnesses { pub stiffnesses : Vec < f32 > } impl WrappedTypesupport for JointStiffnesses { type CStruct = nao_sensor_msgs__msg__JointStiffnesses ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__nao_sensor_msgs__msg__JointStiffnesses () } } fn create_msg () -> * mut nao_sensor_msgs__msg__JointStiffnesses { unsafe { nao_sensor_msgs__msg__JointStiffnesses__create () } } fn destroy_msg (msg : * mut nao_sensor_msgs__msg__JointStiffnesses) -> () { unsafe { nao_sensor_msgs__msg__JointStiffnesses__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> JointStiffnesses { JointStiffnesses { stiffnesses : msg . stiffnesses . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { assert_eq ! (self . stiffnesses . len () , 25usize , "Field {} is fixed size of {}!" , "stiffnesses" , 25usize) ; msg . stiffnesses . copy_from_slice (& self . stiffnesses [.. 25usize]) ; } } impl Default for JointStiffnesses { fn default () -> Self { let msg_native = WrappedNativeMsg :: < JointStiffnesses > :: new () ; JointStiffnesses :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct JointTemperatures { pub temperatures : Vec < f32 > } impl WrappedTypesupport for JointTemperatures { type CStruct = nao_sensor_msgs__msg__JointTemperatures ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__nao_sensor_msgs__msg__JointTemperatures () } } fn create_msg () -> * mut nao_sensor_msgs__msg__JointTemperatures { unsafe { nao_sensor_msgs__msg__JointTemperatures__create () } } fn destroy_msg (msg : * mut nao_sensor_msgs__msg__JointTemperatures) -> () { unsafe { nao_sensor_msgs__msg__JointTemperatures__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> JointTemperatures { JointTemperatures { temperatures : msg . temperatures . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { assert_eq ! (self . temperatures . len () , 25usize , "Field {} is fixed size of {}!" , "temperatures" , 25usize) ; msg . temperatures . copy_from_slice (& self . temperatures [.. 25usize]) ; } } impl Default for JointTemperatures { fn default () -> Self { let msg_native = WrappedNativeMsg :: < JointTemperatures > :: new () ; JointTemperatures :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct RobotConfig { pub body_id : std :: string :: String , pub body_version : std :: string :: String , pub head_id : std :: string :: String , pub head_version : std :: string :: String } impl WrappedTypesupport for RobotConfig { type CStruct = nao_sensor_msgs__msg__RobotConfig ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__nao_sensor_msgs__msg__RobotConfig () } } fn create_msg () -> * mut nao_sensor_msgs__msg__RobotConfig { unsafe { nao_sensor_msgs__msg__RobotConfig__create () } } fn destroy_msg (msg : * mut nao_sensor_msgs__msg__RobotConfig) -> () { unsafe { nao_sensor_msgs__msg__RobotConfig__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> RobotConfig { RobotConfig { body_id : msg . body_id . to_str () . to_owned () , body_version : msg . body_version . to_str () . to_owned () , head_id : msg . head_id . to_str () . to_owned () , head_version : msg . head_version . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . body_id . assign (& self . body_id) ; msg . body_version . assign (& self . body_version) ; msg . head_id . assign (& self . head_id) ; msg . head_version . assign (& self . head_version) ; } } impl Default for RobotConfig { fn default () -> Self { let msg_native = WrappedNativeMsg :: < RobotConfig > :: new () ; RobotConfig :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Sonar { pub left : f32 , pub right : f32 } impl WrappedTypesupport for Sonar { type CStruct = nao_sensor_msgs__msg__Sonar ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__nao_sensor_msgs__msg__Sonar () } } fn create_msg () -> * mut nao_sensor_msgs__msg__Sonar { unsafe { nao_sensor_msgs__msg__Sonar__create () } } fn destroy_msg (msg : * mut nao_sensor_msgs__msg__Sonar) -> () { unsafe { nao_sensor_msgs__msg__Sonar__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Sonar { Sonar { left : msg . left , right : msg . right , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . left = self . left ; msg . right = self . right ; } } impl Default for Sonar { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Sonar > :: new () ; Sonar :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Touch { pub head_front : bool , pub head_middle : bool , pub head_rear : bool } impl WrappedTypesupport for Touch { type CStruct = nao_sensor_msgs__msg__Touch ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__nao_sensor_msgs__msg__Touch () } } fn create_msg () -> * mut nao_sensor_msgs__msg__Touch { unsafe { nao_sensor_msgs__msg__Touch__create () } } fn destroy_msg (msg : * mut nao_sensor_msgs__msg__Touch) -> () { unsafe { nao_sensor_msgs__msg__Touch__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Touch { Touch { head_front : msg . head_front , head_middle : msg . head_middle , head_rear : msg . head_rear , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . head_front = self . head_front ; msg . head_middle = self . head_middle ; msg . head_rear = self . head_rear ; } } impl Default for Touch { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Touch > :: new () ; Touch :: from_native (& msg_native) } } }