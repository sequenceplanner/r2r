pub mod srv { # [allow (non_snake_case)] pub mod ApplyPlanningScene { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__moveit_msgs__srv__ApplyPlanningScene () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub scene : moveit_msgs :: msg :: PlanningScene } impl WrappedTypesupport for Request { type CStruct = moveit_msgs__srv__ApplyPlanningScene_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__srv__ApplyPlanningScene_Request () } } fn create_msg () -> * mut moveit_msgs__srv__ApplyPlanningScene_Request { unsafe { moveit_msgs__srv__ApplyPlanningScene_Request__create () } } fn destroy_msg (msg : * mut moveit_msgs__srv__ApplyPlanningScene_Request) -> () { unsafe { moveit_msgs__srv__ApplyPlanningScene_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { scene : moveit_msgs :: msg :: PlanningScene :: from_native (& msg . scene) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . scene . copy_to_native (& mut msg . scene) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool } impl WrappedTypesupport for Response { type CStruct = moveit_msgs__srv__ApplyPlanningScene_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__srv__ApplyPlanningScene_Response () } } fn create_msg () -> * mut moveit_msgs__srv__ApplyPlanningScene_Response { unsafe { moveit_msgs__srv__ApplyPlanningScene_Response__create () } } fn destroy_msg (msg : * mut moveit_msgs__srv__ApplyPlanningScene_Response) -> () { unsafe { moveit_msgs__srv__ApplyPlanningScene_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod ChangeControlDimensions { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__moveit_msgs__srv__ChangeControlDimensions () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub control_x_translation : bool , pub control_y_translation : bool , pub control_z_translation : bool , pub control_x_rotation : bool , pub control_y_rotation : bool , pub control_z_rotation : bool } impl WrappedTypesupport for Request { type CStruct = moveit_msgs__srv__ChangeControlDimensions_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__srv__ChangeControlDimensions_Request () } } fn create_msg () -> * mut moveit_msgs__srv__ChangeControlDimensions_Request { unsafe { moveit_msgs__srv__ChangeControlDimensions_Request__create () } } fn destroy_msg (msg : * mut moveit_msgs__srv__ChangeControlDimensions_Request) -> () { unsafe { moveit_msgs__srv__ChangeControlDimensions_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { control_x_translation : msg . control_x_translation , control_y_translation : msg . control_y_translation , control_z_translation : msg . control_z_translation , control_x_rotation : msg . control_x_rotation , control_y_rotation : msg . control_y_rotation , control_z_rotation : msg . control_z_rotation , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . control_x_translation = self . control_x_translation ; msg . control_y_translation = self . control_y_translation ; msg . control_z_translation = self . control_z_translation ; msg . control_x_rotation = self . control_x_rotation ; msg . control_y_rotation = self . control_y_rotation ; msg . control_z_rotation = self . control_z_rotation ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool } impl WrappedTypesupport for Response { type CStruct = moveit_msgs__srv__ChangeControlDimensions_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__srv__ChangeControlDimensions_Response () } } fn create_msg () -> * mut moveit_msgs__srv__ChangeControlDimensions_Response { unsafe { moveit_msgs__srv__ChangeControlDimensions_Response__create () } } fn destroy_msg (msg : * mut moveit_msgs__srv__ChangeControlDimensions_Response) -> () { unsafe { moveit_msgs__srv__ChangeControlDimensions_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod ChangeDriftDimensions { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__moveit_msgs__srv__ChangeDriftDimensions () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub drift_x_translation : bool , pub drift_y_translation : bool , pub drift_z_translation : bool , pub drift_x_rotation : bool , pub drift_y_rotation : bool , pub drift_z_rotation : bool , pub transform_jog_frame_to_drift_frame : geometry_msgs :: msg :: Transform } impl WrappedTypesupport for Request { type CStruct = moveit_msgs__srv__ChangeDriftDimensions_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__srv__ChangeDriftDimensions_Request () } } fn create_msg () -> * mut moveit_msgs__srv__ChangeDriftDimensions_Request { unsafe { moveit_msgs__srv__ChangeDriftDimensions_Request__create () } } fn destroy_msg (msg : * mut moveit_msgs__srv__ChangeDriftDimensions_Request) -> () { unsafe { moveit_msgs__srv__ChangeDriftDimensions_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { drift_x_translation : msg . drift_x_translation , drift_y_translation : msg . drift_y_translation , drift_z_translation : msg . drift_z_translation , drift_x_rotation : msg . drift_x_rotation , drift_y_rotation : msg . drift_y_rotation , drift_z_rotation : msg . drift_z_rotation , transform_jog_frame_to_drift_frame : geometry_msgs :: msg :: Transform :: from_native (& msg . transform_jog_frame_to_drift_frame) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . drift_x_translation = self . drift_x_translation ; msg . drift_y_translation = self . drift_y_translation ; msg . drift_z_translation = self . drift_z_translation ; msg . drift_x_rotation = self . drift_x_rotation ; msg . drift_y_rotation = self . drift_y_rotation ; msg . drift_z_rotation = self . drift_z_rotation ; self . transform_jog_frame_to_drift_frame . copy_to_native (& mut msg . transform_jog_frame_to_drift_frame) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool } impl WrappedTypesupport for Response { type CStruct = moveit_msgs__srv__ChangeDriftDimensions_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__srv__ChangeDriftDimensions_Response () } } fn create_msg () -> * mut moveit_msgs__srv__ChangeDriftDimensions_Response { unsafe { moveit_msgs__srv__ChangeDriftDimensions_Response__create () } } fn destroy_msg (msg : * mut moveit_msgs__srv__ChangeDriftDimensions_Response) -> () { unsafe { moveit_msgs__srv__ChangeDriftDimensions_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod CheckIfRobotStateExistsInWarehouse { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__moveit_msgs__srv__CheckIfRobotStateExistsInWarehouse () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub name : std :: string :: String , pub robot : std :: string :: String } impl WrappedTypesupport for Request { type CStruct = moveit_msgs__srv__CheckIfRobotStateExistsInWarehouse_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__srv__CheckIfRobotStateExistsInWarehouse_Request () } } fn create_msg () -> * mut moveit_msgs__srv__CheckIfRobotStateExistsInWarehouse_Request { unsafe { moveit_msgs__srv__CheckIfRobotStateExistsInWarehouse_Request__create () } } fn destroy_msg (msg : * mut moveit_msgs__srv__CheckIfRobotStateExistsInWarehouse_Request) -> () { unsafe { moveit_msgs__srv__CheckIfRobotStateExistsInWarehouse_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { name : msg . name . to_str () . to_owned () , robot : msg . robot . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . name . assign (& self . name) ; msg . robot . assign (& self . robot) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub exists : bool } impl WrappedTypesupport for Response { type CStruct = moveit_msgs__srv__CheckIfRobotStateExistsInWarehouse_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__srv__CheckIfRobotStateExistsInWarehouse_Response () } } fn create_msg () -> * mut moveit_msgs__srv__CheckIfRobotStateExistsInWarehouse_Response { unsafe { moveit_msgs__srv__CheckIfRobotStateExistsInWarehouse_Response__create () } } fn destroy_msg (msg : * mut moveit_msgs__srv__CheckIfRobotStateExistsInWarehouse_Response) -> () { unsafe { moveit_msgs__srv__CheckIfRobotStateExistsInWarehouse_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { exists : msg . exists , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . exists = self . exists ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod DeleteRobotStateFromWarehouse { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__moveit_msgs__srv__DeleteRobotStateFromWarehouse () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub name : std :: string :: String , pub robot : std :: string :: String } impl WrappedTypesupport for Request { type CStruct = moveit_msgs__srv__DeleteRobotStateFromWarehouse_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__srv__DeleteRobotStateFromWarehouse_Request () } } fn create_msg () -> * mut moveit_msgs__srv__DeleteRobotStateFromWarehouse_Request { unsafe { moveit_msgs__srv__DeleteRobotStateFromWarehouse_Request__create () } } fn destroy_msg (msg : * mut moveit_msgs__srv__DeleteRobotStateFromWarehouse_Request) -> () { unsafe { moveit_msgs__srv__DeleteRobotStateFromWarehouse_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { name : msg . name . to_str () . to_owned () , robot : msg . robot . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . name . assign (& self . name) ; msg . robot . assign (& self . robot) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { } impl WrappedTypesupport for Response { type CStruct = moveit_msgs__srv__DeleteRobotStateFromWarehouse_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__srv__DeleteRobotStateFromWarehouse_Response () } } fn create_msg () -> * mut moveit_msgs__srv__DeleteRobotStateFromWarehouse_Response { unsafe { moveit_msgs__srv__DeleteRobotStateFromWarehouse_Response__create () } } fn destroy_msg (msg : * mut moveit_msgs__srv__DeleteRobotStateFromWarehouse_Response) -> () { unsafe { moveit_msgs__srv__DeleteRobotStateFromWarehouse_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod ExecuteKnownTrajectory { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__moveit_msgs__srv__ExecuteKnownTrajectory () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub trajectory : moveit_msgs :: msg :: RobotTrajectory , pub wait_for_execution : bool } impl WrappedTypesupport for Request { type CStruct = moveit_msgs__srv__ExecuteKnownTrajectory_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__srv__ExecuteKnownTrajectory_Request () } } fn create_msg () -> * mut moveit_msgs__srv__ExecuteKnownTrajectory_Request { unsafe { moveit_msgs__srv__ExecuteKnownTrajectory_Request__create () } } fn destroy_msg (msg : * mut moveit_msgs__srv__ExecuteKnownTrajectory_Request) -> () { unsafe { moveit_msgs__srv__ExecuteKnownTrajectory_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { trajectory : moveit_msgs :: msg :: RobotTrajectory :: from_native (& msg . trajectory) , wait_for_execution : msg . wait_for_execution , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . trajectory . copy_to_native (& mut msg . trajectory) ; msg . wait_for_execution = self . wait_for_execution ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub error_code : moveit_msgs :: msg :: MoveItErrorCodes } impl WrappedTypesupport for Response { type CStruct = moveit_msgs__srv__ExecuteKnownTrajectory_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__srv__ExecuteKnownTrajectory_Response () } } fn create_msg () -> * mut moveit_msgs__srv__ExecuteKnownTrajectory_Response { unsafe { moveit_msgs__srv__ExecuteKnownTrajectory_Response__create () } } fn destroy_msg (msg : * mut moveit_msgs__srv__ExecuteKnownTrajectory_Response) -> () { unsafe { moveit_msgs__srv__ExecuteKnownTrajectory_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { error_code : moveit_msgs :: msg :: MoveItErrorCodes :: from_native (& msg . error_code) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . error_code . copy_to_native (& mut msg . error_code) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetCartesianPath { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__moveit_msgs__srv__GetCartesianPath () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub header : std_msgs :: msg :: Header , pub start_state : moveit_msgs :: msg :: RobotState , pub group_name : std :: string :: String , pub link_name : std :: string :: String , pub waypoints : Vec < geometry_msgs :: msg :: Pose > , pub max_step : f64 , pub jump_threshold : f64 , pub prismatic_jump_threshold : f64 , pub revolute_jump_threshold : f64 , pub avoid_collisions : bool , pub path_constraints : moveit_msgs :: msg :: Constraints } impl WrappedTypesupport for Request { type CStruct = moveit_msgs__srv__GetCartesianPath_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__srv__GetCartesianPath_Request () } } fn create_msg () -> * mut moveit_msgs__srv__GetCartesianPath_Request { unsafe { moveit_msgs__srv__GetCartesianPath_Request__create () } } fn destroy_msg (msg : * mut moveit_msgs__srv__GetCartesianPath_Request) -> () { unsafe { moveit_msgs__srv__GetCartesianPath_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { header : std_msgs :: msg :: Header :: from_native (& msg . header) , start_state : moveit_msgs :: msg :: RobotState :: from_native (& msg . start_state) , group_name : msg . group_name . to_str () . to_owned () , link_name : msg . link_name . to_str () . to_owned () , waypoints : { let mut temp = Vec :: with_capacity (msg . waypoints . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . waypoints . data , msg . waypoints . size) } ; for s in slice { temp . push (geometry_msgs :: msg :: Pose :: from_native (s)) ; } temp } , max_step : msg . max_step , jump_threshold : msg . jump_threshold , prismatic_jump_threshold : msg . prismatic_jump_threshold , revolute_jump_threshold : msg . revolute_jump_threshold , avoid_collisions : msg . avoid_collisions , path_constraints : moveit_msgs :: msg :: Constraints :: from_native (& msg . path_constraints) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; self . start_state . copy_to_native (& mut msg . start_state) ; msg . group_name . assign (& self . group_name) ; msg . link_name . assign (& self . link_name) ; unsafe { geometry_msgs__msg__Pose__Sequence__fini (& mut msg . waypoints) ; geometry_msgs__msg__Pose__Sequence__init (& mut msg . waypoints , self . waypoints . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . waypoints . data , msg . waypoints . size) ; for (t , s) in slice . iter_mut () . zip (& self . waypoints) { s . copy_to_native (t) ; } } msg . max_step = self . max_step ; msg . jump_threshold = self . jump_threshold ; msg . prismatic_jump_threshold = self . prismatic_jump_threshold ; msg . revolute_jump_threshold = self . revolute_jump_threshold ; msg . avoid_collisions = self . avoid_collisions ; self . path_constraints . copy_to_native (& mut msg . path_constraints) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub start_state : moveit_msgs :: msg :: RobotState , pub solution : moveit_msgs :: msg :: RobotTrajectory , pub fraction : f64 , pub error_code : moveit_msgs :: msg :: MoveItErrorCodes } impl WrappedTypesupport for Response { type CStruct = moveit_msgs__srv__GetCartesianPath_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__srv__GetCartesianPath_Response () } } fn create_msg () -> * mut moveit_msgs__srv__GetCartesianPath_Response { unsafe { moveit_msgs__srv__GetCartesianPath_Response__create () } } fn destroy_msg (msg : * mut moveit_msgs__srv__GetCartesianPath_Response) -> () { unsafe { moveit_msgs__srv__GetCartesianPath_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { start_state : moveit_msgs :: msg :: RobotState :: from_native (& msg . start_state) , solution : moveit_msgs :: msg :: RobotTrajectory :: from_native (& msg . solution) , fraction : msg . fraction , error_code : moveit_msgs :: msg :: MoveItErrorCodes :: from_native (& msg . error_code) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . start_state . copy_to_native (& mut msg . start_state) ; self . solution . copy_to_native (& mut msg . solution) ; msg . fraction = self . fraction ; self . error_code . copy_to_native (& mut msg . error_code) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetMotionPlan { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__moveit_msgs__srv__GetMotionPlan () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub motion_plan_request : moveit_msgs :: msg :: MotionPlanRequest } impl WrappedTypesupport for Request { type CStruct = moveit_msgs__srv__GetMotionPlan_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__srv__GetMotionPlan_Request () } } fn create_msg () -> * mut moveit_msgs__srv__GetMotionPlan_Request { unsafe { moveit_msgs__srv__GetMotionPlan_Request__create () } } fn destroy_msg (msg : * mut moveit_msgs__srv__GetMotionPlan_Request) -> () { unsafe { moveit_msgs__srv__GetMotionPlan_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { motion_plan_request : moveit_msgs :: msg :: MotionPlanRequest :: from_native (& msg . motion_plan_request) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . motion_plan_request . copy_to_native (& mut msg . motion_plan_request) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub motion_plan_response : moveit_msgs :: msg :: MotionPlanResponse } impl WrappedTypesupport for Response { type CStruct = moveit_msgs__srv__GetMotionPlan_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__srv__GetMotionPlan_Response () } } fn create_msg () -> * mut moveit_msgs__srv__GetMotionPlan_Response { unsafe { moveit_msgs__srv__GetMotionPlan_Response__create () } } fn destroy_msg (msg : * mut moveit_msgs__srv__GetMotionPlan_Response) -> () { unsafe { moveit_msgs__srv__GetMotionPlan_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { motion_plan_response : moveit_msgs :: msg :: MotionPlanResponse :: from_native (& msg . motion_plan_response) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . motion_plan_response . copy_to_native (& mut msg . motion_plan_response) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetMotionSequence { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__moveit_msgs__srv__GetMotionSequence () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub request : moveit_msgs :: msg :: MotionSequenceRequest } impl WrappedTypesupport for Request { type CStruct = moveit_msgs__srv__GetMotionSequence_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__srv__GetMotionSequence_Request () } } fn create_msg () -> * mut moveit_msgs__srv__GetMotionSequence_Request { unsafe { moveit_msgs__srv__GetMotionSequence_Request__create () } } fn destroy_msg (msg : * mut moveit_msgs__srv__GetMotionSequence_Request) -> () { unsafe { moveit_msgs__srv__GetMotionSequence_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { request : moveit_msgs :: msg :: MotionSequenceRequest :: from_native (& msg . request) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . request . copy_to_native (& mut msg . request) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub response : moveit_msgs :: msg :: MotionSequenceResponse } impl WrappedTypesupport for Response { type CStruct = moveit_msgs__srv__GetMotionSequence_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__srv__GetMotionSequence_Response () } } fn create_msg () -> * mut moveit_msgs__srv__GetMotionSequence_Response { unsafe { moveit_msgs__srv__GetMotionSequence_Response__create () } } fn destroy_msg (msg : * mut moveit_msgs__srv__GetMotionSequence_Response) -> () { unsafe { moveit_msgs__srv__GetMotionSequence_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { response : moveit_msgs :: msg :: MotionSequenceResponse :: from_native (& msg . response) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . response . copy_to_native (& mut msg . response) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetPlannerParams { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__moveit_msgs__srv__GetPlannerParams () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub pipeline_id : std :: string :: String , pub planner_config : std :: string :: String , pub group : std :: string :: String } impl WrappedTypesupport for Request { type CStruct = moveit_msgs__srv__GetPlannerParams_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__srv__GetPlannerParams_Request () } } fn create_msg () -> * mut moveit_msgs__srv__GetPlannerParams_Request { unsafe { moveit_msgs__srv__GetPlannerParams_Request__create () } } fn destroy_msg (msg : * mut moveit_msgs__srv__GetPlannerParams_Request) -> () { unsafe { moveit_msgs__srv__GetPlannerParams_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { pipeline_id : msg . pipeline_id . to_str () . to_owned () , planner_config : msg . planner_config . to_str () . to_owned () , group : msg . group . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . pipeline_id . assign (& self . pipeline_id) ; msg . planner_config . assign (& self . planner_config) ; msg . group . assign (& self . group) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub params : moveit_msgs :: msg :: PlannerParams } impl WrappedTypesupport for Response { type CStruct = moveit_msgs__srv__GetPlannerParams_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__srv__GetPlannerParams_Response () } } fn create_msg () -> * mut moveit_msgs__srv__GetPlannerParams_Response { unsafe { moveit_msgs__srv__GetPlannerParams_Response__create () } } fn destroy_msg (msg : * mut moveit_msgs__srv__GetPlannerParams_Response) -> () { unsafe { moveit_msgs__srv__GetPlannerParams_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { params : moveit_msgs :: msg :: PlannerParams :: from_native (& msg . params) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . params . copy_to_native (& mut msg . params) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetPlanningScene { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__moveit_msgs__srv__GetPlanningScene () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub components : moveit_msgs :: msg :: PlanningSceneComponents } impl WrappedTypesupport for Request { type CStruct = moveit_msgs__srv__GetPlanningScene_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__srv__GetPlanningScene_Request () } } fn create_msg () -> * mut moveit_msgs__srv__GetPlanningScene_Request { unsafe { moveit_msgs__srv__GetPlanningScene_Request__create () } } fn destroy_msg (msg : * mut moveit_msgs__srv__GetPlanningScene_Request) -> () { unsafe { moveit_msgs__srv__GetPlanningScene_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { components : moveit_msgs :: msg :: PlanningSceneComponents :: from_native (& msg . components) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . components . copy_to_native (& mut msg . components) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub scene : moveit_msgs :: msg :: PlanningScene } impl WrappedTypesupport for Response { type CStruct = moveit_msgs__srv__GetPlanningScene_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__srv__GetPlanningScene_Response () } } fn create_msg () -> * mut moveit_msgs__srv__GetPlanningScene_Response { unsafe { moveit_msgs__srv__GetPlanningScene_Response__create () } } fn destroy_msg (msg : * mut moveit_msgs__srv__GetPlanningScene_Response) -> () { unsafe { moveit_msgs__srv__GetPlanningScene_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { scene : moveit_msgs :: msg :: PlanningScene :: from_native (& msg . scene) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . scene . copy_to_native (& mut msg . scene) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetPositionFK { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__moveit_msgs__srv__GetPositionFK () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub header : std_msgs :: msg :: Header , pub fk_link_names : Vec < std :: string :: String > , pub robot_state : moveit_msgs :: msg :: RobotState } impl WrappedTypesupport for Request { type CStruct = moveit_msgs__srv__GetPositionFK_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__srv__GetPositionFK_Request () } } fn create_msg () -> * mut moveit_msgs__srv__GetPositionFK_Request { unsafe { moveit_msgs__srv__GetPositionFK_Request__create () } } fn destroy_msg (msg : * mut moveit_msgs__srv__GetPositionFK_Request) -> () { unsafe { moveit_msgs__srv__GetPositionFK_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { header : std_msgs :: msg :: Header :: from_native (& msg . header) , fk_link_names : msg . fk_link_names . to_vec () , robot_state : moveit_msgs :: msg :: RobotState :: from_native (& msg . robot_state) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . fk_link_names . update (& self . fk_link_names) ; self . robot_state . copy_to_native (& mut msg . robot_state) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub pose_stamped : Vec < geometry_msgs :: msg :: PoseStamped > , pub fk_link_names : Vec < std :: string :: String > , pub error_code : moveit_msgs :: msg :: MoveItErrorCodes } impl WrappedTypesupport for Response { type CStruct = moveit_msgs__srv__GetPositionFK_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__srv__GetPositionFK_Response () } } fn create_msg () -> * mut moveit_msgs__srv__GetPositionFK_Response { unsafe { moveit_msgs__srv__GetPositionFK_Response__create () } } fn destroy_msg (msg : * mut moveit_msgs__srv__GetPositionFK_Response) -> () { unsafe { moveit_msgs__srv__GetPositionFK_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { pose_stamped : { let mut temp = Vec :: with_capacity (msg . pose_stamped . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . pose_stamped . data , msg . pose_stamped . size) } ; for s in slice { temp . push (geometry_msgs :: msg :: PoseStamped :: from_native (s)) ; } temp } , fk_link_names : msg . fk_link_names . to_vec () , error_code : moveit_msgs :: msg :: MoveItErrorCodes :: from_native (& msg . error_code) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { unsafe { geometry_msgs__msg__PoseStamped__Sequence__fini (& mut msg . pose_stamped) ; geometry_msgs__msg__PoseStamped__Sequence__init (& mut msg . pose_stamped , self . pose_stamped . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . pose_stamped . data , msg . pose_stamped . size) ; for (t , s) in slice . iter_mut () . zip (& self . pose_stamped) { s . copy_to_native (t) ; } } msg . fk_link_names . update (& self . fk_link_names) ; self . error_code . copy_to_native (& mut msg . error_code) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetPositionIK { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__moveit_msgs__srv__GetPositionIK () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub ik_request : moveit_msgs :: msg :: PositionIKRequest } impl WrappedTypesupport for Request { type CStruct = moveit_msgs__srv__GetPositionIK_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__srv__GetPositionIK_Request () } } fn create_msg () -> * mut moveit_msgs__srv__GetPositionIK_Request { unsafe { moveit_msgs__srv__GetPositionIK_Request__create () } } fn destroy_msg (msg : * mut moveit_msgs__srv__GetPositionIK_Request) -> () { unsafe { moveit_msgs__srv__GetPositionIK_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { ik_request : moveit_msgs :: msg :: PositionIKRequest :: from_native (& msg . ik_request) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . ik_request . copy_to_native (& mut msg . ik_request) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub solution : moveit_msgs :: msg :: RobotState , pub error_code : moveit_msgs :: msg :: MoveItErrorCodes } impl WrappedTypesupport for Response { type CStruct = moveit_msgs__srv__GetPositionIK_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__srv__GetPositionIK_Response () } } fn create_msg () -> * mut moveit_msgs__srv__GetPositionIK_Response { unsafe { moveit_msgs__srv__GetPositionIK_Response__create () } } fn destroy_msg (msg : * mut moveit_msgs__srv__GetPositionIK_Response) -> () { unsafe { moveit_msgs__srv__GetPositionIK_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { solution : moveit_msgs :: msg :: RobotState :: from_native (& msg . solution) , error_code : moveit_msgs :: msg :: MoveItErrorCodes :: from_native (& msg . error_code) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . solution . copy_to_native (& mut msg . solution) ; self . error_code . copy_to_native (& mut msg . error_code) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetRobotStateFromWarehouse { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__moveit_msgs__srv__GetRobotStateFromWarehouse () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub name : std :: string :: String , pub robot : std :: string :: String } impl WrappedTypesupport for Request { type CStruct = moveit_msgs__srv__GetRobotStateFromWarehouse_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__srv__GetRobotStateFromWarehouse_Request () } } fn create_msg () -> * mut moveit_msgs__srv__GetRobotStateFromWarehouse_Request { unsafe { moveit_msgs__srv__GetRobotStateFromWarehouse_Request__create () } } fn destroy_msg (msg : * mut moveit_msgs__srv__GetRobotStateFromWarehouse_Request) -> () { unsafe { moveit_msgs__srv__GetRobotStateFromWarehouse_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { name : msg . name . to_str () . to_owned () , robot : msg . robot . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . name . assign (& self . name) ; msg . robot . assign (& self . robot) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub state : moveit_msgs :: msg :: RobotState } impl WrappedTypesupport for Response { type CStruct = moveit_msgs__srv__GetRobotStateFromWarehouse_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__srv__GetRobotStateFromWarehouse_Response () } } fn create_msg () -> * mut moveit_msgs__srv__GetRobotStateFromWarehouse_Response { unsafe { moveit_msgs__srv__GetRobotStateFromWarehouse_Response__create () } } fn destroy_msg (msg : * mut moveit_msgs__srv__GetRobotStateFromWarehouse_Response) -> () { unsafe { moveit_msgs__srv__GetRobotStateFromWarehouse_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { state : moveit_msgs :: msg :: RobotState :: from_native (& msg . state) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . state . copy_to_native (& mut msg . state) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetStateValidity { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__moveit_msgs__srv__GetStateValidity () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub robot_state : moveit_msgs :: msg :: RobotState , pub group_name : std :: string :: String , pub constraints : moveit_msgs :: msg :: Constraints } impl WrappedTypesupport for Request { type CStruct = moveit_msgs__srv__GetStateValidity_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__srv__GetStateValidity_Request () } } fn create_msg () -> * mut moveit_msgs__srv__GetStateValidity_Request { unsafe { moveit_msgs__srv__GetStateValidity_Request__create () } } fn destroy_msg (msg : * mut moveit_msgs__srv__GetStateValidity_Request) -> () { unsafe { moveit_msgs__srv__GetStateValidity_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { robot_state : moveit_msgs :: msg :: RobotState :: from_native (& msg . robot_state) , group_name : msg . group_name . to_str () . to_owned () , constraints : moveit_msgs :: msg :: Constraints :: from_native (& msg . constraints) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . robot_state . copy_to_native (& mut msg . robot_state) ; msg . group_name . assign (& self . group_name) ; self . constraints . copy_to_native (& mut msg . constraints) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub valid : bool , pub contacts : Vec < moveit_msgs :: msg :: ContactInformation > , pub cost_sources : Vec < moveit_msgs :: msg :: CostSource > , pub constraint_result : Vec < moveit_msgs :: msg :: ConstraintEvalResult > } impl WrappedTypesupport for Response { type CStruct = moveit_msgs__srv__GetStateValidity_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__srv__GetStateValidity_Response () } } fn create_msg () -> * mut moveit_msgs__srv__GetStateValidity_Response { unsafe { moveit_msgs__srv__GetStateValidity_Response__create () } } fn destroy_msg (msg : * mut moveit_msgs__srv__GetStateValidity_Response) -> () { unsafe { moveit_msgs__srv__GetStateValidity_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { valid : msg . valid , contacts : { let mut temp = Vec :: with_capacity (msg . contacts . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . contacts . data , msg . contacts . size) } ; for s in slice { temp . push (moveit_msgs :: msg :: ContactInformation :: from_native (s)) ; } temp } , cost_sources : { let mut temp = Vec :: with_capacity (msg . cost_sources . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . cost_sources . data , msg . cost_sources . size) } ; for s in slice { temp . push (moveit_msgs :: msg :: CostSource :: from_native (s)) ; } temp } , constraint_result : { let mut temp = Vec :: with_capacity (msg . constraint_result . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . constraint_result . data , msg . constraint_result . size) } ; for s in slice { temp . push (moveit_msgs :: msg :: ConstraintEvalResult :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . valid = self . valid ; unsafe { moveit_msgs__msg__ContactInformation__Sequence__fini (& mut msg . contacts) ; moveit_msgs__msg__ContactInformation__Sequence__init (& mut msg . contacts , self . contacts . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . contacts . data , msg . contacts . size) ; for (t , s) in slice . iter_mut () . zip (& self . contacts) { s . copy_to_native (t) ; } } unsafe { moveit_msgs__msg__CostSource__Sequence__fini (& mut msg . cost_sources) ; moveit_msgs__msg__CostSource__Sequence__init (& mut msg . cost_sources , self . cost_sources . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . cost_sources . data , msg . cost_sources . size) ; for (t , s) in slice . iter_mut () . zip (& self . cost_sources) { s . copy_to_native (t) ; } } unsafe { moveit_msgs__msg__ConstraintEvalResult__Sequence__fini (& mut msg . constraint_result) ; moveit_msgs__msg__ConstraintEvalResult__Sequence__init (& mut msg . constraint_result , self . constraint_result . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . constraint_result . data , msg . constraint_result . size) ; for (t , s) in slice . iter_mut () . zip (& self . constraint_result) { s . copy_to_native (t) ; } } } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GraspPlanning { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__moveit_msgs__srv__GraspPlanning () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub group_name : std :: string :: String , pub target : moveit_msgs :: msg :: CollisionObject , pub support_surfaces : Vec < std :: string :: String > , pub candidate_grasps : Vec < moveit_msgs :: msg :: Grasp > , pub movable_obstacles : Vec < moveit_msgs :: msg :: CollisionObject > } impl WrappedTypesupport for Request { type CStruct = moveit_msgs__srv__GraspPlanning_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__srv__GraspPlanning_Request () } } fn create_msg () -> * mut moveit_msgs__srv__GraspPlanning_Request { unsafe { moveit_msgs__srv__GraspPlanning_Request__create () } } fn destroy_msg (msg : * mut moveit_msgs__srv__GraspPlanning_Request) -> () { unsafe { moveit_msgs__srv__GraspPlanning_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { group_name : msg . group_name . to_str () . to_owned () , target : moveit_msgs :: msg :: CollisionObject :: from_native (& msg . target) , support_surfaces : msg . support_surfaces . to_vec () , candidate_grasps : { let mut temp = Vec :: with_capacity (msg . candidate_grasps . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . candidate_grasps . data , msg . candidate_grasps . size) } ; for s in slice { temp . push (moveit_msgs :: msg :: Grasp :: from_native (s)) ; } temp } , movable_obstacles : { let mut temp = Vec :: with_capacity (msg . movable_obstacles . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . movable_obstacles . data , msg . movable_obstacles . size) } ; for s in slice { temp . push (moveit_msgs :: msg :: CollisionObject :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . group_name . assign (& self . group_name) ; self . target . copy_to_native (& mut msg . target) ; msg . support_surfaces . update (& self . support_surfaces) ; unsafe { moveit_msgs__msg__Grasp__Sequence__fini (& mut msg . candidate_grasps) ; moveit_msgs__msg__Grasp__Sequence__init (& mut msg . candidate_grasps , self . candidate_grasps . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . candidate_grasps . data , msg . candidate_grasps . size) ; for (t , s) in slice . iter_mut () . zip (& self . candidate_grasps) { s . copy_to_native (t) ; } } unsafe { moveit_msgs__msg__CollisionObject__Sequence__fini (& mut msg . movable_obstacles) ; moveit_msgs__msg__CollisionObject__Sequence__init (& mut msg . movable_obstacles , self . movable_obstacles . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . movable_obstacles . data , msg . movable_obstacles . size) ; for (t , s) in slice . iter_mut () . zip (& self . movable_obstacles) { s . copy_to_native (t) ; } } } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub grasps : Vec < moveit_msgs :: msg :: Grasp > , pub error_code : moveit_msgs :: msg :: MoveItErrorCodes } impl WrappedTypesupport for Response { type CStruct = moveit_msgs__srv__GraspPlanning_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__srv__GraspPlanning_Response () } } fn create_msg () -> * mut moveit_msgs__srv__GraspPlanning_Response { unsafe { moveit_msgs__srv__GraspPlanning_Response__create () } } fn destroy_msg (msg : * mut moveit_msgs__srv__GraspPlanning_Response) -> () { unsafe { moveit_msgs__srv__GraspPlanning_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { grasps : { let mut temp = Vec :: with_capacity (msg . grasps . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . grasps . data , msg . grasps . size) } ; for s in slice { temp . push (moveit_msgs :: msg :: Grasp :: from_native (s)) ; } temp } , error_code : moveit_msgs :: msg :: MoveItErrorCodes :: from_native (& msg . error_code) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { unsafe { moveit_msgs__msg__Grasp__Sequence__fini (& mut msg . grasps) ; moveit_msgs__msg__Grasp__Sequence__init (& mut msg . grasps , self . grasps . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . grasps . data , msg . grasps . size) ; for (t , s) in slice . iter_mut () . zip (& self . grasps) { s . copy_to_native (t) ; } } self . error_code . copy_to_native (& mut msg . error_code) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod ListRobotStatesInWarehouse { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__moveit_msgs__srv__ListRobotStatesInWarehouse () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub regex : std :: string :: String , pub robot : std :: string :: String } impl WrappedTypesupport for Request { type CStruct = moveit_msgs__srv__ListRobotStatesInWarehouse_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__srv__ListRobotStatesInWarehouse_Request () } } fn create_msg () -> * mut moveit_msgs__srv__ListRobotStatesInWarehouse_Request { unsafe { moveit_msgs__srv__ListRobotStatesInWarehouse_Request__create () } } fn destroy_msg (msg : * mut moveit_msgs__srv__ListRobotStatesInWarehouse_Request) -> () { unsafe { moveit_msgs__srv__ListRobotStatesInWarehouse_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { regex : msg . regex . to_str () . to_owned () , robot : msg . robot . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . regex . assign (& self . regex) ; msg . robot . assign (& self . robot) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub states : Vec < std :: string :: String > } impl WrappedTypesupport for Response { type CStruct = moveit_msgs__srv__ListRobotStatesInWarehouse_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__srv__ListRobotStatesInWarehouse_Response () } } fn create_msg () -> * mut moveit_msgs__srv__ListRobotStatesInWarehouse_Response { unsafe { moveit_msgs__srv__ListRobotStatesInWarehouse_Response__create () } } fn destroy_msg (msg : * mut moveit_msgs__srv__ListRobotStatesInWarehouse_Response) -> () { unsafe { moveit_msgs__srv__ListRobotStatesInWarehouse_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { states : msg . states . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . states . update (& self . states) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod LoadMap { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__moveit_msgs__srv__LoadMap () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub filename : std :: string :: String } impl WrappedTypesupport for Request { type CStruct = moveit_msgs__srv__LoadMap_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__srv__LoadMap_Request () } } fn create_msg () -> * mut moveit_msgs__srv__LoadMap_Request { unsafe { moveit_msgs__srv__LoadMap_Request__create () } } fn destroy_msg (msg : * mut moveit_msgs__srv__LoadMap_Request) -> () { unsafe { moveit_msgs__srv__LoadMap_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { filename : msg . filename . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . filename . assign (& self . filename) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool } impl WrappedTypesupport for Response { type CStruct = moveit_msgs__srv__LoadMap_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__srv__LoadMap_Response () } } fn create_msg () -> * mut moveit_msgs__srv__LoadMap_Response { unsafe { moveit_msgs__srv__LoadMap_Response__create () } } fn destroy_msg (msg : * mut moveit_msgs__srv__LoadMap_Response) -> () { unsafe { moveit_msgs__srv__LoadMap_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod QueryPlannerInterfaces { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__moveit_msgs__srv__QueryPlannerInterfaces () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { } impl WrappedTypesupport for Request { type CStruct = moveit_msgs__srv__QueryPlannerInterfaces_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__srv__QueryPlannerInterfaces_Request () } } fn create_msg () -> * mut moveit_msgs__srv__QueryPlannerInterfaces_Request { unsafe { moveit_msgs__srv__QueryPlannerInterfaces_Request__create () } } fn destroy_msg (msg : * mut moveit_msgs__srv__QueryPlannerInterfaces_Request) -> () { unsafe { moveit_msgs__srv__QueryPlannerInterfaces_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub planner_interfaces : Vec < moveit_msgs :: msg :: PlannerInterfaceDescription > } impl WrappedTypesupport for Response { type CStruct = moveit_msgs__srv__QueryPlannerInterfaces_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__srv__QueryPlannerInterfaces_Response () } } fn create_msg () -> * mut moveit_msgs__srv__QueryPlannerInterfaces_Response { unsafe { moveit_msgs__srv__QueryPlannerInterfaces_Response__create () } } fn destroy_msg (msg : * mut moveit_msgs__srv__QueryPlannerInterfaces_Response) -> () { unsafe { moveit_msgs__srv__QueryPlannerInterfaces_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { planner_interfaces : { let mut temp = Vec :: with_capacity (msg . planner_interfaces . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . planner_interfaces . data , msg . planner_interfaces . size) } ; for s in slice { temp . push (moveit_msgs :: msg :: PlannerInterfaceDescription :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { unsafe { moveit_msgs__msg__PlannerInterfaceDescription__Sequence__fini (& mut msg . planner_interfaces) ; moveit_msgs__msg__PlannerInterfaceDescription__Sequence__init (& mut msg . planner_interfaces , self . planner_interfaces . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . planner_interfaces . data , msg . planner_interfaces . size) ; for (t , s) in slice . iter_mut () . zip (& self . planner_interfaces) { s . copy_to_native (t) ; } } } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod RenameRobotStateInWarehouse { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__moveit_msgs__srv__RenameRobotStateInWarehouse () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub old_name : std :: string :: String , pub new_name : std :: string :: String , pub robot : std :: string :: String } impl WrappedTypesupport for Request { type CStruct = moveit_msgs__srv__RenameRobotStateInWarehouse_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__srv__RenameRobotStateInWarehouse_Request () } } fn create_msg () -> * mut moveit_msgs__srv__RenameRobotStateInWarehouse_Request { unsafe { moveit_msgs__srv__RenameRobotStateInWarehouse_Request__create () } } fn destroy_msg (msg : * mut moveit_msgs__srv__RenameRobotStateInWarehouse_Request) -> () { unsafe { moveit_msgs__srv__RenameRobotStateInWarehouse_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { old_name : msg . old_name . to_str () . to_owned () , new_name : msg . new_name . to_str () . to_owned () , robot : msg . robot . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . old_name . assign (& self . old_name) ; msg . new_name . assign (& self . new_name) ; msg . robot . assign (& self . robot) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { } impl WrappedTypesupport for Response { type CStruct = moveit_msgs__srv__RenameRobotStateInWarehouse_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__srv__RenameRobotStateInWarehouse_Response () } } fn create_msg () -> * mut moveit_msgs__srv__RenameRobotStateInWarehouse_Response { unsafe { moveit_msgs__srv__RenameRobotStateInWarehouse_Response__create () } } fn destroy_msg (msg : * mut moveit_msgs__srv__RenameRobotStateInWarehouse_Response) -> () { unsafe { moveit_msgs__srv__RenameRobotStateInWarehouse_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod SaveMap { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__moveit_msgs__srv__SaveMap () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub filename : std :: string :: String } impl WrappedTypesupport for Request { type CStruct = moveit_msgs__srv__SaveMap_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__srv__SaveMap_Request () } } fn create_msg () -> * mut moveit_msgs__srv__SaveMap_Request { unsafe { moveit_msgs__srv__SaveMap_Request__create () } } fn destroy_msg (msg : * mut moveit_msgs__srv__SaveMap_Request) -> () { unsafe { moveit_msgs__srv__SaveMap_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { filename : msg . filename . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . filename . assign (& self . filename) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool } impl WrappedTypesupport for Response { type CStruct = moveit_msgs__srv__SaveMap_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__srv__SaveMap_Response () } } fn create_msg () -> * mut moveit_msgs__srv__SaveMap_Response { unsafe { moveit_msgs__srv__SaveMap_Response__create () } } fn destroy_msg (msg : * mut moveit_msgs__srv__SaveMap_Response) -> () { unsafe { moveit_msgs__srv__SaveMap_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod SaveRobotStateToWarehouse { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__moveit_msgs__srv__SaveRobotStateToWarehouse () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub name : std :: string :: String , pub robot : std :: string :: String , pub state : moveit_msgs :: msg :: RobotState } impl WrappedTypesupport for Request { type CStruct = moveit_msgs__srv__SaveRobotStateToWarehouse_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__srv__SaveRobotStateToWarehouse_Request () } } fn create_msg () -> * mut moveit_msgs__srv__SaveRobotStateToWarehouse_Request { unsafe { moveit_msgs__srv__SaveRobotStateToWarehouse_Request__create () } } fn destroy_msg (msg : * mut moveit_msgs__srv__SaveRobotStateToWarehouse_Request) -> () { unsafe { moveit_msgs__srv__SaveRobotStateToWarehouse_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { name : msg . name . to_str () . to_owned () , robot : msg . robot . to_str () . to_owned () , state : moveit_msgs :: msg :: RobotState :: from_native (& msg . state) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . name . assign (& self . name) ; msg . robot . assign (& self . robot) ; self . state . copy_to_native (& mut msg . state) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool } impl WrappedTypesupport for Response { type CStruct = moveit_msgs__srv__SaveRobotStateToWarehouse_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__srv__SaveRobotStateToWarehouse_Response () } } fn create_msg () -> * mut moveit_msgs__srv__SaveRobotStateToWarehouse_Response { unsafe { moveit_msgs__srv__SaveRobotStateToWarehouse_Response__create () } } fn destroy_msg (msg : * mut moveit_msgs__srv__SaveRobotStateToWarehouse_Response) -> () { unsafe { moveit_msgs__srv__SaveRobotStateToWarehouse_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod SetPlannerParams { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__moveit_msgs__srv__SetPlannerParams () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub pipeline_id : std :: string :: String , pub planner_config : std :: string :: String , pub group : std :: string :: String , pub params : moveit_msgs :: msg :: PlannerParams , pub replace : bool } impl WrappedTypesupport for Request { type CStruct = moveit_msgs__srv__SetPlannerParams_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__srv__SetPlannerParams_Request () } } fn create_msg () -> * mut moveit_msgs__srv__SetPlannerParams_Request { unsafe { moveit_msgs__srv__SetPlannerParams_Request__create () } } fn destroy_msg (msg : * mut moveit_msgs__srv__SetPlannerParams_Request) -> () { unsafe { moveit_msgs__srv__SetPlannerParams_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { pipeline_id : msg . pipeline_id . to_str () . to_owned () , planner_config : msg . planner_config . to_str () . to_owned () , group : msg . group . to_str () . to_owned () , params : moveit_msgs :: msg :: PlannerParams :: from_native (& msg . params) , replace : msg . replace , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . pipeline_id . assign (& self . pipeline_id) ; msg . planner_config . assign (& self . planner_config) ; msg . group . assign (& self . group) ; self . params . copy_to_native (& mut msg . params) ; msg . replace = self . replace ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { } impl WrappedTypesupport for Response { type CStruct = moveit_msgs__srv__SetPlannerParams_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__srv__SetPlannerParams_Response () } } fn create_msg () -> * mut moveit_msgs__srv__SetPlannerParams_Response { unsafe { moveit_msgs__srv__SetPlannerParams_Response__create () } } fn destroy_msg (msg : * mut moveit_msgs__srv__SetPlannerParams_Response) -> () { unsafe { moveit_msgs__srv__SetPlannerParams_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod UpdatePointcloudOctomap { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__moveit_msgs__srv__UpdatePointcloudOctomap () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub cloud : sensor_msgs :: msg :: PointCloud2 } impl WrappedTypesupport for Request { type CStruct = moveit_msgs__srv__UpdatePointcloudOctomap_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__srv__UpdatePointcloudOctomap_Request () } } fn create_msg () -> * mut moveit_msgs__srv__UpdatePointcloudOctomap_Request { unsafe { moveit_msgs__srv__UpdatePointcloudOctomap_Request__create () } } fn destroy_msg (msg : * mut moveit_msgs__srv__UpdatePointcloudOctomap_Request) -> () { unsafe { moveit_msgs__srv__UpdatePointcloudOctomap_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { cloud : sensor_msgs :: msg :: PointCloud2 :: from_native (& msg . cloud) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . cloud . copy_to_native (& mut msg . cloud) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool } impl WrappedTypesupport for Response { type CStruct = moveit_msgs__srv__UpdatePointcloudOctomap_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__srv__UpdatePointcloudOctomap_Response () } } fn create_msg () -> * mut moveit_msgs__srv__UpdatePointcloudOctomap_Response { unsafe { moveit_msgs__srv__UpdatePointcloudOctomap_Response__create () } } fn destroy_msg (msg : * mut moveit_msgs__srv__UpdatePointcloudOctomap_Response) -> () { unsafe { moveit_msgs__srv__UpdatePointcloudOctomap_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } } pub mod action { # [allow (non_snake_case)] pub mod ExecuteTrajectory { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Action () ; impl WrappedActionTypeSupport for Action { type Goal = Goal ; type Result = Result ; type Feedback = Feedback ; type FeedbackMessage = FeedbackMessage ; type SendGoal = SendGoal :: Service ; type GetResult = GetResult :: Service ; fn get_ts () -> & 'static rosidl_action_type_support_t { unsafe { & * rosidl_typesupport_c__get_action_type_support_handle__moveit_msgs__action__ExecuteTrajectory () } } fn make_goal_request_msg (goal_id : unique_identifier_msgs :: msg :: UUID , goal : Goal) -> SendGoal :: Request { SendGoal :: Request { goal_id , goal } } fn make_goal_response_msg (accepted : bool , stamp : builtin_interfaces :: msg :: Time) -> SendGoal :: Response { SendGoal :: Response { accepted , stamp } } fn make_feedback_msg (goal_id : unique_identifier_msgs :: msg :: UUID , feedback : Feedback) -> FeedbackMessage { FeedbackMessage { goal_id , feedback } } fn make_result_request_msg (goal_id : unique_identifier_msgs :: msg :: UUID) -> GetResult :: Request { GetResult :: Request { goal_id , } } fn make_result_response_msg (status : i8 , result : Result) -> GetResult :: Response { GetResult :: Response { status , result , } } fn destructure_goal_request_msg (msg : SendGoal :: Request) -> (unique_identifier_msgs :: msg :: UUID , Goal) { (msg . goal_id , msg . goal) } fn destructure_goal_response_msg (msg : SendGoal :: Response) -> (bool , builtin_interfaces :: msg :: Time) { (msg . accepted , msg . stamp) } fn destructure_feedback_msg (msg : FeedbackMessage) -> (unique_identifier_msgs :: msg :: UUID , Feedback) { (msg . goal_id , msg . feedback) } fn destructure_result_response_msg (msg : GetResult :: Response) -> (i8 , Result) { (msg . status , msg . result) } fn destructure_result_request_msg (msg : GetResult :: Request) -> unique_identifier_msgs :: msg :: UUID { msg . goal_id } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Goal { pub trajectory : moveit_msgs :: msg :: RobotTrajectory } impl WrappedTypesupport for Goal { type CStruct = moveit_msgs__action__ExecuteTrajectory_Goal ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__action__ExecuteTrajectory_Goal () } } fn create_msg () -> * mut moveit_msgs__action__ExecuteTrajectory_Goal { unsafe { moveit_msgs__action__ExecuteTrajectory_Goal__create () } } fn destroy_msg (msg : * mut moveit_msgs__action__ExecuteTrajectory_Goal) -> () { unsafe { moveit_msgs__action__ExecuteTrajectory_Goal__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Goal { Goal { trajectory : moveit_msgs :: msg :: RobotTrajectory :: from_native (& msg . trajectory) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . trajectory . copy_to_native (& mut msg . trajectory) ; } } impl Default for Goal { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Goal > :: new () ; Goal :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Result { pub error_code : moveit_msgs :: msg :: MoveItErrorCodes } impl WrappedTypesupport for Result { type CStruct = moveit_msgs__action__ExecuteTrajectory_Result ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__action__ExecuteTrajectory_Result () } } fn create_msg () -> * mut moveit_msgs__action__ExecuteTrajectory_Result { unsafe { moveit_msgs__action__ExecuteTrajectory_Result__create () } } fn destroy_msg (msg : * mut moveit_msgs__action__ExecuteTrajectory_Result) -> () { unsafe { moveit_msgs__action__ExecuteTrajectory_Result__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Result { Result { error_code : moveit_msgs :: msg :: MoveItErrorCodes :: from_native (& msg . error_code) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . error_code . copy_to_native (& mut msg . error_code) ; } } impl Default for Result { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Result > :: new () ; Result :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Feedback { pub state : std :: string :: String } impl WrappedTypesupport for Feedback { type CStruct = moveit_msgs__action__ExecuteTrajectory_Feedback ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__action__ExecuteTrajectory_Feedback () } } fn create_msg () -> * mut moveit_msgs__action__ExecuteTrajectory_Feedback { unsafe { moveit_msgs__action__ExecuteTrajectory_Feedback__create () } } fn destroy_msg (msg : * mut moveit_msgs__action__ExecuteTrajectory_Feedback) -> () { unsafe { moveit_msgs__action__ExecuteTrajectory_Feedback__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Feedback { Feedback { state : msg . state . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . state . assign (& self . state) ; } } impl Default for Feedback { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Feedback > :: new () ; Feedback :: from_native (& msg_native) } } # [allow (non_snake_case)] pub mod SendGoal { use super :: super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__moveit_msgs__action__ExecuteTrajectory_SendGoal () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub goal_id : unique_identifier_msgs :: msg :: UUID , pub goal : moveit_msgs :: action :: ExecuteTrajectory :: Goal } impl WrappedTypesupport for Request { type CStruct = moveit_msgs__action__ExecuteTrajectory_SendGoal_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__action__ExecuteTrajectory_SendGoal_Request () } } fn create_msg () -> * mut moveit_msgs__action__ExecuteTrajectory_SendGoal_Request { unsafe { moveit_msgs__action__ExecuteTrajectory_SendGoal_Request__create () } } fn destroy_msg (msg : * mut moveit_msgs__action__ExecuteTrajectory_SendGoal_Request) -> () { unsafe { moveit_msgs__action__ExecuteTrajectory_SendGoal_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { goal_id : unique_identifier_msgs :: msg :: UUID :: from_native (& msg . goal_id) , goal : moveit_msgs :: action :: ExecuteTrajectory :: Goal :: from_native (& msg . goal) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . goal_id . copy_to_native (& mut msg . goal_id) ; self . goal . copy_to_native (& mut msg . goal) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub accepted : bool , pub stamp : builtin_interfaces :: msg :: Time } impl WrappedTypesupport for Response { type CStruct = moveit_msgs__action__ExecuteTrajectory_SendGoal_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__action__ExecuteTrajectory_SendGoal_Response () } } fn create_msg () -> * mut moveit_msgs__action__ExecuteTrajectory_SendGoal_Response { unsafe { moveit_msgs__action__ExecuteTrajectory_SendGoal_Response__create () } } fn destroy_msg (msg : * mut moveit_msgs__action__ExecuteTrajectory_SendGoal_Response) -> () { unsafe { moveit_msgs__action__ExecuteTrajectory_SendGoal_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { accepted : msg . accepted , stamp : builtin_interfaces :: msg :: Time :: from_native (& msg . stamp) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . accepted = self . accepted ; self . stamp . copy_to_native (& mut msg . stamp) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetResult { use super :: super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__moveit_msgs__action__ExecuteTrajectory_GetResult () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub goal_id : unique_identifier_msgs :: msg :: UUID } impl WrappedTypesupport for Request { type CStruct = moveit_msgs__action__ExecuteTrajectory_GetResult_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__action__ExecuteTrajectory_GetResult_Request () } } fn create_msg () -> * mut moveit_msgs__action__ExecuteTrajectory_GetResult_Request { unsafe { moveit_msgs__action__ExecuteTrajectory_GetResult_Request__create () } } fn destroy_msg (msg : * mut moveit_msgs__action__ExecuteTrajectory_GetResult_Request) -> () { unsafe { moveit_msgs__action__ExecuteTrajectory_GetResult_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { goal_id : unique_identifier_msgs :: msg :: UUID :: from_native (& msg . goal_id) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . goal_id . copy_to_native (& mut msg . goal_id) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub status : i8 , pub result : moveit_msgs :: action :: ExecuteTrajectory :: Result } impl WrappedTypesupport for Response { type CStruct = moveit_msgs__action__ExecuteTrajectory_GetResult_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__action__ExecuteTrajectory_GetResult_Response () } } fn create_msg () -> * mut moveit_msgs__action__ExecuteTrajectory_GetResult_Response { unsafe { moveit_msgs__action__ExecuteTrajectory_GetResult_Response__create () } } fn destroy_msg (msg : * mut moveit_msgs__action__ExecuteTrajectory_GetResult_Response) -> () { unsafe { moveit_msgs__action__ExecuteTrajectory_GetResult_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { status : msg . status , result : moveit_msgs :: action :: ExecuteTrajectory :: Result :: from_native (& msg . result) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . status = self . status ; self . result . copy_to_native (& mut msg . result) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct FeedbackMessage { pub goal_id : unique_identifier_msgs :: msg :: UUID , pub feedback : moveit_msgs :: action :: ExecuteTrajectory :: Feedback } impl WrappedTypesupport for FeedbackMessage { type CStruct = moveit_msgs__action__ExecuteTrajectory_FeedbackMessage ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__action__ExecuteTrajectory_FeedbackMessage () } } fn create_msg () -> * mut moveit_msgs__action__ExecuteTrajectory_FeedbackMessage { unsafe { moveit_msgs__action__ExecuteTrajectory_FeedbackMessage__create () } } fn destroy_msg (msg : * mut moveit_msgs__action__ExecuteTrajectory_FeedbackMessage) -> () { unsafe { moveit_msgs__action__ExecuteTrajectory_FeedbackMessage__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> FeedbackMessage { FeedbackMessage { goal_id : unique_identifier_msgs :: msg :: UUID :: from_native (& msg . goal_id) , feedback : moveit_msgs :: action :: ExecuteTrajectory :: Feedback :: from_native (& msg . feedback) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . goal_id . copy_to_native (& mut msg . goal_id) ; self . feedback . copy_to_native (& mut msg . feedback) ; } } impl Default for FeedbackMessage { fn default () -> Self { let msg_native = WrappedNativeMsg :: < FeedbackMessage > :: new () ; FeedbackMessage :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GlobalPlanner { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Action () ; impl WrappedActionTypeSupport for Action { type Goal = Goal ; type Result = Result ; type Feedback = Feedback ; type FeedbackMessage = FeedbackMessage ; type SendGoal = SendGoal :: Service ; type GetResult = GetResult :: Service ; fn get_ts () -> & 'static rosidl_action_type_support_t { unsafe { & * rosidl_typesupport_c__get_action_type_support_handle__moveit_msgs__action__GlobalPlanner () } } fn make_goal_request_msg (goal_id : unique_identifier_msgs :: msg :: UUID , goal : Goal) -> SendGoal :: Request { SendGoal :: Request { goal_id , goal } } fn make_goal_response_msg (accepted : bool , stamp : builtin_interfaces :: msg :: Time) -> SendGoal :: Response { SendGoal :: Response { accepted , stamp } } fn make_feedback_msg (goal_id : unique_identifier_msgs :: msg :: UUID , feedback : Feedback) -> FeedbackMessage { FeedbackMessage { goal_id , feedback } } fn make_result_request_msg (goal_id : unique_identifier_msgs :: msg :: UUID) -> GetResult :: Request { GetResult :: Request { goal_id , } } fn make_result_response_msg (status : i8 , result : Result) -> GetResult :: Response { GetResult :: Response { status , result , } } fn destructure_goal_request_msg (msg : SendGoal :: Request) -> (unique_identifier_msgs :: msg :: UUID , Goal) { (msg . goal_id , msg . goal) } fn destructure_goal_response_msg (msg : SendGoal :: Response) -> (bool , builtin_interfaces :: msg :: Time) { (msg . accepted , msg . stamp) } fn destructure_feedback_msg (msg : FeedbackMessage) -> (unique_identifier_msgs :: msg :: UUID , Feedback) { (msg . goal_id , msg . feedback) } fn destructure_result_response_msg (msg : GetResult :: Response) -> (i8 , Result) { (msg . status , msg . result) } fn destructure_result_request_msg (msg : GetResult :: Request) -> unique_identifier_msgs :: msg :: UUID { msg . goal_id } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Goal { pub planning_group : std :: string :: String , pub motion_sequence : moveit_msgs :: msg :: MotionSequenceRequest } impl WrappedTypesupport for Goal { type CStruct = moveit_msgs__action__GlobalPlanner_Goal ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__action__GlobalPlanner_Goal () } } fn create_msg () -> * mut moveit_msgs__action__GlobalPlanner_Goal { unsafe { moveit_msgs__action__GlobalPlanner_Goal__create () } } fn destroy_msg (msg : * mut moveit_msgs__action__GlobalPlanner_Goal) -> () { unsafe { moveit_msgs__action__GlobalPlanner_Goal__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Goal { Goal { planning_group : msg . planning_group . to_str () . to_owned () , motion_sequence : moveit_msgs :: msg :: MotionSequenceRequest :: from_native (& msg . motion_sequence) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . planning_group . assign (& self . planning_group) ; self . motion_sequence . copy_to_native (& mut msg . motion_sequence) ; } } impl Default for Goal { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Goal > :: new () ; Goal :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Result { pub response : moveit_msgs :: msg :: MotionPlanResponse } impl WrappedTypesupport for Result { type CStruct = moveit_msgs__action__GlobalPlanner_Result ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__action__GlobalPlanner_Result () } } fn create_msg () -> * mut moveit_msgs__action__GlobalPlanner_Result { unsafe { moveit_msgs__action__GlobalPlanner_Result__create () } } fn destroy_msg (msg : * mut moveit_msgs__action__GlobalPlanner_Result) -> () { unsafe { moveit_msgs__action__GlobalPlanner_Result__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Result { Result { response : moveit_msgs :: msg :: MotionPlanResponse :: from_native (& msg . response) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . response . copy_to_native (& mut msg . response) ; } } impl Default for Result { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Result > :: new () ; Result :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Feedback { pub feedback : std :: string :: String } impl WrappedTypesupport for Feedback { type CStruct = moveit_msgs__action__GlobalPlanner_Feedback ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__action__GlobalPlanner_Feedback () } } fn create_msg () -> * mut moveit_msgs__action__GlobalPlanner_Feedback { unsafe { moveit_msgs__action__GlobalPlanner_Feedback__create () } } fn destroy_msg (msg : * mut moveit_msgs__action__GlobalPlanner_Feedback) -> () { unsafe { moveit_msgs__action__GlobalPlanner_Feedback__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Feedback { Feedback { feedback : msg . feedback . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . feedback . assign (& self . feedback) ; } } impl Default for Feedback { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Feedback > :: new () ; Feedback :: from_native (& msg_native) } } # [allow (non_snake_case)] pub mod SendGoal { use super :: super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__moveit_msgs__action__GlobalPlanner_SendGoal () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub goal_id : unique_identifier_msgs :: msg :: UUID , pub goal : moveit_msgs :: action :: GlobalPlanner :: Goal } impl WrappedTypesupport for Request { type CStruct = moveit_msgs__action__GlobalPlanner_SendGoal_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__action__GlobalPlanner_SendGoal_Request () } } fn create_msg () -> * mut moveit_msgs__action__GlobalPlanner_SendGoal_Request { unsafe { moveit_msgs__action__GlobalPlanner_SendGoal_Request__create () } } fn destroy_msg (msg : * mut moveit_msgs__action__GlobalPlanner_SendGoal_Request) -> () { unsafe { moveit_msgs__action__GlobalPlanner_SendGoal_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { goal_id : unique_identifier_msgs :: msg :: UUID :: from_native (& msg . goal_id) , goal : moveit_msgs :: action :: GlobalPlanner :: Goal :: from_native (& msg . goal) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . goal_id . copy_to_native (& mut msg . goal_id) ; self . goal . copy_to_native (& mut msg . goal) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub accepted : bool , pub stamp : builtin_interfaces :: msg :: Time } impl WrappedTypesupport for Response { type CStruct = moveit_msgs__action__GlobalPlanner_SendGoal_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__action__GlobalPlanner_SendGoal_Response () } } fn create_msg () -> * mut moveit_msgs__action__GlobalPlanner_SendGoal_Response { unsafe { moveit_msgs__action__GlobalPlanner_SendGoal_Response__create () } } fn destroy_msg (msg : * mut moveit_msgs__action__GlobalPlanner_SendGoal_Response) -> () { unsafe { moveit_msgs__action__GlobalPlanner_SendGoal_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { accepted : msg . accepted , stamp : builtin_interfaces :: msg :: Time :: from_native (& msg . stamp) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . accepted = self . accepted ; self . stamp . copy_to_native (& mut msg . stamp) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetResult { use super :: super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__moveit_msgs__action__GlobalPlanner_GetResult () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub goal_id : unique_identifier_msgs :: msg :: UUID } impl WrappedTypesupport for Request { type CStruct = moveit_msgs__action__GlobalPlanner_GetResult_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__action__GlobalPlanner_GetResult_Request () } } fn create_msg () -> * mut moveit_msgs__action__GlobalPlanner_GetResult_Request { unsafe { moveit_msgs__action__GlobalPlanner_GetResult_Request__create () } } fn destroy_msg (msg : * mut moveit_msgs__action__GlobalPlanner_GetResult_Request) -> () { unsafe { moveit_msgs__action__GlobalPlanner_GetResult_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { goal_id : unique_identifier_msgs :: msg :: UUID :: from_native (& msg . goal_id) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . goal_id . copy_to_native (& mut msg . goal_id) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub status : i8 , pub result : moveit_msgs :: action :: GlobalPlanner :: Result } impl WrappedTypesupport for Response { type CStruct = moveit_msgs__action__GlobalPlanner_GetResult_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__action__GlobalPlanner_GetResult_Response () } } fn create_msg () -> * mut moveit_msgs__action__GlobalPlanner_GetResult_Response { unsafe { moveit_msgs__action__GlobalPlanner_GetResult_Response__create () } } fn destroy_msg (msg : * mut moveit_msgs__action__GlobalPlanner_GetResult_Response) -> () { unsafe { moveit_msgs__action__GlobalPlanner_GetResult_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { status : msg . status , result : moveit_msgs :: action :: GlobalPlanner :: Result :: from_native (& msg . result) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . status = self . status ; self . result . copy_to_native (& mut msg . result) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct FeedbackMessage { pub goal_id : unique_identifier_msgs :: msg :: UUID , pub feedback : moveit_msgs :: action :: GlobalPlanner :: Feedback } impl WrappedTypesupport for FeedbackMessage { type CStruct = moveit_msgs__action__GlobalPlanner_FeedbackMessage ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__action__GlobalPlanner_FeedbackMessage () } } fn create_msg () -> * mut moveit_msgs__action__GlobalPlanner_FeedbackMessage { unsafe { moveit_msgs__action__GlobalPlanner_FeedbackMessage__create () } } fn destroy_msg (msg : * mut moveit_msgs__action__GlobalPlanner_FeedbackMessage) -> () { unsafe { moveit_msgs__action__GlobalPlanner_FeedbackMessage__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> FeedbackMessage { FeedbackMessage { goal_id : unique_identifier_msgs :: msg :: UUID :: from_native (& msg . goal_id) , feedback : moveit_msgs :: action :: GlobalPlanner :: Feedback :: from_native (& msg . feedback) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . goal_id . copy_to_native (& mut msg . goal_id) ; self . feedback . copy_to_native (& mut msg . feedback) ; } } impl Default for FeedbackMessage { fn default () -> Self { let msg_native = WrappedNativeMsg :: < FeedbackMessage > :: new () ; FeedbackMessage :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod HybridPlanner { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Action () ; impl WrappedActionTypeSupport for Action { type Goal = Goal ; type Result = Result ; type Feedback = Feedback ; type FeedbackMessage = FeedbackMessage ; type SendGoal = SendGoal :: Service ; type GetResult = GetResult :: Service ; fn get_ts () -> & 'static rosidl_action_type_support_t { unsafe { & * rosidl_typesupport_c__get_action_type_support_handle__moveit_msgs__action__HybridPlanner () } } fn make_goal_request_msg (goal_id : unique_identifier_msgs :: msg :: UUID , goal : Goal) -> SendGoal :: Request { SendGoal :: Request { goal_id , goal } } fn make_goal_response_msg (accepted : bool , stamp : builtin_interfaces :: msg :: Time) -> SendGoal :: Response { SendGoal :: Response { accepted , stamp } } fn make_feedback_msg (goal_id : unique_identifier_msgs :: msg :: UUID , feedback : Feedback) -> FeedbackMessage { FeedbackMessage { goal_id , feedback } } fn make_result_request_msg (goal_id : unique_identifier_msgs :: msg :: UUID) -> GetResult :: Request { GetResult :: Request { goal_id , } } fn make_result_response_msg (status : i8 , result : Result) -> GetResult :: Response { GetResult :: Response { status , result , } } fn destructure_goal_request_msg (msg : SendGoal :: Request) -> (unique_identifier_msgs :: msg :: UUID , Goal) { (msg . goal_id , msg . goal) } fn destructure_goal_response_msg (msg : SendGoal :: Response) -> (bool , builtin_interfaces :: msg :: Time) { (msg . accepted , msg . stamp) } fn destructure_feedback_msg (msg : FeedbackMessage) -> (unique_identifier_msgs :: msg :: UUID , Feedback) { (msg . goal_id , msg . feedback) } fn destructure_result_response_msg (msg : GetResult :: Response) -> (i8 , Result) { (msg . status , msg . result) } fn destructure_result_request_msg (msg : GetResult :: Request) -> unique_identifier_msgs :: msg :: UUID { msg . goal_id } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Goal { pub planning_group : std :: string :: String , pub motion_sequence : moveit_msgs :: msg :: MotionSequenceRequest } impl WrappedTypesupport for Goal { type CStruct = moveit_msgs__action__HybridPlanner_Goal ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__action__HybridPlanner_Goal () } } fn create_msg () -> * mut moveit_msgs__action__HybridPlanner_Goal { unsafe { moveit_msgs__action__HybridPlanner_Goal__create () } } fn destroy_msg (msg : * mut moveit_msgs__action__HybridPlanner_Goal) -> () { unsafe { moveit_msgs__action__HybridPlanner_Goal__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Goal { Goal { planning_group : msg . planning_group . to_str () . to_owned () , motion_sequence : moveit_msgs :: msg :: MotionSequenceRequest :: from_native (& msg . motion_sequence) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . planning_group . assign (& self . planning_group) ; self . motion_sequence . copy_to_native (& mut msg . motion_sequence) ; } } impl Default for Goal { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Goal > :: new () ; Goal :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Result { pub error_code : moveit_msgs :: msg :: MoveItErrorCodes , pub error_message : std :: string :: String } impl WrappedTypesupport for Result { type CStruct = moveit_msgs__action__HybridPlanner_Result ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__action__HybridPlanner_Result () } } fn create_msg () -> * mut moveit_msgs__action__HybridPlanner_Result { unsafe { moveit_msgs__action__HybridPlanner_Result__create () } } fn destroy_msg (msg : * mut moveit_msgs__action__HybridPlanner_Result) -> () { unsafe { moveit_msgs__action__HybridPlanner_Result__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Result { Result { error_code : moveit_msgs :: msg :: MoveItErrorCodes :: from_native (& msg . error_code) , error_message : msg . error_message . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . error_code . copy_to_native (& mut msg . error_code) ; msg . error_message . assign (& self . error_message) ; } } impl Default for Result { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Result > :: new () ; Result :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Feedback { pub feedback : std :: string :: String } impl WrappedTypesupport for Feedback { type CStruct = moveit_msgs__action__HybridPlanner_Feedback ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__action__HybridPlanner_Feedback () } } fn create_msg () -> * mut moveit_msgs__action__HybridPlanner_Feedback { unsafe { moveit_msgs__action__HybridPlanner_Feedback__create () } } fn destroy_msg (msg : * mut moveit_msgs__action__HybridPlanner_Feedback) -> () { unsafe { moveit_msgs__action__HybridPlanner_Feedback__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Feedback { Feedback { feedback : msg . feedback . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . feedback . assign (& self . feedback) ; } } impl Default for Feedback { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Feedback > :: new () ; Feedback :: from_native (& msg_native) } } # [allow (non_snake_case)] pub mod SendGoal { use super :: super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__moveit_msgs__action__HybridPlanner_SendGoal () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub goal_id : unique_identifier_msgs :: msg :: UUID , pub goal : moveit_msgs :: action :: HybridPlanner :: Goal } impl WrappedTypesupport for Request { type CStruct = moveit_msgs__action__HybridPlanner_SendGoal_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__action__HybridPlanner_SendGoal_Request () } } fn create_msg () -> * mut moveit_msgs__action__HybridPlanner_SendGoal_Request { unsafe { moveit_msgs__action__HybridPlanner_SendGoal_Request__create () } } fn destroy_msg (msg : * mut moveit_msgs__action__HybridPlanner_SendGoal_Request) -> () { unsafe { moveit_msgs__action__HybridPlanner_SendGoal_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { goal_id : unique_identifier_msgs :: msg :: UUID :: from_native (& msg . goal_id) , goal : moveit_msgs :: action :: HybridPlanner :: Goal :: from_native (& msg . goal) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . goal_id . copy_to_native (& mut msg . goal_id) ; self . goal . copy_to_native (& mut msg . goal) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub accepted : bool , pub stamp : builtin_interfaces :: msg :: Time } impl WrappedTypesupport for Response { type CStruct = moveit_msgs__action__HybridPlanner_SendGoal_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__action__HybridPlanner_SendGoal_Response () } } fn create_msg () -> * mut moveit_msgs__action__HybridPlanner_SendGoal_Response { unsafe { moveit_msgs__action__HybridPlanner_SendGoal_Response__create () } } fn destroy_msg (msg : * mut moveit_msgs__action__HybridPlanner_SendGoal_Response) -> () { unsafe { moveit_msgs__action__HybridPlanner_SendGoal_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { accepted : msg . accepted , stamp : builtin_interfaces :: msg :: Time :: from_native (& msg . stamp) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . accepted = self . accepted ; self . stamp . copy_to_native (& mut msg . stamp) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetResult { use super :: super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__moveit_msgs__action__HybridPlanner_GetResult () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub goal_id : unique_identifier_msgs :: msg :: UUID } impl WrappedTypesupport for Request { type CStruct = moveit_msgs__action__HybridPlanner_GetResult_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__action__HybridPlanner_GetResult_Request () } } fn create_msg () -> * mut moveit_msgs__action__HybridPlanner_GetResult_Request { unsafe { moveit_msgs__action__HybridPlanner_GetResult_Request__create () } } fn destroy_msg (msg : * mut moveit_msgs__action__HybridPlanner_GetResult_Request) -> () { unsafe { moveit_msgs__action__HybridPlanner_GetResult_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { goal_id : unique_identifier_msgs :: msg :: UUID :: from_native (& msg . goal_id) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . goal_id . copy_to_native (& mut msg . goal_id) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub status : i8 , pub result : moveit_msgs :: action :: HybridPlanner :: Result } impl WrappedTypesupport for Response { type CStruct = moveit_msgs__action__HybridPlanner_GetResult_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__action__HybridPlanner_GetResult_Response () } } fn create_msg () -> * mut moveit_msgs__action__HybridPlanner_GetResult_Response { unsafe { moveit_msgs__action__HybridPlanner_GetResult_Response__create () } } fn destroy_msg (msg : * mut moveit_msgs__action__HybridPlanner_GetResult_Response) -> () { unsafe { moveit_msgs__action__HybridPlanner_GetResult_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { status : msg . status , result : moveit_msgs :: action :: HybridPlanner :: Result :: from_native (& msg . result) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . status = self . status ; self . result . copy_to_native (& mut msg . result) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct FeedbackMessage { pub goal_id : unique_identifier_msgs :: msg :: UUID , pub feedback : moveit_msgs :: action :: HybridPlanner :: Feedback } impl WrappedTypesupport for FeedbackMessage { type CStruct = moveit_msgs__action__HybridPlanner_FeedbackMessage ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__action__HybridPlanner_FeedbackMessage () } } fn create_msg () -> * mut moveit_msgs__action__HybridPlanner_FeedbackMessage { unsafe { moveit_msgs__action__HybridPlanner_FeedbackMessage__create () } } fn destroy_msg (msg : * mut moveit_msgs__action__HybridPlanner_FeedbackMessage) -> () { unsafe { moveit_msgs__action__HybridPlanner_FeedbackMessage__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> FeedbackMessage { FeedbackMessage { goal_id : unique_identifier_msgs :: msg :: UUID :: from_native (& msg . goal_id) , feedback : moveit_msgs :: action :: HybridPlanner :: Feedback :: from_native (& msg . feedback) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . goal_id . copy_to_native (& mut msg . goal_id) ; self . feedback . copy_to_native (& mut msg . feedback) ; } } impl Default for FeedbackMessage { fn default () -> Self { let msg_native = WrappedNativeMsg :: < FeedbackMessage > :: new () ; FeedbackMessage :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod LocalPlanner { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Action () ; impl WrappedActionTypeSupport for Action { type Goal = Goal ; type Result = Result ; type Feedback = Feedback ; type FeedbackMessage = FeedbackMessage ; type SendGoal = SendGoal :: Service ; type GetResult = GetResult :: Service ; fn get_ts () -> & 'static rosidl_action_type_support_t { unsafe { & * rosidl_typesupport_c__get_action_type_support_handle__moveit_msgs__action__LocalPlanner () } } fn make_goal_request_msg (goal_id : unique_identifier_msgs :: msg :: UUID , goal : Goal) -> SendGoal :: Request { SendGoal :: Request { goal_id , goal } } fn make_goal_response_msg (accepted : bool , stamp : builtin_interfaces :: msg :: Time) -> SendGoal :: Response { SendGoal :: Response { accepted , stamp } } fn make_feedback_msg (goal_id : unique_identifier_msgs :: msg :: UUID , feedback : Feedback) -> FeedbackMessage { FeedbackMessage { goal_id , feedback } } fn make_result_request_msg (goal_id : unique_identifier_msgs :: msg :: UUID) -> GetResult :: Request { GetResult :: Request { goal_id , } } fn make_result_response_msg (status : i8 , result : Result) -> GetResult :: Response { GetResult :: Response { status , result , } } fn destructure_goal_request_msg (msg : SendGoal :: Request) -> (unique_identifier_msgs :: msg :: UUID , Goal) { (msg . goal_id , msg . goal) } fn destructure_goal_response_msg (msg : SendGoal :: Response) -> (bool , builtin_interfaces :: msg :: Time) { (msg . accepted , msg . stamp) } fn destructure_feedback_msg (msg : FeedbackMessage) -> (unique_identifier_msgs :: msg :: UUID , Feedback) { (msg . goal_id , msg . feedback) } fn destructure_result_response_msg (msg : GetResult :: Response) -> (i8 , Result) { (msg . status , msg . result) } fn destructure_result_request_msg (msg : GetResult :: Request) -> unique_identifier_msgs :: msg :: UUID { msg . goal_id } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Goal { pub local_constraints : Vec < moveit_msgs :: msg :: Constraints > } impl WrappedTypesupport for Goal { type CStruct = moveit_msgs__action__LocalPlanner_Goal ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__action__LocalPlanner_Goal () } } fn create_msg () -> * mut moveit_msgs__action__LocalPlanner_Goal { unsafe { moveit_msgs__action__LocalPlanner_Goal__create () } } fn destroy_msg (msg : * mut moveit_msgs__action__LocalPlanner_Goal) -> () { unsafe { moveit_msgs__action__LocalPlanner_Goal__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Goal { Goal { local_constraints : { let mut temp = Vec :: with_capacity (msg . local_constraints . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . local_constraints . data , msg . local_constraints . size) } ; for s in slice { temp . push (moveit_msgs :: msg :: Constraints :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { unsafe { moveit_msgs__msg__Constraints__Sequence__fini (& mut msg . local_constraints) ; moveit_msgs__msg__Constraints__Sequence__init (& mut msg . local_constraints , self . local_constraints . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . local_constraints . data , msg . local_constraints . size) ; for (t , s) in slice . iter_mut () . zip (& self . local_constraints) { s . copy_to_native (t) ; } } } } impl Default for Goal { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Goal > :: new () ; Goal :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Result { pub error_code : moveit_msgs :: msg :: MoveItErrorCodes , pub error_message : std :: string :: String } impl WrappedTypesupport for Result { type CStruct = moveit_msgs__action__LocalPlanner_Result ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__action__LocalPlanner_Result () } } fn create_msg () -> * mut moveit_msgs__action__LocalPlanner_Result { unsafe { moveit_msgs__action__LocalPlanner_Result__create () } } fn destroy_msg (msg : * mut moveit_msgs__action__LocalPlanner_Result) -> () { unsafe { moveit_msgs__action__LocalPlanner_Result__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Result { Result { error_code : moveit_msgs :: msg :: MoveItErrorCodes :: from_native (& msg . error_code) , error_message : msg . error_message . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . error_code . copy_to_native (& mut msg . error_code) ; msg . error_message . assign (& self . error_message) ; } } impl Default for Result { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Result > :: new () ; Result :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Feedback { pub feedback : std :: string :: String } impl WrappedTypesupport for Feedback { type CStruct = moveit_msgs__action__LocalPlanner_Feedback ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__action__LocalPlanner_Feedback () } } fn create_msg () -> * mut moveit_msgs__action__LocalPlanner_Feedback { unsafe { moveit_msgs__action__LocalPlanner_Feedback__create () } } fn destroy_msg (msg : * mut moveit_msgs__action__LocalPlanner_Feedback) -> () { unsafe { moveit_msgs__action__LocalPlanner_Feedback__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Feedback { Feedback { feedback : msg . feedback . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . feedback . assign (& self . feedback) ; } } impl Default for Feedback { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Feedback > :: new () ; Feedback :: from_native (& msg_native) } } # [allow (non_snake_case)] pub mod SendGoal { use super :: super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__moveit_msgs__action__LocalPlanner_SendGoal () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub goal_id : unique_identifier_msgs :: msg :: UUID , pub goal : moveit_msgs :: action :: LocalPlanner :: Goal } impl WrappedTypesupport for Request { type CStruct = moveit_msgs__action__LocalPlanner_SendGoal_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__action__LocalPlanner_SendGoal_Request () } } fn create_msg () -> * mut moveit_msgs__action__LocalPlanner_SendGoal_Request { unsafe { moveit_msgs__action__LocalPlanner_SendGoal_Request__create () } } fn destroy_msg (msg : * mut moveit_msgs__action__LocalPlanner_SendGoal_Request) -> () { unsafe { moveit_msgs__action__LocalPlanner_SendGoal_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { goal_id : unique_identifier_msgs :: msg :: UUID :: from_native (& msg . goal_id) , goal : moveit_msgs :: action :: LocalPlanner :: Goal :: from_native (& msg . goal) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . goal_id . copy_to_native (& mut msg . goal_id) ; self . goal . copy_to_native (& mut msg . goal) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub accepted : bool , pub stamp : builtin_interfaces :: msg :: Time } impl WrappedTypesupport for Response { type CStruct = moveit_msgs__action__LocalPlanner_SendGoal_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__action__LocalPlanner_SendGoal_Response () } } fn create_msg () -> * mut moveit_msgs__action__LocalPlanner_SendGoal_Response { unsafe { moveit_msgs__action__LocalPlanner_SendGoal_Response__create () } } fn destroy_msg (msg : * mut moveit_msgs__action__LocalPlanner_SendGoal_Response) -> () { unsafe { moveit_msgs__action__LocalPlanner_SendGoal_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { accepted : msg . accepted , stamp : builtin_interfaces :: msg :: Time :: from_native (& msg . stamp) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . accepted = self . accepted ; self . stamp . copy_to_native (& mut msg . stamp) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetResult { use super :: super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__moveit_msgs__action__LocalPlanner_GetResult () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub goal_id : unique_identifier_msgs :: msg :: UUID } impl WrappedTypesupport for Request { type CStruct = moveit_msgs__action__LocalPlanner_GetResult_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__action__LocalPlanner_GetResult_Request () } } fn create_msg () -> * mut moveit_msgs__action__LocalPlanner_GetResult_Request { unsafe { moveit_msgs__action__LocalPlanner_GetResult_Request__create () } } fn destroy_msg (msg : * mut moveit_msgs__action__LocalPlanner_GetResult_Request) -> () { unsafe { moveit_msgs__action__LocalPlanner_GetResult_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { goal_id : unique_identifier_msgs :: msg :: UUID :: from_native (& msg . goal_id) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . goal_id . copy_to_native (& mut msg . goal_id) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub status : i8 , pub result : moveit_msgs :: action :: LocalPlanner :: Result } impl WrappedTypesupport for Response { type CStruct = moveit_msgs__action__LocalPlanner_GetResult_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__action__LocalPlanner_GetResult_Response () } } fn create_msg () -> * mut moveit_msgs__action__LocalPlanner_GetResult_Response { unsafe { moveit_msgs__action__LocalPlanner_GetResult_Response__create () } } fn destroy_msg (msg : * mut moveit_msgs__action__LocalPlanner_GetResult_Response) -> () { unsafe { moveit_msgs__action__LocalPlanner_GetResult_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { status : msg . status , result : moveit_msgs :: action :: LocalPlanner :: Result :: from_native (& msg . result) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . status = self . status ; self . result . copy_to_native (& mut msg . result) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct FeedbackMessage { pub goal_id : unique_identifier_msgs :: msg :: UUID , pub feedback : moveit_msgs :: action :: LocalPlanner :: Feedback } impl WrappedTypesupport for FeedbackMessage { type CStruct = moveit_msgs__action__LocalPlanner_FeedbackMessage ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__action__LocalPlanner_FeedbackMessage () } } fn create_msg () -> * mut moveit_msgs__action__LocalPlanner_FeedbackMessage { unsafe { moveit_msgs__action__LocalPlanner_FeedbackMessage__create () } } fn destroy_msg (msg : * mut moveit_msgs__action__LocalPlanner_FeedbackMessage) -> () { unsafe { moveit_msgs__action__LocalPlanner_FeedbackMessage__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> FeedbackMessage { FeedbackMessage { goal_id : unique_identifier_msgs :: msg :: UUID :: from_native (& msg . goal_id) , feedback : moveit_msgs :: action :: LocalPlanner :: Feedback :: from_native (& msg . feedback) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . goal_id . copy_to_native (& mut msg . goal_id) ; self . feedback . copy_to_native (& mut msg . feedback) ; } } impl Default for FeedbackMessage { fn default () -> Self { let msg_native = WrappedNativeMsg :: < FeedbackMessage > :: new () ; FeedbackMessage :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod MoveGroup { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Action () ; impl WrappedActionTypeSupport for Action { type Goal = Goal ; type Result = Result ; type Feedback = Feedback ; type FeedbackMessage = FeedbackMessage ; type SendGoal = SendGoal :: Service ; type GetResult = GetResult :: Service ; fn get_ts () -> & 'static rosidl_action_type_support_t { unsafe { & * rosidl_typesupport_c__get_action_type_support_handle__moveit_msgs__action__MoveGroup () } } fn make_goal_request_msg (goal_id : unique_identifier_msgs :: msg :: UUID , goal : Goal) -> SendGoal :: Request { SendGoal :: Request { goal_id , goal } } fn make_goal_response_msg (accepted : bool , stamp : builtin_interfaces :: msg :: Time) -> SendGoal :: Response { SendGoal :: Response { accepted , stamp } } fn make_feedback_msg (goal_id : unique_identifier_msgs :: msg :: UUID , feedback : Feedback) -> FeedbackMessage { FeedbackMessage { goal_id , feedback } } fn make_result_request_msg (goal_id : unique_identifier_msgs :: msg :: UUID) -> GetResult :: Request { GetResult :: Request { goal_id , } } fn make_result_response_msg (status : i8 , result : Result) -> GetResult :: Response { GetResult :: Response { status , result , } } fn destructure_goal_request_msg (msg : SendGoal :: Request) -> (unique_identifier_msgs :: msg :: UUID , Goal) { (msg . goal_id , msg . goal) } fn destructure_goal_response_msg (msg : SendGoal :: Response) -> (bool , builtin_interfaces :: msg :: Time) { (msg . accepted , msg . stamp) } fn destructure_feedback_msg (msg : FeedbackMessage) -> (unique_identifier_msgs :: msg :: UUID , Feedback) { (msg . goal_id , msg . feedback) } fn destructure_result_response_msg (msg : GetResult :: Response) -> (i8 , Result) { (msg . status , msg . result) } fn destructure_result_request_msg (msg : GetResult :: Request) -> unique_identifier_msgs :: msg :: UUID { msg . goal_id } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Goal { pub request : moveit_msgs :: msg :: MotionPlanRequest , pub planning_options : moveit_msgs :: msg :: PlanningOptions } impl WrappedTypesupport for Goal { type CStruct = moveit_msgs__action__MoveGroup_Goal ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__action__MoveGroup_Goal () } } fn create_msg () -> * mut moveit_msgs__action__MoveGroup_Goal { unsafe { moveit_msgs__action__MoveGroup_Goal__create () } } fn destroy_msg (msg : * mut moveit_msgs__action__MoveGroup_Goal) -> () { unsafe { moveit_msgs__action__MoveGroup_Goal__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Goal { Goal { request : moveit_msgs :: msg :: MotionPlanRequest :: from_native (& msg . request) , planning_options : moveit_msgs :: msg :: PlanningOptions :: from_native (& msg . planning_options) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . request . copy_to_native (& mut msg . request) ; self . planning_options . copy_to_native (& mut msg . planning_options) ; } } impl Default for Goal { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Goal > :: new () ; Goal :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Result { pub error_code : moveit_msgs :: msg :: MoveItErrorCodes , pub trajectory_start : moveit_msgs :: msg :: RobotState , pub planned_trajectory : moveit_msgs :: msg :: RobotTrajectory , pub executed_trajectory : moveit_msgs :: msg :: RobotTrajectory , pub planning_time : f64 } impl WrappedTypesupport for Result { type CStruct = moveit_msgs__action__MoveGroup_Result ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__action__MoveGroup_Result () } } fn create_msg () -> * mut moveit_msgs__action__MoveGroup_Result { unsafe { moveit_msgs__action__MoveGroup_Result__create () } } fn destroy_msg (msg : * mut moveit_msgs__action__MoveGroup_Result) -> () { unsafe { moveit_msgs__action__MoveGroup_Result__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Result { Result { error_code : moveit_msgs :: msg :: MoveItErrorCodes :: from_native (& msg . error_code) , trajectory_start : moveit_msgs :: msg :: RobotState :: from_native (& msg . trajectory_start) , planned_trajectory : moveit_msgs :: msg :: RobotTrajectory :: from_native (& msg . planned_trajectory) , executed_trajectory : moveit_msgs :: msg :: RobotTrajectory :: from_native (& msg . executed_trajectory) , planning_time : msg . planning_time , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . error_code . copy_to_native (& mut msg . error_code) ; self . trajectory_start . copy_to_native (& mut msg . trajectory_start) ; self . planned_trajectory . copy_to_native (& mut msg . planned_trajectory) ; self . executed_trajectory . copy_to_native (& mut msg . executed_trajectory) ; msg . planning_time = self . planning_time ; } } impl Default for Result { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Result > :: new () ; Result :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Feedback { pub state : std :: string :: String } impl WrappedTypesupport for Feedback { type CStruct = moveit_msgs__action__MoveGroup_Feedback ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__action__MoveGroup_Feedback () } } fn create_msg () -> * mut moveit_msgs__action__MoveGroup_Feedback { unsafe { moveit_msgs__action__MoveGroup_Feedback__create () } } fn destroy_msg (msg : * mut moveit_msgs__action__MoveGroup_Feedback) -> () { unsafe { moveit_msgs__action__MoveGroup_Feedback__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Feedback { Feedback { state : msg . state . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . state . assign (& self . state) ; } } impl Default for Feedback { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Feedback > :: new () ; Feedback :: from_native (& msg_native) } } # [allow (non_snake_case)] pub mod SendGoal { use super :: super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__moveit_msgs__action__MoveGroup_SendGoal () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub goal_id : unique_identifier_msgs :: msg :: UUID , pub goal : moveit_msgs :: action :: MoveGroup :: Goal } impl WrappedTypesupport for Request { type CStruct = moveit_msgs__action__MoveGroup_SendGoal_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__action__MoveGroup_SendGoal_Request () } } fn create_msg () -> * mut moveit_msgs__action__MoveGroup_SendGoal_Request { unsafe { moveit_msgs__action__MoveGroup_SendGoal_Request__create () } } fn destroy_msg (msg : * mut moveit_msgs__action__MoveGroup_SendGoal_Request) -> () { unsafe { moveit_msgs__action__MoveGroup_SendGoal_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { goal_id : unique_identifier_msgs :: msg :: UUID :: from_native (& msg . goal_id) , goal : moveit_msgs :: action :: MoveGroup :: Goal :: from_native (& msg . goal) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . goal_id . copy_to_native (& mut msg . goal_id) ; self . goal . copy_to_native (& mut msg . goal) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub accepted : bool , pub stamp : builtin_interfaces :: msg :: Time } impl WrappedTypesupport for Response { type CStruct = moveit_msgs__action__MoveGroup_SendGoal_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__action__MoveGroup_SendGoal_Response () } } fn create_msg () -> * mut moveit_msgs__action__MoveGroup_SendGoal_Response { unsafe { moveit_msgs__action__MoveGroup_SendGoal_Response__create () } } fn destroy_msg (msg : * mut moveit_msgs__action__MoveGroup_SendGoal_Response) -> () { unsafe { moveit_msgs__action__MoveGroup_SendGoal_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { accepted : msg . accepted , stamp : builtin_interfaces :: msg :: Time :: from_native (& msg . stamp) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . accepted = self . accepted ; self . stamp . copy_to_native (& mut msg . stamp) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetResult { use super :: super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__moveit_msgs__action__MoveGroup_GetResult () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub goal_id : unique_identifier_msgs :: msg :: UUID } impl WrappedTypesupport for Request { type CStruct = moveit_msgs__action__MoveGroup_GetResult_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__action__MoveGroup_GetResult_Request () } } fn create_msg () -> * mut moveit_msgs__action__MoveGroup_GetResult_Request { unsafe { moveit_msgs__action__MoveGroup_GetResult_Request__create () } } fn destroy_msg (msg : * mut moveit_msgs__action__MoveGroup_GetResult_Request) -> () { unsafe { moveit_msgs__action__MoveGroup_GetResult_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { goal_id : unique_identifier_msgs :: msg :: UUID :: from_native (& msg . goal_id) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . goal_id . copy_to_native (& mut msg . goal_id) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub status : i8 , pub result : moveit_msgs :: action :: MoveGroup :: Result } impl WrappedTypesupport for Response { type CStruct = moveit_msgs__action__MoveGroup_GetResult_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__action__MoveGroup_GetResult_Response () } } fn create_msg () -> * mut moveit_msgs__action__MoveGroup_GetResult_Response { unsafe { moveit_msgs__action__MoveGroup_GetResult_Response__create () } } fn destroy_msg (msg : * mut moveit_msgs__action__MoveGroup_GetResult_Response) -> () { unsafe { moveit_msgs__action__MoveGroup_GetResult_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { status : msg . status , result : moveit_msgs :: action :: MoveGroup :: Result :: from_native (& msg . result) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . status = self . status ; self . result . copy_to_native (& mut msg . result) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct FeedbackMessage { pub goal_id : unique_identifier_msgs :: msg :: UUID , pub feedback : moveit_msgs :: action :: MoveGroup :: Feedback } impl WrappedTypesupport for FeedbackMessage { type CStruct = moveit_msgs__action__MoveGroup_FeedbackMessage ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__action__MoveGroup_FeedbackMessage () } } fn create_msg () -> * mut moveit_msgs__action__MoveGroup_FeedbackMessage { unsafe { moveit_msgs__action__MoveGroup_FeedbackMessage__create () } } fn destroy_msg (msg : * mut moveit_msgs__action__MoveGroup_FeedbackMessage) -> () { unsafe { moveit_msgs__action__MoveGroup_FeedbackMessage__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> FeedbackMessage { FeedbackMessage { goal_id : unique_identifier_msgs :: msg :: UUID :: from_native (& msg . goal_id) , feedback : moveit_msgs :: action :: MoveGroup :: Feedback :: from_native (& msg . feedback) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . goal_id . copy_to_native (& mut msg . goal_id) ; self . feedback . copy_to_native (& mut msg . feedback) ; } } impl Default for FeedbackMessage { fn default () -> Self { let msg_native = WrappedNativeMsg :: < FeedbackMessage > :: new () ; FeedbackMessage :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod MoveGroupSequence { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Action () ; impl WrappedActionTypeSupport for Action { type Goal = Goal ; type Result = Result ; type Feedback = Feedback ; type FeedbackMessage = FeedbackMessage ; type SendGoal = SendGoal :: Service ; type GetResult = GetResult :: Service ; fn get_ts () -> & 'static rosidl_action_type_support_t { unsafe { & * rosidl_typesupport_c__get_action_type_support_handle__moveit_msgs__action__MoveGroupSequence () } } fn make_goal_request_msg (goal_id : unique_identifier_msgs :: msg :: UUID , goal : Goal) -> SendGoal :: Request { SendGoal :: Request { goal_id , goal } } fn make_goal_response_msg (accepted : bool , stamp : builtin_interfaces :: msg :: Time) -> SendGoal :: Response { SendGoal :: Response { accepted , stamp } } fn make_feedback_msg (goal_id : unique_identifier_msgs :: msg :: UUID , feedback : Feedback) -> FeedbackMessage { FeedbackMessage { goal_id , feedback } } fn make_result_request_msg (goal_id : unique_identifier_msgs :: msg :: UUID) -> GetResult :: Request { GetResult :: Request { goal_id , } } fn make_result_response_msg (status : i8 , result : Result) -> GetResult :: Response { GetResult :: Response { status , result , } } fn destructure_goal_request_msg (msg : SendGoal :: Request) -> (unique_identifier_msgs :: msg :: UUID , Goal) { (msg . goal_id , msg . goal) } fn destructure_goal_response_msg (msg : SendGoal :: Response) -> (bool , builtin_interfaces :: msg :: Time) { (msg . accepted , msg . stamp) } fn destructure_feedback_msg (msg : FeedbackMessage) -> (unique_identifier_msgs :: msg :: UUID , Feedback) { (msg . goal_id , msg . feedback) } fn destructure_result_response_msg (msg : GetResult :: Response) -> (i8 , Result) { (msg . status , msg . result) } fn destructure_result_request_msg (msg : GetResult :: Request) -> unique_identifier_msgs :: msg :: UUID { msg . goal_id } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Goal { pub request : moveit_msgs :: msg :: MotionSequenceRequest , pub planning_options : moveit_msgs :: msg :: PlanningOptions } impl WrappedTypesupport for Goal { type CStruct = moveit_msgs__action__MoveGroupSequence_Goal ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__action__MoveGroupSequence_Goal () } } fn create_msg () -> * mut moveit_msgs__action__MoveGroupSequence_Goal { unsafe { moveit_msgs__action__MoveGroupSequence_Goal__create () } } fn destroy_msg (msg : * mut moveit_msgs__action__MoveGroupSequence_Goal) -> () { unsafe { moveit_msgs__action__MoveGroupSequence_Goal__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Goal { Goal { request : moveit_msgs :: msg :: MotionSequenceRequest :: from_native (& msg . request) , planning_options : moveit_msgs :: msg :: PlanningOptions :: from_native (& msg . planning_options) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . request . copy_to_native (& mut msg . request) ; self . planning_options . copy_to_native (& mut msg . planning_options) ; } } impl Default for Goal { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Goal > :: new () ; Goal :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Result { pub response : moveit_msgs :: msg :: MotionSequenceResponse } impl WrappedTypesupport for Result { type CStruct = moveit_msgs__action__MoveGroupSequence_Result ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__action__MoveGroupSequence_Result () } } fn create_msg () -> * mut moveit_msgs__action__MoveGroupSequence_Result { unsafe { moveit_msgs__action__MoveGroupSequence_Result__create () } } fn destroy_msg (msg : * mut moveit_msgs__action__MoveGroupSequence_Result) -> () { unsafe { moveit_msgs__action__MoveGroupSequence_Result__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Result { Result { response : moveit_msgs :: msg :: MotionSequenceResponse :: from_native (& msg . response) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . response . copy_to_native (& mut msg . response) ; } } impl Default for Result { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Result > :: new () ; Result :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Feedback { pub state : std :: string :: String } impl WrappedTypesupport for Feedback { type CStruct = moveit_msgs__action__MoveGroupSequence_Feedback ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__action__MoveGroupSequence_Feedback () } } fn create_msg () -> * mut moveit_msgs__action__MoveGroupSequence_Feedback { unsafe { moveit_msgs__action__MoveGroupSequence_Feedback__create () } } fn destroy_msg (msg : * mut moveit_msgs__action__MoveGroupSequence_Feedback) -> () { unsafe { moveit_msgs__action__MoveGroupSequence_Feedback__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Feedback { Feedback { state : msg . state . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . state . assign (& self . state) ; } } impl Default for Feedback { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Feedback > :: new () ; Feedback :: from_native (& msg_native) } } # [allow (non_snake_case)] pub mod SendGoal { use super :: super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__moveit_msgs__action__MoveGroupSequence_SendGoal () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub goal_id : unique_identifier_msgs :: msg :: UUID , pub goal : moveit_msgs :: action :: MoveGroupSequence :: Goal } impl WrappedTypesupport for Request { type CStruct = moveit_msgs__action__MoveGroupSequence_SendGoal_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__action__MoveGroupSequence_SendGoal_Request () } } fn create_msg () -> * mut moveit_msgs__action__MoveGroupSequence_SendGoal_Request { unsafe { moveit_msgs__action__MoveGroupSequence_SendGoal_Request__create () } } fn destroy_msg (msg : * mut moveit_msgs__action__MoveGroupSequence_SendGoal_Request) -> () { unsafe { moveit_msgs__action__MoveGroupSequence_SendGoal_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { goal_id : unique_identifier_msgs :: msg :: UUID :: from_native (& msg . goal_id) , goal : moveit_msgs :: action :: MoveGroupSequence :: Goal :: from_native (& msg . goal) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . goal_id . copy_to_native (& mut msg . goal_id) ; self . goal . copy_to_native (& mut msg . goal) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub accepted : bool , pub stamp : builtin_interfaces :: msg :: Time } impl WrappedTypesupport for Response { type CStruct = moveit_msgs__action__MoveGroupSequence_SendGoal_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__action__MoveGroupSequence_SendGoal_Response () } } fn create_msg () -> * mut moveit_msgs__action__MoveGroupSequence_SendGoal_Response { unsafe { moveit_msgs__action__MoveGroupSequence_SendGoal_Response__create () } } fn destroy_msg (msg : * mut moveit_msgs__action__MoveGroupSequence_SendGoal_Response) -> () { unsafe { moveit_msgs__action__MoveGroupSequence_SendGoal_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { accepted : msg . accepted , stamp : builtin_interfaces :: msg :: Time :: from_native (& msg . stamp) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . accepted = self . accepted ; self . stamp . copy_to_native (& mut msg . stamp) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetResult { use super :: super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__moveit_msgs__action__MoveGroupSequence_GetResult () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub goal_id : unique_identifier_msgs :: msg :: UUID } impl WrappedTypesupport for Request { type CStruct = moveit_msgs__action__MoveGroupSequence_GetResult_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__action__MoveGroupSequence_GetResult_Request () } } fn create_msg () -> * mut moveit_msgs__action__MoveGroupSequence_GetResult_Request { unsafe { moveit_msgs__action__MoveGroupSequence_GetResult_Request__create () } } fn destroy_msg (msg : * mut moveit_msgs__action__MoveGroupSequence_GetResult_Request) -> () { unsafe { moveit_msgs__action__MoveGroupSequence_GetResult_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { goal_id : unique_identifier_msgs :: msg :: UUID :: from_native (& msg . goal_id) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . goal_id . copy_to_native (& mut msg . goal_id) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub status : i8 , pub result : moveit_msgs :: action :: MoveGroupSequence :: Result } impl WrappedTypesupport for Response { type CStruct = moveit_msgs__action__MoveGroupSequence_GetResult_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__action__MoveGroupSequence_GetResult_Response () } } fn create_msg () -> * mut moveit_msgs__action__MoveGroupSequence_GetResult_Response { unsafe { moveit_msgs__action__MoveGroupSequence_GetResult_Response__create () } } fn destroy_msg (msg : * mut moveit_msgs__action__MoveGroupSequence_GetResult_Response) -> () { unsafe { moveit_msgs__action__MoveGroupSequence_GetResult_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { status : msg . status , result : moveit_msgs :: action :: MoveGroupSequence :: Result :: from_native (& msg . result) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . status = self . status ; self . result . copy_to_native (& mut msg . result) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct FeedbackMessage { pub goal_id : unique_identifier_msgs :: msg :: UUID , pub feedback : moveit_msgs :: action :: MoveGroupSequence :: Feedback } impl WrappedTypesupport for FeedbackMessage { type CStruct = moveit_msgs__action__MoveGroupSequence_FeedbackMessage ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__action__MoveGroupSequence_FeedbackMessage () } } fn create_msg () -> * mut moveit_msgs__action__MoveGroupSequence_FeedbackMessage { unsafe { moveit_msgs__action__MoveGroupSequence_FeedbackMessage__create () } } fn destroy_msg (msg : * mut moveit_msgs__action__MoveGroupSequence_FeedbackMessage) -> () { unsafe { moveit_msgs__action__MoveGroupSequence_FeedbackMessage__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> FeedbackMessage { FeedbackMessage { goal_id : unique_identifier_msgs :: msg :: UUID :: from_native (& msg . goal_id) , feedback : moveit_msgs :: action :: MoveGroupSequence :: Feedback :: from_native (& msg . feedback) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . goal_id . copy_to_native (& mut msg . goal_id) ; self . feedback . copy_to_native (& mut msg . feedback) ; } } impl Default for FeedbackMessage { fn default () -> Self { let msg_native = WrappedNativeMsg :: < FeedbackMessage > :: new () ; FeedbackMessage :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod Pickup { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Action () ; impl WrappedActionTypeSupport for Action { type Goal = Goal ; type Result = Result ; type Feedback = Feedback ; type FeedbackMessage = FeedbackMessage ; type SendGoal = SendGoal :: Service ; type GetResult = GetResult :: Service ; fn get_ts () -> & 'static rosidl_action_type_support_t { unsafe { & * rosidl_typesupport_c__get_action_type_support_handle__moveit_msgs__action__Pickup () } } fn make_goal_request_msg (goal_id : unique_identifier_msgs :: msg :: UUID , goal : Goal) -> SendGoal :: Request { SendGoal :: Request { goal_id , goal } } fn make_goal_response_msg (accepted : bool , stamp : builtin_interfaces :: msg :: Time) -> SendGoal :: Response { SendGoal :: Response { accepted , stamp } } fn make_feedback_msg (goal_id : unique_identifier_msgs :: msg :: UUID , feedback : Feedback) -> FeedbackMessage { FeedbackMessage { goal_id , feedback } } fn make_result_request_msg (goal_id : unique_identifier_msgs :: msg :: UUID) -> GetResult :: Request { GetResult :: Request { goal_id , } } fn make_result_response_msg (status : i8 , result : Result) -> GetResult :: Response { GetResult :: Response { status , result , } } fn destructure_goal_request_msg (msg : SendGoal :: Request) -> (unique_identifier_msgs :: msg :: UUID , Goal) { (msg . goal_id , msg . goal) } fn destructure_goal_response_msg (msg : SendGoal :: Response) -> (bool , builtin_interfaces :: msg :: Time) { (msg . accepted , msg . stamp) } fn destructure_feedback_msg (msg : FeedbackMessage) -> (unique_identifier_msgs :: msg :: UUID , Feedback) { (msg . goal_id , msg . feedback) } fn destructure_result_response_msg (msg : GetResult :: Response) -> (i8 , Result) { (msg . status , msg . result) } fn destructure_result_request_msg (msg : GetResult :: Request) -> unique_identifier_msgs :: msg :: UUID { msg . goal_id } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Goal { pub target_name : std :: string :: String , pub group_name : std :: string :: String , pub end_effector : std :: string :: String , pub possible_grasps : Vec < moveit_msgs :: msg :: Grasp > , pub support_surface_name : std :: string :: String , pub allow_gripper_support_collision : bool , pub attached_object_touch_links : Vec < std :: string :: String > , pub minimize_object_distance : bool , pub path_constraints : moveit_msgs :: msg :: Constraints , pub planner_id : std :: string :: String , pub allowed_touch_objects : Vec < std :: string :: String > , pub allowed_planning_time : f64 , pub planning_options : moveit_msgs :: msg :: PlanningOptions } impl WrappedTypesupport for Goal { type CStruct = moveit_msgs__action__Pickup_Goal ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__action__Pickup_Goal () } } fn create_msg () -> * mut moveit_msgs__action__Pickup_Goal { unsafe { moveit_msgs__action__Pickup_Goal__create () } } fn destroy_msg (msg : * mut moveit_msgs__action__Pickup_Goal) -> () { unsafe { moveit_msgs__action__Pickup_Goal__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Goal { Goal { target_name : msg . target_name . to_str () . to_owned () , group_name : msg . group_name . to_str () . to_owned () , end_effector : msg . end_effector . to_str () . to_owned () , possible_grasps : { let mut temp = Vec :: with_capacity (msg . possible_grasps . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . possible_grasps . data , msg . possible_grasps . size) } ; for s in slice { temp . push (moveit_msgs :: msg :: Grasp :: from_native (s)) ; } temp } , support_surface_name : msg . support_surface_name . to_str () . to_owned () , allow_gripper_support_collision : msg . allow_gripper_support_collision , attached_object_touch_links : msg . attached_object_touch_links . to_vec () , minimize_object_distance : msg . minimize_object_distance , path_constraints : moveit_msgs :: msg :: Constraints :: from_native (& msg . path_constraints) , planner_id : msg . planner_id . to_str () . to_owned () , allowed_touch_objects : msg . allowed_touch_objects . to_vec () , allowed_planning_time : msg . allowed_planning_time , planning_options : moveit_msgs :: msg :: PlanningOptions :: from_native (& msg . planning_options) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . target_name . assign (& self . target_name) ; msg . group_name . assign (& self . group_name) ; msg . end_effector . assign (& self . end_effector) ; unsafe { moveit_msgs__msg__Grasp__Sequence__fini (& mut msg . possible_grasps) ; moveit_msgs__msg__Grasp__Sequence__init (& mut msg . possible_grasps , self . possible_grasps . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . possible_grasps . data , msg . possible_grasps . size) ; for (t , s) in slice . iter_mut () . zip (& self . possible_grasps) { s . copy_to_native (t) ; } } msg . support_surface_name . assign (& self . support_surface_name) ; msg . allow_gripper_support_collision = self . allow_gripper_support_collision ; msg . attached_object_touch_links . update (& self . attached_object_touch_links) ; msg . minimize_object_distance = self . minimize_object_distance ; self . path_constraints . copy_to_native (& mut msg . path_constraints) ; msg . planner_id . assign (& self . planner_id) ; msg . allowed_touch_objects . update (& self . allowed_touch_objects) ; msg . allowed_planning_time = self . allowed_planning_time ; self . planning_options . copy_to_native (& mut msg . planning_options) ; } } impl Default for Goal { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Goal > :: new () ; Goal :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Result { pub error_code : moveit_msgs :: msg :: MoveItErrorCodes , pub trajectory_start : moveit_msgs :: msg :: RobotState , pub trajectory_stages : Vec < moveit_msgs :: msg :: RobotTrajectory > , pub trajectory_descriptions : Vec < std :: string :: String > , pub grasp : moveit_msgs :: msg :: Grasp , pub planning_time : f64 } impl WrappedTypesupport for Result { type CStruct = moveit_msgs__action__Pickup_Result ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__action__Pickup_Result () } } fn create_msg () -> * mut moveit_msgs__action__Pickup_Result { unsafe { moveit_msgs__action__Pickup_Result__create () } } fn destroy_msg (msg : * mut moveit_msgs__action__Pickup_Result) -> () { unsafe { moveit_msgs__action__Pickup_Result__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Result { Result { error_code : moveit_msgs :: msg :: MoveItErrorCodes :: from_native (& msg . error_code) , trajectory_start : moveit_msgs :: msg :: RobotState :: from_native (& msg . trajectory_start) , trajectory_stages : { let mut temp = Vec :: with_capacity (msg . trajectory_stages . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . trajectory_stages . data , msg . trajectory_stages . size) } ; for s in slice { temp . push (moveit_msgs :: msg :: RobotTrajectory :: from_native (s)) ; } temp } , trajectory_descriptions : msg . trajectory_descriptions . to_vec () , grasp : moveit_msgs :: msg :: Grasp :: from_native (& msg . grasp) , planning_time : msg . planning_time , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . error_code . copy_to_native (& mut msg . error_code) ; self . trajectory_start . copy_to_native (& mut msg . trajectory_start) ; unsafe { moveit_msgs__msg__RobotTrajectory__Sequence__fini (& mut msg . trajectory_stages) ; moveit_msgs__msg__RobotTrajectory__Sequence__init (& mut msg . trajectory_stages , self . trajectory_stages . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . trajectory_stages . data , msg . trajectory_stages . size) ; for (t , s) in slice . iter_mut () . zip (& self . trajectory_stages) { s . copy_to_native (t) ; } } msg . trajectory_descriptions . update (& self . trajectory_descriptions) ; self . grasp . copy_to_native (& mut msg . grasp) ; msg . planning_time = self . planning_time ; } } impl Default for Result { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Result > :: new () ; Result :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Feedback { pub state : std :: string :: String } impl WrappedTypesupport for Feedback { type CStruct = moveit_msgs__action__Pickup_Feedback ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__action__Pickup_Feedback () } } fn create_msg () -> * mut moveit_msgs__action__Pickup_Feedback { unsafe { moveit_msgs__action__Pickup_Feedback__create () } } fn destroy_msg (msg : * mut moveit_msgs__action__Pickup_Feedback) -> () { unsafe { moveit_msgs__action__Pickup_Feedback__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Feedback { Feedback { state : msg . state . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . state . assign (& self . state) ; } } impl Default for Feedback { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Feedback > :: new () ; Feedback :: from_native (& msg_native) } } # [allow (non_snake_case)] pub mod SendGoal { use super :: super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__moveit_msgs__action__Pickup_SendGoal () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub goal_id : unique_identifier_msgs :: msg :: UUID , pub goal : moveit_msgs :: action :: Pickup :: Goal } impl WrappedTypesupport for Request { type CStruct = moveit_msgs__action__Pickup_SendGoal_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__action__Pickup_SendGoal_Request () } } fn create_msg () -> * mut moveit_msgs__action__Pickup_SendGoal_Request { unsafe { moveit_msgs__action__Pickup_SendGoal_Request__create () } } fn destroy_msg (msg : * mut moveit_msgs__action__Pickup_SendGoal_Request) -> () { unsafe { moveit_msgs__action__Pickup_SendGoal_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { goal_id : unique_identifier_msgs :: msg :: UUID :: from_native (& msg . goal_id) , goal : moveit_msgs :: action :: Pickup :: Goal :: from_native (& msg . goal) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . goal_id . copy_to_native (& mut msg . goal_id) ; self . goal . copy_to_native (& mut msg . goal) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub accepted : bool , pub stamp : builtin_interfaces :: msg :: Time } impl WrappedTypesupport for Response { type CStruct = moveit_msgs__action__Pickup_SendGoal_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__action__Pickup_SendGoal_Response () } } fn create_msg () -> * mut moveit_msgs__action__Pickup_SendGoal_Response { unsafe { moveit_msgs__action__Pickup_SendGoal_Response__create () } } fn destroy_msg (msg : * mut moveit_msgs__action__Pickup_SendGoal_Response) -> () { unsafe { moveit_msgs__action__Pickup_SendGoal_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { accepted : msg . accepted , stamp : builtin_interfaces :: msg :: Time :: from_native (& msg . stamp) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . accepted = self . accepted ; self . stamp . copy_to_native (& mut msg . stamp) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetResult { use super :: super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__moveit_msgs__action__Pickup_GetResult () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub goal_id : unique_identifier_msgs :: msg :: UUID } impl WrappedTypesupport for Request { type CStruct = moveit_msgs__action__Pickup_GetResult_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__action__Pickup_GetResult_Request () } } fn create_msg () -> * mut moveit_msgs__action__Pickup_GetResult_Request { unsafe { moveit_msgs__action__Pickup_GetResult_Request__create () } } fn destroy_msg (msg : * mut moveit_msgs__action__Pickup_GetResult_Request) -> () { unsafe { moveit_msgs__action__Pickup_GetResult_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { goal_id : unique_identifier_msgs :: msg :: UUID :: from_native (& msg . goal_id) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . goal_id . copy_to_native (& mut msg . goal_id) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub status : i8 , pub result : moveit_msgs :: action :: Pickup :: Result } impl WrappedTypesupport for Response { type CStruct = moveit_msgs__action__Pickup_GetResult_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__action__Pickup_GetResult_Response () } } fn create_msg () -> * mut moveit_msgs__action__Pickup_GetResult_Response { unsafe { moveit_msgs__action__Pickup_GetResult_Response__create () } } fn destroy_msg (msg : * mut moveit_msgs__action__Pickup_GetResult_Response) -> () { unsafe { moveit_msgs__action__Pickup_GetResult_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { status : msg . status , result : moveit_msgs :: action :: Pickup :: Result :: from_native (& msg . result) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . status = self . status ; self . result . copy_to_native (& mut msg . result) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct FeedbackMessage { pub goal_id : unique_identifier_msgs :: msg :: UUID , pub feedback : moveit_msgs :: action :: Pickup :: Feedback } impl WrappedTypesupport for FeedbackMessage { type CStruct = moveit_msgs__action__Pickup_FeedbackMessage ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__action__Pickup_FeedbackMessage () } } fn create_msg () -> * mut moveit_msgs__action__Pickup_FeedbackMessage { unsafe { moveit_msgs__action__Pickup_FeedbackMessage__create () } } fn destroy_msg (msg : * mut moveit_msgs__action__Pickup_FeedbackMessage) -> () { unsafe { moveit_msgs__action__Pickup_FeedbackMessage__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> FeedbackMessage { FeedbackMessage { goal_id : unique_identifier_msgs :: msg :: UUID :: from_native (& msg . goal_id) , feedback : moveit_msgs :: action :: Pickup :: Feedback :: from_native (& msg . feedback) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . goal_id . copy_to_native (& mut msg . goal_id) ; self . feedback . copy_to_native (& mut msg . feedback) ; } } impl Default for FeedbackMessage { fn default () -> Self { let msg_native = WrappedNativeMsg :: < FeedbackMessage > :: new () ; FeedbackMessage :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod Place { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Action () ; impl WrappedActionTypeSupport for Action { type Goal = Goal ; type Result = Result ; type Feedback = Feedback ; type FeedbackMessage = FeedbackMessage ; type SendGoal = SendGoal :: Service ; type GetResult = GetResult :: Service ; fn get_ts () -> & 'static rosidl_action_type_support_t { unsafe { & * rosidl_typesupport_c__get_action_type_support_handle__moveit_msgs__action__Place () } } fn make_goal_request_msg (goal_id : unique_identifier_msgs :: msg :: UUID , goal : Goal) -> SendGoal :: Request { SendGoal :: Request { goal_id , goal } } fn make_goal_response_msg (accepted : bool , stamp : builtin_interfaces :: msg :: Time) -> SendGoal :: Response { SendGoal :: Response { accepted , stamp } } fn make_feedback_msg (goal_id : unique_identifier_msgs :: msg :: UUID , feedback : Feedback) -> FeedbackMessage { FeedbackMessage { goal_id , feedback } } fn make_result_request_msg (goal_id : unique_identifier_msgs :: msg :: UUID) -> GetResult :: Request { GetResult :: Request { goal_id , } } fn make_result_response_msg (status : i8 , result : Result) -> GetResult :: Response { GetResult :: Response { status , result , } } fn destructure_goal_request_msg (msg : SendGoal :: Request) -> (unique_identifier_msgs :: msg :: UUID , Goal) { (msg . goal_id , msg . goal) } fn destructure_goal_response_msg (msg : SendGoal :: Response) -> (bool , builtin_interfaces :: msg :: Time) { (msg . accepted , msg . stamp) } fn destructure_feedback_msg (msg : FeedbackMessage) -> (unique_identifier_msgs :: msg :: UUID , Feedback) { (msg . goal_id , msg . feedback) } fn destructure_result_response_msg (msg : GetResult :: Response) -> (i8 , Result) { (msg . status , msg . result) } fn destructure_result_request_msg (msg : GetResult :: Request) -> unique_identifier_msgs :: msg :: UUID { msg . goal_id } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Goal { pub group_name : std :: string :: String , pub attached_object_name : std :: string :: String , pub place_locations : Vec < moveit_msgs :: msg :: PlaceLocation > , pub place_eef : bool , pub support_surface_name : std :: string :: String , pub allow_gripper_support_collision : bool , pub path_constraints : moveit_msgs :: msg :: Constraints , pub planner_id : std :: string :: String , pub allowed_touch_objects : Vec < std :: string :: String > , pub allowed_planning_time : f64 , pub planning_options : moveit_msgs :: msg :: PlanningOptions } impl WrappedTypesupport for Goal { type CStruct = moveit_msgs__action__Place_Goal ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__action__Place_Goal () } } fn create_msg () -> * mut moveit_msgs__action__Place_Goal { unsafe { moveit_msgs__action__Place_Goal__create () } } fn destroy_msg (msg : * mut moveit_msgs__action__Place_Goal) -> () { unsafe { moveit_msgs__action__Place_Goal__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Goal { Goal { group_name : msg . group_name . to_str () . to_owned () , attached_object_name : msg . attached_object_name . to_str () . to_owned () , place_locations : { let mut temp = Vec :: with_capacity (msg . place_locations . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . place_locations . data , msg . place_locations . size) } ; for s in slice { temp . push (moveit_msgs :: msg :: PlaceLocation :: from_native (s)) ; } temp } , place_eef : msg . place_eef , support_surface_name : msg . support_surface_name . to_str () . to_owned () , allow_gripper_support_collision : msg . allow_gripper_support_collision , path_constraints : moveit_msgs :: msg :: Constraints :: from_native (& msg . path_constraints) , planner_id : msg . planner_id . to_str () . to_owned () , allowed_touch_objects : msg . allowed_touch_objects . to_vec () , allowed_planning_time : msg . allowed_planning_time , planning_options : moveit_msgs :: msg :: PlanningOptions :: from_native (& msg . planning_options) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . group_name . assign (& self . group_name) ; msg . attached_object_name . assign (& self . attached_object_name) ; unsafe { moveit_msgs__msg__PlaceLocation__Sequence__fini (& mut msg . place_locations) ; moveit_msgs__msg__PlaceLocation__Sequence__init (& mut msg . place_locations , self . place_locations . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . place_locations . data , msg . place_locations . size) ; for (t , s) in slice . iter_mut () . zip (& self . place_locations) { s . copy_to_native (t) ; } } msg . place_eef = self . place_eef ; msg . support_surface_name . assign (& self . support_surface_name) ; msg . allow_gripper_support_collision = self . allow_gripper_support_collision ; self . path_constraints . copy_to_native (& mut msg . path_constraints) ; msg . planner_id . assign (& self . planner_id) ; msg . allowed_touch_objects . update (& self . allowed_touch_objects) ; msg . allowed_planning_time = self . allowed_planning_time ; self . planning_options . copy_to_native (& mut msg . planning_options) ; } } impl Default for Goal { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Goal > :: new () ; Goal :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Result { pub error_code : moveit_msgs :: msg :: MoveItErrorCodes , pub trajectory_start : moveit_msgs :: msg :: RobotState , pub trajectory_stages : Vec < moveit_msgs :: msg :: RobotTrajectory > , pub trajectory_descriptions : Vec < std :: string :: String > , pub place_location : moveit_msgs :: msg :: PlaceLocation , pub planning_time : f64 } impl WrappedTypesupport for Result { type CStruct = moveit_msgs__action__Place_Result ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__action__Place_Result () } } fn create_msg () -> * mut moveit_msgs__action__Place_Result { unsafe { moveit_msgs__action__Place_Result__create () } } fn destroy_msg (msg : * mut moveit_msgs__action__Place_Result) -> () { unsafe { moveit_msgs__action__Place_Result__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Result { Result { error_code : moveit_msgs :: msg :: MoveItErrorCodes :: from_native (& msg . error_code) , trajectory_start : moveit_msgs :: msg :: RobotState :: from_native (& msg . trajectory_start) , trajectory_stages : { let mut temp = Vec :: with_capacity (msg . trajectory_stages . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . trajectory_stages . data , msg . trajectory_stages . size) } ; for s in slice { temp . push (moveit_msgs :: msg :: RobotTrajectory :: from_native (s)) ; } temp } , trajectory_descriptions : msg . trajectory_descriptions . to_vec () , place_location : moveit_msgs :: msg :: PlaceLocation :: from_native (& msg . place_location) , planning_time : msg . planning_time , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . error_code . copy_to_native (& mut msg . error_code) ; self . trajectory_start . copy_to_native (& mut msg . trajectory_start) ; unsafe { moveit_msgs__msg__RobotTrajectory__Sequence__fini (& mut msg . trajectory_stages) ; moveit_msgs__msg__RobotTrajectory__Sequence__init (& mut msg . trajectory_stages , self . trajectory_stages . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . trajectory_stages . data , msg . trajectory_stages . size) ; for (t , s) in slice . iter_mut () . zip (& self . trajectory_stages) { s . copy_to_native (t) ; } } msg . trajectory_descriptions . update (& self . trajectory_descriptions) ; self . place_location . copy_to_native (& mut msg . place_location) ; msg . planning_time = self . planning_time ; } } impl Default for Result { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Result > :: new () ; Result :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Feedback { pub state : std :: string :: String } impl WrappedTypesupport for Feedback { type CStruct = moveit_msgs__action__Place_Feedback ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__action__Place_Feedback () } } fn create_msg () -> * mut moveit_msgs__action__Place_Feedback { unsafe { moveit_msgs__action__Place_Feedback__create () } } fn destroy_msg (msg : * mut moveit_msgs__action__Place_Feedback) -> () { unsafe { moveit_msgs__action__Place_Feedback__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Feedback { Feedback { state : msg . state . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . state . assign (& self . state) ; } } impl Default for Feedback { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Feedback > :: new () ; Feedback :: from_native (& msg_native) } } # [allow (non_snake_case)] pub mod SendGoal { use super :: super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__moveit_msgs__action__Place_SendGoal () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub goal_id : unique_identifier_msgs :: msg :: UUID , pub goal : moveit_msgs :: action :: Place :: Goal } impl WrappedTypesupport for Request { type CStruct = moveit_msgs__action__Place_SendGoal_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__action__Place_SendGoal_Request () } } fn create_msg () -> * mut moveit_msgs__action__Place_SendGoal_Request { unsafe { moveit_msgs__action__Place_SendGoal_Request__create () } } fn destroy_msg (msg : * mut moveit_msgs__action__Place_SendGoal_Request) -> () { unsafe { moveit_msgs__action__Place_SendGoal_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { goal_id : unique_identifier_msgs :: msg :: UUID :: from_native (& msg . goal_id) , goal : moveit_msgs :: action :: Place :: Goal :: from_native (& msg . goal) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . goal_id . copy_to_native (& mut msg . goal_id) ; self . goal . copy_to_native (& mut msg . goal) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub accepted : bool , pub stamp : builtin_interfaces :: msg :: Time } impl WrappedTypesupport for Response { type CStruct = moveit_msgs__action__Place_SendGoal_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__action__Place_SendGoal_Response () } } fn create_msg () -> * mut moveit_msgs__action__Place_SendGoal_Response { unsafe { moveit_msgs__action__Place_SendGoal_Response__create () } } fn destroy_msg (msg : * mut moveit_msgs__action__Place_SendGoal_Response) -> () { unsafe { moveit_msgs__action__Place_SendGoal_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { accepted : msg . accepted , stamp : builtin_interfaces :: msg :: Time :: from_native (& msg . stamp) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . accepted = self . accepted ; self . stamp . copy_to_native (& mut msg . stamp) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetResult { use super :: super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__moveit_msgs__action__Place_GetResult () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub goal_id : unique_identifier_msgs :: msg :: UUID } impl WrappedTypesupport for Request { type CStruct = moveit_msgs__action__Place_GetResult_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__action__Place_GetResult_Request () } } fn create_msg () -> * mut moveit_msgs__action__Place_GetResult_Request { unsafe { moveit_msgs__action__Place_GetResult_Request__create () } } fn destroy_msg (msg : * mut moveit_msgs__action__Place_GetResult_Request) -> () { unsafe { moveit_msgs__action__Place_GetResult_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { goal_id : unique_identifier_msgs :: msg :: UUID :: from_native (& msg . goal_id) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . goal_id . copy_to_native (& mut msg . goal_id) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub status : i8 , pub result : moveit_msgs :: action :: Place :: Result } impl WrappedTypesupport for Response { type CStruct = moveit_msgs__action__Place_GetResult_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__action__Place_GetResult_Response () } } fn create_msg () -> * mut moveit_msgs__action__Place_GetResult_Response { unsafe { moveit_msgs__action__Place_GetResult_Response__create () } } fn destroy_msg (msg : * mut moveit_msgs__action__Place_GetResult_Response) -> () { unsafe { moveit_msgs__action__Place_GetResult_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { status : msg . status , result : moveit_msgs :: action :: Place :: Result :: from_native (& msg . result) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . status = self . status ; self . result . copy_to_native (& mut msg . result) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct FeedbackMessage { pub goal_id : unique_identifier_msgs :: msg :: UUID , pub feedback : moveit_msgs :: action :: Place :: Feedback } impl WrappedTypesupport for FeedbackMessage { type CStruct = moveit_msgs__action__Place_FeedbackMessage ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__action__Place_FeedbackMessage () } } fn create_msg () -> * mut moveit_msgs__action__Place_FeedbackMessage { unsafe { moveit_msgs__action__Place_FeedbackMessage__create () } } fn destroy_msg (msg : * mut moveit_msgs__action__Place_FeedbackMessage) -> () { unsafe { moveit_msgs__action__Place_FeedbackMessage__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> FeedbackMessage { FeedbackMessage { goal_id : unique_identifier_msgs :: msg :: UUID :: from_native (& msg . goal_id) , feedback : moveit_msgs :: action :: Place :: Feedback :: from_native (& msg . feedback) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . goal_id . copy_to_native (& mut msg . goal_id) ; self . feedback . copy_to_native (& mut msg . feedback) ; } } impl Default for FeedbackMessage { fn default () -> Self { let msg_native = WrappedNativeMsg :: < FeedbackMessage > :: new () ; FeedbackMessage :: from_native (& msg_native) } } } } pub mod msg { use super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct AllowedCollisionEntry { pub enabled : Vec < bool > } impl WrappedTypesupport for AllowedCollisionEntry { type CStruct = moveit_msgs__msg__AllowedCollisionEntry ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__msg__AllowedCollisionEntry () } } fn create_msg () -> * mut moveit_msgs__msg__AllowedCollisionEntry { unsafe { moveit_msgs__msg__AllowedCollisionEntry__create () } } fn destroy_msg (msg : * mut moveit_msgs__msg__AllowedCollisionEntry) -> () { unsafe { moveit_msgs__msg__AllowedCollisionEntry__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> AllowedCollisionEntry { AllowedCollisionEntry { enabled : msg . enabled . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . enabled . update (& self . enabled) ; } } impl Default for AllowedCollisionEntry { fn default () -> Self { let msg_native = WrappedNativeMsg :: < AllowedCollisionEntry > :: new () ; AllowedCollisionEntry :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct AllowedCollisionMatrix { pub entry_names : Vec < std :: string :: String > , pub entry_values : Vec < moveit_msgs :: msg :: AllowedCollisionEntry > , pub default_entry_names : Vec < std :: string :: String > , pub default_entry_values : Vec < bool > } impl WrappedTypesupport for AllowedCollisionMatrix { type CStruct = moveit_msgs__msg__AllowedCollisionMatrix ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__msg__AllowedCollisionMatrix () } } fn create_msg () -> * mut moveit_msgs__msg__AllowedCollisionMatrix { unsafe { moveit_msgs__msg__AllowedCollisionMatrix__create () } } fn destroy_msg (msg : * mut moveit_msgs__msg__AllowedCollisionMatrix) -> () { unsafe { moveit_msgs__msg__AllowedCollisionMatrix__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> AllowedCollisionMatrix { AllowedCollisionMatrix { entry_names : msg . entry_names . to_vec () , entry_values : { let mut temp = Vec :: with_capacity (msg . entry_values . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . entry_values . data , msg . entry_values . size) } ; for s in slice { temp . push (moveit_msgs :: msg :: AllowedCollisionEntry :: from_native (s)) ; } temp } , default_entry_names : msg . default_entry_names . to_vec () , default_entry_values : msg . default_entry_values . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . entry_names . update (& self . entry_names) ; unsafe { moveit_msgs__msg__AllowedCollisionEntry__Sequence__fini (& mut msg . entry_values) ; moveit_msgs__msg__AllowedCollisionEntry__Sequence__init (& mut msg . entry_values , self . entry_values . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . entry_values . data , msg . entry_values . size) ; for (t , s) in slice . iter_mut () . zip (& self . entry_values) { s . copy_to_native (t) ; } } msg . default_entry_names . update (& self . default_entry_names) ; msg . default_entry_values . update (& self . default_entry_values) ; } } impl Default for AllowedCollisionMatrix { fn default () -> Self { let msg_native = WrappedNativeMsg :: < AllowedCollisionMatrix > :: new () ; AllowedCollisionMatrix :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct AttachedCollisionObject { pub link_name : std :: string :: String , pub object : moveit_msgs :: msg :: CollisionObject , pub touch_links : Vec < std :: string :: String > , pub detach_posture : trajectory_msgs :: msg :: JointTrajectory , pub weight : f64 } impl WrappedTypesupport for AttachedCollisionObject { type CStruct = moveit_msgs__msg__AttachedCollisionObject ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__msg__AttachedCollisionObject () } } fn create_msg () -> * mut moveit_msgs__msg__AttachedCollisionObject { unsafe { moveit_msgs__msg__AttachedCollisionObject__create () } } fn destroy_msg (msg : * mut moveit_msgs__msg__AttachedCollisionObject) -> () { unsafe { moveit_msgs__msg__AttachedCollisionObject__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> AttachedCollisionObject { AttachedCollisionObject { link_name : msg . link_name . to_str () . to_owned () , object : moveit_msgs :: msg :: CollisionObject :: from_native (& msg . object) , touch_links : msg . touch_links . to_vec () , detach_posture : trajectory_msgs :: msg :: JointTrajectory :: from_native (& msg . detach_posture) , weight : msg . weight , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . link_name . assign (& self . link_name) ; self . object . copy_to_native (& mut msg . object) ; msg . touch_links . update (& self . touch_links) ; self . detach_posture . copy_to_native (& mut msg . detach_posture) ; msg . weight = self . weight ; } } impl Default for AttachedCollisionObject { fn default () -> Self { let msg_native = WrappedNativeMsg :: < AttachedCollisionObject > :: new () ; AttachedCollisionObject :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct BoundingVolume { pub primitives : Vec < shape_msgs :: msg :: SolidPrimitive > , pub primitive_poses : Vec < geometry_msgs :: msg :: Pose > , pub meshes : Vec < shape_msgs :: msg :: Mesh > , pub mesh_poses : Vec < geometry_msgs :: msg :: Pose > } impl WrappedTypesupport for BoundingVolume { type CStruct = moveit_msgs__msg__BoundingVolume ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__msg__BoundingVolume () } } fn create_msg () -> * mut moveit_msgs__msg__BoundingVolume { unsafe { moveit_msgs__msg__BoundingVolume__create () } } fn destroy_msg (msg : * mut moveit_msgs__msg__BoundingVolume) -> () { unsafe { moveit_msgs__msg__BoundingVolume__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> BoundingVolume { BoundingVolume { primitives : { let mut temp = Vec :: with_capacity (msg . primitives . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . primitives . data , msg . primitives . size) } ; for s in slice { temp . push (shape_msgs :: msg :: SolidPrimitive :: from_native (s)) ; } temp } , primitive_poses : { let mut temp = Vec :: with_capacity (msg . primitive_poses . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . primitive_poses . data , msg . primitive_poses . size) } ; for s in slice { temp . push (geometry_msgs :: msg :: Pose :: from_native (s)) ; } temp } , meshes : { let mut temp = Vec :: with_capacity (msg . meshes . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . meshes . data , msg . meshes . size) } ; for s in slice { temp . push (shape_msgs :: msg :: Mesh :: from_native (s)) ; } temp } , mesh_poses : { let mut temp = Vec :: with_capacity (msg . mesh_poses . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . mesh_poses . data , msg . mesh_poses . size) } ; for s in slice { temp . push (geometry_msgs :: msg :: Pose :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { unsafe { shape_msgs__msg__SolidPrimitive__Sequence__fini (& mut msg . primitives) ; shape_msgs__msg__SolidPrimitive__Sequence__init (& mut msg . primitives , self . primitives . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . primitives . data , msg . primitives . size) ; for (t , s) in slice . iter_mut () . zip (& self . primitives) { s . copy_to_native (t) ; } } unsafe { geometry_msgs__msg__Pose__Sequence__fini (& mut msg . primitive_poses) ; geometry_msgs__msg__Pose__Sequence__init (& mut msg . primitive_poses , self . primitive_poses . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . primitive_poses . data , msg . primitive_poses . size) ; for (t , s) in slice . iter_mut () . zip (& self . primitive_poses) { s . copy_to_native (t) ; } } unsafe { shape_msgs__msg__Mesh__Sequence__fini (& mut msg . meshes) ; shape_msgs__msg__Mesh__Sequence__init (& mut msg . meshes , self . meshes . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . meshes . data , msg . meshes . size) ; for (t , s) in slice . iter_mut () . zip (& self . meshes) { s . copy_to_native (t) ; } } unsafe { geometry_msgs__msg__Pose__Sequence__fini (& mut msg . mesh_poses) ; geometry_msgs__msg__Pose__Sequence__init (& mut msg . mesh_poses , self . mesh_poses . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . mesh_poses . data , msg . mesh_poses . size) ; for (t , s) in slice . iter_mut () . zip (& self . mesh_poses) { s . copy_to_native (t) ; } } } } impl Default for BoundingVolume { fn default () -> Self { let msg_native = WrappedNativeMsg :: < BoundingVolume > :: new () ; BoundingVolume :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct CartesianPoint { pub pose : geometry_msgs :: msg :: Pose , pub velocity : geometry_msgs :: msg :: Twist , pub acceleration : geometry_msgs :: msg :: Accel } impl WrappedTypesupport for CartesianPoint { type CStruct = moveit_msgs__msg__CartesianPoint ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__msg__CartesianPoint () } } fn create_msg () -> * mut moveit_msgs__msg__CartesianPoint { unsafe { moveit_msgs__msg__CartesianPoint__create () } } fn destroy_msg (msg : * mut moveit_msgs__msg__CartesianPoint) -> () { unsafe { moveit_msgs__msg__CartesianPoint__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> CartesianPoint { CartesianPoint { pose : geometry_msgs :: msg :: Pose :: from_native (& msg . pose) , velocity : geometry_msgs :: msg :: Twist :: from_native (& msg . velocity) , acceleration : geometry_msgs :: msg :: Accel :: from_native (& msg . acceleration) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . pose . copy_to_native (& mut msg . pose) ; self . velocity . copy_to_native (& mut msg . velocity) ; self . acceleration . copy_to_native (& mut msg . acceleration) ; } } impl Default for CartesianPoint { fn default () -> Self { let msg_native = WrappedNativeMsg :: < CartesianPoint > :: new () ; CartesianPoint :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct CartesianTrajectory { pub header : std_msgs :: msg :: Header , pub tracked_frame : std :: string :: String , pub points : Vec < moveit_msgs :: msg :: CartesianTrajectoryPoint > } impl WrappedTypesupport for CartesianTrajectory { type CStruct = moveit_msgs__msg__CartesianTrajectory ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__msg__CartesianTrajectory () } } fn create_msg () -> * mut moveit_msgs__msg__CartesianTrajectory { unsafe { moveit_msgs__msg__CartesianTrajectory__create () } } fn destroy_msg (msg : * mut moveit_msgs__msg__CartesianTrajectory) -> () { unsafe { moveit_msgs__msg__CartesianTrajectory__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> CartesianTrajectory { CartesianTrajectory { header : std_msgs :: msg :: Header :: from_native (& msg . header) , tracked_frame : msg . tracked_frame . to_str () . to_owned () , points : { let mut temp = Vec :: with_capacity (msg . points . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . points . data , msg . points . size) } ; for s in slice { temp . push (moveit_msgs :: msg :: CartesianTrajectoryPoint :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . tracked_frame . assign (& self . tracked_frame) ; unsafe { moveit_msgs__msg__CartesianTrajectoryPoint__Sequence__fini (& mut msg . points) ; moveit_msgs__msg__CartesianTrajectoryPoint__Sequence__init (& mut msg . points , self . points . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . points . data , msg . points . size) ; for (t , s) in slice . iter_mut () . zip (& self . points) { s . copy_to_native (t) ; } } } } impl Default for CartesianTrajectory { fn default () -> Self { let msg_native = WrappedNativeMsg :: < CartesianTrajectory > :: new () ; CartesianTrajectory :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct CartesianTrajectoryPoint { pub point : moveit_msgs :: msg :: CartesianPoint , pub time_from_start : builtin_interfaces :: msg :: Duration } impl WrappedTypesupport for CartesianTrajectoryPoint { type CStruct = moveit_msgs__msg__CartesianTrajectoryPoint ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__msg__CartesianTrajectoryPoint () } } fn create_msg () -> * mut moveit_msgs__msg__CartesianTrajectoryPoint { unsafe { moveit_msgs__msg__CartesianTrajectoryPoint__create () } } fn destroy_msg (msg : * mut moveit_msgs__msg__CartesianTrajectoryPoint) -> () { unsafe { moveit_msgs__msg__CartesianTrajectoryPoint__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> CartesianTrajectoryPoint { CartesianTrajectoryPoint { point : moveit_msgs :: msg :: CartesianPoint :: from_native (& msg . point) , time_from_start : builtin_interfaces :: msg :: Duration :: from_native (& msg . time_from_start) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . point . copy_to_native (& mut msg . point) ; self . time_from_start . copy_to_native (& mut msg . time_from_start) ; } } impl Default for CartesianTrajectoryPoint { fn default () -> Self { let msg_native = WrappedNativeMsg :: < CartesianTrajectoryPoint > :: new () ; CartesianTrajectoryPoint :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct CollisionObject { pub header : std_msgs :: msg :: Header , pub pose : geometry_msgs :: msg :: Pose , pub id : std :: string :: String , # [serde (rename = "type")] pub type_ : object_recognition_msgs :: msg :: ObjectType , pub primitives : Vec < shape_msgs :: msg :: SolidPrimitive > , pub primitive_poses : Vec < geometry_msgs :: msg :: Pose > , pub meshes : Vec < shape_msgs :: msg :: Mesh > , pub mesh_poses : Vec < geometry_msgs :: msg :: Pose > , pub planes : Vec < shape_msgs :: msg :: Plane > , pub plane_poses : Vec < geometry_msgs :: msg :: Pose > , pub subframe_names : Vec < std :: string :: String > , pub subframe_poses : Vec < geometry_msgs :: msg :: Pose > , pub operation : u8 } impl WrappedTypesupport for CollisionObject { type CStruct = moveit_msgs__msg__CollisionObject ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__msg__CollisionObject () } } fn create_msg () -> * mut moveit_msgs__msg__CollisionObject { unsafe { moveit_msgs__msg__CollisionObject__create () } } fn destroy_msg (msg : * mut moveit_msgs__msg__CollisionObject) -> () { unsafe { moveit_msgs__msg__CollisionObject__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> CollisionObject { CollisionObject { header : std_msgs :: msg :: Header :: from_native (& msg . header) , pose : geometry_msgs :: msg :: Pose :: from_native (& msg . pose) , id : msg . id . to_str () . to_owned () , type_ : object_recognition_msgs :: msg :: ObjectType :: from_native (& msg . type_) , primitives : { let mut temp = Vec :: with_capacity (msg . primitives . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . primitives . data , msg . primitives . size) } ; for s in slice { temp . push (shape_msgs :: msg :: SolidPrimitive :: from_native (s)) ; } temp } , primitive_poses : { let mut temp = Vec :: with_capacity (msg . primitive_poses . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . primitive_poses . data , msg . primitive_poses . size) } ; for s in slice { temp . push (geometry_msgs :: msg :: Pose :: from_native (s)) ; } temp } , meshes : { let mut temp = Vec :: with_capacity (msg . meshes . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . meshes . data , msg . meshes . size) } ; for s in slice { temp . push (shape_msgs :: msg :: Mesh :: from_native (s)) ; } temp } , mesh_poses : { let mut temp = Vec :: with_capacity (msg . mesh_poses . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . mesh_poses . data , msg . mesh_poses . size) } ; for s in slice { temp . push (geometry_msgs :: msg :: Pose :: from_native (s)) ; } temp } , planes : { let mut temp = Vec :: with_capacity (msg . planes . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . planes . data , msg . planes . size) } ; for s in slice { temp . push (shape_msgs :: msg :: Plane :: from_native (s)) ; } temp } , plane_poses : { let mut temp = Vec :: with_capacity (msg . plane_poses . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . plane_poses . data , msg . plane_poses . size) } ; for s in slice { temp . push (geometry_msgs :: msg :: Pose :: from_native (s)) ; } temp } , subframe_names : msg . subframe_names . to_vec () , subframe_poses : { let mut temp = Vec :: with_capacity (msg . subframe_poses . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . subframe_poses . data , msg . subframe_poses . size) } ; for s in slice { temp . push (geometry_msgs :: msg :: Pose :: from_native (s)) ; } temp } , operation : msg . operation , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; self . pose . copy_to_native (& mut msg . pose) ; msg . id . assign (& self . id) ; self . type_ . copy_to_native (& mut msg . type_) ; unsafe { shape_msgs__msg__SolidPrimitive__Sequence__fini (& mut msg . primitives) ; shape_msgs__msg__SolidPrimitive__Sequence__init (& mut msg . primitives , self . primitives . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . primitives . data , msg . primitives . size) ; for (t , s) in slice . iter_mut () . zip (& self . primitives) { s . copy_to_native (t) ; } } unsafe { geometry_msgs__msg__Pose__Sequence__fini (& mut msg . primitive_poses) ; geometry_msgs__msg__Pose__Sequence__init (& mut msg . primitive_poses , self . primitive_poses . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . primitive_poses . data , msg . primitive_poses . size) ; for (t , s) in slice . iter_mut () . zip (& self . primitive_poses) { s . copy_to_native (t) ; } } unsafe { shape_msgs__msg__Mesh__Sequence__fini (& mut msg . meshes) ; shape_msgs__msg__Mesh__Sequence__init (& mut msg . meshes , self . meshes . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . meshes . data , msg . meshes . size) ; for (t , s) in slice . iter_mut () . zip (& self . meshes) { s . copy_to_native (t) ; } } unsafe { geometry_msgs__msg__Pose__Sequence__fini (& mut msg . mesh_poses) ; geometry_msgs__msg__Pose__Sequence__init (& mut msg . mesh_poses , self . mesh_poses . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . mesh_poses . data , msg . mesh_poses . size) ; for (t , s) in slice . iter_mut () . zip (& self . mesh_poses) { s . copy_to_native (t) ; } } unsafe { shape_msgs__msg__Plane__Sequence__fini (& mut msg . planes) ; shape_msgs__msg__Plane__Sequence__init (& mut msg . planes , self . planes . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . planes . data , msg . planes . size) ; for (t , s) in slice . iter_mut () . zip (& self . planes) { s . copy_to_native (t) ; } } unsafe { geometry_msgs__msg__Pose__Sequence__fini (& mut msg . plane_poses) ; geometry_msgs__msg__Pose__Sequence__init (& mut msg . plane_poses , self . plane_poses . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . plane_poses . data , msg . plane_poses . size) ; for (t , s) in slice . iter_mut () . zip (& self . plane_poses) { s . copy_to_native (t) ; } } msg . subframe_names . update (& self . subframe_names) ; unsafe { geometry_msgs__msg__Pose__Sequence__fini (& mut msg . subframe_poses) ; geometry_msgs__msg__Pose__Sequence__init (& mut msg . subframe_poses , self . subframe_poses . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . subframe_poses . data , msg . subframe_poses . size) ; for (t , s) in slice . iter_mut () . zip (& self . subframe_poses) { s . copy_to_native (t) ; } } msg . operation = self . operation ; } } impl Default for CollisionObject { fn default () -> Self { let msg_native = WrappedNativeMsg :: < CollisionObject > :: new () ; CollisionObject :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl CollisionObject { pub const ADD : _bindgen_ty_939 = moveit_msgs__msg__CollisionObject__ADD ; pub const APPEND : _bindgen_ty_941 = moveit_msgs__msg__CollisionObject__APPEND ; pub const MOVE : _bindgen_ty_942 = moveit_msgs__msg__CollisionObject__MOVE ; pub const REMOVE : _bindgen_ty_940 = moveit_msgs__msg__CollisionObject__REMOVE ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ConstraintEvalResult { pub result : bool , pub distance : f64 } impl WrappedTypesupport for ConstraintEvalResult { type CStruct = moveit_msgs__msg__ConstraintEvalResult ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__msg__ConstraintEvalResult () } } fn create_msg () -> * mut moveit_msgs__msg__ConstraintEvalResult { unsafe { moveit_msgs__msg__ConstraintEvalResult__create () } } fn destroy_msg (msg : * mut moveit_msgs__msg__ConstraintEvalResult) -> () { unsafe { moveit_msgs__msg__ConstraintEvalResult__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ConstraintEvalResult { ConstraintEvalResult { result : msg . result , distance : msg . distance , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . result = self . result ; msg . distance = self . distance ; } } impl Default for ConstraintEvalResult { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ConstraintEvalResult > :: new () ; ConstraintEvalResult :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Constraints { pub name : std :: string :: String , pub joint_constraints : Vec < moveit_msgs :: msg :: JointConstraint > , pub position_constraints : Vec < moveit_msgs :: msg :: PositionConstraint > , pub orientation_constraints : Vec < moveit_msgs :: msg :: OrientationConstraint > , pub visibility_constraints : Vec < moveit_msgs :: msg :: VisibilityConstraint > } impl WrappedTypesupport for Constraints { type CStruct = moveit_msgs__msg__Constraints ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__msg__Constraints () } } fn create_msg () -> * mut moveit_msgs__msg__Constraints { unsafe { moveit_msgs__msg__Constraints__create () } } fn destroy_msg (msg : * mut moveit_msgs__msg__Constraints) -> () { unsafe { moveit_msgs__msg__Constraints__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Constraints { Constraints { name : msg . name . to_str () . to_owned () , joint_constraints : { let mut temp = Vec :: with_capacity (msg . joint_constraints . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . joint_constraints . data , msg . joint_constraints . size) } ; for s in slice { temp . push (moveit_msgs :: msg :: JointConstraint :: from_native (s)) ; } temp } , position_constraints : { let mut temp = Vec :: with_capacity (msg . position_constraints . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . position_constraints . data , msg . position_constraints . size) } ; for s in slice { temp . push (moveit_msgs :: msg :: PositionConstraint :: from_native (s)) ; } temp } , orientation_constraints : { let mut temp = Vec :: with_capacity (msg . orientation_constraints . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . orientation_constraints . data , msg . orientation_constraints . size) } ; for s in slice { temp . push (moveit_msgs :: msg :: OrientationConstraint :: from_native (s)) ; } temp } , visibility_constraints : { let mut temp = Vec :: with_capacity (msg . visibility_constraints . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . visibility_constraints . data , msg . visibility_constraints . size) } ; for s in slice { temp . push (moveit_msgs :: msg :: VisibilityConstraint :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . name . assign (& self . name) ; unsafe { moveit_msgs__msg__JointConstraint__Sequence__fini (& mut msg . joint_constraints) ; moveit_msgs__msg__JointConstraint__Sequence__init (& mut msg . joint_constraints , self . joint_constraints . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . joint_constraints . data , msg . joint_constraints . size) ; for (t , s) in slice . iter_mut () . zip (& self . joint_constraints) { s . copy_to_native (t) ; } } unsafe { moveit_msgs__msg__PositionConstraint__Sequence__fini (& mut msg . position_constraints) ; moveit_msgs__msg__PositionConstraint__Sequence__init (& mut msg . position_constraints , self . position_constraints . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . position_constraints . data , msg . position_constraints . size) ; for (t , s) in slice . iter_mut () . zip (& self . position_constraints) { s . copy_to_native (t) ; } } unsafe { moveit_msgs__msg__OrientationConstraint__Sequence__fini (& mut msg . orientation_constraints) ; moveit_msgs__msg__OrientationConstraint__Sequence__init (& mut msg . orientation_constraints , self . orientation_constraints . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . orientation_constraints . data , msg . orientation_constraints . size) ; for (t , s) in slice . iter_mut () . zip (& self . orientation_constraints) { s . copy_to_native (t) ; } } unsafe { moveit_msgs__msg__VisibilityConstraint__Sequence__fini (& mut msg . visibility_constraints) ; moveit_msgs__msg__VisibilityConstraint__Sequence__init (& mut msg . visibility_constraints , self . visibility_constraints . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . visibility_constraints . data , msg . visibility_constraints . size) ; for (t , s) in slice . iter_mut () . zip (& self . visibility_constraints) { s . copy_to_native (t) ; } } } } impl Default for Constraints { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Constraints > :: new () ; Constraints :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ContactInformation { pub header : std_msgs :: msg :: Header , pub position : geometry_msgs :: msg :: Point , pub normal : geometry_msgs :: msg :: Vector3 , pub depth : f64 , pub contact_body_1 : std :: string :: String , pub body_type_1 : u32 , pub contact_body_2 : std :: string :: String , pub body_type_2 : u32 } impl WrappedTypesupport for ContactInformation { type CStruct = moveit_msgs__msg__ContactInformation ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__msg__ContactInformation () } } fn create_msg () -> * mut moveit_msgs__msg__ContactInformation { unsafe { moveit_msgs__msg__ContactInformation__create () } } fn destroy_msg (msg : * mut moveit_msgs__msg__ContactInformation) -> () { unsafe { moveit_msgs__msg__ContactInformation__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ContactInformation { ContactInformation { header : std_msgs :: msg :: Header :: from_native (& msg . header) , position : geometry_msgs :: msg :: Point :: from_native (& msg . position) , normal : geometry_msgs :: msg :: Vector3 :: from_native (& msg . normal) , depth : msg . depth , contact_body_1 : msg . contact_body_1 . to_str () . to_owned () , body_type_1 : msg . body_type_1 , contact_body_2 : msg . contact_body_2 . to_str () . to_owned () , body_type_2 : msg . body_type_2 , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; self . position . copy_to_native (& mut msg . position) ; self . normal . copy_to_native (& mut msg . normal) ; msg . depth = self . depth ; msg . contact_body_1 . assign (& self . contact_body_1) ; msg . body_type_1 = self . body_type_1 ; msg . contact_body_2 . assign (& self . contact_body_2) ; msg . body_type_2 = self . body_type_2 ; } } impl Default for ContactInformation { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ContactInformation > :: new () ; ContactInformation :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl ContactInformation { pub const ROBOT_ATTACHED : _bindgen_ty_963 = moveit_msgs__msg__ContactInformation__ROBOT_ATTACHED ; pub const ROBOT_LINK : _bindgen_ty_961 = moveit_msgs__msg__ContactInformation__ROBOT_LINK ; pub const WORLD_OBJECT : _bindgen_ty_962 = moveit_msgs__msg__ContactInformation__WORLD_OBJECT ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct CostSource { pub cost_density : f64 , pub aabb_min : geometry_msgs :: msg :: Vector3 , pub aabb_max : geometry_msgs :: msg :: Vector3 } impl WrappedTypesupport for CostSource { type CStruct = moveit_msgs__msg__CostSource ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__msg__CostSource () } } fn create_msg () -> * mut moveit_msgs__msg__CostSource { unsafe { moveit_msgs__msg__CostSource__create () } } fn destroy_msg (msg : * mut moveit_msgs__msg__CostSource) -> () { unsafe { moveit_msgs__msg__CostSource__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> CostSource { CostSource { cost_density : msg . cost_density , aabb_min : geometry_msgs :: msg :: Vector3 :: from_native (& msg . aabb_min) , aabb_max : geometry_msgs :: msg :: Vector3 :: from_native (& msg . aabb_max) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . cost_density = self . cost_density ; self . aabb_min . copy_to_native (& mut msg . aabb_min) ; self . aabb_max . copy_to_native (& mut msg . aabb_max) ; } } impl Default for CostSource { fn default () -> Self { let msg_native = WrappedNativeMsg :: < CostSource > :: new () ; CostSource :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct DisplayRobotState { pub state : moveit_msgs :: msg :: RobotState , pub highlight_links : Vec < moveit_msgs :: msg :: ObjectColor > , pub hide : bool } impl WrappedTypesupport for DisplayRobotState { type CStruct = moveit_msgs__msg__DisplayRobotState ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__msg__DisplayRobotState () } } fn create_msg () -> * mut moveit_msgs__msg__DisplayRobotState { unsafe { moveit_msgs__msg__DisplayRobotState__create () } } fn destroy_msg (msg : * mut moveit_msgs__msg__DisplayRobotState) -> () { unsafe { moveit_msgs__msg__DisplayRobotState__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> DisplayRobotState { DisplayRobotState { state : moveit_msgs :: msg :: RobotState :: from_native (& msg . state) , highlight_links : { let mut temp = Vec :: with_capacity (msg . highlight_links . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . highlight_links . data , msg . highlight_links . size) } ; for s in slice { temp . push (moveit_msgs :: msg :: ObjectColor :: from_native (s)) ; } temp } , hide : msg . hide , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . state . copy_to_native (& mut msg . state) ; unsafe { moveit_msgs__msg__ObjectColor__Sequence__fini (& mut msg . highlight_links) ; moveit_msgs__msg__ObjectColor__Sequence__init (& mut msg . highlight_links , self . highlight_links . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . highlight_links . data , msg . highlight_links . size) ; for (t , s) in slice . iter_mut () . zip (& self . highlight_links) { s . copy_to_native (t) ; } } msg . hide = self . hide ; } } impl Default for DisplayRobotState { fn default () -> Self { let msg_native = WrappedNativeMsg :: < DisplayRobotState > :: new () ; DisplayRobotState :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct DisplayTrajectory { pub model_id : std :: string :: String , pub trajectory : Vec < moveit_msgs :: msg :: RobotTrajectory > , pub trajectory_start : moveit_msgs :: msg :: RobotState } impl WrappedTypesupport for DisplayTrajectory { type CStruct = moveit_msgs__msg__DisplayTrajectory ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__msg__DisplayTrajectory () } } fn create_msg () -> * mut moveit_msgs__msg__DisplayTrajectory { unsafe { moveit_msgs__msg__DisplayTrajectory__create () } } fn destroy_msg (msg : * mut moveit_msgs__msg__DisplayTrajectory) -> () { unsafe { moveit_msgs__msg__DisplayTrajectory__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> DisplayTrajectory { DisplayTrajectory { model_id : msg . model_id . to_str () . to_owned () , trajectory : { let mut temp = Vec :: with_capacity (msg . trajectory . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . trajectory . data , msg . trajectory . size) } ; for s in slice { temp . push (moveit_msgs :: msg :: RobotTrajectory :: from_native (s)) ; } temp } , trajectory_start : moveit_msgs :: msg :: RobotState :: from_native (& msg . trajectory_start) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . model_id . assign (& self . model_id) ; unsafe { moveit_msgs__msg__RobotTrajectory__Sequence__fini (& mut msg . trajectory) ; moveit_msgs__msg__RobotTrajectory__Sequence__init (& mut msg . trajectory , self . trajectory . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . trajectory . data , msg . trajectory . size) ; for (t , s) in slice . iter_mut () . zip (& self . trajectory) { s . copy_to_native (t) ; } } self . trajectory_start . copy_to_native (& mut msg . trajectory_start) ; } } impl Default for DisplayTrajectory { fn default () -> Self { let msg_native = WrappedNativeMsg :: < DisplayTrajectory > :: new () ; DisplayTrajectory :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct GenericTrajectory { pub header : std_msgs :: msg :: Header , pub joint_trajectory : Vec < trajectory_msgs :: msg :: JointTrajectory > , pub cartesian_trajectory : Vec < moveit_msgs :: msg :: CartesianTrajectory > } impl WrappedTypesupport for GenericTrajectory { type CStruct = moveit_msgs__msg__GenericTrajectory ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__msg__GenericTrajectory () } } fn create_msg () -> * mut moveit_msgs__msg__GenericTrajectory { unsafe { moveit_msgs__msg__GenericTrajectory__create () } } fn destroy_msg (msg : * mut moveit_msgs__msg__GenericTrajectory) -> () { unsafe { moveit_msgs__msg__GenericTrajectory__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> GenericTrajectory { GenericTrajectory { header : std_msgs :: msg :: Header :: from_native (& msg . header) , joint_trajectory : { let mut temp = Vec :: with_capacity (msg . joint_trajectory . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . joint_trajectory . data , msg . joint_trajectory . size) } ; for s in slice { temp . push (trajectory_msgs :: msg :: JointTrajectory :: from_native (s)) ; } temp } , cartesian_trajectory : { let mut temp = Vec :: with_capacity (msg . cartesian_trajectory . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . cartesian_trajectory . data , msg . cartesian_trajectory . size) } ; for s in slice { temp . push (moveit_msgs :: msg :: CartesianTrajectory :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; unsafe { trajectory_msgs__msg__JointTrajectory__Sequence__fini (& mut msg . joint_trajectory) ; trajectory_msgs__msg__JointTrajectory__Sequence__init (& mut msg . joint_trajectory , self . joint_trajectory . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . joint_trajectory . data , msg . joint_trajectory . size) ; for (t , s) in slice . iter_mut () . zip (& self . joint_trajectory) { s . copy_to_native (t) ; } } unsafe { moveit_msgs__msg__CartesianTrajectory__Sequence__fini (& mut msg . cartesian_trajectory) ; moveit_msgs__msg__CartesianTrajectory__Sequence__init (& mut msg . cartesian_trajectory , self . cartesian_trajectory . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . cartesian_trajectory . data , msg . cartesian_trajectory . size) ; for (t , s) in slice . iter_mut () . zip (& self . cartesian_trajectory) { s . copy_to_native (t) ; } } } } impl Default for GenericTrajectory { fn default () -> Self { let msg_native = WrappedNativeMsg :: < GenericTrajectory > :: new () ; GenericTrajectory :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Grasp { pub id : std :: string :: String , pub pre_grasp_posture : trajectory_msgs :: msg :: JointTrajectory , pub grasp_posture : trajectory_msgs :: msg :: JointTrajectory , pub grasp_pose : geometry_msgs :: msg :: PoseStamped , pub grasp_quality : f64 , pub pre_grasp_approach : moveit_msgs :: msg :: GripperTranslation , pub post_grasp_retreat : moveit_msgs :: msg :: GripperTranslation , pub post_place_retreat : moveit_msgs :: msg :: GripperTranslation , pub max_contact_force : f32 , pub allowed_touch_objects : Vec < std :: string :: String > } impl WrappedTypesupport for Grasp { type CStruct = moveit_msgs__msg__Grasp ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__msg__Grasp () } } fn create_msg () -> * mut moveit_msgs__msg__Grasp { unsafe { moveit_msgs__msg__Grasp__create () } } fn destroy_msg (msg : * mut moveit_msgs__msg__Grasp) -> () { unsafe { moveit_msgs__msg__Grasp__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Grasp { Grasp { id : msg . id . to_str () . to_owned () , pre_grasp_posture : trajectory_msgs :: msg :: JointTrajectory :: from_native (& msg . pre_grasp_posture) , grasp_posture : trajectory_msgs :: msg :: JointTrajectory :: from_native (& msg . grasp_posture) , grasp_pose : geometry_msgs :: msg :: PoseStamped :: from_native (& msg . grasp_pose) , grasp_quality : msg . grasp_quality , pre_grasp_approach : moveit_msgs :: msg :: GripperTranslation :: from_native (& msg . pre_grasp_approach) , post_grasp_retreat : moveit_msgs :: msg :: GripperTranslation :: from_native (& msg . post_grasp_retreat) , post_place_retreat : moveit_msgs :: msg :: GripperTranslation :: from_native (& msg . post_place_retreat) , max_contact_force : msg . max_contact_force , allowed_touch_objects : msg . allowed_touch_objects . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . id . assign (& self . id) ; self . pre_grasp_posture . copy_to_native (& mut msg . pre_grasp_posture) ; self . grasp_posture . copy_to_native (& mut msg . grasp_posture) ; self . grasp_pose . copy_to_native (& mut msg . grasp_pose) ; msg . grasp_quality = self . grasp_quality ; self . pre_grasp_approach . copy_to_native (& mut msg . pre_grasp_approach) ; self . post_grasp_retreat . copy_to_native (& mut msg . post_grasp_retreat) ; self . post_place_retreat . copy_to_native (& mut msg . post_place_retreat) ; msg . max_contact_force = self . max_contact_force ; msg . allowed_touch_objects . update (& self . allowed_touch_objects) ; } } impl Default for Grasp { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Grasp > :: new () ; Grasp :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct GripperTranslation { pub direction : geometry_msgs :: msg :: Vector3Stamped , pub desired_distance : f32 , pub min_distance : f32 } impl WrappedTypesupport for GripperTranslation { type CStruct = moveit_msgs__msg__GripperTranslation ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__msg__GripperTranslation () } } fn create_msg () -> * mut moveit_msgs__msg__GripperTranslation { unsafe { moveit_msgs__msg__GripperTranslation__create () } } fn destroy_msg (msg : * mut moveit_msgs__msg__GripperTranslation) -> () { unsafe { moveit_msgs__msg__GripperTranslation__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> GripperTranslation { GripperTranslation { direction : geometry_msgs :: msg :: Vector3Stamped :: from_native (& msg . direction) , desired_distance : msg . desired_distance , min_distance : msg . min_distance , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . direction . copy_to_native (& mut msg . direction) ; msg . desired_distance = self . desired_distance ; msg . min_distance = self . min_distance ; } } impl Default for GripperTranslation { fn default () -> Self { let msg_native = WrappedNativeMsg :: < GripperTranslation > :: new () ; GripperTranslation :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct JointConstraint { pub joint_name : std :: string :: String , pub position : f64 , pub tolerance_above : f64 , pub tolerance_below : f64 , pub weight : f64 } impl WrappedTypesupport for JointConstraint { type CStruct = moveit_msgs__msg__JointConstraint ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__msg__JointConstraint () } } fn create_msg () -> * mut moveit_msgs__msg__JointConstraint { unsafe { moveit_msgs__msg__JointConstraint__create () } } fn destroy_msg (msg : * mut moveit_msgs__msg__JointConstraint) -> () { unsafe { moveit_msgs__msg__JointConstraint__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> JointConstraint { JointConstraint { joint_name : msg . joint_name . to_str () . to_owned () , position : msg . position , tolerance_above : msg . tolerance_above , tolerance_below : msg . tolerance_below , weight : msg . weight , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . joint_name . assign (& self . joint_name) ; msg . position = self . position ; msg . tolerance_above = self . tolerance_above ; msg . tolerance_below = self . tolerance_below ; msg . weight = self . weight ; } } impl Default for JointConstraint { fn default () -> Self { let msg_native = WrappedNativeMsg :: < JointConstraint > :: new () ; JointConstraint :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct JointLimits { pub joint_name : std :: string :: String , pub has_position_limits : bool , pub min_position : f64 , pub max_position : f64 , pub has_velocity_limits : bool , pub max_velocity : f64 , pub has_acceleration_limits : bool , pub max_acceleration : f64 , pub has_jerk_limits : bool , pub max_jerk : f64 } impl WrappedTypesupport for JointLimits { type CStruct = moveit_msgs__msg__JointLimits ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__msg__JointLimits () } } fn create_msg () -> * mut moveit_msgs__msg__JointLimits { unsafe { moveit_msgs__msg__JointLimits__create () } } fn destroy_msg (msg : * mut moveit_msgs__msg__JointLimits) -> () { unsafe { moveit_msgs__msg__JointLimits__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> JointLimits { JointLimits { joint_name : msg . joint_name . to_str () . to_owned () , has_position_limits : msg . has_position_limits , min_position : msg . min_position , max_position : msg . max_position , has_velocity_limits : msg . has_velocity_limits , max_velocity : msg . max_velocity , has_acceleration_limits : msg . has_acceleration_limits , max_acceleration : msg . max_acceleration , has_jerk_limits : msg . has_jerk_limits , max_jerk : msg . max_jerk , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . joint_name . assign (& self . joint_name) ; msg . has_position_limits = self . has_position_limits ; msg . min_position = self . min_position ; msg . max_position = self . max_position ; msg . has_velocity_limits = self . has_velocity_limits ; msg . max_velocity = self . max_velocity ; msg . has_acceleration_limits = self . has_acceleration_limits ; msg . max_acceleration = self . max_acceleration ; msg . has_jerk_limits = self . has_jerk_limits ; msg . max_jerk = self . max_jerk ; } } impl Default for JointLimits { fn default () -> Self { let msg_native = WrappedNativeMsg :: < JointLimits > :: new () ; JointLimits :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct KinematicSolverInfo { pub joint_names : Vec < std :: string :: String > , pub limits : Vec < moveit_msgs :: msg :: JointLimits > , pub link_names : Vec < std :: string :: String > } impl WrappedTypesupport for KinematicSolverInfo { type CStruct = moveit_msgs__msg__KinematicSolverInfo ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__msg__KinematicSolverInfo () } } fn create_msg () -> * mut moveit_msgs__msg__KinematicSolverInfo { unsafe { moveit_msgs__msg__KinematicSolverInfo__create () } } fn destroy_msg (msg : * mut moveit_msgs__msg__KinematicSolverInfo) -> () { unsafe { moveit_msgs__msg__KinematicSolverInfo__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> KinematicSolverInfo { KinematicSolverInfo { joint_names : msg . joint_names . to_vec () , limits : { let mut temp = Vec :: with_capacity (msg . limits . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . limits . data , msg . limits . size) } ; for s in slice { temp . push (moveit_msgs :: msg :: JointLimits :: from_native (s)) ; } temp } , link_names : msg . link_names . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . joint_names . update (& self . joint_names) ; unsafe { moveit_msgs__msg__JointLimits__Sequence__fini (& mut msg . limits) ; moveit_msgs__msg__JointLimits__Sequence__init (& mut msg . limits , self . limits . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . limits . data , msg . limits . size) ; for (t , s) in slice . iter_mut () . zip (& self . limits) { s . copy_to_native (t) ; } } msg . link_names . update (& self . link_names) ; } } impl Default for KinematicSolverInfo { fn default () -> Self { let msg_native = WrappedNativeMsg :: < KinematicSolverInfo > :: new () ; KinematicSolverInfo :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct LinkPadding { pub link_name : std :: string :: String , pub padding : f64 } impl WrappedTypesupport for LinkPadding { type CStruct = moveit_msgs__msg__LinkPadding ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__msg__LinkPadding () } } fn create_msg () -> * mut moveit_msgs__msg__LinkPadding { unsafe { moveit_msgs__msg__LinkPadding__create () } } fn destroy_msg (msg : * mut moveit_msgs__msg__LinkPadding) -> () { unsafe { moveit_msgs__msg__LinkPadding__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> LinkPadding { LinkPadding { link_name : msg . link_name . to_str () . to_owned () , padding : msg . padding , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . link_name . assign (& self . link_name) ; msg . padding = self . padding ; } } impl Default for LinkPadding { fn default () -> Self { let msg_native = WrappedNativeMsg :: < LinkPadding > :: new () ; LinkPadding :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct LinkScale { pub link_name : std :: string :: String , pub scale : f64 } impl WrappedTypesupport for LinkScale { type CStruct = moveit_msgs__msg__LinkScale ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__msg__LinkScale () } } fn create_msg () -> * mut moveit_msgs__msg__LinkScale { unsafe { moveit_msgs__msg__LinkScale__create () } } fn destroy_msg (msg : * mut moveit_msgs__msg__LinkScale) -> () { unsafe { moveit_msgs__msg__LinkScale__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> LinkScale { LinkScale { link_name : msg . link_name . to_str () . to_owned () , scale : msg . scale , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . link_name . assign (& self . link_name) ; msg . scale = self . scale ; } } impl Default for LinkScale { fn default () -> Self { let msg_native = WrappedNativeMsg :: < LinkScale > :: new () ; LinkScale :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct MotionPlanDetailedResponse { pub trajectory_start : moveit_msgs :: msg :: RobotState , pub group_name : std :: string :: String , pub trajectory : Vec < moveit_msgs :: msg :: RobotTrajectory > , pub description : Vec < std :: string :: String > , pub processing_time : Vec < f64 > , pub error_code : moveit_msgs :: msg :: MoveItErrorCodes } impl WrappedTypesupport for MotionPlanDetailedResponse { type CStruct = moveit_msgs__msg__MotionPlanDetailedResponse ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__msg__MotionPlanDetailedResponse () } } fn create_msg () -> * mut moveit_msgs__msg__MotionPlanDetailedResponse { unsafe { moveit_msgs__msg__MotionPlanDetailedResponse__create () } } fn destroy_msg (msg : * mut moveit_msgs__msg__MotionPlanDetailedResponse) -> () { unsafe { moveit_msgs__msg__MotionPlanDetailedResponse__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> MotionPlanDetailedResponse { MotionPlanDetailedResponse { trajectory_start : moveit_msgs :: msg :: RobotState :: from_native (& msg . trajectory_start) , group_name : msg . group_name . to_str () . to_owned () , trajectory : { let mut temp = Vec :: with_capacity (msg . trajectory . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . trajectory . data , msg . trajectory . size) } ; for s in slice { temp . push (moveit_msgs :: msg :: RobotTrajectory :: from_native (s)) ; } temp } , description : msg . description . to_vec () , processing_time : msg . processing_time . to_vec () , error_code : moveit_msgs :: msg :: MoveItErrorCodes :: from_native (& msg . error_code) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . trajectory_start . copy_to_native (& mut msg . trajectory_start) ; msg . group_name . assign (& self . group_name) ; unsafe { moveit_msgs__msg__RobotTrajectory__Sequence__fini (& mut msg . trajectory) ; moveit_msgs__msg__RobotTrajectory__Sequence__init (& mut msg . trajectory , self . trajectory . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . trajectory . data , msg . trajectory . size) ; for (t , s) in slice . iter_mut () . zip (& self . trajectory) { s . copy_to_native (t) ; } } msg . description . update (& self . description) ; msg . processing_time . update (& self . processing_time) ; self . error_code . copy_to_native (& mut msg . error_code) ; } } impl Default for MotionPlanDetailedResponse { fn default () -> Self { let msg_native = WrappedNativeMsg :: < MotionPlanDetailedResponse > :: new () ; MotionPlanDetailedResponse :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct MotionPlanRequest { pub workspace_parameters : moveit_msgs :: msg :: WorkspaceParameters , pub start_state : moveit_msgs :: msg :: RobotState , pub goal_constraints : Vec < moveit_msgs :: msg :: Constraints > , pub path_constraints : moveit_msgs :: msg :: Constraints , pub trajectory_constraints : moveit_msgs :: msg :: TrajectoryConstraints , pub reference_trajectories : Vec < moveit_msgs :: msg :: GenericTrajectory > , pub pipeline_id : std :: string :: String , pub planner_id : std :: string :: String , pub group_name : std :: string :: String , pub num_planning_attempts : i32 , pub allowed_planning_time : f64 , pub max_velocity_scaling_factor : f64 , pub max_acceleration_scaling_factor : f64 , pub cartesian_speed_end_effector_link : std :: string :: String , pub max_cartesian_speed : f64 } impl WrappedTypesupport for MotionPlanRequest { type CStruct = moveit_msgs__msg__MotionPlanRequest ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__msg__MotionPlanRequest () } } fn create_msg () -> * mut moveit_msgs__msg__MotionPlanRequest { unsafe { moveit_msgs__msg__MotionPlanRequest__create () } } fn destroy_msg (msg : * mut moveit_msgs__msg__MotionPlanRequest) -> () { unsafe { moveit_msgs__msg__MotionPlanRequest__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> MotionPlanRequest { MotionPlanRequest { workspace_parameters : moveit_msgs :: msg :: WorkspaceParameters :: from_native (& msg . workspace_parameters) , start_state : moveit_msgs :: msg :: RobotState :: from_native (& msg . start_state) , goal_constraints : { let mut temp = Vec :: with_capacity (msg . goal_constraints . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . goal_constraints . data , msg . goal_constraints . size) } ; for s in slice { temp . push (moveit_msgs :: msg :: Constraints :: from_native (s)) ; } temp } , path_constraints : moveit_msgs :: msg :: Constraints :: from_native (& msg . path_constraints) , trajectory_constraints : moveit_msgs :: msg :: TrajectoryConstraints :: from_native (& msg . trajectory_constraints) , reference_trajectories : { let mut temp = Vec :: with_capacity (msg . reference_trajectories . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . reference_trajectories . data , msg . reference_trajectories . size) } ; for s in slice { temp . push (moveit_msgs :: msg :: GenericTrajectory :: from_native (s)) ; } temp } , pipeline_id : msg . pipeline_id . to_str () . to_owned () , planner_id : msg . planner_id . to_str () . to_owned () , group_name : msg . group_name . to_str () . to_owned () , num_planning_attempts : msg . num_planning_attempts , allowed_planning_time : msg . allowed_planning_time , max_velocity_scaling_factor : msg . max_velocity_scaling_factor , max_acceleration_scaling_factor : msg . max_acceleration_scaling_factor , cartesian_speed_end_effector_link : msg . cartesian_speed_end_effector_link . to_str () . to_owned () , max_cartesian_speed : msg . max_cartesian_speed , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . workspace_parameters . copy_to_native (& mut msg . workspace_parameters) ; self . start_state . copy_to_native (& mut msg . start_state) ; unsafe { moveit_msgs__msg__Constraints__Sequence__fini (& mut msg . goal_constraints) ; moveit_msgs__msg__Constraints__Sequence__init (& mut msg . goal_constraints , self . goal_constraints . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . goal_constraints . data , msg . goal_constraints . size) ; for (t , s) in slice . iter_mut () . zip (& self . goal_constraints) { s . copy_to_native (t) ; } } self . path_constraints . copy_to_native (& mut msg . path_constraints) ; self . trajectory_constraints . copy_to_native (& mut msg . trajectory_constraints) ; unsafe { moveit_msgs__msg__GenericTrajectory__Sequence__fini (& mut msg . reference_trajectories) ; moveit_msgs__msg__GenericTrajectory__Sequence__init (& mut msg . reference_trajectories , self . reference_trajectories . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . reference_trajectories . data , msg . reference_trajectories . size) ; for (t , s) in slice . iter_mut () . zip (& self . reference_trajectories) { s . copy_to_native (t) ; } } msg . pipeline_id . assign (& self . pipeline_id) ; msg . planner_id . assign (& self . planner_id) ; msg . group_name . assign (& self . group_name) ; msg . num_planning_attempts = self . num_planning_attempts ; msg . allowed_planning_time = self . allowed_planning_time ; msg . max_velocity_scaling_factor = self . max_velocity_scaling_factor ; msg . max_acceleration_scaling_factor = self . max_acceleration_scaling_factor ; msg . cartesian_speed_end_effector_link . assign (& self . cartesian_speed_end_effector_link) ; msg . max_cartesian_speed = self . max_cartesian_speed ; } } impl Default for MotionPlanRequest { fn default () -> Self { let msg_native = WrappedNativeMsg :: < MotionPlanRequest > :: new () ; MotionPlanRequest :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct MotionPlanResponse { pub trajectory_start : moveit_msgs :: msg :: RobotState , pub group_name : std :: string :: String , pub trajectory : moveit_msgs :: msg :: RobotTrajectory , pub planning_time : f64 , pub error_code : moveit_msgs :: msg :: MoveItErrorCodes } impl WrappedTypesupport for MotionPlanResponse { type CStruct = moveit_msgs__msg__MotionPlanResponse ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__msg__MotionPlanResponse () } } fn create_msg () -> * mut moveit_msgs__msg__MotionPlanResponse { unsafe { moveit_msgs__msg__MotionPlanResponse__create () } } fn destroy_msg (msg : * mut moveit_msgs__msg__MotionPlanResponse) -> () { unsafe { moveit_msgs__msg__MotionPlanResponse__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> MotionPlanResponse { MotionPlanResponse { trajectory_start : moveit_msgs :: msg :: RobotState :: from_native (& msg . trajectory_start) , group_name : msg . group_name . to_str () . to_owned () , trajectory : moveit_msgs :: msg :: RobotTrajectory :: from_native (& msg . trajectory) , planning_time : msg . planning_time , error_code : moveit_msgs :: msg :: MoveItErrorCodes :: from_native (& msg . error_code) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . trajectory_start . copy_to_native (& mut msg . trajectory_start) ; msg . group_name . assign (& self . group_name) ; self . trajectory . copy_to_native (& mut msg . trajectory) ; msg . planning_time = self . planning_time ; self . error_code . copy_to_native (& mut msg . error_code) ; } } impl Default for MotionPlanResponse { fn default () -> Self { let msg_native = WrappedNativeMsg :: < MotionPlanResponse > :: new () ; MotionPlanResponse :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct MotionSequenceItem { pub req : moveit_msgs :: msg :: MotionPlanRequest , pub blend_radius : f64 } impl WrappedTypesupport for MotionSequenceItem { type CStruct = moveit_msgs__msg__MotionSequenceItem ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__msg__MotionSequenceItem () } } fn create_msg () -> * mut moveit_msgs__msg__MotionSequenceItem { unsafe { moveit_msgs__msg__MotionSequenceItem__create () } } fn destroy_msg (msg : * mut moveit_msgs__msg__MotionSequenceItem) -> () { unsafe { moveit_msgs__msg__MotionSequenceItem__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> MotionSequenceItem { MotionSequenceItem { req : moveit_msgs :: msg :: MotionPlanRequest :: from_native (& msg . req) , blend_radius : msg . blend_radius , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . req . copy_to_native (& mut msg . req) ; msg . blend_radius = self . blend_radius ; } } impl Default for MotionSequenceItem { fn default () -> Self { let msg_native = WrappedNativeMsg :: < MotionSequenceItem > :: new () ; MotionSequenceItem :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct MotionSequenceRequest { pub items : Vec < moveit_msgs :: msg :: MotionSequenceItem > } impl WrappedTypesupport for MotionSequenceRequest { type CStruct = moveit_msgs__msg__MotionSequenceRequest ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__msg__MotionSequenceRequest () } } fn create_msg () -> * mut moveit_msgs__msg__MotionSequenceRequest { unsafe { moveit_msgs__msg__MotionSequenceRequest__create () } } fn destroy_msg (msg : * mut moveit_msgs__msg__MotionSequenceRequest) -> () { unsafe { moveit_msgs__msg__MotionSequenceRequest__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> MotionSequenceRequest { MotionSequenceRequest { items : { let mut temp = Vec :: with_capacity (msg . items . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . items . data , msg . items . size) } ; for s in slice { temp . push (moveit_msgs :: msg :: MotionSequenceItem :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { unsafe { moveit_msgs__msg__MotionSequenceItem__Sequence__fini (& mut msg . items) ; moveit_msgs__msg__MotionSequenceItem__Sequence__init (& mut msg . items , self . items . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . items . data , msg . items . size) ; for (t , s) in slice . iter_mut () . zip (& self . items) { s . copy_to_native (t) ; } } } } impl Default for MotionSequenceRequest { fn default () -> Self { let msg_native = WrappedNativeMsg :: < MotionSequenceRequest > :: new () ; MotionSequenceRequest :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct MotionSequenceResponse { pub error_code : moveit_msgs :: msg :: MoveItErrorCodes , pub sequence_start : moveit_msgs :: msg :: RobotState , pub planned_trajectories : Vec < moveit_msgs :: msg :: RobotTrajectory > , pub planning_time : f64 } impl WrappedTypesupport for MotionSequenceResponse { type CStruct = moveit_msgs__msg__MotionSequenceResponse ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__msg__MotionSequenceResponse () } } fn create_msg () -> * mut moveit_msgs__msg__MotionSequenceResponse { unsafe { moveit_msgs__msg__MotionSequenceResponse__create () } } fn destroy_msg (msg : * mut moveit_msgs__msg__MotionSequenceResponse) -> () { unsafe { moveit_msgs__msg__MotionSequenceResponse__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> MotionSequenceResponse { MotionSequenceResponse { error_code : moveit_msgs :: msg :: MoveItErrorCodes :: from_native (& msg . error_code) , sequence_start : moveit_msgs :: msg :: RobotState :: from_native (& msg . sequence_start) , planned_trajectories : { let mut temp = Vec :: with_capacity (msg . planned_trajectories . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . planned_trajectories . data , msg . planned_trajectories . size) } ; for s in slice { temp . push (moveit_msgs :: msg :: RobotTrajectory :: from_native (s)) ; } temp } , planning_time : msg . planning_time , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . error_code . copy_to_native (& mut msg . error_code) ; self . sequence_start . copy_to_native (& mut msg . sequence_start) ; unsafe { moveit_msgs__msg__RobotTrajectory__Sequence__fini (& mut msg . planned_trajectories) ; moveit_msgs__msg__RobotTrajectory__Sequence__init (& mut msg . planned_trajectories , self . planned_trajectories . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . planned_trajectories . data , msg . planned_trajectories . size) ; for (t , s) in slice . iter_mut () . zip (& self . planned_trajectories) { s . copy_to_native (t) ; } } msg . planning_time = self . planning_time ; } } impl Default for MotionSequenceResponse { fn default () -> Self { let msg_native = WrappedNativeMsg :: < MotionSequenceResponse > :: new () ; MotionSequenceResponse :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct MoveItErrorCodes { pub val : i32 } impl WrappedTypesupport for MoveItErrorCodes { type CStruct = moveit_msgs__msg__MoveItErrorCodes ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__msg__MoveItErrorCodes () } } fn create_msg () -> * mut moveit_msgs__msg__MoveItErrorCodes { unsafe { moveit_msgs__msg__MoveItErrorCodes__create () } } fn destroy_msg (msg : * mut moveit_msgs__msg__MoveItErrorCodes) -> () { unsafe { moveit_msgs__msg__MoveItErrorCodes__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> MoveItErrorCodes { MoveItErrorCodes { val : msg . val , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . val = self . val ; } } impl Default for MoveItErrorCodes { fn default () -> Self { let msg_native = WrappedNativeMsg :: < MoveItErrorCodes > :: new () ; MoveItErrorCodes :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl MoveItErrorCodes { pub const COLLISION_CHECKING_UNAVAILABLE : _bindgen_ty_934 = moveit_msgs__msg__MoveItErrorCodes__COLLISION_CHECKING_UNAVAILABLE ; pub const COMMUNICATION_FAILURE : _bindgen_ty_937 = moveit_msgs__msg__MoveItErrorCodes__COMMUNICATION_FAILURE ; pub const CONTROL_FAILED : _bindgen_ty_919 = moveit_msgs__msg__MoveItErrorCodes__CONTROL_FAILED ; pub const FAILURE : _bindgen_ty_915 = moveit_msgs__msg__MoveItErrorCodes__FAILURE ; pub const FRAME_TRANSFORM_FAILURE : _bindgen_ty_933 = moveit_msgs__msg__MoveItErrorCodes__FRAME_TRANSFORM_FAILURE ; pub const GOAL_CONSTRAINTS_VIOLATED : _bindgen_ty_927 = moveit_msgs__msg__MoveItErrorCodes__GOAL_CONSTRAINTS_VIOLATED ; pub const GOAL_IN_COLLISION : _bindgen_ty_925 = moveit_msgs__msg__MoveItErrorCodes__GOAL_IN_COLLISION ; pub const GOAL_VIOLATES_PATH_CONSTRAINTS : _bindgen_ty_926 = moveit_msgs__msg__MoveItErrorCodes__GOAL_VIOLATES_PATH_CONSTRAINTS ; pub const INVALID_GOAL_CONSTRAINTS : _bindgen_ty_929 = moveit_msgs__msg__MoveItErrorCodes__INVALID_GOAL_CONSTRAINTS ; pub const INVALID_GROUP_NAME : _bindgen_ty_928 = moveit_msgs__msg__MoveItErrorCodes__INVALID_GROUP_NAME ; pub const INVALID_LINK_NAME : _bindgen_ty_931 = moveit_msgs__msg__MoveItErrorCodes__INVALID_LINK_NAME ; pub const INVALID_MOTION_PLAN : _bindgen_ty_917 = moveit_msgs__msg__MoveItErrorCodes__INVALID_MOTION_PLAN ; pub const INVALID_OBJECT_NAME : _bindgen_ty_932 = moveit_msgs__msg__MoveItErrorCodes__INVALID_OBJECT_NAME ; pub const INVALID_ROBOT_STATE : _bindgen_ty_930 = moveit_msgs__msg__MoveItErrorCodes__INVALID_ROBOT_STATE ; pub const MOTION_PLAN_INVALIDATED_BY_ENVIRONMENT_CHANGE : _bindgen_ty_918 = moveit_msgs__msg__MoveItErrorCodes__MOTION_PLAN_INVALIDATED_BY_ENVIRONMENT_CHANGE ; pub const NO_IK_SOLUTION : _bindgen_ty_938 = moveit_msgs__msg__MoveItErrorCodes__NO_IK_SOLUTION ; pub const PLANNING_FAILED : _bindgen_ty_916 = moveit_msgs__msg__MoveItErrorCodes__PLANNING_FAILED ; pub const PREEMPTED : _bindgen_ty_922 = moveit_msgs__msg__MoveItErrorCodes__PREEMPTED ; pub const ROBOT_STATE_STALE : _bindgen_ty_935 = moveit_msgs__msg__MoveItErrorCodes__ROBOT_STATE_STALE ; pub const SENSOR_INFO_STALE : _bindgen_ty_936 = moveit_msgs__msg__MoveItErrorCodes__SENSOR_INFO_STALE ; pub const START_STATE_IN_COLLISION : _bindgen_ty_923 = moveit_msgs__msg__MoveItErrorCodes__START_STATE_IN_COLLISION ; pub const START_STATE_VIOLATES_PATH_CONSTRAINTS : _bindgen_ty_924 = moveit_msgs__msg__MoveItErrorCodes__START_STATE_VIOLATES_PATH_CONSTRAINTS ; pub const SUCCESS : _bindgen_ty_914 = moveit_msgs__msg__MoveItErrorCodes__SUCCESS ; pub const TIMED_OUT : _bindgen_ty_921 = moveit_msgs__msg__MoveItErrorCodes__TIMED_OUT ; pub const UNABLE_TO_AQUIRE_SENSOR_DATA : _bindgen_ty_920 = moveit_msgs__msg__MoveItErrorCodes__UNABLE_TO_AQUIRE_SENSOR_DATA ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ObjectColor { pub id : std :: string :: String , pub color : std_msgs :: msg :: ColorRGBA } impl WrappedTypesupport for ObjectColor { type CStruct = moveit_msgs__msg__ObjectColor ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__msg__ObjectColor () } } fn create_msg () -> * mut moveit_msgs__msg__ObjectColor { unsafe { moveit_msgs__msg__ObjectColor__create () } } fn destroy_msg (msg : * mut moveit_msgs__msg__ObjectColor) -> () { unsafe { moveit_msgs__msg__ObjectColor__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ObjectColor { ObjectColor { id : msg . id . to_str () . to_owned () , color : std_msgs :: msg :: ColorRGBA :: from_native (& msg . color) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . id . assign (& self . id) ; self . color . copy_to_native (& mut msg . color) ; } } impl Default for ObjectColor { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ObjectColor > :: new () ; ObjectColor :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct OrientationConstraint { pub header : std_msgs :: msg :: Header , pub orientation : geometry_msgs :: msg :: Quaternion , pub link_name : std :: string :: String , pub absolute_x_axis_tolerance : f64 , pub absolute_y_axis_tolerance : f64 , pub absolute_z_axis_tolerance : f64 , pub parameterization : u8 , pub weight : f64 } impl WrappedTypesupport for OrientationConstraint { type CStruct = moveit_msgs__msg__OrientationConstraint ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__msg__OrientationConstraint () } } fn create_msg () -> * mut moveit_msgs__msg__OrientationConstraint { unsafe { moveit_msgs__msg__OrientationConstraint__create () } } fn destroy_msg (msg : * mut moveit_msgs__msg__OrientationConstraint) -> () { unsafe { moveit_msgs__msg__OrientationConstraint__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> OrientationConstraint { OrientationConstraint { header : std_msgs :: msg :: Header :: from_native (& msg . header) , orientation : geometry_msgs :: msg :: Quaternion :: from_native (& msg . orientation) , link_name : msg . link_name . to_str () . to_owned () , absolute_x_axis_tolerance : msg . absolute_x_axis_tolerance , absolute_y_axis_tolerance : msg . absolute_y_axis_tolerance , absolute_z_axis_tolerance : msg . absolute_z_axis_tolerance , parameterization : msg . parameterization , weight : msg . weight , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; self . orientation . copy_to_native (& mut msg . orientation) ; msg . link_name . assign (& self . link_name) ; msg . absolute_x_axis_tolerance = self . absolute_x_axis_tolerance ; msg . absolute_y_axis_tolerance = self . absolute_y_axis_tolerance ; msg . absolute_z_axis_tolerance = self . absolute_z_axis_tolerance ; msg . parameterization = self . parameterization ; msg . weight = self . weight ; } } impl Default for OrientationConstraint { fn default () -> Self { let msg_native = WrappedNativeMsg :: < OrientationConstraint > :: new () ; OrientationConstraint :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl OrientationConstraint { pub const ROTATION_VECTOR : _bindgen_ty_957 = moveit_msgs__msg__OrientationConstraint__ROTATION_VECTOR ; pub const XYZ_EULER_ANGLES : _bindgen_ty_956 = moveit_msgs__msg__OrientationConstraint__XYZ_EULER_ANGLES ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct OrientedBoundingBox { pub pose : geometry_msgs :: msg :: Pose , pub extents : geometry_msgs :: msg :: Point32 } impl WrappedTypesupport for OrientedBoundingBox { type CStruct = moveit_msgs__msg__OrientedBoundingBox ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__msg__OrientedBoundingBox () } } fn create_msg () -> * mut moveit_msgs__msg__OrientedBoundingBox { unsafe { moveit_msgs__msg__OrientedBoundingBox__create () } } fn destroy_msg (msg : * mut moveit_msgs__msg__OrientedBoundingBox) -> () { unsafe { moveit_msgs__msg__OrientedBoundingBox__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> OrientedBoundingBox { OrientedBoundingBox { pose : geometry_msgs :: msg :: Pose :: from_native (& msg . pose) , extents : geometry_msgs :: msg :: Point32 :: from_native (& msg . extents) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . pose . copy_to_native (& mut msg . pose) ; self . extents . copy_to_native (& mut msg . extents) ; } } impl Default for OrientedBoundingBox { fn default () -> Self { let msg_native = WrappedNativeMsg :: < OrientedBoundingBox > :: new () ; OrientedBoundingBox :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct PlaceLocation { pub id : std :: string :: String , pub post_place_posture : trajectory_msgs :: msg :: JointTrajectory , pub place_pose : geometry_msgs :: msg :: PoseStamped , pub quality : f64 , pub pre_place_approach : moveit_msgs :: msg :: GripperTranslation , pub post_place_retreat : moveit_msgs :: msg :: GripperTranslation , pub allowed_touch_objects : Vec < std :: string :: String > } impl WrappedTypesupport for PlaceLocation { type CStruct = moveit_msgs__msg__PlaceLocation ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__msg__PlaceLocation () } } fn create_msg () -> * mut moveit_msgs__msg__PlaceLocation { unsafe { moveit_msgs__msg__PlaceLocation__create () } } fn destroy_msg (msg : * mut moveit_msgs__msg__PlaceLocation) -> () { unsafe { moveit_msgs__msg__PlaceLocation__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> PlaceLocation { PlaceLocation { id : msg . id . to_str () . to_owned () , post_place_posture : trajectory_msgs :: msg :: JointTrajectory :: from_native (& msg . post_place_posture) , place_pose : geometry_msgs :: msg :: PoseStamped :: from_native (& msg . place_pose) , quality : msg . quality , pre_place_approach : moveit_msgs :: msg :: GripperTranslation :: from_native (& msg . pre_place_approach) , post_place_retreat : moveit_msgs :: msg :: GripperTranslation :: from_native (& msg . post_place_retreat) , allowed_touch_objects : msg . allowed_touch_objects . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . id . assign (& self . id) ; self . post_place_posture . copy_to_native (& mut msg . post_place_posture) ; self . place_pose . copy_to_native (& mut msg . place_pose) ; msg . quality = self . quality ; self . pre_place_approach . copy_to_native (& mut msg . pre_place_approach) ; self . post_place_retreat . copy_to_native (& mut msg . post_place_retreat) ; msg . allowed_touch_objects . update (& self . allowed_touch_objects) ; } } impl Default for PlaceLocation { fn default () -> Self { let msg_native = WrappedNativeMsg :: < PlaceLocation > :: new () ; PlaceLocation :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct PlannerInterfaceDescription { pub name : std :: string :: String , pub pipeline_id : std :: string :: String , pub planner_ids : Vec < std :: string :: String > } impl WrappedTypesupport for PlannerInterfaceDescription { type CStruct = moveit_msgs__msg__PlannerInterfaceDescription ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__msg__PlannerInterfaceDescription () } } fn create_msg () -> * mut moveit_msgs__msg__PlannerInterfaceDescription { unsafe { moveit_msgs__msg__PlannerInterfaceDescription__create () } } fn destroy_msg (msg : * mut moveit_msgs__msg__PlannerInterfaceDescription) -> () { unsafe { moveit_msgs__msg__PlannerInterfaceDescription__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> PlannerInterfaceDescription { PlannerInterfaceDescription { name : msg . name . to_str () . to_owned () , pipeline_id : msg . pipeline_id . to_str () . to_owned () , planner_ids : msg . planner_ids . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . name . assign (& self . name) ; msg . pipeline_id . assign (& self . pipeline_id) ; msg . planner_ids . update (& self . planner_ids) ; } } impl Default for PlannerInterfaceDescription { fn default () -> Self { let msg_native = WrappedNativeMsg :: < PlannerInterfaceDescription > :: new () ; PlannerInterfaceDescription :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct PlannerParams { pub keys : Vec < std :: string :: String > , pub values : Vec < std :: string :: String > , pub descriptions : Vec < std :: string :: String > } impl WrappedTypesupport for PlannerParams { type CStruct = moveit_msgs__msg__PlannerParams ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__msg__PlannerParams () } } fn create_msg () -> * mut moveit_msgs__msg__PlannerParams { unsafe { moveit_msgs__msg__PlannerParams__create () } } fn destroy_msg (msg : * mut moveit_msgs__msg__PlannerParams) -> () { unsafe { moveit_msgs__msg__PlannerParams__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> PlannerParams { PlannerParams { keys : msg . keys . to_vec () , values : msg . values . to_vec () , descriptions : msg . descriptions . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . keys . update (& self . keys) ; msg . values . update (& self . values) ; msg . descriptions . update (& self . descriptions) ; } } impl Default for PlannerParams { fn default () -> Self { let msg_native = WrappedNativeMsg :: < PlannerParams > :: new () ; PlannerParams :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct PlanningOptions { pub planning_scene_diff : moveit_msgs :: msg :: PlanningScene , pub plan_only : bool , pub look_around : bool , pub look_around_attempts : i32 , pub max_safe_execution_cost : f64 , pub replan : bool , pub replan_attempts : i32 , pub replan_delay : f64 } impl WrappedTypesupport for PlanningOptions { type CStruct = moveit_msgs__msg__PlanningOptions ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__msg__PlanningOptions () } } fn create_msg () -> * mut moveit_msgs__msg__PlanningOptions { unsafe { moveit_msgs__msg__PlanningOptions__create () } } fn destroy_msg (msg : * mut moveit_msgs__msg__PlanningOptions) -> () { unsafe { moveit_msgs__msg__PlanningOptions__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> PlanningOptions { PlanningOptions { planning_scene_diff : moveit_msgs :: msg :: PlanningScene :: from_native (& msg . planning_scene_diff) , plan_only : msg . plan_only , look_around : msg . look_around , look_around_attempts : msg . look_around_attempts , max_safe_execution_cost : msg . max_safe_execution_cost , replan : msg . replan , replan_attempts : msg . replan_attempts , replan_delay : msg . replan_delay , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . planning_scene_diff . copy_to_native (& mut msg . planning_scene_diff) ; msg . plan_only = self . plan_only ; msg . look_around = self . look_around ; msg . look_around_attempts = self . look_around_attempts ; msg . max_safe_execution_cost = self . max_safe_execution_cost ; msg . replan = self . replan ; msg . replan_attempts = self . replan_attempts ; msg . replan_delay = self . replan_delay ; } } impl Default for PlanningOptions { fn default () -> Self { let msg_native = WrappedNativeMsg :: < PlanningOptions > :: new () ; PlanningOptions :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct PlanningScene { pub name : std :: string :: String , pub robot_state : moveit_msgs :: msg :: RobotState , pub robot_model_name : std :: string :: String , pub fixed_frame_transforms : Vec < geometry_msgs :: msg :: TransformStamped > , pub allowed_collision_matrix : moveit_msgs :: msg :: AllowedCollisionMatrix , pub link_padding : Vec < moveit_msgs :: msg :: LinkPadding > , pub link_scale : Vec < moveit_msgs :: msg :: LinkScale > , pub object_colors : Vec < moveit_msgs :: msg :: ObjectColor > , pub world : moveit_msgs :: msg :: PlanningSceneWorld , pub is_diff : bool } impl WrappedTypesupport for PlanningScene { type CStruct = moveit_msgs__msg__PlanningScene ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__msg__PlanningScene () } } fn create_msg () -> * mut moveit_msgs__msg__PlanningScene { unsafe { moveit_msgs__msg__PlanningScene__create () } } fn destroy_msg (msg : * mut moveit_msgs__msg__PlanningScene) -> () { unsafe { moveit_msgs__msg__PlanningScene__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> PlanningScene { PlanningScene { name : msg . name . to_str () . to_owned () , robot_state : moveit_msgs :: msg :: RobotState :: from_native (& msg . robot_state) , robot_model_name : msg . robot_model_name . to_str () . to_owned () , fixed_frame_transforms : { let mut temp = Vec :: with_capacity (msg . fixed_frame_transforms . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . fixed_frame_transforms . data , msg . fixed_frame_transforms . size) } ; for s in slice { temp . push (geometry_msgs :: msg :: TransformStamped :: from_native (s)) ; } temp } , allowed_collision_matrix : moveit_msgs :: msg :: AllowedCollisionMatrix :: from_native (& msg . allowed_collision_matrix) , link_padding : { let mut temp = Vec :: with_capacity (msg . link_padding . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . link_padding . data , msg . link_padding . size) } ; for s in slice { temp . push (moveit_msgs :: msg :: LinkPadding :: from_native (s)) ; } temp } , link_scale : { let mut temp = Vec :: with_capacity (msg . link_scale . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . link_scale . data , msg . link_scale . size) } ; for s in slice { temp . push (moveit_msgs :: msg :: LinkScale :: from_native (s)) ; } temp } , object_colors : { let mut temp = Vec :: with_capacity (msg . object_colors . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . object_colors . data , msg . object_colors . size) } ; for s in slice { temp . push (moveit_msgs :: msg :: ObjectColor :: from_native (s)) ; } temp } , world : moveit_msgs :: msg :: PlanningSceneWorld :: from_native (& msg . world) , is_diff : msg . is_diff , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . name . assign (& self . name) ; self . robot_state . copy_to_native (& mut msg . robot_state) ; msg . robot_model_name . assign (& self . robot_model_name) ; unsafe { geometry_msgs__msg__TransformStamped__Sequence__fini (& mut msg . fixed_frame_transforms) ; geometry_msgs__msg__TransformStamped__Sequence__init (& mut msg . fixed_frame_transforms , self . fixed_frame_transforms . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . fixed_frame_transforms . data , msg . fixed_frame_transforms . size) ; for (t , s) in slice . iter_mut () . zip (& self . fixed_frame_transforms) { s . copy_to_native (t) ; } } self . allowed_collision_matrix . copy_to_native (& mut msg . allowed_collision_matrix) ; unsafe { moveit_msgs__msg__LinkPadding__Sequence__fini (& mut msg . link_padding) ; moveit_msgs__msg__LinkPadding__Sequence__init (& mut msg . link_padding , self . link_padding . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . link_padding . data , msg . link_padding . size) ; for (t , s) in slice . iter_mut () . zip (& self . link_padding) { s . copy_to_native (t) ; } } unsafe { moveit_msgs__msg__LinkScale__Sequence__fini (& mut msg . link_scale) ; moveit_msgs__msg__LinkScale__Sequence__init (& mut msg . link_scale , self . link_scale . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . link_scale . data , msg . link_scale . size) ; for (t , s) in slice . iter_mut () . zip (& self . link_scale) { s . copy_to_native (t) ; } } unsafe { moveit_msgs__msg__ObjectColor__Sequence__fini (& mut msg . object_colors) ; moveit_msgs__msg__ObjectColor__Sequence__init (& mut msg . object_colors , self . object_colors . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . object_colors . data , msg . object_colors . size) ; for (t , s) in slice . iter_mut () . zip (& self . object_colors) { s . copy_to_native (t) ; } } self . world . copy_to_native (& mut msg . world) ; msg . is_diff = self . is_diff ; } } impl Default for PlanningScene { fn default () -> Self { let msg_native = WrappedNativeMsg :: < PlanningScene > :: new () ; PlanningScene :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct PlanningSceneComponents { pub components : u32 } impl WrappedTypesupport for PlanningSceneComponents { type CStruct = moveit_msgs__msg__PlanningSceneComponents ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__msg__PlanningSceneComponents () } } fn create_msg () -> * mut moveit_msgs__msg__PlanningSceneComponents { unsafe { moveit_msgs__msg__PlanningSceneComponents__create () } } fn destroy_msg (msg : * mut moveit_msgs__msg__PlanningSceneComponents) -> () { unsafe { moveit_msgs__msg__PlanningSceneComponents__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> PlanningSceneComponents { PlanningSceneComponents { components : msg . components , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . components = self . components ; } } impl Default for PlanningSceneComponents { fn default () -> Self { let msg_native = WrappedNativeMsg :: < PlanningSceneComponents > :: new () ; PlanningSceneComponents :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl PlanningSceneComponents { pub const ALLOWED_COLLISION_MATRIX : _bindgen_ty_971 = moveit_msgs__msg__PlanningSceneComponents__ALLOWED_COLLISION_MATRIX ; pub const LINK_PADDING_AND_SCALING : _bindgen_ty_972 = moveit_msgs__msg__PlanningSceneComponents__LINK_PADDING_AND_SCALING ; pub const OBJECT_COLORS : _bindgen_ty_973 = moveit_msgs__msg__PlanningSceneComponents__OBJECT_COLORS ; pub const OCTOMAP : _bindgen_ty_969 = moveit_msgs__msg__PlanningSceneComponents__OCTOMAP ; pub const ROBOT_STATE : _bindgen_ty_965 = moveit_msgs__msg__PlanningSceneComponents__ROBOT_STATE ; pub const ROBOT_STATE_ATTACHED_OBJECTS : _bindgen_ty_966 = moveit_msgs__msg__PlanningSceneComponents__ROBOT_STATE_ATTACHED_OBJECTS ; pub const SCENE_SETTINGS : _bindgen_ty_964 = moveit_msgs__msg__PlanningSceneComponents__SCENE_SETTINGS ; pub const TRANSFORMS : _bindgen_ty_970 = moveit_msgs__msg__PlanningSceneComponents__TRANSFORMS ; pub const WORLD_OBJECT_GEOMETRY : _bindgen_ty_968 = moveit_msgs__msg__PlanningSceneComponents__WORLD_OBJECT_GEOMETRY ; pub const WORLD_OBJECT_NAMES : _bindgen_ty_967 = moveit_msgs__msg__PlanningSceneComponents__WORLD_OBJECT_NAMES ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct PlanningSceneWorld { pub collision_objects : Vec < moveit_msgs :: msg :: CollisionObject > , pub octomap : octomap_msgs :: msg :: OctomapWithPose } impl WrappedTypesupport for PlanningSceneWorld { type CStruct = moveit_msgs__msg__PlanningSceneWorld ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__msg__PlanningSceneWorld () } } fn create_msg () -> * mut moveit_msgs__msg__PlanningSceneWorld { unsafe { moveit_msgs__msg__PlanningSceneWorld__create () } } fn destroy_msg (msg : * mut moveit_msgs__msg__PlanningSceneWorld) -> () { unsafe { moveit_msgs__msg__PlanningSceneWorld__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> PlanningSceneWorld { PlanningSceneWorld { collision_objects : { let mut temp = Vec :: with_capacity (msg . collision_objects . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . collision_objects . data , msg . collision_objects . size) } ; for s in slice { temp . push (moveit_msgs :: msg :: CollisionObject :: from_native (s)) ; } temp } , octomap : octomap_msgs :: msg :: OctomapWithPose :: from_native (& msg . octomap) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { unsafe { moveit_msgs__msg__CollisionObject__Sequence__fini (& mut msg . collision_objects) ; moveit_msgs__msg__CollisionObject__Sequence__init (& mut msg . collision_objects , self . collision_objects . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . collision_objects . data , msg . collision_objects . size) ; for (t , s) in slice . iter_mut () . zip (& self . collision_objects) { s . copy_to_native (t) ; } } self . octomap . copy_to_native (& mut msg . octomap) ; } } impl Default for PlanningSceneWorld { fn default () -> Self { let msg_native = WrappedNativeMsg :: < PlanningSceneWorld > :: new () ; PlanningSceneWorld :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct PositionConstraint { pub header : std_msgs :: msg :: Header , pub link_name : std :: string :: String , pub target_point_offset : geometry_msgs :: msg :: Vector3 , pub constraint_region : moveit_msgs :: msg :: BoundingVolume , pub weight : f64 } impl WrappedTypesupport for PositionConstraint { type CStruct = moveit_msgs__msg__PositionConstraint ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__msg__PositionConstraint () } } fn create_msg () -> * mut moveit_msgs__msg__PositionConstraint { unsafe { moveit_msgs__msg__PositionConstraint__create () } } fn destroy_msg (msg : * mut moveit_msgs__msg__PositionConstraint) -> () { unsafe { moveit_msgs__msg__PositionConstraint__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> PositionConstraint { PositionConstraint { header : std_msgs :: msg :: Header :: from_native (& msg . header) , link_name : msg . link_name . to_str () . to_owned () , target_point_offset : geometry_msgs :: msg :: Vector3 :: from_native (& msg . target_point_offset) , constraint_region : moveit_msgs :: msg :: BoundingVolume :: from_native (& msg . constraint_region) , weight : msg . weight , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . link_name . assign (& self . link_name) ; self . target_point_offset . copy_to_native (& mut msg . target_point_offset) ; self . constraint_region . copy_to_native (& mut msg . constraint_region) ; msg . weight = self . weight ; } } impl Default for PositionConstraint { fn default () -> Self { let msg_native = WrappedNativeMsg :: < PositionConstraint > :: new () ; PositionConstraint :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct PositionIKRequest { pub group_name : std :: string :: String , pub robot_state : moveit_msgs :: msg :: RobotState , pub constraints : moveit_msgs :: msg :: Constraints , pub avoid_collisions : bool , pub ik_link_name : std :: string :: String , pub pose_stamped : geometry_msgs :: msg :: PoseStamped , pub ik_link_names : Vec < std :: string :: String > , pub pose_stamped_vector : Vec < geometry_msgs :: msg :: PoseStamped > , pub timeout : builtin_interfaces :: msg :: Duration } impl WrappedTypesupport for PositionIKRequest { type CStruct = moveit_msgs__msg__PositionIKRequest ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__msg__PositionIKRequest () } } fn create_msg () -> * mut moveit_msgs__msg__PositionIKRequest { unsafe { moveit_msgs__msg__PositionIKRequest__create () } } fn destroy_msg (msg : * mut moveit_msgs__msg__PositionIKRequest) -> () { unsafe { moveit_msgs__msg__PositionIKRequest__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> PositionIKRequest { PositionIKRequest { group_name : msg . group_name . to_str () . to_owned () , robot_state : moveit_msgs :: msg :: RobotState :: from_native (& msg . robot_state) , constraints : moveit_msgs :: msg :: Constraints :: from_native (& msg . constraints) , avoid_collisions : msg . avoid_collisions , ik_link_name : msg . ik_link_name . to_str () . to_owned () , pose_stamped : geometry_msgs :: msg :: PoseStamped :: from_native (& msg . pose_stamped) , ik_link_names : msg . ik_link_names . to_vec () , pose_stamped_vector : { let mut temp = Vec :: with_capacity (msg . pose_stamped_vector . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . pose_stamped_vector . data , msg . pose_stamped_vector . size) } ; for s in slice { temp . push (geometry_msgs :: msg :: PoseStamped :: from_native (s)) ; } temp } , timeout : builtin_interfaces :: msg :: Duration :: from_native (& msg . timeout) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . group_name . assign (& self . group_name) ; self . robot_state . copy_to_native (& mut msg . robot_state) ; self . constraints . copy_to_native (& mut msg . constraints) ; msg . avoid_collisions = self . avoid_collisions ; msg . ik_link_name . assign (& self . ik_link_name) ; self . pose_stamped . copy_to_native (& mut msg . pose_stamped) ; msg . ik_link_names . update (& self . ik_link_names) ; unsafe { geometry_msgs__msg__PoseStamped__Sequence__fini (& mut msg . pose_stamped_vector) ; geometry_msgs__msg__PoseStamped__Sequence__init (& mut msg . pose_stamped_vector , self . pose_stamped_vector . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . pose_stamped_vector . data , msg . pose_stamped_vector . size) ; for (t , s) in slice . iter_mut () . zip (& self . pose_stamped_vector) { s . copy_to_native (t) ; } } self . timeout . copy_to_native (& mut msg . timeout) ; } } impl Default for PositionIKRequest { fn default () -> Self { let msg_native = WrappedNativeMsg :: < PositionIKRequest > :: new () ; PositionIKRequest :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct RobotState { pub joint_state : sensor_msgs :: msg :: JointState , pub multi_dof_joint_state : sensor_msgs :: msg :: MultiDOFJointState , pub attached_collision_objects : Vec < moveit_msgs :: msg :: AttachedCollisionObject > , pub is_diff : bool } impl WrappedTypesupport for RobotState { type CStruct = moveit_msgs__msg__RobotState ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__msg__RobotState () } } fn create_msg () -> * mut moveit_msgs__msg__RobotState { unsafe { moveit_msgs__msg__RobotState__create () } } fn destroy_msg (msg : * mut moveit_msgs__msg__RobotState) -> () { unsafe { moveit_msgs__msg__RobotState__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> RobotState { RobotState { joint_state : sensor_msgs :: msg :: JointState :: from_native (& msg . joint_state) , multi_dof_joint_state : sensor_msgs :: msg :: MultiDOFJointState :: from_native (& msg . multi_dof_joint_state) , attached_collision_objects : { let mut temp = Vec :: with_capacity (msg . attached_collision_objects . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . attached_collision_objects . data , msg . attached_collision_objects . size) } ; for s in slice { temp . push (moveit_msgs :: msg :: AttachedCollisionObject :: from_native (s)) ; } temp } , is_diff : msg . is_diff , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . joint_state . copy_to_native (& mut msg . joint_state) ; self . multi_dof_joint_state . copy_to_native (& mut msg . multi_dof_joint_state) ; unsafe { moveit_msgs__msg__AttachedCollisionObject__Sequence__fini (& mut msg . attached_collision_objects) ; moveit_msgs__msg__AttachedCollisionObject__Sequence__init (& mut msg . attached_collision_objects , self . attached_collision_objects . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . attached_collision_objects . data , msg . attached_collision_objects . size) ; for (t , s) in slice . iter_mut () . zip (& self . attached_collision_objects) { s . copy_to_native (t) ; } } msg . is_diff = self . is_diff ; } } impl Default for RobotState { fn default () -> Self { let msg_native = WrappedNativeMsg :: < RobotState > :: new () ; RobotState :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct RobotTrajectory { pub joint_trajectory : trajectory_msgs :: msg :: JointTrajectory , pub multi_dof_joint_trajectory : trajectory_msgs :: msg :: MultiDOFJointTrajectory } impl WrappedTypesupport for RobotTrajectory { type CStruct = moveit_msgs__msg__RobotTrajectory ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__msg__RobotTrajectory () } } fn create_msg () -> * mut moveit_msgs__msg__RobotTrajectory { unsafe { moveit_msgs__msg__RobotTrajectory__create () } } fn destroy_msg (msg : * mut moveit_msgs__msg__RobotTrajectory) -> () { unsafe { moveit_msgs__msg__RobotTrajectory__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> RobotTrajectory { RobotTrajectory { joint_trajectory : trajectory_msgs :: msg :: JointTrajectory :: from_native (& msg . joint_trajectory) , multi_dof_joint_trajectory : trajectory_msgs :: msg :: MultiDOFJointTrajectory :: from_native (& msg . multi_dof_joint_trajectory) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . joint_trajectory . copy_to_native (& mut msg . joint_trajectory) ; self . multi_dof_joint_trajectory . copy_to_native (& mut msg . multi_dof_joint_trajectory) ; } } impl Default for RobotTrajectory { fn default () -> Self { let msg_native = WrappedNativeMsg :: < RobotTrajectory > :: new () ; RobotTrajectory :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct TrajectoryConstraints { pub constraints : Vec < moveit_msgs :: msg :: Constraints > } impl WrappedTypesupport for TrajectoryConstraints { type CStruct = moveit_msgs__msg__TrajectoryConstraints ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__msg__TrajectoryConstraints () } } fn create_msg () -> * mut moveit_msgs__msg__TrajectoryConstraints { unsafe { moveit_msgs__msg__TrajectoryConstraints__create () } } fn destroy_msg (msg : * mut moveit_msgs__msg__TrajectoryConstraints) -> () { unsafe { moveit_msgs__msg__TrajectoryConstraints__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> TrajectoryConstraints { TrajectoryConstraints { constraints : { let mut temp = Vec :: with_capacity (msg . constraints . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . constraints . data , msg . constraints . size) } ; for s in slice { temp . push (moveit_msgs :: msg :: Constraints :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { unsafe { moveit_msgs__msg__Constraints__Sequence__fini (& mut msg . constraints) ; moveit_msgs__msg__Constraints__Sequence__init (& mut msg . constraints , self . constraints . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . constraints . data , msg . constraints . size) ; for (t , s) in slice . iter_mut () . zip (& self . constraints) { s . copy_to_native (t) ; } } } } impl Default for TrajectoryConstraints { fn default () -> Self { let msg_native = WrappedNativeMsg :: < TrajectoryConstraints > :: new () ; TrajectoryConstraints :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct VisibilityConstraint { pub target_radius : f64 , pub target_pose : geometry_msgs :: msg :: PoseStamped , pub cone_sides : i32 , pub sensor_pose : geometry_msgs :: msg :: PoseStamped , pub max_view_angle : f64 , pub max_range_angle : f64 , pub sensor_view_direction : u8 , pub weight : f64 } impl WrappedTypesupport for VisibilityConstraint { type CStruct = moveit_msgs__msg__VisibilityConstraint ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__msg__VisibilityConstraint () } } fn create_msg () -> * mut moveit_msgs__msg__VisibilityConstraint { unsafe { moveit_msgs__msg__VisibilityConstraint__create () } } fn destroy_msg (msg : * mut moveit_msgs__msg__VisibilityConstraint) -> () { unsafe { moveit_msgs__msg__VisibilityConstraint__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> VisibilityConstraint { VisibilityConstraint { target_radius : msg . target_radius , target_pose : geometry_msgs :: msg :: PoseStamped :: from_native (& msg . target_pose) , cone_sides : msg . cone_sides , sensor_pose : geometry_msgs :: msg :: PoseStamped :: from_native (& msg . sensor_pose) , max_view_angle : msg . max_view_angle , max_range_angle : msg . max_range_angle , sensor_view_direction : msg . sensor_view_direction , weight : msg . weight , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . target_radius = self . target_radius ; self . target_pose . copy_to_native (& mut msg . target_pose) ; msg . cone_sides = self . cone_sides ; self . sensor_pose . copy_to_native (& mut msg . sensor_pose) ; msg . max_view_angle = self . max_view_angle ; msg . max_range_angle = self . max_range_angle ; msg . sensor_view_direction = self . sensor_view_direction ; msg . weight = self . weight ; } } impl Default for VisibilityConstraint { fn default () -> Self { let msg_native = WrappedNativeMsg :: < VisibilityConstraint > :: new () ; VisibilityConstraint :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl VisibilityConstraint { pub const SENSOR_X : _bindgen_ty_960 = moveit_msgs__msg__VisibilityConstraint__SENSOR_X ; pub const SENSOR_Y : _bindgen_ty_959 = moveit_msgs__msg__VisibilityConstraint__SENSOR_Y ; pub const SENSOR_Z : _bindgen_ty_958 = moveit_msgs__msg__VisibilityConstraint__SENSOR_Z ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct WorkspaceParameters { pub header : std_msgs :: msg :: Header , pub min_corner : geometry_msgs :: msg :: Vector3 , pub max_corner : geometry_msgs :: msg :: Vector3 } impl WrappedTypesupport for WorkspaceParameters { type CStruct = moveit_msgs__msg__WorkspaceParameters ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__moveit_msgs__msg__WorkspaceParameters () } } fn create_msg () -> * mut moveit_msgs__msg__WorkspaceParameters { unsafe { moveit_msgs__msg__WorkspaceParameters__create () } } fn destroy_msg (msg : * mut moveit_msgs__msg__WorkspaceParameters) -> () { unsafe { moveit_msgs__msg__WorkspaceParameters__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> WorkspaceParameters { WorkspaceParameters { header : std_msgs :: msg :: Header :: from_native (& msg . header) , min_corner : geometry_msgs :: msg :: Vector3 :: from_native (& msg . min_corner) , max_corner : geometry_msgs :: msg :: Vector3 :: from_native (& msg . max_corner) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; self . min_corner . copy_to_native (& mut msg . min_corner) ; self . max_corner . copy_to_native (& mut msg . max_corner) ; } } impl Default for WorkspaceParameters { fn default () -> Self { let msg_native = WrappedNativeMsg :: < WorkspaceParameters > :: new () ; WorkspaceParameters :: from_native (& msg_native) } } }