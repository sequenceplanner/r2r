pub mod msg { use super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct DoorMode { pub value : u32 } impl WrappedTypesupport for DoorMode { type CStruct = rmf_door_msgs__msg__DoorMode ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_door_msgs__msg__DoorMode () } } fn create_msg () -> * mut rmf_door_msgs__msg__DoorMode { unsafe { rmf_door_msgs__msg__DoorMode__create () } } fn destroy_msg (msg : * mut rmf_door_msgs__msg__DoorMode) -> () { unsafe { rmf_door_msgs__msg__DoorMode__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> DoorMode { DoorMode { value : msg . value , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . value = self . value ; } } impl Default for DoorMode { fn default () -> Self { let msg_native = WrappedNativeMsg :: < DoorMode > :: new () ; DoorMode :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl DoorMode { pub const MODE_CLOSED : _bindgen_ty_1526 = rmf_door_msgs__msg__DoorMode__MODE_CLOSED ; pub const MODE_MOVING : _bindgen_ty_1527 = rmf_door_msgs__msg__DoorMode__MODE_MOVING ; pub const MODE_OFFLINE : _bindgen_ty_1529 = rmf_door_msgs__msg__DoorMode__MODE_OFFLINE ; pub const MODE_OPEN : _bindgen_ty_1528 = rmf_door_msgs__msg__DoorMode__MODE_OPEN ; pub const MODE_UNKNOWN : _bindgen_ty_1530 = rmf_door_msgs__msg__DoorMode__MODE_UNKNOWN ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct DoorRequest { pub request_time : builtin_interfaces :: msg :: Time , pub requester_id : std :: string :: String , pub door_name : std :: string :: String , pub requested_mode : rmf_door_msgs :: msg :: DoorMode } impl WrappedTypesupport for DoorRequest { type CStruct = rmf_door_msgs__msg__DoorRequest ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_door_msgs__msg__DoorRequest () } } fn create_msg () -> * mut rmf_door_msgs__msg__DoorRequest { unsafe { rmf_door_msgs__msg__DoorRequest__create () } } fn destroy_msg (msg : * mut rmf_door_msgs__msg__DoorRequest) -> () { unsafe { rmf_door_msgs__msg__DoorRequest__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> DoorRequest { DoorRequest { request_time : builtin_interfaces :: msg :: Time :: from_native (& msg . request_time) , requester_id : msg . requester_id . to_str () . to_owned () , door_name : msg . door_name . to_str () . to_owned () , requested_mode : rmf_door_msgs :: msg :: DoorMode :: from_native (& msg . requested_mode) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . request_time . copy_to_native (& mut msg . request_time) ; msg . requester_id . assign (& self . requester_id) ; msg . door_name . assign (& self . door_name) ; self . requested_mode . copy_to_native (& mut msg . requested_mode) ; } } impl Default for DoorRequest { fn default () -> Self { let msg_native = WrappedNativeMsg :: < DoorRequest > :: new () ; DoorRequest :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct DoorSessions { pub door_name : std :: string :: String , pub sessions : Vec < rmf_door_msgs :: msg :: Session > } impl WrappedTypesupport for DoorSessions { type CStruct = rmf_door_msgs__msg__DoorSessions ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_door_msgs__msg__DoorSessions () } } fn create_msg () -> * mut rmf_door_msgs__msg__DoorSessions { unsafe { rmf_door_msgs__msg__DoorSessions__create () } } fn destroy_msg (msg : * mut rmf_door_msgs__msg__DoorSessions) -> () { unsafe { rmf_door_msgs__msg__DoorSessions__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> DoorSessions { DoorSessions { door_name : msg . door_name . to_str () . to_owned () , sessions : { let mut temp = Vec :: with_capacity (msg . sessions . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . sessions . data , msg . sessions . size) } ; for s in slice { temp . push (rmf_door_msgs :: msg :: Session :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . door_name . assign (& self . door_name) ; unsafe { rmf_door_msgs__msg__Session__Sequence__fini (& mut msg . sessions) ; rmf_door_msgs__msg__Session__Sequence__init (& mut msg . sessions , self . sessions . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . sessions . data , msg . sessions . size) ; for (t , s) in slice . iter_mut () . zip (& self . sessions) { s . copy_to_native (t) ; } } } } impl Default for DoorSessions { fn default () -> Self { let msg_native = WrappedNativeMsg :: < DoorSessions > :: new () ; DoorSessions :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct DoorState { pub door_time : builtin_interfaces :: msg :: Time , pub door_name : std :: string :: String , pub current_mode : rmf_door_msgs :: msg :: DoorMode } impl WrappedTypesupport for DoorState { type CStruct = rmf_door_msgs__msg__DoorState ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_door_msgs__msg__DoorState () } } fn create_msg () -> * mut rmf_door_msgs__msg__DoorState { unsafe { rmf_door_msgs__msg__DoorState__create () } } fn destroy_msg (msg : * mut rmf_door_msgs__msg__DoorState) -> () { unsafe { rmf_door_msgs__msg__DoorState__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> DoorState { DoorState { door_time : builtin_interfaces :: msg :: Time :: from_native (& msg . door_time) , door_name : msg . door_name . to_str () . to_owned () , current_mode : rmf_door_msgs :: msg :: DoorMode :: from_native (& msg . current_mode) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . door_time . copy_to_native (& mut msg . door_time) ; msg . door_name . assign (& self . door_name) ; self . current_mode . copy_to_native (& mut msg . current_mode) ; } } impl Default for DoorState { fn default () -> Self { let msg_native = WrappedNativeMsg :: < DoorState > :: new () ; DoorState :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Session { pub request_time : builtin_interfaces :: msg :: Time , pub requester_id : std :: string :: String } impl WrappedTypesupport for Session { type CStruct = rmf_door_msgs__msg__Session ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_door_msgs__msg__Session () } } fn create_msg () -> * mut rmf_door_msgs__msg__Session { unsafe { rmf_door_msgs__msg__Session__create () } } fn destroy_msg (msg : * mut rmf_door_msgs__msg__Session) -> () { unsafe { rmf_door_msgs__msg__Session__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Session { Session { request_time : builtin_interfaces :: msg :: Time :: from_native (& msg . request_time) , requester_id : msg . requester_id . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . request_time . copy_to_native (& mut msg . request_time) ; msg . requester_id . assign (& self . requester_id) ; } } impl Default for Session { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Session > :: new () ; Session :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct SupervisorHeartbeat { pub all_sessions : Vec < rmf_door_msgs :: msg :: DoorSessions > } impl WrappedTypesupport for SupervisorHeartbeat { type CStruct = rmf_door_msgs__msg__SupervisorHeartbeat ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_door_msgs__msg__SupervisorHeartbeat () } } fn create_msg () -> * mut rmf_door_msgs__msg__SupervisorHeartbeat { unsafe { rmf_door_msgs__msg__SupervisorHeartbeat__create () } } fn destroy_msg (msg : * mut rmf_door_msgs__msg__SupervisorHeartbeat) -> () { unsafe { rmf_door_msgs__msg__SupervisorHeartbeat__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> SupervisorHeartbeat { SupervisorHeartbeat { all_sessions : { let mut temp = Vec :: with_capacity (msg . all_sessions . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . all_sessions . data , msg . all_sessions . size) } ; for s in slice { temp . push (rmf_door_msgs :: msg :: DoorSessions :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { unsafe { rmf_door_msgs__msg__DoorSessions__Sequence__fini (& mut msg . all_sessions) ; rmf_door_msgs__msg__DoorSessions__Sequence__init (& mut msg . all_sessions , self . all_sessions . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . all_sessions . data , msg . all_sessions . size) ; for (t , s) in slice . iter_mut () . zip (& self . all_sessions) { s . copy_to_native (t) ; } } } } impl Default for SupervisorHeartbeat { fn default () -> Self { let msg_native = WrappedNativeMsg :: < SupervisorHeartbeat > :: new () ; SupervisorHeartbeat :: from_native (& msg_native) } } }