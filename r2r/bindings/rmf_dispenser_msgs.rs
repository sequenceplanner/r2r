pub mod msg { use super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct DispenserRequest { pub time : builtin_interfaces :: msg :: Time , pub request_guid : std :: string :: String , pub target_guid : std :: string :: String , pub transporter_type : std :: string :: String , pub items : Vec < rmf_dispenser_msgs :: msg :: DispenserRequestItem > } impl WrappedTypesupport for DispenserRequest { type CStruct = rmf_dispenser_msgs__msg__DispenserRequest ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_dispenser_msgs__msg__DispenserRequest () } } fn create_msg () -> * mut rmf_dispenser_msgs__msg__DispenserRequest { unsafe { rmf_dispenser_msgs__msg__DispenserRequest__create () } } fn destroy_msg (msg : * mut rmf_dispenser_msgs__msg__DispenserRequest) -> () { unsafe { rmf_dispenser_msgs__msg__DispenserRequest__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> DispenserRequest { DispenserRequest { time : builtin_interfaces :: msg :: Time :: from_native (& msg . time) , request_guid : msg . request_guid . to_str () . to_owned () , target_guid : msg . target_guid . to_str () . to_owned () , transporter_type : msg . transporter_type . to_str () . to_owned () , items : { let mut temp = Vec :: with_capacity (msg . items . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . items . data , msg . items . size) } ; for s in slice { temp . push (rmf_dispenser_msgs :: msg :: DispenserRequestItem :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . time . copy_to_native (& mut msg . time) ; msg . request_guid . assign (& self . request_guid) ; msg . target_guid . assign (& self . target_guid) ; msg . transporter_type . assign (& self . transporter_type) ; unsafe { rmf_dispenser_msgs__msg__DispenserRequestItem__Sequence__fini (& mut msg . items) ; rmf_dispenser_msgs__msg__DispenserRequestItem__Sequence__init (& mut msg . items , self . items . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . items . data , msg . items . size) ; for (t , s) in slice . iter_mut () . zip (& self . items) { s . copy_to_native (t) ; } } } } impl Default for DispenserRequest { fn default () -> Self { let msg_native = WrappedNativeMsg :: < DispenserRequest > :: new () ; DispenserRequest :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct DispenserRequestItem { pub type_guid : std :: string :: String , pub quantity : i32 , pub compartment_name : std :: string :: String } impl WrappedTypesupport for DispenserRequestItem { type CStruct = rmf_dispenser_msgs__msg__DispenserRequestItem ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_dispenser_msgs__msg__DispenserRequestItem () } } fn create_msg () -> * mut rmf_dispenser_msgs__msg__DispenserRequestItem { unsafe { rmf_dispenser_msgs__msg__DispenserRequestItem__create () } } fn destroy_msg (msg : * mut rmf_dispenser_msgs__msg__DispenserRequestItem) -> () { unsafe { rmf_dispenser_msgs__msg__DispenserRequestItem__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> DispenserRequestItem { DispenserRequestItem { type_guid : msg . type_guid . to_str () . to_owned () , quantity : msg . quantity , compartment_name : msg . compartment_name . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . type_guid . assign (& self . type_guid) ; msg . quantity = self . quantity ; msg . compartment_name . assign (& self . compartment_name) ; } } impl Default for DispenserRequestItem { fn default () -> Self { let msg_native = WrappedNativeMsg :: < DispenserRequestItem > :: new () ; DispenserRequestItem :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct DispenserResult { pub time : builtin_interfaces :: msg :: Time , pub request_guid : std :: string :: String , pub source_guid : std :: string :: String , pub status : u8 } impl WrappedTypesupport for DispenserResult { type CStruct = rmf_dispenser_msgs__msg__DispenserResult ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_dispenser_msgs__msg__DispenserResult () } } fn create_msg () -> * mut rmf_dispenser_msgs__msg__DispenserResult { unsafe { rmf_dispenser_msgs__msg__DispenserResult__create () } } fn destroy_msg (msg : * mut rmf_dispenser_msgs__msg__DispenserResult) -> () { unsafe { rmf_dispenser_msgs__msg__DispenserResult__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> DispenserResult { DispenserResult { time : builtin_interfaces :: msg :: Time :: from_native (& msg . time) , request_guid : msg . request_guid . to_str () . to_owned () , source_guid : msg . source_guid . to_str () . to_owned () , status : msg . status , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . time . copy_to_native (& mut msg . time) ; msg . request_guid . assign (& self . request_guid) ; msg . source_guid . assign (& self . source_guid) ; msg . status = self . status ; } } impl Default for DispenserResult { fn default () -> Self { let msg_native = WrappedNativeMsg :: < DispenserResult > :: new () ; DispenserResult :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl DispenserResult { pub const ACKNOWLEDGED : _bindgen_ty_1520 = rmf_dispenser_msgs__msg__DispenserResult__ACKNOWLEDGED ; pub const FAILED : _bindgen_ty_1522 = rmf_dispenser_msgs__msg__DispenserResult__FAILED ; pub const SUCCESS : _bindgen_ty_1521 = rmf_dispenser_msgs__msg__DispenserResult__SUCCESS ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct DispenserState { pub time : builtin_interfaces :: msg :: Time , pub guid : std :: string :: String , pub mode : i32 , pub request_guid_queue : Vec < std :: string :: String > , pub seconds_remaining : f32 } impl WrappedTypesupport for DispenserState { type CStruct = rmf_dispenser_msgs__msg__DispenserState ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rmf_dispenser_msgs__msg__DispenserState () } } fn create_msg () -> * mut rmf_dispenser_msgs__msg__DispenserState { unsafe { rmf_dispenser_msgs__msg__DispenserState__create () } } fn destroy_msg (msg : * mut rmf_dispenser_msgs__msg__DispenserState) -> () { unsafe { rmf_dispenser_msgs__msg__DispenserState__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> DispenserState { DispenserState { time : builtin_interfaces :: msg :: Time :: from_native (& msg . time) , guid : msg . guid . to_str () . to_owned () , mode : msg . mode , request_guid_queue : msg . request_guid_queue . to_vec () , seconds_remaining : msg . seconds_remaining , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . time . copy_to_native (& mut msg . time) ; msg . guid . assign (& self . guid) ; msg . mode = self . mode ; msg . request_guid_queue . update (& self . request_guid_queue) ; msg . seconds_remaining = self . seconds_remaining ; } } impl Default for DispenserState { fn default () -> Self { let msg_native = WrappedNativeMsg :: < DispenserState > :: new () ; DispenserState :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl DispenserState { pub const BUSY : _bindgen_ty_1524 = rmf_dispenser_msgs__msg__DispenserState__BUSY ; pub const IDLE : _bindgen_ty_1523 = rmf_dispenser_msgs__msg__DispenserState__IDLE ; pub const OFFLINE : _bindgen_ty_1525 = rmf_dispenser_msgs__msg__DispenserState__OFFLINE ; } }