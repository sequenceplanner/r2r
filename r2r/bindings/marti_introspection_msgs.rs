pub mod msg { use super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct NodeInfo { pub name : std :: string :: String , pub location : std :: string :: String , pub nodelet_manager : std :: string :: String , pub description : std :: string :: String , pub topics : Vec < marti_introspection_msgs :: msg :: TopicInfo > , pub parameters : Vec < marti_introspection_msgs :: msg :: ParamInfo > , pub services : Vec < marti_introspection_msgs :: msg :: ServiceInfo > } impl WrappedTypesupport for NodeInfo { type CStruct = marti_introspection_msgs__msg__NodeInfo ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__marti_introspection_msgs__msg__NodeInfo () } } fn create_msg () -> * mut marti_introspection_msgs__msg__NodeInfo { unsafe { marti_introspection_msgs__msg__NodeInfo__create () } } fn destroy_msg (msg : * mut marti_introspection_msgs__msg__NodeInfo) -> () { unsafe { marti_introspection_msgs__msg__NodeInfo__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> NodeInfo { NodeInfo { name : msg . name . to_str () . to_owned () , location : msg . location . to_str () . to_owned () , nodelet_manager : msg . nodelet_manager . to_str () . to_owned () , description : msg . description . to_str () . to_owned () , topics : { let mut temp = Vec :: with_capacity (msg . topics . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . topics . data , msg . topics . size) } ; for s in slice { temp . push (marti_introspection_msgs :: msg :: TopicInfo :: from_native (s)) ; } temp } , parameters : { let mut temp = Vec :: with_capacity (msg . parameters . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . parameters . data , msg . parameters . size) } ; for s in slice { temp . push (marti_introspection_msgs :: msg :: ParamInfo :: from_native (s)) ; } temp } , services : { let mut temp = Vec :: with_capacity (msg . services . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . services . data , msg . services . size) } ; for s in slice { temp . push (marti_introspection_msgs :: msg :: ServiceInfo :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . name . assign (& self . name) ; msg . location . assign (& self . location) ; msg . nodelet_manager . assign (& self . nodelet_manager) ; msg . description . assign (& self . description) ; unsafe { marti_introspection_msgs__msg__TopicInfo__Sequence__fini (& mut msg . topics) ; marti_introspection_msgs__msg__TopicInfo__Sequence__init (& mut msg . topics , self . topics . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . topics . data , msg . topics . size) ; for (t , s) in slice . iter_mut () . zip (& self . topics) { s . copy_to_native (t) ; } } unsafe { marti_introspection_msgs__msg__ParamInfo__Sequence__fini (& mut msg . parameters) ; marti_introspection_msgs__msg__ParamInfo__Sequence__init (& mut msg . parameters , self . parameters . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . parameters . data , msg . parameters . size) ; for (t , s) in slice . iter_mut () . zip (& self . parameters) { s . copy_to_native (t) ; } } unsafe { marti_introspection_msgs__msg__ServiceInfo__Sequence__fini (& mut msg . services) ; marti_introspection_msgs__msg__ServiceInfo__Sequence__init (& mut msg . services , self . services . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . services . data , msg . services . size) ; for (t , s) in slice . iter_mut () . zip (& self . services) { s . copy_to_native (t) ; } } } } impl Default for NodeInfo { fn default () -> Self { let msg_native = WrappedNativeMsg :: < NodeInfo > :: new () ; NodeInfo :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ParamInfo { pub name : std :: string :: String , pub resolved_name : std :: string :: String , pub description : std :: string :: String , pub group : std :: string :: String , # [serde (rename = "type")] pub type_ : u8 , pub dynamic : bool , pub default_int : i32 , pub default_float : f32 , pub default_double : f64 , pub default_string : std :: string :: String , pub default_bool : bool , pub max_value : f64 , pub min_value : f64 } impl WrappedTypesupport for ParamInfo { type CStruct = marti_introspection_msgs__msg__ParamInfo ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__marti_introspection_msgs__msg__ParamInfo () } } fn create_msg () -> * mut marti_introspection_msgs__msg__ParamInfo { unsafe { marti_introspection_msgs__msg__ParamInfo__create () } } fn destroy_msg (msg : * mut marti_introspection_msgs__msg__ParamInfo) -> () { unsafe { marti_introspection_msgs__msg__ParamInfo__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ParamInfo { ParamInfo { name : msg . name . to_str () . to_owned () , resolved_name : msg . resolved_name . to_str () . to_owned () , description : msg . description . to_str () . to_owned () , group : msg . group . to_str () . to_owned () , type_ : msg . type_ , dynamic : msg . dynamic , default_int : msg . default_int , default_float : msg . default_float , default_double : msg . default_double , default_string : msg . default_string . to_str () . to_owned () , default_bool : msg . default_bool , max_value : msg . max_value , min_value : msg . min_value , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . name . assign (& self . name) ; msg . resolved_name . assign (& self . resolved_name) ; msg . description . assign (& self . description) ; msg . group . assign (& self . group) ; msg . type_ = self . type_ ; msg . dynamic = self . dynamic ; msg . default_int = self . default_int ; msg . default_float = self . default_float ; msg . default_double = self . default_double ; msg . default_string . assign (& self . default_string) ; msg . default_bool = self . default_bool ; msg . max_value = self . max_value ; msg . min_value = self . min_value ; } } impl Default for ParamInfo { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ParamInfo > :: new () ; ParamInfo :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl ParamInfo { pub const TYPE_BOOL : _bindgen_ty_445 = marti_introspection_msgs__msg__ParamInfo__TYPE_BOOL ; pub const TYPE_DOUBLE : _bindgen_ty_441 = marti_introspection_msgs__msg__ParamInfo__TYPE_DOUBLE ; pub const TYPE_FLOAT : _bindgen_ty_444 = marti_introspection_msgs__msg__ParamInfo__TYPE_FLOAT ; pub const TYPE_INT : _bindgen_ty_443 = marti_introspection_msgs__msg__ParamInfo__TYPE_INT ; pub const TYPE_STRING : _bindgen_ty_442 = marti_introspection_msgs__msg__ParamInfo__TYPE_STRING ; pub const TYPE_XMLRPC : _bindgen_ty_440 = marti_introspection_msgs__msg__ParamInfo__TYPE_XMLRPC ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ServiceInfo { pub name : std :: string :: String , pub resolved_name : std :: string :: String , pub description : std :: string :: String , pub group : std :: string :: String , pub message_type : std :: string :: String , pub server : bool , pub topic_service : bool } impl WrappedTypesupport for ServiceInfo { type CStruct = marti_introspection_msgs__msg__ServiceInfo ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__marti_introspection_msgs__msg__ServiceInfo () } } fn create_msg () -> * mut marti_introspection_msgs__msg__ServiceInfo { unsafe { marti_introspection_msgs__msg__ServiceInfo__create () } } fn destroy_msg (msg : * mut marti_introspection_msgs__msg__ServiceInfo) -> () { unsafe { marti_introspection_msgs__msg__ServiceInfo__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ServiceInfo { ServiceInfo { name : msg . name . to_str () . to_owned () , resolved_name : msg . resolved_name . to_str () . to_owned () , description : msg . description . to_str () . to_owned () , group : msg . group . to_str () . to_owned () , message_type : msg . message_type . to_str () . to_owned () , server : msg . server , topic_service : msg . topic_service , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . name . assign (& self . name) ; msg . resolved_name . assign (& self . resolved_name) ; msg . description . assign (& self . description) ; msg . group . assign (& self . group) ; msg . message_type . assign (& self . message_type) ; msg . server = self . server ; msg . topic_service = self . topic_service ; } } impl Default for ServiceInfo { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ServiceInfo > :: new () ; ServiceInfo :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct TopicInfo { pub name : std :: string :: String , pub resolved_name : std :: string :: String , pub description : std :: string :: String , pub group : std :: string :: String , pub message_type : std :: string :: String , pub advertised : bool } impl WrappedTypesupport for TopicInfo { type CStruct = marti_introspection_msgs__msg__TopicInfo ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__marti_introspection_msgs__msg__TopicInfo () } } fn create_msg () -> * mut marti_introspection_msgs__msg__TopicInfo { unsafe { marti_introspection_msgs__msg__TopicInfo__create () } } fn destroy_msg (msg : * mut marti_introspection_msgs__msg__TopicInfo) -> () { unsafe { marti_introspection_msgs__msg__TopicInfo__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> TopicInfo { TopicInfo { name : msg . name . to_str () . to_owned () , resolved_name : msg . resolved_name . to_str () . to_owned () , description : msg . description . to_str () . to_owned () , group : msg . group . to_str () . to_owned () , message_type : msg . message_type . to_str () . to_owned () , advertised : msg . advertised , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . name . assign (& self . name) ; msg . resolved_name . assign (& self . resolved_name) ; msg . description . assign (& self . description) ; msg . group . assign (& self . group) ; msg . message_type . assign (& self . message_type) ; msg . advertised = self . advertised ; } } impl Default for TopicInfo { fn default () -> Self { let msg_native = WrappedNativeMsg :: < TopicInfo > :: new () ; TopicInfo :: from_native (& msg_native) } } }