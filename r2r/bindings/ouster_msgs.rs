pub mod srv { # [allow (non_snake_case)] pub mod GetMetadata { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__ouster_msgs__srv__GetMetadata () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { } impl WrappedTypesupport for Request { type CStruct = ouster_msgs__srv__GetMetadata_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ouster_msgs__srv__GetMetadata_Request () } } fn create_msg () -> * mut ouster_msgs__srv__GetMetadata_Request { unsafe { ouster_msgs__srv__GetMetadata_Request__create () } } fn destroy_msg (msg : * mut ouster_msgs__srv__GetMetadata_Request) -> () { unsafe { ouster_msgs__srv__GetMetadata_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub metadata : ouster_msgs :: msg :: Metadata } impl WrappedTypesupport for Response { type CStruct = ouster_msgs__srv__GetMetadata_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ouster_msgs__srv__GetMetadata_Response () } } fn create_msg () -> * mut ouster_msgs__srv__GetMetadata_Response { unsafe { ouster_msgs__srv__GetMetadata_Response__create () } } fn destroy_msg (msg : * mut ouster_msgs__srv__GetMetadata_Response) -> () { unsafe { ouster_msgs__srv__GetMetadata_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { metadata : ouster_msgs :: msg :: Metadata :: from_native (& msg . metadata) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . metadata . copy_to_native (& mut msg . metadata) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } } pub mod msg { use super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Metadata { pub hostname : std :: string :: String , pub lidar_mode : std :: string :: String , pub timestamp_mode : std :: string :: String , pub beam_azimuth_angles : Vec < f64 > , pub beam_altitude_angles : Vec < f64 > , pub imu_to_sensor_transform : Vec < f64 > , pub lidar_to_sensor_transform : Vec < f64 > , pub serial_no : std :: string :: String , pub firmware_rev : std :: string :: String , pub imu_port : i8 , pub lidar_port : i8 } impl WrappedTypesupport for Metadata { type CStruct = ouster_msgs__msg__Metadata ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ouster_msgs__msg__Metadata () } } fn create_msg () -> * mut ouster_msgs__msg__Metadata { unsafe { ouster_msgs__msg__Metadata__create () } } fn destroy_msg (msg : * mut ouster_msgs__msg__Metadata) -> () { unsafe { ouster_msgs__msg__Metadata__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Metadata { Metadata { hostname : msg . hostname . to_str () . to_owned () , lidar_mode : msg . lidar_mode . to_str () . to_owned () , timestamp_mode : msg . timestamp_mode . to_str () . to_owned () , beam_azimuth_angles : msg . beam_azimuth_angles . to_vec () , beam_altitude_angles : msg . beam_altitude_angles . to_vec () , imu_to_sensor_transform : msg . imu_to_sensor_transform . to_vec () , lidar_to_sensor_transform : msg . lidar_to_sensor_transform . to_vec () , serial_no : msg . serial_no . to_str () . to_owned () , firmware_rev : msg . firmware_rev . to_str () . to_owned () , imu_port : msg . imu_port , lidar_port : msg . lidar_port , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . hostname . assign (& self . hostname) ; msg . lidar_mode . assign (& self . lidar_mode) ; msg . timestamp_mode . assign (& self . timestamp_mode) ; msg . beam_azimuth_angles . update (& self . beam_azimuth_angles) ; msg . beam_altitude_angles . update (& self . beam_altitude_angles) ; msg . imu_to_sensor_transform . update (& self . imu_to_sensor_transform) ; msg . lidar_to_sensor_transform . update (& self . lidar_to_sensor_transform) ; msg . serial_no . assign (& self . serial_no) ; msg . firmware_rev . assign (& self . firmware_rev) ; msg . imu_port = self . imu_port ; msg . lidar_port = self . lidar_port ; } } impl Default for Metadata { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Metadata > :: new () ; Metadata :: from_native (& msg_native) } } }