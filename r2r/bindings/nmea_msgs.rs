pub mod msg { use super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Gpgga { pub header : std_msgs :: msg :: Header , pub message_id : std :: string :: String , pub utc_seconds : f64 , pub lat : f64 , pub lon : f64 , pub lat_dir : std :: string :: String , pub lon_dir : std :: string :: String , pub gps_qual : u32 , pub num_sats : u32 , pub hdop : f32 , pub alt : f32 , pub altitude_units : std :: string :: String , pub undulation : f32 , pub undulation_units : std :: string :: String , pub diff_age : u32 , pub station_id : std :: string :: String } impl WrappedTypesupport for Gpgga { type CStruct = nmea_msgs__msg__Gpgga ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__nmea_msgs__msg__Gpgga () } } fn create_msg () -> * mut nmea_msgs__msg__Gpgga { unsafe { nmea_msgs__msg__Gpgga__create () } } fn destroy_msg (msg : * mut nmea_msgs__msg__Gpgga) -> () { unsafe { nmea_msgs__msg__Gpgga__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Gpgga { Gpgga { header : std_msgs :: msg :: Header :: from_native (& msg . header) , message_id : msg . message_id . to_str () . to_owned () , utc_seconds : msg . utc_seconds , lat : msg . lat , lon : msg . lon , lat_dir : msg . lat_dir . to_str () . to_owned () , lon_dir : msg . lon_dir . to_str () . to_owned () , gps_qual : msg . gps_qual , num_sats : msg . num_sats , hdop : msg . hdop , alt : msg . alt , altitude_units : msg . altitude_units . to_str () . to_owned () , undulation : msg . undulation , undulation_units : msg . undulation_units . to_str () . to_owned () , diff_age : msg . diff_age , station_id : msg . station_id . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . message_id . assign (& self . message_id) ; msg . utc_seconds = self . utc_seconds ; msg . lat = self . lat ; msg . lon = self . lon ; msg . lat_dir . assign (& self . lat_dir) ; msg . lon_dir . assign (& self . lon_dir) ; msg . gps_qual = self . gps_qual ; msg . num_sats = self . num_sats ; msg . hdop = self . hdop ; msg . alt = self . alt ; msg . altitude_units . assign (& self . altitude_units) ; msg . undulation = self . undulation ; msg . undulation_units . assign (& self . undulation_units) ; msg . diff_age = self . diff_age ; msg . station_id . assign (& self . station_id) ; } } impl Default for Gpgga { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Gpgga > :: new () ; Gpgga :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Gpgsa { pub header : std_msgs :: msg :: Header , pub message_id : std :: string :: String , pub auto_manual_mode : std :: string :: String , pub fix_mode : u8 , pub sv_ids : Vec < u8 > , pub pdop : f32 , pub hdop : f32 , pub vdop : f32 } impl WrappedTypesupport for Gpgsa { type CStruct = nmea_msgs__msg__Gpgsa ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__nmea_msgs__msg__Gpgsa () } } fn create_msg () -> * mut nmea_msgs__msg__Gpgsa { unsafe { nmea_msgs__msg__Gpgsa__create () } } fn destroy_msg (msg : * mut nmea_msgs__msg__Gpgsa) -> () { unsafe { nmea_msgs__msg__Gpgsa__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Gpgsa { Gpgsa { header : std_msgs :: msg :: Header :: from_native (& msg . header) , message_id : msg . message_id . to_str () . to_owned () , auto_manual_mode : msg . auto_manual_mode . to_str () . to_owned () , fix_mode : msg . fix_mode , sv_ids : msg . sv_ids . to_vec () , pdop : msg . pdop , hdop : msg . hdop , vdop : msg . vdop , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . message_id . assign (& self . message_id) ; msg . auto_manual_mode . assign (& self . auto_manual_mode) ; msg . fix_mode = self . fix_mode ; msg . sv_ids . update (& self . sv_ids) ; msg . pdop = self . pdop ; msg . hdop = self . hdop ; msg . vdop = self . vdop ; } } impl Default for Gpgsa { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Gpgsa > :: new () ; Gpgsa :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Gpgsv { pub header : std_msgs :: msg :: Header , pub message_id : std :: string :: String , pub n_msgs : u8 , pub msg_number : u8 , pub n_satellites : u8 , pub satellites : Vec < nmea_msgs :: msg :: GpgsvSatellite > } impl WrappedTypesupport for Gpgsv { type CStruct = nmea_msgs__msg__Gpgsv ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__nmea_msgs__msg__Gpgsv () } } fn create_msg () -> * mut nmea_msgs__msg__Gpgsv { unsafe { nmea_msgs__msg__Gpgsv__create () } } fn destroy_msg (msg : * mut nmea_msgs__msg__Gpgsv) -> () { unsafe { nmea_msgs__msg__Gpgsv__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Gpgsv { Gpgsv { header : std_msgs :: msg :: Header :: from_native (& msg . header) , message_id : msg . message_id . to_str () . to_owned () , n_msgs : msg . n_msgs , msg_number : msg . msg_number , n_satellites : msg . n_satellites , satellites : { let mut temp = Vec :: with_capacity (msg . satellites . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . satellites . data , msg . satellites . size) } ; for s in slice { temp . push (nmea_msgs :: msg :: GpgsvSatellite :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . message_id . assign (& self . message_id) ; msg . n_msgs = self . n_msgs ; msg . msg_number = self . msg_number ; msg . n_satellites = self . n_satellites ; unsafe { nmea_msgs__msg__GpgsvSatellite__Sequence__fini (& mut msg . satellites) ; nmea_msgs__msg__GpgsvSatellite__Sequence__init (& mut msg . satellites , self . satellites . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . satellites . data , msg . satellites . size) ; for (t , s) in slice . iter_mut () . zip (& self . satellites) { s . copy_to_native (t) ; } } } } impl Default for Gpgsv { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Gpgsv > :: new () ; Gpgsv :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct GpgsvSatellite { pub prn : u8 , pub elevation : u8 , pub azimuth : u16 , pub snr : i8 } impl WrappedTypesupport for GpgsvSatellite { type CStruct = nmea_msgs__msg__GpgsvSatellite ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__nmea_msgs__msg__GpgsvSatellite () } } fn create_msg () -> * mut nmea_msgs__msg__GpgsvSatellite { unsafe { nmea_msgs__msg__GpgsvSatellite__create () } } fn destroy_msg (msg : * mut nmea_msgs__msg__GpgsvSatellite) -> () { unsafe { nmea_msgs__msg__GpgsvSatellite__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> GpgsvSatellite { GpgsvSatellite { prn : msg . prn , elevation : msg . elevation , azimuth : msg . azimuth , snr : msg . snr , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . prn = self . prn ; msg . elevation = self . elevation ; msg . azimuth = self . azimuth ; msg . snr = self . snr ; } } impl Default for GpgsvSatellite { fn default () -> Self { let msg_native = WrappedNativeMsg :: < GpgsvSatellite > :: new () ; GpgsvSatellite :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Gprmc { pub header : std_msgs :: msg :: Header , pub message_id : std :: string :: String , pub utc_seconds : f64 , pub position_status : std :: string :: String , pub lat : f64 , pub lon : f64 , pub lat_dir : std :: string :: String , pub lon_dir : std :: string :: String , pub speed : f32 , pub track : f32 , pub date : std :: string :: String , pub mag_var : f32 , pub mag_var_direction : std :: string :: String , pub mode_indicator : std :: string :: String } impl WrappedTypesupport for Gprmc { type CStruct = nmea_msgs__msg__Gprmc ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__nmea_msgs__msg__Gprmc () } } fn create_msg () -> * mut nmea_msgs__msg__Gprmc { unsafe { nmea_msgs__msg__Gprmc__create () } } fn destroy_msg (msg : * mut nmea_msgs__msg__Gprmc) -> () { unsafe { nmea_msgs__msg__Gprmc__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Gprmc { Gprmc { header : std_msgs :: msg :: Header :: from_native (& msg . header) , message_id : msg . message_id . to_str () . to_owned () , utc_seconds : msg . utc_seconds , position_status : msg . position_status . to_str () . to_owned () , lat : msg . lat , lon : msg . lon , lat_dir : msg . lat_dir . to_str () . to_owned () , lon_dir : msg . lon_dir . to_str () . to_owned () , speed : msg . speed , track : msg . track , date : msg . date . to_str () . to_owned () , mag_var : msg . mag_var , mag_var_direction : msg . mag_var_direction . to_str () . to_owned () , mode_indicator : msg . mode_indicator . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . message_id . assign (& self . message_id) ; msg . utc_seconds = self . utc_seconds ; msg . position_status . assign (& self . position_status) ; msg . lat = self . lat ; msg . lon = self . lon ; msg . lat_dir . assign (& self . lat_dir) ; msg . lon_dir . assign (& self . lon_dir) ; msg . speed = self . speed ; msg . track = self . track ; msg . date . assign (& self . date) ; msg . mag_var = self . mag_var ; msg . mag_var_direction . assign (& self . mag_var_direction) ; msg . mode_indicator . assign (& self . mode_indicator) ; } } impl Default for Gprmc { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Gprmc > :: new () ; Gprmc :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Sentence { pub header : std_msgs :: msg :: Header , pub sentence : std :: string :: String } impl WrappedTypesupport for Sentence { type CStruct = nmea_msgs__msg__Sentence ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__nmea_msgs__msg__Sentence () } } fn create_msg () -> * mut nmea_msgs__msg__Sentence { unsafe { nmea_msgs__msg__Sentence__create () } } fn destroy_msg (msg : * mut nmea_msgs__msg__Sentence) -> () { unsafe { nmea_msgs__msg__Sentence__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Sentence { Sentence { header : std_msgs :: msg :: Header :: from_native (& msg . header) , sentence : msg . sentence . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . sentence . assign (& self . sentence) ; } } impl Default for Sentence { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Sentence > :: new () ; Sentence :: from_native (& msg_native) } } }