pub mod msg { use super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Box { pub x : f64 , pub y : f64 , pub z : f64 } impl WrappedTypesupport for Box { type CStruct = rc_reason_msgs__msg__Box ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rc_reason_msgs__msg__Box () } } fn create_msg () -> * mut rc_reason_msgs__msg__Box { unsafe { rc_reason_msgs__msg__Box__create () } } fn destroy_msg (msg : * mut rc_reason_msgs__msg__Box) -> () { unsafe { rc_reason_msgs__msg__Box__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Box { Box { x : msg . x , y : msg . y , z : msg . z , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . x = self . x ; msg . y = self . y ; msg . z = self . z ; } } impl Default for Box { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Box > :: new () ; Box :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct CellFillingLevel { pub cell_size : rc_reason_msgs :: msg :: Rectangle , pub cell_position : geometry_msgs :: msg :: Point , pub level_in_percent : rc_reason_msgs :: msg :: RangeValue , pub level_free_in_meters : rc_reason_msgs :: msg :: RangeValue , pub coverage : f64 } impl WrappedTypesupport for CellFillingLevel { type CStruct = rc_reason_msgs__msg__CellFillingLevel ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rc_reason_msgs__msg__CellFillingLevel () } } fn create_msg () -> * mut rc_reason_msgs__msg__CellFillingLevel { unsafe { rc_reason_msgs__msg__CellFillingLevel__create () } } fn destroy_msg (msg : * mut rc_reason_msgs__msg__CellFillingLevel) -> () { unsafe { rc_reason_msgs__msg__CellFillingLevel__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> CellFillingLevel { CellFillingLevel { cell_size : rc_reason_msgs :: msg :: Rectangle :: from_native (& msg . cell_size) , cell_position : geometry_msgs :: msg :: Point :: from_native (& msg . cell_position) , level_in_percent : rc_reason_msgs :: msg :: RangeValue :: from_native (& msg . level_in_percent) , level_free_in_meters : rc_reason_msgs :: msg :: RangeValue :: from_native (& msg . level_free_in_meters) , coverage : msg . coverage , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . cell_size . copy_to_native (& mut msg . cell_size) ; self . cell_position . copy_to_native (& mut msg . cell_position) ; self . level_in_percent . copy_to_native (& mut msg . level_in_percent) ; self . level_free_in_meters . copy_to_native (& mut msg . level_free_in_meters) ; msg . coverage = self . coverage ; } } impl Default for CellFillingLevel { fn default () -> Self { let msg_native = WrappedNativeMsg :: < CellFillingLevel > :: new () ; CellFillingLevel :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct CollisionDetection { pub gripper_id : std :: string :: String , pub pre_grasp_offset : geometry_msgs :: msg :: Point } impl WrappedTypesupport for CollisionDetection { type CStruct = rc_reason_msgs__msg__CollisionDetection ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rc_reason_msgs__msg__CollisionDetection () } } fn create_msg () -> * mut rc_reason_msgs__msg__CollisionDetection { unsafe { rc_reason_msgs__msg__CollisionDetection__create () } } fn destroy_msg (msg : * mut rc_reason_msgs__msg__CollisionDetection) -> () { unsafe { rc_reason_msgs__msg__CollisionDetection__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> CollisionDetection { CollisionDetection { gripper_id : msg . gripper_id . to_str () . to_owned () , pre_grasp_offset : geometry_msgs :: msg :: Point :: from_native (& msg . pre_grasp_offset) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . gripper_id . assign (& self . gripper_id) ; self . pre_grasp_offset . copy_to_native (& mut msg . pre_grasp_offset) ; } } impl Default for CollisionDetection { fn default () -> Self { let msg_native = WrappedNativeMsg :: < CollisionDetection > :: new () ; CollisionDetection :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Compartment { pub pose : geometry_msgs :: msg :: Pose , # [serde (rename = "box")] pub box_ : rc_reason_msgs :: msg :: Box } impl WrappedTypesupport for Compartment { type CStruct = rc_reason_msgs__msg__Compartment ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rc_reason_msgs__msg__Compartment () } } fn create_msg () -> * mut rc_reason_msgs__msg__Compartment { unsafe { rc_reason_msgs__msg__Compartment__create () } } fn destroy_msg (msg : * mut rc_reason_msgs__msg__Compartment) -> () { unsafe { rc_reason_msgs__msg__Compartment__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Compartment { Compartment { pose : geometry_msgs :: msg :: Pose :: from_native (& msg . pose) , box_ : rc_reason_msgs :: msg :: Box :: from_native (& msg . box_) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . pose . copy_to_native (& mut msg . pose) ; self . box_ . copy_to_native (& mut msg . box_) ; } } impl Default for Compartment { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Compartment > :: new () ; Compartment :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct DetectedTag { pub header : std_msgs :: msg :: Header , pub tag : rc_reason_msgs :: msg :: Tag , pub pose : geometry_msgs :: msg :: PoseStamped , pub instance_id : std :: string :: String } impl WrappedTypesupport for DetectedTag { type CStruct = rc_reason_msgs__msg__DetectedTag ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rc_reason_msgs__msg__DetectedTag () } } fn create_msg () -> * mut rc_reason_msgs__msg__DetectedTag { unsafe { rc_reason_msgs__msg__DetectedTag__create () } } fn destroy_msg (msg : * mut rc_reason_msgs__msg__DetectedTag) -> () { unsafe { rc_reason_msgs__msg__DetectedTag__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> DetectedTag { DetectedTag { header : std_msgs :: msg :: Header :: from_native (& msg . header) , tag : rc_reason_msgs :: msg :: Tag :: from_native (& msg . tag) , pose : geometry_msgs :: msg :: PoseStamped :: from_native (& msg . pose) , instance_id : msg . instance_id . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; self . tag . copy_to_native (& mut msg . tag) ; self . pose . copy_to_native (& mut msg . pose) ; msg . instance_id . assign (& self . instance_id) ; } } impl Default for DetectedTag { fn default () -> Self { let msg_native = WrappedNativeMsg :: < DetectedTag > :: new () ; DetectedTag :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Grasp { pub id : std :: string :: String , pub uuid : std :: string :: String , pub match_uuid : std :: string :: String , pub pose : geometry_msgs :: msg :: PoseStamped } impl WrappedTypesupport for Grasp { type CStruct = rc_reason_msgs__msg__Grasp ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rc_reason_msgs__msg__Grasp () } } fn create_msg () -> * mut rc_reason_msgs__msg__Grasp { unsafe { rc_reason_msgs__msg__Grasp__create () } } fn destroy_msg (msg : * mut rc_reason_msgs__msg__Grasp) -> () { unsafe { rc_reason_msgs__msg__Grasp__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Grasp { Grasp { id : msg . id . to_str () . to_owned () , uuid : msg . uuid . to_str () . to_owned () , match_uuid : msg . match_uuid . to_str () . to_owned () , pose : geometry_msgs :: msg :: PoseStamped :: from_native (& msg . pose) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . id . assign (& self . id) ; msg . uuid . assign (& self . uuid) ; msg . match_uuid . assign (& self . match_uuid) ; self . pose . copy_to_native (& mut msg . pose) ; } } impl Default for Grasp { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Grasp > :: new () ; Grasp :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct GridSize { pub x : u32 , pub y : u32 } impl WrappedTypesupport for GridSize { type CStruct = rc_reason_msgs__msg__GridSize ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rc_reason_msgs__msg__GridSize () } } fn create_msg () -> * mut rc_reason_msgs__msg__GridSize { unsafe { rc_reason_msgs__msg__GridSize__create () } } fn destroy_msg (msg : * mut rc_reason_msgs__msg__GridSize) -> () { unsafe { rc_reason_msgs__msg__GridSize__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> GridSize { GridSize { x : msg . x , y : msg . y , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . x = self . x ; msg . y = self . y ; } } impl Default for GridSize { fn default () -> Self { let msg_native = WrappedNativeMsg :: < GridSize > :: new () ; GridSize :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Item { pub uuid : std :: string :: String , pub grasp_uuids : Vec < std :: string :: String > , # [serde (rename = "type")] pub type_ : std :: string :: String , pub rectangle : rc_reason_msgs :: msg :: Rectangle , pub pose : geometry_msgs :: msg :: PoseStamped } impl WrappedTypesupport for Item { type CStruct = rc_reason_msgs__msg__Item ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rc_reason_msgs__msg__Item () } } fn create_msg () -> * mut rc_reason_msgs__msg__Item { unsafe { rc_reason_msgs__msg__Item__create () } } fn destroy_msg (msg : * mut rc_reason_msgs__msg__Item) -> () { unsafe { rc_reason_msgs__msg__Item__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Item { Item { uuid : msg . uuid . to_str () . to_owned () , grasp_uuids : msg . grasp_uuids . to_vec () , type_ : msg . type_ . to_str () . to_owned () , rectangle : rc_reason_msgs :: msg :: Rectangle :: from_native (& msg . rectangle) , pose : geometry_msgs :: msg :: PoseStamped :: from_native (& msg . pose) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . uuid . assign (& self . uuid) ; msg . grasp_uuids . update (& self . grasp_uuids) ; msg . type_ . assign (& self . type_) ; self . rectangle . copy_to_native (& mut msg . rectangle) ; self . pose . copy_to_native (& mut msg . pose) ; } } impl Default for Item { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Item > :: new () ; Item :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl Item { pub const RECTANGLE : & [u8 ; 10usize] = rc_reason_msgs__msg__Item__RECTANGLE ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ItemModel { # [serde (rename = "type")] pub type_ : std :: string :: String , pub unknown : rc_reason_msgs :: msg :: RangeBox , pub rectangle : rc_reason_msgs :: msg :: RangeRectangle } impl WrappedTypesupport for ItemModel { type CStruct = rc_reason_msgs__msg__ItemModel ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rc_reason_msgs__msg__ItemModel () } } fn create_msg () -> * mut rc_reason_msgs__msg__ItemModel { unsafe { rc_reason_msgs__msg__ItemModel__create () } } fn destroy_msg (msg : * mut rc_reason_msgs__msg__ItemModel) -> () { unsafe { rc_reason_msgs__msg__ItemModel__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ItemModel { ItemModel { type_ : msg . type_ . to_str () . to_owned () , unknown : rc_reason_msgs :: msg :: RangeBox :: from_native (& msg . unknown) , rectangle : rc_reason_msgs :: msg :: RangeRectangle :: from_native (& msg . rectangle) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . type_ . assign (& self . type_) ; self . unknown . copy_to_native (& mut msg . unknown) ; self . rectangle . copy_to_native (& mut msg . rectangle) ; } } impl Default for ItemModel { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ItemModel > :: new () ; ItemModel :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl ItemModel { pub const RECTANGLE : & [u8 ; 10usize] = rc_reason_msgs__msg__ItemModel__RECTANGLE ; pub const UNKNOWN : & [u8 ; 8usize] = rc_reason_msgs__msg__ItemModel__UNKNOWN ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct LoadCarrier { pub id : std :: string :: String , # [serde (rename = "type")] pub type_ : std :: string :: String , pub outer_dimensions : rc_reason_msgs :: msg :: Box , pub inner_dimensions : rc_reason_msgs :: msg :: Box , pub rim_thickness : rc_reason_msgs :: msg :: Rectangle , pub rim_step_height : f64 , pub rim_ledge : rc_reason_msgs :: msg :: Rectangle , pub pose : geometry_msgs :: msg :: PoseStamped , pub overfilled : bool } impl WrappedTypesupport for LoadCarrier { type CStruct = rc_reason_msgs__msg__LoadCarrier ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rc_reason_msgs__msg__LoadCarrier () } } fn create_msg () -> * mut rc_reason_msgs__msg__LoadCarrier { unsafe { rc_reason_msgs__msg__LoadCarrier__create () } } fn destroy_msg (msg : * mut rc_reason_msgs__msg__LoadCarrier) -> () { unsafe { rc_reason_msgs__msg__LoadCarrier__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> LoadCarrier { LoadCarrier { id : msg . id . to_str () . to_owned () , type_ : msg . type_ . to_str () . to_owned () , outer_dimensions : rc_reason_msgs :: msg :: Box :: from_native (& msg . outer_dimensions) , inner_dimensions : rc_reason_msgs :: msg :: Box :: from_native (& msg . inner_dimensions) , rim_thickness : rc_reason_msgs :: msg :: Rectangle :: from_native (& msg . rim_thickness) , rim_step_height : msg . rim_step_height , rim_ledge : rc_reason_msgs :: msg :: Rectangle :: from_native (& msg . rim_ledge) , pose : geometry_msgs :: msg :: PoseStamped :: from_native (& msg . pose) , overfilled : msg . overfilled , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . id . assign (& self . id) ; msg . type_ . assign (& self . type_) ; self . outer_dimensions . copy_to_native (& mut msg . outer_dimensions) ; self . inner_dimensions . copy_to_native (& mut msg . inner_dimensions) ; self . rim_thickness . copy_to_native (& mut msg . rim_thickness) ; msg . rim_step_height = self . rim_step_height ; self . rim_ledge . copy_to_native (& mut msg . rim_ledge) ; self . pose . copy_to_native (& mut msg . pose) ; msg . overfilled = self . overfilled ; } } impl Default for LoadCarrier { fn default () -> Self { let msg_native = WrappedNativeMsg :: < LoadCarrier > :: new () ; LoadCarrier :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct LoadCarrierModel { pub id : std :: string :: String , # [serde (rename = "type")] pub type_ : std :: string :: String , pub outer_dimensions : rc_reason_msgs :: msg :: Box , pub inner_dimensions : rc_reason_msgs :: msg :: Box , pub rim_thickness : rc_reason_msgs :: msg :: Rectangle , pub rim_step_height : f64 , pub rim_ledge : rc_reason_msgs :: msg :: Rectangle , pub pose : geometry_msgs :: msg :: PoseStamped , pub pose_type : std :: string :: String } impl WrappedTypesupport for LoadCarrierModel { type CStruct = rc_reason_msgs__msg__LoadCarrierModel ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rc_reason_msgs__msg__LoadCarrierModel () } } fn create_msg () -> * mut rc_reason_msgs__msg__LoadCarrierModel { unsafe { rc_reason_msgs__msg__LoadCarrierModel__create () } } fn destroy_msg (msg : * mut rc_reason_msgs__msg__LoadCarrierModel) -> () { unsafe { rc_reason_msgs__msg__LoadCarrierModel__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> LoadCarrierModel { LoadCarrierModel { id : msg . id . to_str () . to_owned () , type_ : msg . type_ . to_str () . to_owned () , outer_dimensions : rc_reason_msgs :: msg :: Box :: from_native (& msg . outer_dimensions) , inner_dimensions : rc_reason_msgs :: msg :: Box :: from_native (& msg . inner_dimensions) , rim_thickness : rc_reason_msgs :: msg :: Rectangle :: from_native (& msg . rim_thickness) , rim_step_height : msg . rim_step_height , rim_ledge : rc_reason_msgs :: msg :: Rectangle :: from_native (& msg . rim_ledge) , pose : geometry_msgs :: msg :: PoseStamped :: from_native (& msg . pose) , pose_type : msg . pose_type . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . id . assign (& self . id) ; msg . type_ . assign (& self . type_) ; self . outer_dimensions . copy_to_native (& mut msg . outer_dimensions) ; self . inner_dimensions . copy_to_native (& mut msg . inner_dimensions) ; self . rim_thickness . copy_to_native (& mut msg . rim_thickness) ; msg . rim_step_height = self . rim_step_height ; self . rim_ledge . copy_to_native (& mut msg . rim_ledge) ; self . pose . copy_to_native (& mut msg . pose) ; msg . pose_type . assign (& self . pose_type) ; } } impl Default for LoadCarrierModel { fn default () -> Self { let msg_native = WrappedNativeMsg :: < LoadCarrierModel > :: new () ; LoadCarrierModel :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct LoadCarrierWithFillingLevel { pub id : std :: string :: String , # [serde (rename = "type")] pub type_ : std :: string :: String , pub outer_dimensions : rc_reason_msgs :: msg :: Box , pub inner_dimensions : rc_reason_msgs :: msg :: Box , pub rim_thickness : rc_reason_msgs :: msg :: Rectangle , pub rim_step_height : f64 , pub rim_ledge : rc_reason_msgs :: msg :: Rectangle , pub pose : geometry_msgs :: msg :: PoseStamped , pub overfilled : bool , pub overall_filling_level : rc_reason_msgs :: msg :: CellFillingLevel , pub cells_filling_levels : Vec < rc_reason_msgs :: msg :: CellFillingLevel > , pub filling_level_cell_count : rc_reason_msgs :: msg :: GridSize } impl WrappedTypesupport for LoadCarrierWithFillingLevel { type CStruct = rc_reason_msgs__msg__LoadCarrierWithFillingLevel ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rc_reason_msgs__msg__LoadCarrierWithFillingLevel () } } fn create_msg () -> * mut rc_reason_msgs__msg__LoadCarrierWithFillingLevel { unsafe { rc_reason_msgs__msg__LoadCarrierWithFillingLevel__create () } } fn destroy_msg (msg : * mut rc_reason_msgs__msg__LoadCarrierWithFillingLevel) -> () { unsafe { rc_reason_msgs__msg__LoadCarrierWithFillingLevel__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> LoadCarrierWithFillingLevel { LoadCarrierWithFillingLevel { id : msg . id . to_str () . to_owned () , type_ : msg . type_ . to_str () . to_owned () , outer_dimensions : rc_reason_msgs :: msg :: Box :: from_native (& msg . outer_dimensions) , inner_dimensions : rc_reason_msgs :: msg :: Box :: from_native (& msg . inner_dimensions) , rim_thickness : rc_reason_msgs :: msg :: Rectangle :: from_native (& msg . rim_thickness) , rim_step_height : msg . rim_step_height , rim_ledge : rc_reason_msgs :: msg :: Rectangle :: from_native (& msg . rim_ledge) , pose : geometry_msgs :: msg :: PoseStamped :: from_native (& msg . pose) , overfilled : msg . overfilled , overall_filling_level : rc_reason_msgs :: msg :: CellFillingLevel :: from_native (& msg . overall_filling_level) , cells_filling_levels : { let mut temp = Vec :: with_capacity (msg . cells_filling_levels . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . cells_filling_levels . data , msg . cells_filling_levels . size) } ; for s in slice { temp . push (rc_reason_msgs :: msg :: CellFillingLevel :: from_native (s)) ; } temp } , filling_level_cell_count : rc_reason_msgs :: msg :: GridSize :: from_native (& msg . filling_level_cell_count) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . id . assign (& self . id) ; msg . type_ . assign (& self . type_) ; self . outer_dimensions . copy_to_native (& mut msg . outer_dimensions) ; self . inner_dimensions . copy_to_native (& mut msg . inner_dimensions) ; self . rim_thickness . copy_to_native (& mut msg . rim_thickness) ; msg . rim_step_height = self . rim_step_height ; self . rim_ledge . copy_to_native (& mut msg . rim_ledge) ; self . pose . copy_to_native (& mut msg . pose) ; msg . overfilled = self . overfilled ; self . overall_filling_level . copy_to_native (& mut msg . overall_filling_level) ; unsafe { rc_reason_msgs__msg__CellFillingLevel__Sequence__fini (& mut msg . cells_filling_levels) ; rc_reason_msgs__msg__CellFillingLevel__Sequence__init (& mut msg . cells_filling_levels , self . cells_filling_levels . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . cells_filling_levels . data , msg . cells_filling_levels . size) ; for (t , s) in slice . iter_mut () . zip (& self . cells_filling_levels) { s . copy_to_native (t) ; } } self . filling_level_cell_count . copy_to_native (& mut msg . filling_level_cell_count) ; } } impl Default for LoadCarrierWithFillingLevel { fn default () -> Self { let msg_native = WrappedNativeMsg :: < LoadCarrierWithFillingLevel > :: new () ; LoadCarrierWithFillingLevel :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Match { pub template_id : std :: string :: String , pub uuid : std :: string :: String , pub pose : geometry_msgs :: msg :: PoseStamped , pub grasp_uuids : Vec < std :: string :: String > , pub score : f64 } impl WrappedTypesupport for Match { type CStruct = rc_reason_msgs__msg__Match ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rc_reason_msgs__msg__Match () } } fn create_msg () -> * mut rc_reason_msgs__msg__Match { unsafe { rc_reason_msgs__msg__Match__create () } } fn destroy_msg (msg : * mut rc_reason_msgs__msg__Match) -> () { unsafe { rc_reason_msgs__msg__Match__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Match { Match { template_id : msg . template_id . to_str () . to_owned () , uuid : msg . uuid . to_str () . to_owned () , pose : geometry_msgs :: msg :: PoseStamped :: from_native (& msg . pose) , grasp_uuids : msg . grasp_uuids . to_vec () , score : msg . score , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . template_id . assign (& self . template_id) ; msg . uuid . assign (& self . uuid) ; self . pose . copy_to_native (& mut msg . pose) ; msg . grasp_uuids . update (& self . grasp_uuids) ; msg . score = self . score ; } } impl Default for Match { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Match > :: new () ; Match :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct RangeBox { pub min_dimensions : rc_reason_msgs :: msg :: Box , pub max_dimensions : rc_reason_msgs :: msg :: Box } impl WrappedTypesupport for RangeBox { type CStruct = rc_reason_msgs__msg__RangeBox ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rc_reason_msgs__msg__RangeBox () } } fn create_msg () -> * mut rc_reason_msgs__msg__RangeBox { unsafe { rc_reason_msgs__msg__RangeBox__create () } } fn destroy_msg (msg : * mut rc_reason_msgs__msg__RangeBox) -> () { unsafe { rc_reason_msgs__msg__RangeBox__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> RangeBox { RangeBox { min_dimensions : rc_reason_msgs :: msg :: Box :: from_native (& msg . min_dimensions) , max_dimensions : rc_reason_msgs :: msg :: Box :: from_native (& msg . max_dimensions) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . min_dimensions . copy_to_native (& mut msg . min_dimensions) ; self . max_dimensions . copy_to_native (& mut msg . max_dimensions) ; } } impl Default for RangeBox { fn default () -> Self { let msg_native = WrappedNativeMsg :: < RangeBox > :: new () ; RangeBox :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct RangeRectangle { pub min_dimensions : rc_reason_msgs :: msg :: Rectangle , pub max_dimensions : rc_reason_msgs :: msg :: Rectangle } impl WrappedTypesupport for RangeRectangle { type CStruct = rc_reason_msgs__msg__RangeRectangle ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rc_reason_msgs__msg__RangeRectangle () } } fn create_msg () -> * mut rc_reason_msgs__msg__RangeRectangle { unsafe { rc_reason_msgs__msg__RangeRectangle__create () } } fn destroy_msg (msg : * mut rc_reason_msgs__msg__RangeRectangle) -> () { unsafe { rc_reason_msgs__msg__RangeRectangle__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> RangeRectangle { RangeRectangle { min_dimensions : rc_reason_msgs :: msg :: Rectangle :: from_native (& msg . min_dimensions) , max_dimensions : rc_reason_msgs :: msg :: Rectangle :: from_native (& msg . max_dimensions) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . min_dimensions . copy_to_native (& mut msg . min_dimensions) ; self . max_dimensions . copy_to_native (& mut msg . max_dimensions) ; } } impl Default for RangeRectangle { fn default () -> Self { let msg_native = WrappedNativeMsg :: < RangeRectangle > :: new () ; RangeRectangle :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct RangeValue { pub min : f64 , pub max : f64 , pub mean : f64 } impl WrappedTypesupport for RangeValue { type CStruct = rc_reason_msgs__msg__RangeValue ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rc_reason_msgs__msg__RangeValue () } } fn create_msg () -> * mut rc_reason_msgs__msg__RangeValue { unsafe { rc_reason_msgs__msg__RangeValue__create () } } fn destroy_msg (msg : * mut rc_reason_msgs__msg__RangeValue) -> () { unsafe { rc_reason_msgs__msg__RangeValue__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> RangeValue { RangeValue { min : msg . min , max : msg . max , mean : msg . mean , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . min = self . min ; msg . max = self . max ; msg . mean = self . mean ; } } impl Default for RangeValue { fn default () -> Self { let msg_native = WrappedNativeMsg :: < RangeValue > :: new () ; RangeValue :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Rectangle { pub x : f64 , pub y : f64 } impl WrappedTypesupport for Rectangle { type CStruct = rc_reason_msgs__msg__Rectangle ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rc_reason_msgs__msg__Rectangle () } } fn create_msg () -> * mut rc_reason_msgs__msg__Rectangle { unsafe { rc_reason_msgs__msg__Rectangle__create () } } fn destroy_msg (msg : * mut rc_reason_msgs__msg__Rectangle) -> () { unsafe { rc_reason_msgs__msg__Rectangle__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Rectangle { Rectangle { x : msg . x , y : msg . y , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . x = self . x ; msg . y = self . y ; } } impl Default for Rectangle { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Rectangle > :: new () ; Rectangle :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct RegionOfInterest2D { pub id : std :: string :: String , pub offset_x : u32 , pub offset_y : u32 , pub width : u32 , pub height : u32 } impl WrappedTypesupport for RegionOfInterest2D { type CStruct = rc_reason_msgs__msg__RegionOfInterest2D ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rc_reason_msgs__msg__RegionOfInterest2D () } } fn create_msg () -> * mut rc_reason_msgs__msg__RegionOfInterest2D { unsafe { rc_reason_msgs__msg__RegionOfInterest2D__create () } } fn destroy_msg (msg : * mut rc_reason_msgs__msg__RegionOfInterest2D) -> () { unsafe { rc_reason_msgs__msg__RegionOfInterest2D__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> RegionOfInterest2D { RegionOfInterest2D { id : msg . id . to_str () . to_owned () , offset_x : msg . offset_x , offset_y : msg . offset_y , width : msg . width , height : msg . height , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . id . assign (& self . id) ; msg . offset_x = self . offset_x ; msg . offset_y = self . offset_y ; msg . width = self . width ; msg . height = self . height ; } } impl Default for RegionOfInterest2D { fn default () -> Self { let msg_native = WrappedNativeMsg :: < RegionOfInterest2D > :: new () ; RegionOfInterest2D :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct RegionOfInterest3D { pub id : std :: string :: String , pub pose : geometry_msgs :: msg :: PoseStamped , pub primitive : shape_msgs :: msg :: SolidPrimitive } impl WrappedTypesupport for RegionOfInterest3D { type CStruct = rc_reason_msgs__msg__RegionOfInterest3D ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rc_reason_msgs__msg__RegionOfInterest3D () } } fn create_msg () -> * mut rc_reason_msgs__msg__RegionOfInterest3D { unsafe { rc_reason_msgs__msg__RegionOfInterest3D__create () } } fn destroy_msg (msg : * mut rc_reason_msgs__msg__RegionOfInterest3D) -> () { unsafe { rc_reason_msgs__msg__RegionOfInterest3D__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> RegionOfInterest3D { RegionOfInterest3D { id : msg . id . to_str () . to_owned () , pose : geometry_msgs :: msg :: PoseStamped :: from_native (& msg . pose) , primitive : shape_msgs :: msg :: SolidPrimitive :: from_native (& msg . primitive) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . id . assign (& self . id) ; self . pose . copy_to_native (& mut msg . pose) ; self . primitive . copy_to_native (& mut msg . primitive) ; } } impl Default for RegionOfInterest3D { fn default () -> Self { let msg_native = WrappedNativeMsg :: < RegionOfInterest3D > :: new () ; RegionOfInterest3D :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct SilhouetteMatchObject { pub object_id : std :: string :: String , pub region_of_interest_2d_id : std :: string :: String } impl WrappedTypesupport for SilhouetteMatchObject { type CStruct = rc_reason_msgs__msg__SilhouetteMatchObject ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rc_reason_msgs__msg__SilhouetteMatchObject () } } fn create_msg () -> * mut rc_reason_msgs__msg__SilhouetteMatchObject { unsafe { rc_reason_msgs__msg__SilhouetteMatchObject__create () } } fn destroy_msg (msg : * mut rc_reason_msgs__msg__SilhouetteMatchObject) -> () { unsafe { rc_reason_msgs__msg__SilhouetteMatchObject__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> SilhouetteMatchObject { SilhouetteMatchObject { object_id : msg . object_id . to_str () . to_owned () , region_of_interest_2d_id : msg . region_of_interest_2d_id . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . object_id . assign (& self . object_id) ; msg . region_of_interest_2d_id . assign (& self . region_of_interest_2d_id) ; } } impl Default for SilhouetteMatchObject { fn default () -> Self { let msg_native = WrappedNativeMsg :: < SilhouetteMatchObject > :: new () ; SilhouetteMatchObject :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct SuctionGrasp { pub uuid : std :: string :: String , pub item_uuid : std :: string :: String , pub pose : geometry_msgs :: msg :: PoseStamped , pub quality : f64 , pub max_suction_surface_length : f64 , pub max_suction_surface_width : f64 } impl WrappedTypesupport for SuctionGrasp { type CStruct = rc_reason_msgs__msg__SuctionGrasp ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rc_reason_msgs__msg__SuctionGrasp () } } fn create_msg () -> * mut rc_reason_msgs__msg__SuctionGrasp { unsafe { rc_reason_msgs__msg__SuctionGrasp__create () } } fn destroy_msg (msg : * mut rc_reason_msgs__msg__SuctionGrasp) -> () { unsafe { rc_reason_msgs__msg__SuctionGrasp__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> SuctionGrasp { SuctionGrasp { uuid : msg . uuid . to_str () . to_owned () , item_uuid : msg . item_uuid . to_str () . to_owned () , pose : geometry_msgs :: msg :: PoseStamped :: from_native (& msg . pose) , quality : msg . quality , max_suction_surface_length : msg . max_suction_surface_length , max_suction_surface_width : msg . max_suction_surface_width , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . uuid . assign (& self . uuid) ; msg . item_uuid . assign (& self . item_uuid) ; self . pose . copy_to_native (& mut msg . pose) ; msg . quality = self . quality ; msg . max_suction_surface_length = self . max_suction_surface_length ; msg . max_suction_surface_width = self . max_suction_surface_width ; } } impl Default for SuctionGrasp { fn default () -> Self { let msg_native = WrappedNativeMsg :: < SuctionGrasp > :: new () ; SuctionGrasp :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Tag { pub id : std :: string :: String , pub size : f64 } impl WrappedTypesupport for Tag { type CStruct = rc_reason_msgs__msg__Tag ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rc_reason_msgs__msg__Tag () } } fn create_msg () -> * mut rc_reason_msgs__msg__Tag { unsafe { rc_reason_msgs__msg__Tag__create () } } fn destroy_msg (msg : * mut rc_reason_msgs__msg__Tag) -> () { unsafe { rc_reason_msgs__msg__Tag__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Tag { Tag { id : msg . id . to_str () . to_owned () , size : msg . size , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . id . assign (& self . id) ; msg . size = self . size ; } } impl Default for Tag { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Tag > :: new () ; Tag :: from_native (& msg_native) } } } pub mod srv { # [allow (non_snake_case)] pub mod CadMatchDetectObject { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__rc_reason_msgs__srv__CadMatchDetectObject () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub template_id : std :: string :: String , pub pose_frame : std :: string :: String , pub region_of_interest_id : std :: string :: String , pub load_carrier_id : std :: string :: String , pub load_carrier_compartment : rc_reason_msgs :: msg :: Compartment , pub robot_pose : geometry_msgs :: msg :: Pose , pub collision_detection : rc_reason_msgs :: msg :: CollisionDetection } impl WrappedTypesupport for Request { type CStruct = rc_reason_msgs__srv__CadMatchDetectObject_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rc_reason_msgs__srv__CadMatchDetectObject_Request () } } fn create_msg () -> * mut rc_reason_msgs__srv__CadMatchDetectObject_Request { unsafe { rc_reason_msgs__srv__CadMatchDetectObject_Request__create () } } fn destroy_msg (msg : * mut rc_reason_msgs__srv__CadMatchDetectObject_Request) -> () { unsafe { rc_reason_msgs__srv__CadMatchDetectObject_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { template_id : msg . template_id . to_str () . to_owned () , pose_frame : msg . pose_frame . to_str () . to_owned () , region_of_interest_id : msg . region_of_interest_id . to_str () . to_owned () , load_carrier_id : msg . load_carrier_id . to_str () . to_owned () , load_carrier_compartment : rc_reason_msgs :: msg :: Compartment :: from_native (& msg . load_carrier_compartment) , robot_pose : geometry_msgs :: msg :: Pose :: from_native (& msg . robot_pose) , collision_detection : rc_reason_msgs :: msg :: CollisionDetection :: from_native (& msg . collision_detection) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . template_id . assign (& self . template_id) ; msg . pose_frame . assign (& self . pose_frame) ; msg . region_of_interest_id . assign (& self . region_of_interest_id) ; msg . load_carrier_id . assign (& self . load_carrier_id) ; self . load_carrier_compartment . copy_to_native (& mut msg . load_carrier_compartment) ; self . robot_pose . copy_to_native (& mut msg . robot_pose) ; self . collision_detection . copy_to_native (& mut msg . collision_detection) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub timestamp : builtin_interfaces :: msg :: Time , pub matches : Vec < rc_reason_msgs :: msg :: Match > , pub grasps : Vec < rc_reason_msgs :: msg :: Grasp > , pub load_carriers : Vec < rc_reason_msgs :: msg :: LoadCarrier > , pub return_code : rc_common_msgs :: msg :: ReturnCode } impl WrappedTypesupport for Response { type CStruct = rc_reason_msgs__srv__CadMatchDetectObject_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rc_reason_msgs__srv__CadMatchDetectObject_Response () } } fn create_msg () -> * mut rc_reason_msgs__srv__CadMatchDetectObject_Response { unsafe { rc_reason_msgs__srv__CadMatchDetectObject_Response__create () } } fn destroy_msg (msg : * mut rc_reason_msgs__srv__CadMatchDetectObject_Response) -> () { unsafe { rc_reason_msgs__srv__CadMatchDetectObject_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { timestamp : builtin_interfaces :: msg :: Time :: from_native (& msg . timestamp) , matches : { let mut temp = Vec :: with_capacity (msg . matches . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . matches . data , msg . matches . size) } ; for s in slice { temp . push (rc_reason_msgs :: msg :: Match :: from_native (s)) ; } temp } , grasps : { let mut temp = Vec :: with_capacity (msg . grasps . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . grasps . data , msg . grasps . size) } ; for s in slice { temp . push (rc_reason_msgs :: msg :: Grasp :: from_native (s)) ; } temp } , load_carriers : { let mut temp = Vec :: with_capacity (msg . load_carriers . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . load_carriers . data , msg . load_carriers . size) } ; for s in slice { temp . push (rc_reason_msgs :: msg :: LoadCarrier :: from_native (s)) ; } temp } , return_code : rc_common_msgs :: msg :: ReturnCode :: from_native (& msg . return_code) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . timestamp . copy_to_native (& mut msg . timestamp) ; unsafe { rc_reason_msgs__msg__Match__Sequence__fini (& mut msg . matches) ; rc_reason_msgs__msg__Match__Sequence__init (& mut msg . matches , self . matches . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . matches . data , msg . matches . size) ; for (t , s) in slice . iter_mut () . zip (& self . matches) { s . copy_to_native (t) ; } } unsafe { rc_reason_msgs__msg__Grasp__Sequence__fini (& mut msg . grasps) ; rc_reason_msgs__msg__Grasp__Sequence__init (& mut msg . grasps , self . grasps . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . grasps . data , msg . grasps . size) ; for (t , s) in slice . iter_mut () . zip (& self . grasps) { s . copy_to_native (t) ; } } unsafe { rc_reason_msgs__msg__LoadCarrier__Sequence__fini (& mut msg . load_carriers) ; rc_reason_msgs__msg__LoadCarrier__Sequence__init (& mut msg . load_carriers , self . load_carriers . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . load_carriers . data , msg . load_carriers . size) ; for (t , s) in slice . iter_mut () . zip (& self . load_carriers) { s . copy_to_native (t) ; } } self . return_code . copy_to_native (& mut msg . return_code) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod CalibrateBasePlane { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__rc_reason_msgs__srv__CalibrateBasePlane () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub pose_frame : std :: string :: String , pub robot_pose : geometry_msgs :: msg :: Pose , pub plane_estimation_method : std :: string :: String , pub stereo_plane_preference : std :: string :: String , pub region_of_interest_2d_id : std :: string :: String , pub offset : f64 , pub plane : shape_msgs :: msg :: Plane } impl WrappedTypesupport for Request { type CStruct = rc_reason_msgs__srv__CalibrateBasePlane_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rc_reason_msgs__srv__CalibrateBasePlane_Request () } } fn create_msg () -> * mut rc_reason_msgs__srv__CalibrateBasePlane_Request { unsafe { rc_reason_msgs__srv__CalibrateBasePlane_Request__create () } } fn destroy_msg (msg : * mut rc_reason_msgs__srv__CalibrateBasePlane_Request) -> () { unsafe { rc_reason_msgs__srv__CalibrateBasePlane_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { pose_frame : msg . pose_frame . to_str () . to_owned () , robot_pose : geometry_msgs :: msg :: Pose :: from_native (& msg . robot_pose) , plane_estimation_method : msg . plane_estimation_method . to_str () . to_owned () , stereo_plane_preference : msg . stereo_plane_preference . to_str () . to_owned () , region_of_interest_2d_id : msg . region_of_interest_2d_id . to_str () . to_owned () , offset : msg . offset , plane : shape_msgs :: msg :: Plane :: from_native (& msg . plane) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . pose_frame . assign (& self . pose_frame) ; self . robot_pose . copy_to_native (& mut msg . robot_pose) ; msg . plane_estimation_method . assign (& self . plane_estimation_method) ; msg . stereo_plane_preference . assign (& self . stereo_plane_preference) ; msg . region_of_interest_2d_id . assign (& self . region_of_interest_2d_id) ; msg . offset = self . offset ; self . plane . copy_to_native (& mut msg . plane) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub timestamp : builtin_interfaces :: msg :: Time , pub pose_frame : std :: string :: String , pub plane : shape_msgs :: msg :: Plane , pub return_code : rc_common_msgs :: msg :: ReturnCode } impl WrappedTypesupport for Response { type CStruct = rc_reason_msgs__srv__CalibrateBasePlane_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rc_reason_msgs__srv__CalibrateBasePlane_Response () } } fn create_msg () -> * mut rc_reason_msgs__srv__CalibrateBasePlane_Response { unsafe { rc_reason_msgs__srv__CalibrateBasePlane_Response__create () } } fn destroy_msg (msg : * mut rc_reason_msgs__srv__CalibrateBasePlane_Response) -> () { unsafe { rc_reason_msgs__srv__CalibrateBasePlane_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { timestamp : builtin_interfaces :: msg :: Time :: from_native (& msg . timestamp) , pose_frame : msg . pose_frame . to_str () . to_owned () , plane : shape_msgs :: msg :: Plane :: from_native (& msg . plane) , return_code : rc_common_msgs :: msg :: ReturnCode :: from_native (& msg . return_code) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . timestamp . copy_to_native (& mut msg . timestamp) ; msg . pose_frame . assign (& self . pose_frame) ; self . plane . copy_to_native (& mut msg . plane) ; self . return_code . copy_to_native (& mut msg . return_code) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod ComputeGrasps { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__rc_reason_msgs__srv__ComputeGrasps () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub pose_frame : std :: string :: String , pub region_of_interest_id : std :: string :: String , pub load_carrier_id : std :: string :: String , pub load_carrier_compartment : rc_reason_msgs :: msg :: Compartment , pub item_models : Vec < rc_reason_msgs :: msg :: ItemModel > , pub suction_surface_length : f64 , pub suction_surface_width : f64 , pub robot_pose : geometry_msgs :: msg :: Pose , pub collision_detection : rc_reason_msgs :: msg :: CollisionDetection } impl WrappedTypesupport for Request { type CStruct = rc_reason_msgs__srv__ComputeGrasps_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rc_reason_msgs__srv__ComputeGrasps_Request () } } fn create_msg () -> * mut rc_reason_msgs__srv__ComputeGrasps_Request { unsafe { rc_reason_msgs__srv__ComputeGrasps_Request__create () } } fn destroy_msg (msg : * mut rc_reason_msgs__srv__ComputeGrasps_Request) -> () { unsafe { rc_reason_msgs__srv__ComputeGrasps_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { pose_frame : msg . pose_frame . to_str () . to_owned () , region_of_interest_id : msg . region_of_interest_id . to_str () . to_owned () , load_carrier_id : msg . load_carrier_id . to_str () . to_owned () , load_carrier_compartment : rc_reason_msgs :: msg :: Compartment :: from_native (& msg . load_carrier_compartment) , item_models : { let mut temp = Vec :: with_capacity (msg . item_models . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . item_models . data , msg . item_models . size) } ; for s in slice { temp . push (rc_reason_msgs :: msg :: ItemModel :: from_native (s)) ; } temp } , suction_surface_length : msg . suction_surface_length , suction_surface_width : msg . suction_surface_width , robot_pose : geometry_msgs :: msg :: Pose :: from_native (& msg . robot_pose) , collision_detection : rc_reason_msgs :: msg :: CollisionDetection :: from_native (& msg . collision_detection) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . pose_frame . assign (& self . pose_frame) ; msg . region_of_interest_id . assign (& self . region_of_interest_id) ; msg . load_carrier_id . assign (& self . load_carrier_id) ; self . load_carrier_compartment . copy_to_native (& mut msg . load_carrier_compartment) ; unsafe { rc_reason_msgs__msg__ItemModel__Sequence__fini (& mut msg . item_models) ; rc_reason_msgs__msg__ItemModel__Sequence__init (& mut msg . item_models , self . item_models . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . item_models . data , msg . item_models . size) ; for (t , s) in slice . iter_mut () . zip (& self . item_models) { s . copy_to_native (t) ; } } msg . suction_surface_length = self . suction_surface_length ; msg . suction_surface_width = self . suction_surface_width ; self . robot_pose . copy_to_native (& mut msg . robot_pose) ; self . collision_detection . copy_to_native (& mut msg . collision_detection) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub timestamp : builtin_interfaces :: msg :: Time , pub items : Vec < rc_reason_msgs :: msg :: Item > , pub load_carriers : Vec < rc_reason_msgs :: msg :: LoadCarrier > , pub grasps : Vec < rc_reason_msgs :: msg :: SuctionGrasp > , pub return_code : rc_common_msgs :: msg :: ReturnCode } impl WrappedTypesupport for Response { type CStruct = rc_reason_msgs__srv__ComputeGrasps_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rc_reason_msgs__srv__ComputeGrasps_Response () } } fn create_msg () -> * mut rc_reason_msgs__srv__ComputeGrasps_Response { unsafe { rc_reason_msgs__srv__ComputeGrasps_Response__create () } } fn destroy_msg (msg : * mut rc_reason_msgs__srv__ComputeGrasps_Response) -> () { unsafe { rc_reason_msgs__srv__ComputeGrasps_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { timestamp : builtin_interfaces :: msg :: Time :: from_native (& msg . timestamp) , items : { let mut temp = Vec :: with_capacity (msg . items . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . items . data , msg . items . size) } ; for s in slice { temp . push (rc_reason_msgs :: msg :: Item :: from_native (s)) ; } temp } , load_carriers : { let mut temp = Vec :: with_capacity (msg . load_carriers . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . load_carriers . data , msg . load_carriers . size) } ; for s in slice { temp . push (rc_reason_msgs :: msg :: LoadCarrier :: from_native (s)) ; } temp } , grasps : { let mut temp = Vec :: with_capacity (msg . grasps . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . grasps . data , msg . grasps . size) } ; for s in slice { temp . push (rc_reason_msgs :: msg :: SuctionGrasp :: from_native (s)) ; } temp } , return_code : rc_common_msgs :: msg :: ReturnCode :: from_native (& msg . return_code) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . timestamp . copy_to_native (& mut msg . timestamp) ; unsafe { rc_reason_msgs__msg__Item__Sequence__fini (& mut msg . items) ; rc_reason_msgs__msg__Item__Sequence__init (& mut msg . items , self . items . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . items . data , msg . items . size) ; for (t , s) in slice . iter_mut () . zip (& self . items) { s . copy_to_native (t) ; } } unsafe { rc_reason_msgs__msg__LoadCarrier__Sequence__fini (& mut msg . load_carriers) ; rc_reason_msgs__msg__LoadCarrier__Sequence__init (& mut msg . load_carriers , self . load_carriers . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . load_carriers . data , msg . load_carriers . size) ; for (t , s) in slice . iter_mut () . zip (& self . load_carriers) { s . copy_to_native (t) ; } } unsafe { rc_reason_msgs__msg__SuctionGrasp__Sequence__fini (& mut msg . grasps) ; rc_reason_msgs__msg__SuctionGrasp__Sequence__init (& mut msg . grasps , self . grasps . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . grasps . data , msg . grasps . size) ; for (t , s) in slice . iter_mut () . zip (& self . grasps) { s . copy_to_native (t) ; } } self . return_code . copy_to_native (& mut msg . return_code) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod DeleteBasePlaneCalibration { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__rc_reason_msgs__srv__DeleteBasePlaneCalibration () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { } impl WrappedTypesupport for Request { type CStruct = rc_reason_msgs__srv__DeleteBasePlaneCalibration_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rc_reason_msgs__srv__DeleteBasePlaneCalibration_Request () } } fn create_msg () -> * mut rc_reason_msgs__srv__DeleteBasePlaneCalibration_Request { unsafe { rc_reason_msgs__srv__DeleteBasePlaneCalibration_Request__create () } } fn destroy_msg (msg : * mut rc_reason_msgs__srv__DeleteBasePlaneCalibration_Request) -> () { unsafe { rc_reason_msgs__srv__DeleteBasePlaneCalibration_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub return_code : rc_common_msgs :: msg :: ReturnCode } impl WrappedTypesupport for Response { type CStruct = rc_reason_msgs__srv__DeleteBasePlaneCalibration_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rc_reason_msgs__srv__DeleteBasePlaneCalibration_Response () } } fn create_msg () -> * mut rc_reason_msgs__srv__DeleteBasePlaneCalibration_Response { unsafe { rc_reason_msgs__srv__DeleteBasePlaneCalibration_Response__create () } } fn destroy_msg (msg : * mut rc_reason_msgs__srv__DeleteBasePlaneCalibration_Response) -> () { unsafe { rc_reason_msgs__srv__DeleteBasePlaneCalibration_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { return_code : rc_common_msgs :: msg :: ReturnCode :: from_native (& msg . return_code) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . return_code . copy_to_native (& mut msg . return_code) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod DeleteLoadCarriers { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__rc_reason_msgs__srv__DeleteLoadCarriers () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub load_carrier_ids : Vec < std :: string :: String > } impl WrappedTypesupport for Request { type CStruct = rc_reason_msgs__srv__DeleteLoadCarriers_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rc_reason_msgs__srv__DeleteLoadCarriers_Request () } } fn create_msg () -> * mut rc_reason_msgs__srv__DeleteLoadCarriers_Request { unsafe { rc_reason_msgs__srv__DeleteLoadCarriers_Request__create () } } fn destroy_msg (msg : * mut rc_reason_msgs__srv__DeleteLoadCarriers_Request) -> () { unsafe { rc_reason_msgs__srv__DeleteLoadCarriers_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { load_carrier_ids : msg . load_carrier_ids . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . load_carrier_ids . update (& self . load_carrier_ids) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub return_code : rc_common_msgs :: msg :: ReturnCode } impl WrappedTypesupport for Response { type CStruct = rc_reason_msgs__srv__DeleteLoadCarriers_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rc_reason_msgs__srv__DeleteLoadCarriers_Response () } } fn create_msg () -> * mut rc_reason_msgs__srv__DeleteLoadCarriers_Response { unsafe { rc_reason_msgs__srv__DeleteLoadCarriers_Response__create () } } fn destroy_msg (msg : * mut rc_reason_msgs__srv__DeleteLoadCarriers_Response) -> () { unsafe { rc_reason_msgs__srv__DeleteLoadCarriers_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { return_code : rc_common_msgs :: msg :: ReturnCode :: from_native (& msg . return_code) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . return_code . copy_to_native (& mut msg . return_code) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod DeleteRegionsOfInterest2D { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__rc_reason_msgs__srv__DeleteRegionsOfInterest2D () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub region_of_interest_2d_ids : Vec < std :: string :: String > } impl WrappedTypesupport for Request { type CStruct = rc_reason_msgs__srv__DeleteRegionsOfInterest2D_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rc_reason_msgs__srv__DeleteRegionsOfInterest2D_Request () } } fn create_msg () -> * mut rc_reason_msgs__srv__DeleteRegionsOfInterest2D_Request { unsafe { rc_reason_msgs__srv__DeleteRegionsOfInterest2D_Request__create () } } fn destroy_msg (msg : * mut rc_reason_msgs__srv__DeleteRegionsOfInterest2D_Request) -> () { unsafe { rc_reason_msgs__srv__DeleteRegionsOfInterest2D_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { region_of_interest_2d_ids : msg . region_of_interest_2d_ids . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . region_of_interest_2d_ids . update (& self . region_of_interest_2d_ids) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub return_code : rc_common_msgs :: msg :: ReturnCode } impl WrappedTypesupport for Response { type CStruct = rc_reason_msgs__srv__DeleteRegionsOfInterest2D_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rc_reason_msgs__srv__DeleteRegionsOfInterest2D_Response () } } fn create_msg () -> * mut rc_reason_msgs__srv__DeleteRegionsOfInterest2D_Response { unsafe { rc_reason_msgs__srv__DeleteRegionsOfInterest2D_Response__create () } } fn destroy_msg (msg : * mut rc_reason_msgs__srv__DeleteRegionsOfInterest2D_Response) -> () { unsafe { rc_reason_msgs__srv__DeleteRegionsOfInterest2D_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { return_code : rc_common_msgs :: msg :: ReturnCode :: from_native (& msg . return_code) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . return_code . copy_to_native (& mut msg . return_code) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod DeleteRegionsOfInterest3D { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__rc_reason_msgs__srv__DeleteRegionsOfInterest3D () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub region_of_interest_ids : Vec < std :: string :: String > } impl WrappedTypesupport for Request { type CStruct = rc_reason_msgs__srv__DeleteRegionsOfInterest3D_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rc_reason_msgs__srv__DeleteRegionsOfInterest3D_Request () } } fn create_msg () -> * mut rc_reason_msgs__srv__DeleteRegionsOfInterest3D_Request { unsafe { rc_reason_msgs__srv__DeleteRegionsOfInterest3D_Request__create () } } fn destroy_msg (msg : * mut rc_reason_msgs__srv__DeleteRegionsOfInterest3D_Request) -> () { unsafe { rc_reason_msgs__srv__DeleteRegionsOfInterest3D_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { region_of_interest_ids : msg . region_of_interest_ids . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . region_of_interest_ids . update (& self . region_of_interest_ids) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub return_code : rc_common_msgs :: msg :: ReturnCode } impl WrappedTypesupport for Response { type CStruct = rc_reason_msgs__srv__DeleteRegionsOfInterest3D_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rc_reason_msgs__srv__DeleteRegionsOfInterest3D_Response () } } fn create_msg () -> * mut rc_reason_msgs__srv__DeleteRegionsOfInterest3D_Response { unsafe { rc_reason_msgs__srv__DeleteRegionsOfInterest3D_Response__create () } } fn destroy_msg (msg : * mut rc_reason_msgs__srv__DeleteRegionsOfInterest3D_Response) -> () { unsafe { rc_reason_msgs__srv__DeleteRegionsOfInterest3D_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { return_code : rc_common_msgs :: msg :: ReturnCode :: from_native (& msg . return_code) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . return_code . copy_to_native (& mut msg . return_code) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod DetectFillingLevel { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__rc_reason_msgs__srv__DetectFillingLevel () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub pose_frame : std :: string :: String , pub region_of_interest_id : std :: string :: String , pub region_of_interest_2d_id : std :: string :: String , pub load_carrier_ids : Vec < std :: string :: String > , pub robot_pose : geometry_msgs :: msg :: Pose , pub filling_level_cell_count : rc_reason_msgs :: msg :: GridSize } impl WrappedTypesupport for Request { type CStruct = rc_reason_msgs__srv__DetectFillingLevel_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rc_reason_msgs__srv__DetectFillingLevel_Request () } } fn create_msg () -> * mut rc_reason_msgs__srv__DetectFillingLevel_Request { unsafe { rc_reason_msgs__srv__DetectFillingLevel_Request__create () } } fn destroy_msg (msg : * mut rc_reason_msgs__srv__DetectFillingLevel_Request) -> () { unsafe { rc_reason_msgs__srv__DetectFillingLevel_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { pose_frame : msg . pose_frame . to_str () . to_owned () , region_of_interest_id : msg . region_of_interest_id . to_str () . to_owned () , region_of_interest_2d_id : msg . region_of_interest_2d_id . to_str () . to_owned () , load_carrier_ids : msg . load_carrier_ids . to_vec () , robot_pose : geometry_msgs :: msg :: Pose :: from_native (& msg . robot_pose) , filling_level_cell_count : rc_reason_msgs :: msg :: GridSize :: from_native (& msg . filling_level_cell_count) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . pose_frame . assign (& self . pose_frame) ; msg . region_of_interest_id . assign (& self . region_of_interest_id) ; msg . region_of_interest_2d_id . assign (& self . region_of_interest_2d_id) ; msg . load_carrier_ids . update (& self . load_carrier_ids) ; self . robot_pose . copy_to_native (& mut msg . robot_pose) ; self . filling_level_cell_count . copy_to_native (& mut msg . filling_level_cell_count) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub timestamp : builtin_interfaces :: msg :: Time , pub load_carriers : Vec < rc_reason_msgs :: msg :: LoadCarrierWithFillingLevel > , pub return_code : rc_common_msgs :: msg :: ReturnCode } impl WrappedTypesupport for Response { type CStruct = rc_reason_msgs__srv__DetectFillingLevel_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rc_reason_msgs__srv__DetectFillingLevel_Response () } } fn create_msg () -> * mut rc_reason_msgs__srv__DetectFillingLevel_Response { unsafe { rc_reason_msgs__srv__DetectFillingLevel_Response__create () } } fn destroy_msg (msg : * mut rc_reason_msgs__srv__DetectFillingLevel_Response) -> () { unsafe { rc_reason_msgs__srv__DetectFillingLevel_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { timestamp : builtin_interfaces :: msg :: Time :: from_native (& msg . timestamp) , load_carriers : { let mut temp = Vec :: with_capacity (msg . load_carriers . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . load_carriers . data , msg . load_carriers . size) } ; for s in slice { temp . push (rc_reason_msgs :: msg :: LoadCarrierWithFillingLevel :: from_native (s)) ; } temp } , return_code : rc_common_msgs :: msg :: ReturnCode :: from_native (& msg . return_code) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . timestamp . copy_to_native (& mut msg . timestamp) ; unsafe { rc_reason_msgs__msg__LoadCarrierWithFillingLevel__Sequence__fini (& mut msg . load_carriers) ; rc_reason_msgs__msg__LoadCarrierWithFillingLevel__Sequence__init (& mut msg . load_carriers , self . load_carriers . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . load_carriers . data , msg . load_carriers . size) ; for (t , s) in slice . iter_mut () . zip (& self . load_carriers) { s . copy_to_native (t) ; } } self . return_code . copy_to_native (& mut msg . return_code) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod DetectItems { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__rc_reason_msgs__srv__DetectItems () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub pose_frame : std :: string :: String , pub region_of_interest_id : std :: string :: String , pub load_carrier_id : std :: string :: String , pub load_carrier_compartment : rc_reason_msgs :: msg :: Compartment , pub item_models : Vec < rc_reason_msgs :: msg :: ItemModel > , pub robot_pose : geometry_msgs :: msg :: Pose } impl WrappedTypesupport for Request { type CStruct = rc_reason_msgs__srv__DetectItems_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rc_reason_msgs__srv__DetectItems_Request () } } fn create_msg () -> * mut rc_reason_msgs__srv__DetectItems_Request { unsafe { rc_reason_msgs__srv__DetectItems_Request__create () } } fn destroy_msg (msg : * mut rc_reason_msgs__srv__DetectItems_Request) -> () { unsafe { rc_reason_msgs__srv__DetectItems_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { pose_frame : msg . pose_frame . to_str () . to_owned () , region_of_interest_id : msg . region_of_interest_id . to_str () . to_owned () , load_carrier_id : msg . load_carrier_id . to_str () . to_owned () , load_carrier_compartment : rc_reason_msgs :: msg :: Compartment :: from_native (& msg . load_carrier_compartment) , item_models : { let mut temp = Vec :: with_capacity (msg . item_models . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . item_models . data , msg . item_models . size) } ; for s in slice { temp . push (rc_reason_msgs :: msg :: ItemModel :: from_native (s)) ; } temp } , robot_pose : geometry_msgs :: msg :: Pose :: from_native (& msg . robot_pose) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . pose_frame . assign (& self . pose_frame) ; msg . region_of_interest_id . assign (& self . region_of_interest_id) ; msg . load_carrier_id . assign (& self . load_carrier_id) ; self . load_carrier_compartment . copy_to_native (& mut msg . load_carrier_compartment) ; unsafe { rc_reason_msgs__msg__ItemModel__Sequence__fini (& mut msg . item_models) ; rc_reason_msgs__msg__ItemModel__Sequence__init (& mut msg . item_models , self . item_models . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . item_models . data , msg . item_models . size) ; for (t , s) in slice . iter_mut () . zip (& self . item_models) { s . copy_to_native (t) ; } } self . robot_pose . copy_to_native (& mut msg . robot_pose) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub timestamp : builtin_interfaces :: msg :: Time , pub items : Vec < rc_reason_msgs :: msg :: Item > , pub load_carriers : Vec < rc_reason_msgs :: msg :: LoadCarrier > , pub return_code : rc_common_msgs :: msg :: ReturnCode } impl WrappedTypesupport for Response { type CStruct = rc_reason_msgs__srv__DetectItems_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rc_reason_msgs__srv__DetectItems_Response () } } fn create_msg () -> * mut rc_reason_msgs__srv__DetectItems_Response { unsafe { rc_reason_msgs__srv__DetectItems_Response__create () } } fn destroy_msg (msg : * mut rc_reason_msgs__srv__DetectItems_Response) -> () { unsafe { rc_reason_msgs__srv__DetectItems_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { timestamp : builtin_interfaces :: msg :: Time :: from_native (& msg . timestamp) , items : { let mut temp = Vec :: with_capacity (msg . items . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . items . data , msg . items . size) } ; for s in slice { temp . push (rc_reason_msgs :: msg :: Item :: from_native (s)) ; } temp } , load_carriers : { let mut temp = Vec :: with_capacity (msg . load_carriers . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . load_carriers . data , msg . load_carriers . size) } ; for s in slice { temp . push (rc_reason_msgs :: msg :: LoadCarrier :: from_native (s)) ; } temp } , return_code : rc_common_msgs :: msg :: ReturnCode :: from_native (& msg . return_code) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . timestamp . copy_to_native (& mut msg . timestamp) ; unsafe { rc_reason_msgs__msg__Item__Sequence__fini (& mut msg . items) ; rc_reason_msgs__msg__Item__Sequence__init (& mut msg . items , self . items . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . items . data , msg . items . size) ; for (t , s) in slice . iter_mut () . zip (& self . items) { s . copy_to_native (t) ; } } unsafe { rc_reason_msgs__msg__LoadCarrier__Sequence__fini (& mut msg . load_carriers) ; rc_reason_msgs__msg__LoadCarrier__Sequence__init (& mut msg . load_carriers , self . load_carriers . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . load_carriers . data , msg . load_carriers . size) ; for (t , s) in slice . iter_mut () . zip (& self . load_carriers) { s . copy_to_native (t) ; } } self . return_code . copy_to_native (& mut msg . return_code) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod DetectLoadCarriers { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__rc_reason_msgs__srv__DetectLoadCarriers () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub pose_frame : std :: string :: String , pub region_of_interest_id : std :: string :: String , pub region_of_interest_2d_id : std :: string :: String , pub load_carrier_ids : Vec < std :: string :: String > , pub robot_pose : geometry_msgs :: msg :: Pose } impl WrappedTypesupport for Request { type CStruct = rc_reason_msgs__srv__DetectLoadCarriers_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rc_reason_msgs__srv__DetectLoadCarriers_Request () } } fn create_msg () -> * mut rc_reason_msgs__srv__DetectLoadCarriers_Request { unsafe { rc_reason_msgs__srv__DetectLoadCarriers_Request__create () } } fn destroy_msg (msg : * mut rc_reason_msgs__srv__DetectLoadCarriers_Request) -> () { unsafe { rc_reason_msgs__srv__DetectLoadCarriers_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { pose_frame : msg . pose_frame . to_str () . to_owned () , region_of_interest_id : msg . region_of_interest_id . to_str () . to_owned () , region_of_interest_2d_id : msg . region_of_interest_2d_id . to_str () . to_owned () , load_carrier_ids : msg . load_carrier_ids . to_vec () , robot_pose : geometry_msgs :: msg :: Pose :: from_native (& msg . robot_pose) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . pose_frame . assign (& self . pose_frame) ; msg . region_of_interest_id . assign (& self . region_of_interest_id) ; msg . region_of_interest_2d_id . assign (& self . region_of_interest_2d_id) ; msg . load_carrier_ids . update (& self . load_carrier_ids) ; self . robot_pose . copy_to_native (& mut msg . robot_pose) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub timestamp : builtin_interfaces :: msg :: Time , pub load_carriers : Vec < rc_reason_msgs :: msg :: LoadCarrier > , pub return_code : rc_common_msgs :: msg :: ReturnCode } impl WrappedTypesupport for Response { type CStruct = rc_reason_msgs__srv__DetectLoadCarriers_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rc_reason_msgs__srv__DetectLoadCarriers_Response () } } fn create_msg () -> * mut rc_reason_msgs__srv__DetectLoadCarriers_Response { unsafe { rc_reason_msgs__srv__DetectLoadCarriers_Response__create () } } fn destroy_msg (msg : * mut rc_reason_msgs__srv__DetectLoadCarriers_Response) -> () { unsafe { rc_reason_msgs__srv__DetectLoadCarriers_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { timestamp : builtin_interfaces :: msg :: Time :: from_native (& msg . timestamp) , load_carriers : { let mut temp = Vec :: with_capacity (msg . load_carriers . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . load_carriers . data , msg . load_carriers . size) } ; for s in slice { temp . push (rc_reason_msgs :: msg :: LoadCarrier :: from_native (s)) ; } temp } , return_code : rc_common_msgs :: msg :: ReturnCode :: from_native (& msg . return_code) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . timestamp . copy_to_native (& mut msg . timestamp) ; unsafe { rc_reason_msgs__msg__LoadCarrier__Sequence__fini (& mut msg . load_carriers) ; rc_reason_msgs__msg__LoadCarrier__Sequence__init (& mut msg . load_carriers , self . load_carriers . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . load_carriers . data , msg . load_carriers . size) ; for (t , s) in slice . iter_mut () . zip (& self . load_carriers) { s . copy_to_native (t) ; } } self . return_code . copy_to_native (& mut msg . return_code) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod DetectTags { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__rc_reason_msgs__srv__DetectTags () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub tags : Vec < rc_reason_msgs :: msg :: Tag > , pub pose_frame : std :: string :: String , pub robot_pose : geometry_msgs :: msg :: Pose } impl WrappedTypesupport for Request { type CStruct = rc_reason_msgs__srv__DetectTags_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rc_reason_msgs__srv__DetectTags_Request () } } fn create_msg () -> * mut rc_reason_msgs__srv__DetectTags_Request { unsafe { rc_reason_msgs__srv__DetectTags_Request__create () } } fn destroy_msg (msg : * mut rc_reason_msgs__srv__DetectTags_Request) -> () { unsafe { rc_reason_msgs__srv__DetectTags_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { tags : { let mut temp = Vec :: with_capacity (msg . tags . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . tags . data , msg . tags . size) } ; for s in slice { temp . push (rc_reason_msgs :: msg :: Tag :: from_native (s)) ; } temp } , pose_frame : msg . pose_frame . to_str () . to_owned () , robot_pose : geometry_msgs :: msg :: Pose :: from_native (& msg . robot_pose) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { unsafe { rc_reason_msgs__msg__Tag__Sequence__fini (& mut msg . tags) ; rc_reason_msgs__msg__Tag__Sequence__init (& mut msg . tags , self . tags . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . tags . data , msg . tags . size) ; for (t , s) in slice . iter_mut () . zip (& self . tags) { s . copy_to_native (t) ; } } msg . pose_frame . assign (& self . pose_frame) ; self . robot_pose . copy_to_native (& mut msg . robot_pose) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub tags : Vec < rc_reason_msgs :: msg :: DetectedTag > , pub timestamp : builtin_interfaces :: msg :: Time , pub return_code : rc_common_msgs :: msg :: ReturnCode } impl WrappedTypesupport for Response { type CStruct = rc_reason_msgs__srv__DetectTags_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rc_reason_msgs__srv__DetectTags_Response () } } fn create_msg () -> * mut rc_reason_msgs__srv__DetectTags_Response { unsafe { rc_reason_msgs__srv__DetectTags_Response__create () } } fn destroy_msg (msg : * mut rc_reason_msgs__srv__DetectTags_Response) -> () { unsafe { rc_reason_msgs__srv__DetectTags_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { tags : { let mut temp = Vec :: with_capacity (msg . tags . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . tags . data , msg . tags . size) } ; for s in slice { temp . push (rc_reason_msgs :: msg :: DetectedTag :: from_native (s)) ; } temp } , timestamp : builtin_interfaces :: msg :: Time :: from_native (& msg . timestamp) , return_code : rc_common_msgs :: msg :: ReturnCode :: from_native (& msg . return_code) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { unsafe { rc_reason_msgs__msg__DetectedTag__Sequence__fini (& mut msg . tags) ; rc_reason_msgs__msg__DetectedTag__Sequence__init (& mut msg . tags , self . tags . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . tags . data , msg . tags . size) ; for (t , s) in slice . iter_mut () . zip (& self . tags) { s . copy_to_native (t) ; } } self . timestamp . copy_to_native (& mut msg . timestamp) ; self . return_code . copy_to_native (& mut msg . return_code) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetBasePlaneCalibration { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__rc_reason_msgs__srv__GetBasePlaneCalibration () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub pose_frame : std :: string :: String , pub robot_pose : geometry_msgs :: msg :: Pose } impl WrappedTypesupport for Request { type CStruct = rc_reason_msgs__srv__GetBasePlaneCalibration_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rc_reason_msgs__srv__GetBasePlaneCalibration_Request () } } fn create_msg () -> * mut rc_reason_msgs__srv__GetBasePlaneCalibration_Request { unsafe { rc_reason_msgs__srv__GetBasePlaneCalibration_Request__create () } } fn destroy_msg (msg : * mut rc_reason_msgs__srv__GetBasePlaneCalibration_Request) -> () { unsafe { rc_reason_msgs__srv__GetBasePlaneCalibration_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { pose_frame : msg . pose_frame . to_str () . to_owned () , robot_pose : geometry_msgs :: msg :: Pose :: from_native (& msg . robot_pose) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . pose_frame . assign (& self . pose_frame) ; self . robot_pose . copy_to_native (& mut msg . robot_pose) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub pose_frame : std :: string :: String , pub plane : shape_msgs :: msg :: Plane , pub return_code : rc_common_msgs :: msg :: ReturnCode } impl WrappedTypesupport for Response { type CStruct = rc_reason_msgs__srv__GetBasePlaneCalibration_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rc_reason_msgs__srv__GetBasePlaneCalibration_Response () } } fn create_msg () -> * mut rc_reason_msgs__srv__GetBasePlaneCalibration_Response { unsafe { rc_reason_msgs__srv__GetBasePlaneCalibration_Response__create () } } fn destroy_msg (msg : * mut rc_reason_msgs__srv__GetBasePlaneCalibration_Response) -> () { unsafe { rc_reason_msgs__srv__GetBasePlaneCalibration_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { pose_frame : msg . pose_frame . to_str () . to_owned () , plane : shape_msgs :: msg :: Plane :: from_native (& msg . plane) , return_code : rc_common_msgs :: msg :: ReturnCode :: from_native (& msg . return_code) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . pose_frame . assign (& self . pose_frame) ; self . plane . copy_to_native (& mut msg . plane) ; self . return_code . copy_to_native (& mut msg . return_code) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetLoadCarriers { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__rc_reason_msgs__srv__GetLoadCarriers () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub load_carrier_ids : Vec < std :: string :: String > } impl WrappedTypesupport for Request { type CStruct = rc_reason_msgs__srv__GetLoadCarriers_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rc_reason_msgs__srv__GetLoadCarriers_Request () } } fn create_msg () -> * mut rc_reason_msgs__srv__GetLoadCarriers_Request { unsafe { rc_reason_msgs__srv__GetLoadCarriers_Request__create () } } fn destroy_msg (msg : * mut rc_reason_msgs__srv__GetLoadCarriers_Request) -> () { unsafe { rc_reason_msgs__srv__GetLoadCarriers_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { load_carrier_ids : msg . load_carrier_ids . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . load_carrier_ids . update (& self . load_carrier_ids) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub load_carriers : Vec < rc_reason_msgs :: msg :: LoadCarrierModel > , pub return_code : rc_common_msgs :: msg :: ReturnCode } impl WrappedTypesupport for Response { type CStruct = rc_reason_msgs__srv__GetLoadCarriers_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rc_reason_msgs__srv__GetLoadCarriers_Response () } } fn create_msg () -> * mut rc_reason_msgs__srv__GetLoadCarriers_Response { unsafe { rc_reason_msgs__srv__GetLoadCarriers_Response__create () } } fn destroy_msg (msg : * mut rc_reason_msgs__srv__GetLoadCarriers_Response) -> () { unsafe { rc_reason_msgs__srv__GetLoadCarriers_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { load_carriers : { let mut temp = Vec :: with_capacity (msg . load_carriers . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . load_carriers . data , msg . load_carriers . size) } ; for s in slice { temp . push (rc_reason_msgs :: msg :: LoadCarrierModel :: from_native (s)) ; } temp } , return_code : rc_common_msgs :: msg :: ReturnCode :: from_native (& msg . return_code) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { unsafe { rc_reason_msgs__msg__LoadCarrierModel__Sequence__fini (& mut msg . load_carriers) ; rc_reason_msgs__msg__LoadCarrierModel__Sequence__init (& mut msg . load_carriers , self . load_carriers . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . load_carriers . data , msg . load_carriers . size) ; for (t , s) in slice . iter_mut () . zip (& self . load_carriers) { s . copy_to_native (t) ; } } self . return_code . copy_to_native (& mut msg . return_code) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetRegionsOfInterest2D { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__rc_reason_msgs__srv__GetRegionsOfInterest2D () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub region_of_interest_2d_ids : Vec < std :: string :: String > } impl WrappedTypesupport for Request { type CStruct = rc_reason_msgs__srv__GetRegionsOfInterest2D_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rc_reason_msgs__srv__GetRegionsOfInterest2D_Request () } } fn create_msg () -> * mut rc_reason_msgs__srv__GetRegionsOfInterest2D_Request { unsafe { rc_reason_msgs__srv__GetRegionsOfInterest2D_Request__create () } } fn destroy_msg (msg : * mut rc_reason_msgs__srv__GetRegionsOfInterest2D_Request) -> () { unsafe { rc_reason_msgs__srv__GetRegionsOfInterest2D_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { region_of_interest_2d_ids : msg . region_of_interest_2d_ids . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . region_of_interest_2d_ids . update (& self . region_of_interest_2d_ids) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub regions_of_interest : Vec < rc_reason_msgs :: msg :: RegionOfInterest2D > , pub return_code : rc_common_msgs :: msg :: ReturnCode } impl WrappedTypesupport for Response { type CStruct = rc_reason_msgs__srv__GetRegionsOfInterest2D_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rc_reason_msgs__srv__GetRegionsOfInterest2D_Response () } } fn create_msg () -> * mut rc_reason_msgs__srv__GetRegionsOfInterest2D_Response { unsafe { rc_reason_msgs__srv__GetRegionsOfInterest2D_Response__create () } } fn destroy_msg (msg : * mut rc_reason_msgs__srv__GetRegionsOfInterest2D_Response) -> () { unsafe { rc_reason_msgs__srv__GetRegionsOfInterest2D_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { regions_of_interest : { let mut temp = Vec :: with_capacity (msg . regions_of_interest . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . regions_of_interest . data , msg . regions_of_interest . size) } ; for s in slice { temp . push (rc_reason_msgs :: msg :: RegionOfInterest2D :: from_native (s)) ; } temp } , return_code : rc_common_msgs :: msg :: ReturnCode :: from_native (& msg . return_code) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { unsafe { rc_reason_msgs__msg__RegionOfInterest2D__Sequence__fini (& mut msg . regions_of_interest) ; rc_reason_msgs__msg__RegionOfInterest2D__Sequence__init (& mut msg . regions_of_interest , self . regions_of_interest . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . regions_of_interest . data , msg . regions_of_interest . size) ; for (t , s) in slice . iter_mut () . zip (& self . regions_of_interest) { s . copy_to_native (t) ; } } self . return_code . copy_to_native (& mut msg . return_code) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetRegionsOfInterest3D { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__rc_reason_msgs__srv__GetRegionsOfInterest3D () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub region_of_interest_ids : Vec < std :: string :: String > } impl WrappedTypesupport for Request { type CStruct = rc_reason_msgs__srv__GetRegionsOfInterest3D_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rc_reason_msgs__srv__GetRegionsOfInterest3D_Request () } } fn create_msg () -> * mut rc_reason_msgs__srv__GetRegionsOfInterest3D_Request { unsafe { rc_reason_msgs__srv__GetRegionsOfInterest3D_Request__create () } } fn destroy_msg (msg : * mut rc_reason_msgs__srv__GetRegionsOfInterest3D_Request) -> () { unsafe { rc_reason_msgs__srv__GetRegionsOfInterest3D_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { region_of_interest_ids : msg . region_of_interest_ids . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . region_of_interest_ids . update (& self . region_of_interest_ids) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub regions_of_interest : Vec < rc_reason_msgs :: msg :: RegionOfInterest3D > , pub return_code : rc_common_msgs :: msg :: ReturnCode } impl WrappedTypesupport for Response { type CStruct = rc_reason_msgs__srv__GetRegionsOfInterest3D_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rc_reason_msgs__srv__GetRegionsOfInterest3D_Response () } } fn create_msg () -> * mut rc_reason_msgs__srv__GetRegionsOfInterest3D_Response { unsafe { rc_reason_msgs__srv__GetRegionsOfInterest3D_Response__create () } } fn destroy_msg (msg : * mut rc_reason_msgs__srv__GetRegionsOfInterest3D_Response) -> () { unsafe { rc_reason_msgs__srv__GetRegionsOfInterest3D_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { regions_of_interest : { let mut temp = Vec :: with_capacity (msg . regions_of_interest . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . regions_of_interest . data , msg . regions_of_interest . size) } ; for s in slice { temp . push (rc_reason_msgs :: msg :: RegionOfInterest3D :: from_native (s)) ; } temp } , return_code : rc_common_msgs :: msg :: ReturnCode :: from_native (& msg . return_code) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { unsafe { rc_reason_msgs__msg__RegionOfInterest3D__Sequence__fini (& mut msg . regions_of_interest) ; rc_reason_msgs__msg__RegionOfInterest3D__Sequence__init (& mut msg . regions_of_interest , self . regions_of_interest . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . regions_of_interest . data , msg . regions_of_interest . size) ; for (t , s) in slice . iter_mut () . zip (& self . regions_of_interest) { s . copy_to_native (t) ; } } self . return_code . copy_to_native (& mut msg . return_code) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod HandEyeCalibration { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__rc_reason_msgs__srv__HandEyeCalibration () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { } impl WrappedTypesupport for Request { type CStruct = rc_reason_msgs__srv__HandEyeCalibration_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rc_reason_msgs__srv__HandEyeCalibration_Request () } } fn create_msg () -> * mut rc_reason_msgs__srv__HandEyeCalibration_Request { unsafe { rc_reason_msgs__srv__HandEyeCalibration_Request__create () } } fn destroy_msg (msg : * mut rc_reason_msgs__srv__HandEyeCalibration_Request) -> () { unsafe { rc_reason_msgs__srv__HandEyeCalibration_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool , pub status : i32 , pub message : std :: string :: String , pub pose : geometry_msgs :: msg :: Pose , pub error : f64 , pub translation_error_meter : f64 , pub rotation_error_degree : f64 , pub robot_mounted : bool } impl WrappedTypesupport for Response { type CStruct = rc_reason_msgs__srv__HandEyeCalibration_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rc_reason_msgs__srv__HandEyeCalibration_Response () } } fn create_msg () -> * mut rc_reason_msgs__srv__HandEyeCalibration_Response { unsafe { rc_reason_msgs__srv__HandEyeCalibration_Response__create () } } fn destroy_msg (msg : * mut rc_reason_msgs__srv__HandEyeCalibration_Response) -> () { unsafe { rc_reason_msgs__srv__HandEyeCalibration_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , status : msg . status , message : msg . message . to_str () . to_owned () , pose : geometry_msgs :: msg :: Pose :: from_native (& msg . pose) , error : msg . error , translation_error_meter : msg . translation_error_meter , rotation_error_degree : msg . rotation_error_degree , robot_mounted : msg . robot_mounted , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; msg . status = self . status ; msg . message . assign (& self . message) ; self . pose . copy_to_native (& mut msg . pose) ; msg . error = self . error ; msg . translation_error_meter = self . translation_error_meter ; msg . rotation_error_degree = self . rotation_error_degree ; msg . robot_mounted = self . robot_mounted ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod HandEyeCalibrationTrigger { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__rc_reason_msgs__srv__HandEyeCalibrationTrigger () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { } impl WrappedTypesupport for Request { type CStruct = rc_reason_msgs__srv__HandEyeCalibrationTrigger_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rc_reason_msgs__srv__HandEyeCalibrationTrigger_Request () } } fn create_msg () -> * mut rc_reason_msgs__srv__HandEyeCalibrationTrigger_Request { unsafe { rc_reason_msgs__srv__HandEyeCalibrationTrigger_Request__create () } } fn destroy_msg (msg : * mut rc_reason_msgs__srv__HandEyeCalibrationTrigger_Request) -> () { unsafe { rc_reason_msgs__srv__HandEyeCalibrationTrigger_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool , pub status : i32 , pub message : std :: string :: String } impl WrappedTypesupport for Response { type CStruct = rc_reason_msgs__srv__HandEyeCalibrationTrigger_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rc_reason_msgs__srv__HandEyeCalibrationTrigger_Response () } } fn create_msg () -> * mut rc_reason_msgs__srv__HandEyeCalibrationTrigger_Response { unsafe { rc_reason_msgs__srv__HandEyeCalibrationTrigger_Response__create () } } fn destroy_msg (msg : * mut rc_reason_msgs__srv__HandEyeCalibrationTrigger_Response) -> () { unsafe { rc_reason_msgs__srv__HandEyeCalibrationTrigger_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , status : msg . status , message : msg . message . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; msg . status = self . status ; msg . message . assign (& self . message) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod SetHandEyeCalibration { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__rc_reason_msgs__srv__SetHandEyeCalibration () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub pose : geometry_msgs :: msg :: Pose , pub robot_mounted : bool } impl WrappedTypesupport for Request { type CStruct = rc_reason_msgs__srv__SetHandEyeCalibration_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rc_reason_msgs__srv__SetHandEyeCalibration_Request () } } fn create_msg () -> * mut rc_reason_msgs__srv__SetHandEyeCalibration_Request { unsafe { rc_reason_msgs__srv__SetHandEyeCalibration_Request__create () } } fn destroy_msg (msg : * mut rc_reason_msgs__srv__SetHandEyeCalibration_Request) -> () { unsafe { rc_reason_msgs__srv__SetHandEyeCalibration_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { pose : geometry_msgs :: msg :: Pose :: from_native (& msg . pose) , robot_mounted : msg . robot_mounted , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . pose . copy_to_native (& mut msg . pose) ; msg . robot_mounted = self . robot_mounted ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool , pub status : i32 , pub message : std :: string :: String } impl WrappedTypesupport for Response { type CStruct = rc_reason_msgs__srv__SetHandEyeCalibration_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rc_reason_msgs__srv__SetHandEyeCalibration_Response () } } fn create_msg () -> * mut rc_reason_msgs__srv__SetHandEyeCalibration_Response { unsafe { rc_reason_msgs__srv__SetHandEyeCalibration_Response__create () } } fn destroy_msg (msg : * mut rc_reason_msgs__srv__SetHandEyeCalibration_Response) -> () { unsafe { rc_reason_msgs__srv__SetHandEyeCalibration_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , status : msg . status , message : msg . message . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; msg . status = self . status ; msg . message . assign (& self . message) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod SetHandEyeCalibrationPose { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__rc_reason_msgs__srv__SetHandEyeCalibrationPose () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub slot : i32 , pub pose : geometry_msgs :: msg :: Pose } impl WrappedTypesupport for Request { type CStruct = rc_reason_msgs__srv__SetHandEyeCalibrationPose_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rc_reason_msgs__srv__SetHandEyeCalibrationPose_Request () } } fn create_msg () -> * mut rc_reason_msgs__srv__SetHandEyeCalibrationPose_Request { unsafe { rc_reason_msgs__srv__SetHandEyeCalibrationPose_Request__create () } } fn destroy_msg (msg : * mut rc_reason_msgs__srv__SetHandEyeCalibrationPose_Request) -> () { unsafe { rc_reason_msgs__srv__SetHandEyeCalibrationPose_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { slot : msg . slot , pose : geometry_msgs :: msg :: Pose :: from_native (& msg . pose) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . slot = self . slot ; self . pose . copy_to_native (& mut msg . pose) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool , pub status : i32 , pub message : std :: string :: String } impl WrappedTypesupport for Response { type CStruct = rc_reason_msgs__srv__SetHandEyeCalibrationPose_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rc_reason_msgs__srv__SetHandEyeCalibrationPose_Response () } } fn create_msg () -> * mut rc_reason_msgs__srv__SetHandEyeCalibrationPose_Response { unsafe { rc_reason_msgs__srv__SetHandEyeCalibrationPose_Response__create () } } fn destroy_msg (msg : * mut rc_reason_msgs__srv__SetHandEyeCalibrationPose_Response) -> () { unsafe { rc_reason_msgs__srv__SetHandEyeCalibrationPose_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , status : msg . status , message : msg . message . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; msg . status = self . status ; msg . message . assign (& self . message) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod SetLoadCarrier { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__rc_reason_msgs__srv__SetLoadCarrier () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub load_carrier : rc_reason_msgs :: msg :: LoadCarrierModel } impl WrappedTypesupport for Request { type CStruct = rc_reason_msgs__srv__SetLoadCarrier_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rc_reason_msgs__srv__SetLoadCarrier_Request () } } fn create_msg () -> * mut rc_reason_msgs__srv__SetLoadCarrier_Request { unsafe { rc_reason_msgs__srv__SetLoadCarrier_Request__create () } } fn destroy_msg (msg : * mut rc_reason_msgs__srv__SetLoadCarrier_Request) -> () { unsafe { rc_reason_msgs__srv__SetLoadCarrier_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { load_carrier : rc_reason_msgs :: msg :: LoadCarrierModel :: from_native (& msg . load_carrier) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . load_carrier . copy_to_native (& mut msg . load_carrier) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub return_code : rc_common_msgs :: msg :: ReturnCode } impl WrappedTypesupport for Response { type CStruct = rc_reason_msgs__srv__SetLoadCarrier_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rc_reason_msgs__srv__SetLoadCarrier_Response () } } fn create_msg () -> * mut rc_reason_msgs__srv__SetLoadCarrier_Response { unsafe { rc_reason_msgs__srv__SetLoadCarrier_Response__create () } } fn destroy_msg (msg : * mut rc_reason_msgs__srv__SetLoadCarrier_Response) -> () { unsafe { rc_reason_msgs__srv__SetLoadCarrier_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { return_code : rc_common_msgs :: msg :: ReturnCode :: from_native (& msg . return_code) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . return_code . copy_to_native (& mut msg . return_code) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod SetRegionOfInterest2D { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__rc_reason_msgs__srv__SetRegionOfInterest2D () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub region_of_interest_2d : rc_reason_msgs :: msg :: RegionOfInterest2D } impl WrappedTypesupport for Request { type CStruct = rc_reason_msgs__srv__SetRegionOfInterest2D_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rc_reason_msgs__srv__SetRegionOfInterest2D_Request () } } fn create_msg () -> * mut rc_reason_msgs__srv__SetRegionOfInterest2D_Request { unsafe { rc_reason_msgs__srv__SetRegionOfInterest2D_Request__create () } } fn destroy_msg (msg : * mut rc_reason_msgs__srv__SetRegionOfInterest2D_Request) -> () { unsafe { rc_reason_msgs__srv__SetRegionOfInterest2D_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { region_of_interest_2d : rc_reason_msgs :: msg :: RegionOfInterest2D :: from_native (& msg . region_of_interest_2d) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . region_of_interest_2d . copy_to_native (& mut msg . region_of_interest_2d) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub return_code : rc_common_msgs :: msg :: ReturnCode } impl WrappedTypesupport for Response { type CStruct = rc_reason_msgs__srv__SetRegionOfInterest2D_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rc_reason_msgs__srv__SetRegionOfInterest2D_Response () } } fn create_msg () -> * mut rc_reason_msgs__srv__SetRegionOfInterest2D_Response { unsafe { rc_reason_msgs__srv__SetRegionOfInterest2D_Response__create () } } fn destroy_msg (msg : * mut rc_reason_msgs__srv__SetRegionOfInterest2D_Response) -> () { unsafe { rc_reason_msgs__srv__SetRegionOfInterest2D_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { return_code : rc_common_msgs :: msg :: ReturnCode :: from_native (& msg . return_code) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . return_code . copy_to_native (& mut msg . return_code) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod SetRegionOfInterest3D { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__rc_reason_msgs__srv__SetRegionOfInterest3D () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub region_of_interest : rc_reason_msgs :: msg :: RegionOfInterest3D } impl WrappedTypesupport for Request { type CStruct = rc_reason_msgs__srv__SetRegionOfInterest3D_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rc_reason_msgs__srv__SetRegionOfInterest3D_Request () } } fn create_msg () -> * mut rc_reason_msgs__srv__SetRegionOfInterest3D_Request { unsafe { rc_reason_msgs__srv__SetRegionOfInterest3D_Request__create () } } fn destroy_msg (msg : * mut rc_reason_msgs__srv__SetRegionOfInterest3D_Request) -> () { unsafe { rc_reason_msgs__srv__SetRegionOfInterest3D_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { region_of_interest : rc_reason_msgs :: msg :: RegionOfInterest3D :: from_native (& msg . region_of_interest) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . region_of_interest . copy_to_native (& mut msg . region_of_interest) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub return_code : rc_common_msgs :: msg :: ReturnCode } impl WrappedTypesupport for Response { type CStruct = rc_reason_msgs__srv__SetRegionOfInterest3D_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rc_reason_msgs__srv__SetRegionOfInterest3D_Response () } } fn create_msg () -> * mut rc_reason_msgs__srv__SetRegionOfInterest3D_Response { unsafe { rc_reason_msgs__srv__SetRegionOfInterest3D_Response__create () } } fn destroy_msg (msg : * mut rc_reason_msgs__srv__SetRegionOfInterest3D_Response) -> () { unsafe { rc_reason_msgs__srv__SetRegionOfInterest3D_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { return_code : rc_common_msgs :: msg :: ReturnCode :: from_native (& msg . return_code) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . return_code . copy_to_native (& mut msg . return_code) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod SilhouetteMatchDetectObject { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__rc_reason_msgs__srv__SilhouetteMatchDetectObject () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub object_to_detect : rc_reason_msgs :: msg :: SilhouetteMatchObject , pub offset : f64 , pub pose_frame : std :: string :: String , pub robot_pose : geometry_msgs :: msg :: Pose , pub load_carrier_id : std :: string :: String , pub collision_detection : rc_reason_msgs :: msg :: CollisionDetection } impl WrappedTypesupport for Request { type CStruct = rc_reason_msgs__srv__SilhouetteMatchDetectObject_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rc_reason_msgs__srv__SilhouetteMatchDetectObject_Request () } } fn create_msg () -> * mut rc_reason_msgs__srv__SilhouetteMatchDetectObject_Request { unsafe { rc_reason_msgs__srv__SilhouetteMatchDetectObject_Request__create () } } fn destroy_msg (msg : * mut rc_reason_msgs__srv__SilhouetteMatchDetectObject_Request) -> () { unsafe { rc_reason_msgs__srv__SilhouetteMatchDetectObject_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { object_to_detect : rc_reason_msgs :: msg :: SilhouetteMatchObject :: from_native (& msg . object_to_detect) , offset : msg . offset , pose_frame : msg . pose_frame . to_str () . to_owned () , robot_pose : geometry_msgs :: msg :: Pose :: from_native (& msg . robot_pose) , load_carrier_id : msg . load_carrier_id . to_str () . to_owned () , collision_detection : rc_reason_msgs :: msg :: CollisionDetection :: from_native (& msg . collision_detection) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . object_to_detect . copy_to_native (& mut msg . object_to_detect) ; msg . offset = self . offset ; msg . pose_frame . assign (& self . pose_frame) ; self . robot_pose . copy_to_native (& mut msg . robot_pose) ; msg . load_carrier_id . assign (& self . load_carrier_id) ; self . collision_detection . copy_to_native (& mut msg . collision_detection) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub timestamp : builtin_interfaces :: msg :: Time , pub matches : Vec < rc_reason_msgs :: msg :: Match > , pub grasps : Vec < rc_reason_msgs :: msg :: Grasp > , pub load_carriers : Vec < rc_reason_msgs :: msg :: LoadCarrier > , pub return_code : rc_common_msgs :: msg :: ReturnCode } impl WrappedTypesupport for Response { type CStruct = rc_reason_msgs__srv__SilhouetteMatchDetectObject_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rc_reason_msgs__srv__SilhouetteMatchDetectObject_Response () } } fn create_msg () -> * mut rc_reason_msgs__srv__SilhouetteMatchDetectObject_Response { unsafe { rc_reason_msgs__srv__SilhouetteMatchDetectObject_Response__create () } } fn destroy_msg (msg : * mut rc_reason_msgs__srv__SilhouetteMatchDetectObject_Response) -> () { unsafe { rc_reason_msgs__srv__SilhouetteMatchDetectObject_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { timestamp : builtin_interfaces :: msg :: Time :: from_native (& msg . timestamp) , matches : { let mut temp = Vec :: with_capacity (msg . matches . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . matches . data , msg . matches . size) } ; for s in slice { temp . push (rc_reason_msgs :: msg :: Match :: from_native (s)) ; } temp } , grasps : { let mut temp = Vec :: with_capacity (msg . grasps . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . grasps . data , msg . grasps . size) } ; for s in slice { temp . push (rc_reason_msgs :: msg :: Grasp :: from_native (s)) ; } temp } , load_carriers : { let mut temp = Vec :: with_capacity (msg . load_carriers . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . load_carriers . data , msg . load_carriers . size) } ; for s in slice { temp . push (rc_reason_msgs :: msg :: LoadCarrier :: from_native (s)) ; } temp } , return_code : rc_common_msgs :: msg :: ReturnCode :: from_native (& msg . return_code) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . timestamp . copy_to_native (& mut msg . timestamp) ; unsafe { rc_reason_msgs__msg__Match__Sequence__fini (& mut msg . matches) ; rc_reason_msgs__msg__Match__Sequence__init (& mut msg . matches , self . matches . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . matches . data , msg . matches . size) ; for (t , s) in slice . iter_mut () . zip (& self . matches) { s . copy_to_native (t) ; } } unsafe { rc_reason_msgs__msg__Grasp__Sequence__fini (& mut msg . grasps) ; rc_reason_msgs__msg__Grasp__Sequence__init (& mut msg . grasps , self . grasps . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . grasps . data , msg . grasps . size) ; for (t , s) in slice . iter_mut () . zip (& self . grasps) { s . copy_to_native (t) ; } } unsafe { rc_reason_msgs__msg__LoadCarrier__Sequence__fini (& mut msg . load_carriers) ; rc_reason_msgs__msg__LoadCarrier__Sequence__init (& mut msg . load_carriers , self . load_carriers . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . load_carriers . data , msg . load_carriers . size) ; for (t , s) in slice . iter_mut () . zip (& self . load_carriers) { s . copy_to_native (t) ; } } self . return_code . copy_to_native (& mut msg . return_code) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } }