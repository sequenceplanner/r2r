pub mod srv { # [allow (non_snake_case)] pub mod AppendEntries { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__foros_msgs__srv__AppendEntries () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub term : u64 , pub leader_id : u32 , pub prev_log_index : u64 , pub prev_log_term : u64 , pub entries : Vec < u8 > , pub leader_commit : u64 } impl WrappedTypesupport for Request { type CStruct = foros_msgs__srv__AppendEntries_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__foros_msgs__srv__AppendEntries_Request () } } fn create_msg () -> * mut foros_msgs__srv__AppendEntries_Request { unsafe { foros_msgs__srv__AppendEntries_Request__create () } } fn destroy_msg (msg : * mut foros_msgs__srv__AppendEntries_Request) -> () { unsafe { foros_msgs__srv__AppendEntries_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { term : msg . term , leader_id : msg . leader_id , prev_log_index : msg . prev_log_index , prev_log_term : msg . prev_log_term , entries : msg . entries . to_vec () , leader_commit : msg . leader_commit , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . term = self . term ; msg . leader_id = self . leader_id ; msg . prev_log_index = self . prev_log_index ; msg . prev_log_term = self . prev_log_term ; msg . entries . update (& self . entries) ; msg . leader_commit = self . leader_commit ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub term : u64 , pub success : bool } impl WrappedTypesupport for Response { type CStruct = foros_msgs__srv__AppendEntries_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__foros_msgs__srv__AppendEntries_Response () } } fn create_msg () -> * mut foros_msgs__srv__AppendEntries_Response { unsafe { foros_msgs__srv__AppendEntries_Response__create () } } fn destroy_msg (msg : * mut foros_msgs__srv__AppendEntries_Response) -> () { unsafe { foros_msgs__srv__AppendEntries_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { term : msg . term , success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . term = self . term ; msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod RequestVote { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__foros_msgs__srv__RequestVote () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub term : u64 , pub candidate_id : u32 , pub last_data_index : u64 , pub loat_data_term : u64 } impl WrappedTypesupport for Request { type CStruct = foros_msgs__srv__RequestVote_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__foros_msgs__srv__RequestVote_Request () } } fn create_msg () -> * mut foros_msgs__srv__RequestVote_Request { unsafe { foros_msgs__srv__RequestVote_Request__create () } } fn destroy_msg (msg : * mut foros_msgs__srv__RequestVote_Request) -> () { unsafe { foros_msgs__srv__RequestVote_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { term : msg . term , candidate_id : msg . candidate_id , last_data_index : msg . last_data_index , loat_data_term : msg . loat_data_term , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . term = self . term ; msg . candidate_id = self . candidate_id ; msg . last_data_index = self . last_data_index ; msg . loat_data_term = self . loat_data_term ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub term : u64 , pub vote_granted : bool } impl WrappedTypesupport for Response { type CStruct = foros_msgs__srv__RequestVote_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__foros_msgs__srv__RequestVote_Response () } } fn create_msg () -> * mut foros_msgs__srv__RequestVote_Response { unsafe { foros_msgs__srv__RequestVote_Response__create () } } fn destroy_msg (msg : * mut foros_msgs__srv__RequestVote_Response) -> () { unsafe { foros_msgs__srv__RequestVote_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { term : msg . term , vote_granted : msg . vote_granted , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . term = self . term ; msg . vote_granted = self . vote_granted ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } } pub mod msg { use super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Inspector { pub stamp : builtin_interfaces :: msg :: Time , pub cluster_name : std :: string :: String , pub cluster_size : u32 , pub id : u32 , pub state : u8 , pub term : u64 , pub data_size : u64 , pub voted_for : u32 } impl WrappedTypesupport for Inspector { type CStruct = foros_msgs__msg__Inspector ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__foros_msgs__msg__Inspector () } } fn create_msg () -> * mut foros_msgs__msg__Inspector { unsafe { foros_msgs__msg__Inspector__create () } } fn destroy_msg (msg : * mut foros_msgs__msg__Inspector) -> () { unsafe { foros_msgs__msg__Inspector__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Inspector { Inspector { stamp : builtin_interfaces :: msg :: Time :: from_native (& msg . stamp) , cluster_name : msg . cluster_name . to_str () . to_owned () , cluster_size : msg . cluster_size , id : msg . id , state : msg . state , term : msg . term , data_size : msg . data_size , voted_for : msg . voted_for , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . stamp . copy_to_native (& mut msg . stamp) ; msg . cluster_name . assign (& self . cluster_name) ; msg . cluster_size = self . cluster_size ; msg . id = self . id ; msg . state = self . state ; msg . term = self . term ; msg . data_size = self . data_size ; msg . voted_for = self . voted_for ; } } impl Default for Inspector { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Inspector > :: new () ; Inspector :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl Inspector { pub const CANDIDATE : _bindgen_ty_174 = foros_msgs__msg__Inspector__CANDIDATE ; pub const FOLLOWER : _bindgen_ty_173 = foros_msgs__msg__Inspector__FOLLOWER ; pub const LEADER : _bindgen_ty_175 = foros_msgs__msg__Inspector__LEADER ; pub const STANDBY : _bindgen_ty_172 = foros_msgs__msg__Inspector__STANDBY ; pub const TOPIC_NAME : & [u8 ; 16usize] = foros_msgs__msg__Inspector__TOPIC_NAME ; pub const UNKNOWN : _bindgen_ty_171 = foros_msgs__msg__Inspector__UNKNOWN ; } }