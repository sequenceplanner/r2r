pub mod msg { use super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct TexturedMarker { pub header : std_msgs :: msg :: Header , pub ns : std :: string :: String , pub id : i32 , pub action : i32 , pub lifetime : builtin_interfaces :: msg :: Duration , pub image : sensor_msgs :: msg :: Image , pub pose : geometry_msgs :: msg :: Pose , pub resolution : f64 , pub alpha : f32 } impl WrappedTypesupport for TexturedMarker { type CStruct = marti_visualization_msgs__msg__TexturedMarker ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__marti_visualization_msgs__msg__TexturedMarker () } } fn create_msg () -> * mut marti_visualization_msgs__msg__TexturedMarker { unsafe { marti_visualization_msgs__msg__TexturedMarker__create () } } fn destroy_msg (msg : * mut marti_visualization_msgs__msg__TexturedMarker) -> () { unsafe { marti_visualization_msgs__msg__TexturedMarker__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> TexturedMarker { TexturedMarker { header : std_msgs :: msg :: Header :: from_native (& msg . header) , ns : msg . ns . to_str () . to_owned () , id : msg . id , action : msg . action , lifetime : builtin_interfaces :: msg :: Duration :: from_native (& msg . lifetime) , image : sensor_msgs :: msg :: Image :: from_native (& msg . image) , pose : geometry_msgs :: msg :: Pose :: from_native (& msg . pose) , resolution : msg . resolution , alpha : msg . alpha , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . ns . assign (& self . ns) ; msg . id = self . id ; msg . action = self . action ; self . lifetime . copy_to_native (& mut msg . lifetime) ; self . image . copy_to_native (& mut msg . image) ; self . pose . copy_to_native (& mut msg . pose) ; msg . resolution = self . resolution ; msg . alpha = self . alpha ; } } impl Default for TexturedMarker { fn default () -> Self { let msg_native = WrappedNativeMsg :: < TexturedMarker > :: new () ; TexturedMarker :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl TexturedMarker { pub const ADD : _bindgen_ty_453 = marti_visualization_msgs__msg__TexturedMarker__ADD ; pub const DELETE : _bindgen_ty_455 = marti_visualization_msgs__msg__TexturedMarker__DELETE ; pub const MODIFY : _bindgen_ty_454 = marti_visualization_msgs__msg__TexturedMarker__MODIFY ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct TexturedMarkerArray { pub markers : Vec < marti_visualization_msgs :: msg :: TexturedMarker > } impl WrappedTypesupport for TexturedMarkerArray { type CStruct = marti_visualization_msgs__msg__TexturedMarkerArray ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__marti_visualization_msgs__msg__TexturedMarkerArray () } } fn create_msg () -> * mut marti_visualization_msgs__msg__TexturedMarkerArray { unsafe { marti_visualization_msgs__msg__TexturedMarkerArray__create () } } fn destroy_msg (msg : * mut marti_visualization_msgs__msg__TexturedMarkerArray) -> () { unsafe { marti_visualization_msgs__msg__TexturedMarkerArray__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> TexturedMarkerArray { TexturedMarkerArray { markers : { let mut temp = Vec :: with_capacity (msg . markers . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . markers . data , msg . markers . size) } ; for s in slice { temp . push (marti_visualization_msgs :: msg :: TexturedMarker :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { unsafe { marti_visualization_msgs__msg__TexturedMarker__Sequence__fini (& mut msg . markers) ; marti_visualization_msgs__msg__TexturedMarker__Sequence__init (& mut msg . markers , self . markers . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . markers . data , msg . markers . size) ; for (t , s) in slice . iter_mut () . zip (& self . markers) { s . copy_to_native (t) ; } } } } impl Default for TexturedMarkerArray { fn default () -> Self { let msg_native = WrappedNativeMsg :: < TexturedMarkerArray > :: new () ; TexturedMarkerArray :: from_native (& msg_native) } } }