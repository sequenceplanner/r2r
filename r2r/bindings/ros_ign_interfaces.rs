pub mod srv { # [allow (non_snake_case)] pub mod ControlWorld { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__ros_ign_interfaces__srv__ControlWorld () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub world_control : ros_ign_interfaces :: msg :: WorldControl } impl WrappedTypesupport for Request { type CStruct = ros_ign_interfaces__srv__ControlWorld_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ros_ign_interfaces__srv__ControlWorld_Request () } } fn create_msg () -> * mut ros_ign_interfaces__srv__ControlWorld_Request { unsafe { ros_ign_interfaces__srv__ControlWorld_Request__create () } } fn destroy_msg (msg : * mut ros_ign_interfaces__srv__ControlWorld_Request) -> () { unsafe { ros_ign_interfaces__srv__ControlWorld_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { world_control : ros_ign_interfaces :: msg :: WorldControl :: from_native (& msg . world_control) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . world_control . copy_to_native (& mut msg . world_control) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool } impl WrappedTypesupport for Response { type CStruct = ros_ign_interfaces__srv__ControlWorld_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ros_ign_interfaces__srv__ControlWorld_Response () } } fn create_msg () -> * mut ros_ign_interfaces__srv__ControlWorld_Response { unsafe { ros_ign_interfaces__srv__ControlWorld_Response__create () } } fn destroy_msg (msg : * mut ros_ign_interfaces__srv__ControlWorld_Response) -> () { unsafe { ros_ign_interfaces__srv__ControlWorld_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod DeleteEntity { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__ros_ign_interfaces__srv__DeleteEntity () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub entity : ros_ign_interfaces :: msg :: Entity } impl WrappedTypesupport for Request { type CStruct = ros_ign_interfaces__srv__DeleteEntity_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ros_ign_interfaces__srv__DeleteEntity_Request () } } fn create_msg () -> * mut ros_ign_interfaces__srv__DeleteEntity_Request { unsafe { ros_ign_interfaces__srv__DeleteEntity_Request__create () } } fn destroy_msg (msg : * mut ros_ign_interfaces__srv__DeleteEntity_Request) -> () { unsafe { ros_ign_interfaces__srv__DeleteEntity_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { entity : ros_ign_interfaces :: msg :: Entity :: from_native (& msg . entity) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . entity . copy_to_native (& mut msg . entity) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool } impl WrappedTypesupport for Response { type CStruct = ros_ign_interfaces__srv__DeleteEntity_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ros_ign_interfaces__srv__DeleteEntity_Response () } } fn create_msg () -> * mut ros_ign_interfaces__srv__DeleteEntity_Response { unsafe { ros_ign_interfaces__srv__DeleteEntity_Response__create () } } fn destroy_msg (msg : * mut ros_ign_interfaces__srv__DeleteEntity_Response) -> () { unsafe { ros_ign_interfaces__srv__DeleteEntity_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod SetEntityPose { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__ros_ign_interfaces__srv__SetEntityPose () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub entity : ros_ign_interfaces :: msg :: Entity , pub pose : geometry_msgs :: msg :: Pose } impl WrappedTypesupport for Request { type CStruct = ros_ign_interfaces__srv__SetEntityPose_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ros_ign_interfaces__srv__SetEntityPose_Request () } } fn create_msg () -> * mut ros_ign_interfaces__srv__SetEntityPose_Request { unsafe { ros_ign_interfaces__srv__SetEntityPose_Request__create () } } fn destroy_msg (msg : * mut ros_ign_interfaces__srv__SetEntityPose_Request) -> () { unsafe { ros_ign_interfaces__srv__SetEntityPose_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { entity : ros_ign_interfaces :: msg :: Entity :: from_native (& msg . entity) , pose : geometry_msgs :: msg :: Pose :: from_native (& msg . pose) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . entity . copy_to_native (& mut msg . entity) ; self . pose . copy_to_native (& mut msg . pose) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool } impl WrappedTypesupport for Response { type CStruct = ros_ign_interfaces__srv__SetEntityPose_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ros_ign_interfaces__srv__SetEntityPose_Response () } } fn create_msg () -> * mut ros_ign_interfaces__srv__SetEntityPose_Response { unsafe { ros_ign_interfaces__srv__SetEntityPose_Response__create () } } fn destroy_msg (msg : * mut ros_ign_interfaces__srv__SetEntityPose_Response) -> () { unsafe { ros_ign_interfaces__srv__SetEntityPose_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod SpawnEntity { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__ros_ign_interfaces__srv__SpawnEntity () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub entity_factory : ros_ign_interfaces :: msg :: EntityFactory } impl WrappedTypesupport for Request { type CStruct = ros_ign_interfaces__srv__SpawnEntity_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ros_ign_interfaces__srv__SpawnEntity_Request () } } fn create_msg () -> * mut ros_ign_interfaces__srv__SpawnEntity_Request { unsafe { ros_ign_interfaces__srv__SpawnEntity_Request__create () } } fn destroy_msg (msg : * mut ros_ign_interfaces__srv__SpawnEntity_Request) -> () { unsafe { ros_ign_interfaces__srv__SpawnEntity_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { entity_factory : ros_ign_interfaces :: msg :: EntityFactory :: from_native (& msg . entity_factory) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . entity_factory . copy_to_native (& mut msg . entity_factory) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool } impl WrappedTypesupport for Response { type CStruct = ros_ign_interfaces__srv__SpawnEntity_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ros_ign_interfaces__srv__SpawnEntity_Response () } } fn create_msg () -> * mut ros_ign_interfaces__srv__SpawnEntity_Response { unsafe { ros_ign_interfaces__srv__SpawnEntity_Response__create () } } fn destroy_msg (msg : * mut ros_ign_interfaces__srv__SpawnEntity_Response) -> () { unsafe { ros_ign_interfaces__srv__SpawnEntity_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } } pub mod msg { use super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Contact { pub collision1 : ros_ign_interfaces :: msg :: Entity , pub collision2 : ros_ign_interfaces :: msg :: Entity , pub positions : Vec < geometry_msgs :: msg :: Vector3 > , pub normals : Vec < geometry_msgs :: msg :: Vector3 > , pub depths : Vec < f64 > , pub wrenches : Vec < ros_ign_interfaces :: msg :: JointWrench > } impl WrappedTypesupport for Contact { type CStruct = ros_ign_interfaces__msg__Contact ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ros_ign_interfaces__msg__Contact () } } fn create_msg () -> * mut ros_ign_interfaces__msg__Contact { unsafe { ros_ign_interfaces__msg__Contact__create () } } fn destroy_msg (msg : * mut ros_ign_interfaces__msg__Contact) -> () { unsafe { ros_ign_interfaces__msg__Contact__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Contact { Contact { collision1 : ros_ign_interfaces :: msg :: Entity :: from_native (& msg . collision1) , collision2 : ros_ign_interfaces :: msg :: Entity :: from_native (& msg . collision2) , positions : { let mut temp = Vec :: with_capacity (msg . positions . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . positions . data , msg . positions . size) } ; for s in slice { temp . push (geometry_msgs :: msg :: Vector3 :: from_native (s)) ; } temp } , normals : { let mut temp = Vec :: with_capacity (msg . normals . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . normals . data , msg . normals . size) } ; for s in slice { temp . push (geometry_msgs :: msg :: Vector3 :: from_native (s)) ; } temp } , depths : msg . depths . to_vec () , wrenches : { let mut temp = Vec :: with_capacity (msg . wrenches . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . wrenches . data , msg . wrenches . size) } ; for s in slice { temp . push (ros_ign_interfaces :: msg :: JointWrench :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . collision1 . copy_to_native (& mut msg . collision1) ; self . collision2 . copy_to_native (& mut msg . collision2) ; unsafe { geometry_msgs__msg__Vector3__Sequence__fini (& mut msg . positions) ; geometry_msgs__msg__Vector3__Sequence__init (& mut msg . positions , self . positions . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . positions . data , msg . positions . size) ; for (t , s) in slice . iter_mut () . zip (& self . positions) { s . copy_to_native (t) ; } } unsafe { geometry_msgs__msg__Vector3__Sequence__fini (& mut msg . normals) ; geometry_msgs__msg__Vector3__Sequence__init (& mut msg . normals , self . normals . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . normals . data , msg . normals . size) ; for (t , s) in slice . iter_mut () . zip (& self . normals) { s . copy_to_native (t) ; } } msg . depths . update (& self . depths) ; unsafe { ros_ign_interfaces__msg__JointWrench__Sequence__fini (& mut msg . wrenches) ; ros_ign_interfaces__msg__JointWrench__Sequence__init (& mut msg . wrenches , self . wrenches . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . wrenches . data , msg . wrenches . size) ; for (t , s) in slice . iter_mut () . zip (& self . wrenches) { s . copy_to_native (t) ; } } } } impl Default for Contact { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Contact > :: new () ; Contact :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Contacts { pub header : std_msgs :: msg :: Header , pub contacts : Vec < ros_ign_interfaces :: msg :: Contact > } impl WrappedTypesupport for Contacts { type CStruct = ros_ign_interfaces__msg__Contacts ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ros_ign_interfaces__msg__Contacts () } } fn create_msg () -> * mut ros_ign_interfaces__msg__Contacts { unsafe { ros_ign_interfaces__msg__Contacts__create () } } fn destroy_msg (msg : * mut ros_ign_interfaces__msg__Contacts) -> () { unsafe { ros_ign_interfaces__msg__Contacts__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Contacts { Contacts { header : std_msgs :: msg :: Header :: from_native (& msg . header) , contacts : { let mut temp = Vec :: with_capacity (msg . contacts . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . contacts . data , msg . contacts . size) } ; for s in slice { temp . push (ros_ign_interfaces :: msg :: Contact :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; unsafe { ros_ign_interfaces__msg__Contact__Sequence__fini (& mut msg . contacts) ; ros_ign_interfaces__msg__Contact__Sequence__init (& mut msg . contacts , self . contacts . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . contacts . data , msg . contacts . size) ; for (t , s) in slice . iter_mut () . zip (& self . contacts) { s . copy_to_native (t) ; } } } } impl Default for Contacts { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Contacts > :: new () ; Contacts :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Entity { pub id : u64 , pub name : std :: string :: String , # [serde (rename = "type")] pub type_ : u8 } impl WrappedTypesupport for Entity { type CStruct = ros_ign_interfaces__msg__Entity ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ros_ign_interfaces__msg__Entity () } } fn create_msg () -> * mut ros_ign_interfaces__msg__Entity { unsafe { ros_ign_interfaces__msg__Entity__create () } } fn destroy_msg (msg : * mut ros_ign_interfaces__msg__Entity) -> () { unsafe { ros_ign_interfaces__msg__Entity__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Entity { Entity { id : msg . id , name : msg . name . to_str () . to_owned () , type_ : msg . type_ , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . id = self . id ; msg . name . assign (& self . name) ; msg . type_ = self . type_ ; } } impl Default for Entity { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Entity > :: new () ; Entity :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl Entity { pub const COLLISION : _bindgen_ty_1615 = ros_ign_interfaces__msg__Entity__COLLISION ; pub const JOINT : _bindgen_ty_1617 = ros_ign_interfaces__msg__Entity__JOINT ; pub const LIGHT : _bindgen_ty_1611 = ros_ign_interfaces__msg__Entity__LIGHT ; pub const LINK : _bindgen_ty_1613 = ros_ign_interfaces__msg__Entity__LINK ; pub const MODEL : _bindgen_ty_1612 = ros_ign_interfaces__msg__Entity__MODEL ; pub const NONE : _bindgen_ty_1610 = ros_ign_interfaces__msg__Entity__NONE ; pub const SENSOR : _bindgen_ty_1616 = ros_ign_interfaces__msg__Entity__SENSOR ; pub const VISUAL : _bindgen_ty_1614 = ros_ign_interfaces__msg__Entity__VISUAL ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct EntityFactory { pub name : std :: string :: String , pub allow_renaming : bool , pub sdf : std :: string :: String , pub sdf_filename : std :: string :: String , pub clone_name : std :: string :: String , pub pose : geometry_msgs :: msg :: Pose , pub relative_to : std :: string :: String } impl WrappedTypesupport for EntityFactory { type CStruct = ros_ign_interfaces__msg__EntityFactory ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ros_ign_interfaces__msg__EntityFactory () } } fn create_msg () -> * mut ros_ign_interfaces__msg__EntityFactory { unsafe { ros_ign_interfaces__msg__EntityFactory__create () } } fn destroy_msg (msg : * mut ros_ign_interfaces__msg__EntityFactory) -> () { unsafe { ros_ign_interfaces__msg__EntityFactory__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> EntityFactory { EntityFactory { name : msg . name . to_str () . to_owned () , allow_renaming : msg . allow_renaming , sdf : msg . sdf . to_str () . to_owned () , sdf_filename : msg . sdf_filename . to_str () . to_owned () , clone_name : msg . clone_name . to_str () . to_owned () , pose : geometry_msgs :: msg :: Pose :: from_native (& msg . pose) , relative_to : msg . relative_to . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . name . assign (& self . name) ; msg . allow_renaming = self . allow_renaming ; msg . sdf . assign (& self . sdf) ; msg . sdf_filename . assign (& self . sdf_filename) ; msg . clone_name . assign (& self . clone_name) ; self . pose . copy_to_native (& mut msg . pose) ; msg . relative_to . assign (& self . relative_to) ; } } impl Default for EntityFactory { fn default () -> Self { let msg_native = WrappedNativeMsg :: < EntityFactory > :: new () ; EntityFactory :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct JointWrench { pub header : std_msgs :: msg :: Header , pub body_1_name : std_msgs :: msg :: String , pub body_1_id : std_msgs :: msg :: UInt32 , pub body_2_name : std_msgs :: msg :: String , pub body_2_id : std_msgs :: msg :: UInt32 , pub body_1_wrench : geometry_msgs :: msg :: Wrench , pub body_2_wrench : geometry_msgs :: msg :: Wrench } impl WrappedTypesupport for JointWrench { type CStruct = ros_ign_interfaces__msg__JointWrench ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ros_ign_interfaces__msg__JointWrench () } } fn create_msg () -> * mut ros_ign_interfaces__msg__JointWrench { unsafe { ros_ign_interfaces__msg__JointWrench__create () } } fn destroy_msg (msg : * mut ros_ign_interfaces__msg__JointWrench) -> () { unsafe { ros_ign_interfaces__msg__JointWrench__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> JointWrench { JointWrench { header : std_msgs :: msg :: Header :: from_native (& msg . header) , body_1_name : std_msgs :: msg :: String :: from_native (& msg . body_1_name) , body_1_id : std_msgs :: msg :: UInt32 :: from_native (& msg . body_1_id) , body_2_name : std_msgs :: msg :: String :: from_native (& msg . body_2_name) , body_2_id : std_msgs :: msg :: UInt32 :: from_native (& msg . body_2_id) , body_1_wrench : geometry_msgs :: msg :: Wrench :: from_native (& msg . body_1_wrench) , body_2_wrench : geometry_msgs :: msg :: Wrench :: from_native (& msg . body_2_wrench) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; self . body_1_name . copy_to_native (& mut msg . body_1_name) ; self . body_1_id . copy_to_native (& mut msg . body_1_id) ; self . body_2_name . copy_to_native (& mut msg . body_2_name) ; self . body_2_id . copy_to_native (& mut msg . body_2_id) ; self . body_1_wrench . copy_to_native (& mut msg . body_1_wrench) ; self . body_2_wrench . copy_to_native (& mut msg . body_2_wrench) ; } } impl Default for JointWrench { fn default () -> Self { let msg_native = WrappedNativeMsg :: < JointWrench > :: new () ; JointWrench :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Light { pub header : std_msgs :: msg :: Header , pub name : std :: string :: String , # [serde (rename = "type")] pub type_ : u8 , pub pose : geometry_msgs :: msg :: Pose , pub diffuse : std_msgs :: msg :: ColorRGBA , pub specular : std_msgs :: msg :: ColorRGBA , pub attenuation_constant : f32 , pub attenuation_linear : f32 , pub attenuation_quadratic : f32 , pub direction : geometry_msgs :: msg :: Vector3 , pub range : f32 , pub cast_shadows : bool , pub spot_inner_angle : f32 , pub spot_outer_angle : f32 , pub spot_falloff : f32 , pub id : u32 , pub parent_id : u32 , pub intensity : f32 } impl WrappedTypesupport for Light { type CStruct = ros_ign_interfaces__msg__Light ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ros_ign_interfaces__msg__Light () } } fn create_msg () -> * mut ros_ign_interfaces__msg__Light { unsafe { ros_ign_interfaces__msg__Light__create () } } fn destroy_msg (msg : * mut ros_ign_interfaces__msg__Light) -> () { unsafe { ros_ign_interfaces__msg__Light__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Light { Light { header : std_msgs :: msg :: Header :: from_native (& msg . header) , name : msg . name . to_str () . to_owned () , type_ : msg . type_ , pose : geometry_msgs :: msg :: Pose :: from_native (& msg . pose) , diffuse : std_msgs :: msg :: ColorRGBA :: from_native (& msg . diffuse) , specular : std_msgs :: msg :: ColorRGBA :: from_native (& msg . specular) , attenuation_constant : msg . attenuation_constant , attenuation_linear : msg . attenuation_linear , attenuation_quadratic : msg . attenuation_quadratic , direction : geometry_msgs :: msg :: Vector3 :: from_native (& msg . direction) , range : msg . range , cast_shadows : msg . cast_shadows , spot_inner_angle : msg . spot_inner_angle , spot_outer_angle : msg . spot_outer_angle , spot_falloff : msg . spot_falloff , id : msg . id , parent_id : msg . parent_id , intensity : msg . intensity , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . name . assign (& self . name) ; msg . type_ = self . type_ ; self . pose . copy_to_native (& mut msg . pose) ; self . diffuse . copy_to_native (& mut msg . diffuse) ; self . specular . copy_to_native (& mut msg . specular) ; msg . attenuation_constant = self . attenuation_constant ; msg . attenuation_linear = self . attenuation_linear ; msg . attenuation_quadratic = self . attenuation_quadratic ; self . direction . copy_to_native (& mut msg . direction) ; msg . range = self . range ; msg . cast_shadows = self . cast_shadows ; msg . spot_inner_angle = self . spot_inner_angle ; msg . spot_outer_angle = self . spot_outer_angle ; msg . spot_falloff = self . spot_falloff ; msg . id = self . id ; msg . parent_id = self . parent_id ; msg . intensity = self . intensity ; } } impl Default for Light { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Light > :: new () ; Light :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl Light { pub const DIRECTIONAL : _bindgen_ty_1620 = ros_ign_interfaces__msg__Light__DIRECTIONAL ; pub const POINT : _bindgen_ty_1618 = ros_ign_interfaces__msg__Light__POINT ; pub const SPOT : _bindgen_ty_1619 = ros_ign_interfaces__msg__Light__SPOT ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct WorldControl { pub pause : bool , pub step : bool , pub multi_step : u32 , pub reset : ros_ign_interfaces :: msg :: WorldReset , pub seed : u32 , pub run_to_sim_time : builtin_interfaces :: msg :: Time } impl WrappedTypesupport for WorldControl { type CStruct = ros_ign_interfaces__msg__WorldControl ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ros_ign_interfaces__msg__WorldControl () } } fn create_msg () -> * mut ros_ign_interfaces__msg__WorldControl { unsafe { ros_ign_interfaces__msg__WorldControl__create () } } fn destroy_msg (msg : * mut ros_ign_interfaces__msg__WorldControl) -> () { unsafe { ros_ign_interfaces__msg__WorldControl__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> WorldControl { WorldControl { pause : msg . pause , step : msg . step , multi_step : msg . multi_step , reset : ros_ign_interfaces :: msg :: WorldReset :: from_native (& msg . reset) , seed : msg . seed , run_to_sim_time : builtin_interfaces :: msg :: Time :: from_native (& msg . run_to_sim_time) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . pause = self . pause ; msg . step = self . step ; msg . multi_step = self . multi_step ; self . reset . copy_to_native (& mut msg . reset) ; msg . seed = self . seed ; self . run_to_sim_time . copy_to_native (& mut msg . run_to_sim_time) ; } } impl Default for WorldControl { fn default () -> Self { let msg_native = WrappedNativeMsg :: < WorldControl > :: new () ; WorldControl :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct WorldReset { pub all : bool , pub time_only : bool , pub model_only : bool } impl WrappedTypesupport for WorldReset { type CStruct = ros_ign_interfaces__msg__WorldReset ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__ros_ign_interfaces__msg__WorldReset () } } fn create_msg () -> * mut ros_ign_interfaces__msg__WorldReset { unsafe { ros_ign_interfaces__msg__WorldReset__create () } } fn destroy_msg (msg : * mut ros_ign_interfaces__msg__WorldReset) -> () { unsafe { ros_ign_interfaces__msg__WorldReset__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> WorldReset { WorldReset { all : msg . all , time_only : msg . time_only , model_only : msg . model_only , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . all = self . all ; msg . time_only = self . time_only ; msg . model_only = self . model_only ; } } impl Default for WorldReset { fn default () -> Self { let msg_native = WrappedNativeMsg :: < WorldReset > :: new () ; WorldReset :: from_native (& msg_native) } } }