pub mod msg { use super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Num { pub num : i64 } impl WrappedTypesupport for Num { type CStruct = rosbridge_test_msgs__msg__Num ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rosbridge_test_msgs__msg__Num () } } fn create_msg () -> * mut rosbridge_test_msgs__msg__Num { unsafe { rosbridge_test_msgs__msg__Num__create () } } fn destroy_msg (msg : * mut rosbridge_test_msgs__msg__Num) -> () { unsafe { rosbridge_test_msgs__msg__Num__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Num { Num { num : msg . num , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . num = self . num ; } } impl Default for Num { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Num > :: new () ; Num :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct TestChar { pub data : Vec < u8 > } impl WrappedTypesupport for TestChar { type CStruct = rosbridge_test_msgs__msg__TestChar ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rosbridge_test_msgs__msg__TestChar () } } fn create_msg () -> * mut rosbridge_test_msgs__msg__TestChar { unsafe { rosbridge_test_msgs__msg__TestChar__create () } } fn destroy_msg (msg : * mut rosbridge_test_msgs__msg__TestChar) -> () { unsafe { rosbridge_test_msgs__msg__TestChar__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> TestChar { TestChar { data : msg . data . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . data . update (& self . data) ; } } impl Default for TestChar { fn default () -> Self { let msg_native = WrappedNativeMsg :: < TestChar > :: new () ; TestChar :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct TestDurationArray { pub durations : Vec < builtin_interfaces :: msg :: Duration > } impl WrappedTypesupport for TestDurationArray { type CStruct = rosbridge_test_msgs__msg__TestDurationArray ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rosbridge_test_msgs__msg__TestDurationArray () } } fn create_msg () -> * mut rosbridge_test_msgs__msg__TestDurationArray { unsafe { rosbridge_test_msgs__msg__TestDurationArray__create () } } fn destroy_msg (msg : * mut rosbridge_test_msgs__msg__TestDurationArray) -> () { unsafe { rosbridge_test_msgs__msg__TestDurationArray__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> TestDurationArray { TestDurationArray { durations : { let mut temp = Vec :: with_capacity (msg . durations . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . durations . data , msg . durations . size) } ; for s in slice { temp . push (builtin_interfaces :: msg :: Duration :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { unsafe { builtin_interfaces__msg__Duration__Sequence__fini (& mut msg . durations) ; builtin_interfaces__msg__Duration__Sequence__init (& mut msg . durations , self . durations . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . durations . data , msg . durations . size) ; for (t , s) in slice . iter_mut () . zip (& self . durations) { s . copy_to_native (t) ; } } } } impl Default for TestDurationArray { fn default () -> Self { let msg_native = WrappedNativeMsg :: < TestDurationArray > :: new () ; TestDurationArray :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct TestFloat32Array { pub data : Vec < f32 > } impl WrappedTypesupport for TestFloat32Array { type CStruct = rosbridge_test_msgs__msg__TestFloat32Array ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rosbridge_test_msgs__msg__TestFloat32Array () } } fn create_msg () -> * mut rosbridge_test_msgs__msg__TestFloat32Array { unsafe { rosbridge_test_msgs__msg__TestFloat32Array__create () } } fn destroy_msg (msg : * mut rosbridge_test_msgs__msg__TestFloat32Array) -> () { unsafe { rosbridge_test_msgs__msg__TestFloat32Array__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> TestFloat32Array { TestFloat32Array { data : msg . data . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . data . update (& self . data) ; } } impl Default for TestFloat32Array { fn default () -> Self { let msg_native = WrappedNativeMsg :: < TestFloat32Array > :: new () ; TestFloat32Array :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct TestFloat32BoundedArray { pub data : Vec < f32 > } impl WrappedTypesupport for TestFloat32BoundedArray { type CStruct = rosbridge_test_msgs__msg__TestFloat32BoundedArray ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rosbridge_test_msgs__msg__TestFloat32BoundedArray () } } fn create_msg () -> * mut rosbridge_test_msgs__msg__TestFloat32BoundedArray { unsafe { rosbridge_test_msgs__msg__TestFloat32BoundedArray__create () } } fn destroy_msg (msg : * mut rosbridge_test_msgs__msg__TestFloat32BoundedArray) -> () { unsafe { rosbridge_test_msgs__msg__TestFloat32BoundedArray__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> TestFloat32BoundedArray { TestFloat32BoundedArray { data : msg . data . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { assert_eq ! (self . data . len () , 16usize , "Field {} is fixed size of {}!" , "data" , 16usize) ; msg . data . copy_from_slice (& self . data [.. 16usize]) ; } } impl Default for TestFloat32BoundedArray { fn default () -> Self { let msg_native = WrappedNativeMsg :: < TestFloat32BoundedArray > :: new () ; TestFloat32BoundedArray :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct TestHeader { pub header : std_msgs :: msg :: Header } impl WrappedTypesupport for TestHeader { type CStruct = rosbridge_test_msgs__msg__TestHeader ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rosbridge_test_msgs__msg__TestHeader () } } fn create_msg () -> * mut rosbridge_test_msgs__msg__TestHeader { unsafe { rosbridge_test_msgs__msg__TestHeader__create () } } fn destroy_msg (msg : * mut rosbridge_test_msgs__msg__TestHeader) -> () { unsafe { rosbridge_test_msgs__msg__TestHeader__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> TestHeader { TestHeader { header : std_msgs :: msg :: Header :: from_native (& msg . header) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; } } impl Default for TestHeader { fn default () -> Self { let msg_native = WrappedNativeMsg :: < TestHeader > :: new () ; TestHeader :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct TestHeaderArray { pub header : Vec < std_msgs :: msg :: Header > } impl WrappedTypesupport for TestHeaderArray { type CStruct = rosbridge_test_msgs__msg__TestHeaderArray ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rosbridge_test_msgs__msg__TestHeaderArray () } } fn create_msg () -> * mut rosbridge_test_msgs__msg__TestHeaderArray { unsafe { rosbridge_test_msgs__msg__TestHeaderArray__create () } } fn destroy_msg (msg : * mut rosbridge_test_msgs__msg__TestHeaderArray) -> () { unsafe { rosbridge_test_msgs__msg__TestHeaderArray__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> TestHeaderArray { TestHeaderArray { header : { let mut temp = Vec :: with_capacity (msg . header . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . header . data , msg . header . size) } ; for s in slice { temp . push (std_msgs :: msg :: Header :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { unsafe { std_msgs__msg__Header__Sequence__fini (& mut msg . header) ; std_msgs__msg__Header__Sequence__init (& mut msg . header , self . header . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . header . data , msg . header . size) ; for (t , s) in slice . iter_mut () . zip (& self . header) { s . copy_to_native (t) ; } } } } impl Default for TestHeaderArray { fn default () -> Self { let msg_native = WrappedNativeMsg :: < TestHeaderArray > :: new () ; TestHeaderArray :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct TestHeaderTwo { pub header : std_msgs :: msg :: Header } impl WrappedTypesupport for TestHeaderTwo { type CStruct = rosbridge_test_msgs__msg__TestHeaderTwo ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rosbridge_test_msgs__msg__TestHeaderTwo () } } fn create_msg () -> * mut rosbridge_test_msgs__msg__TestHeaderTwo { unsafe { rosbridge_test_msgs__msg__TestHeaderTwo__create () } } fn destroy_msg (msg : * mut rosbridge_test_msgs__msg__TestHeaderTwo) -> () { unsafe { rosbridge_test_msgs__msg__TestHeaderTwo__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> TestHeaderTwo { TestHeaderTwo { header : std_msgs :: msg :: Header :: from_native (& msg . header) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; } } impl Default for TestHeaderTwo { fn default () -> Self { let msg_native = WrappedNativeMsg :: < TestHeaderTwo > :: new () ; TestHeaderTwo :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct TestTimeArray { pub times : Vec < builtin_interfaces :: msg :: Time > } impl WrappedTypesupport for TestTimeArray { type CStruct = rosbridge_test_msgs__msg__TestTimeArray ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rosbridge_test_msgs__msg__TestTimeArray () } } fn create_msg () -> * mut rosbridge_test_msgs__msg__TestTimeArray { unsafe { rosbridge_test_msgs__msg__TestTimeArray__create () } } fn destroy_msg (msg : * mut rosbridge_test_msgs__msg__TestTimeArray) -> () { unsafe { rosbridge_test_msgs__msg__TestTimeArray__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> TestTimeArray { TestTimeArray { times : { let mut temp = Vec :: with_capacity (msg . times . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . times . data , msg . times . size) } ; for s in slice { temp . push (builtin_interfaces :: msg :: Time :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { unsafe { builtin_interfaces__msg__Time__Sequence__fini (& mut msg . times) ; builtin_interfaces__msg__Time__Sequence__init (& mut msg . times , self . times . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . times . data , msg . times . size) ; for (t , s) in slice . iter_mut () . zip (& self . times) { s . copy_to_native (t) ; } } } } impl Default for TestTimeArray { fn default () -> Self { let msg_native = WrappedNativeMsg :: < TestTimeArray > :: new () ; TestTimeArray :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct TestUInt8 { pub data : Vec < u8 > } impl WrappedTypesupport for TestUInt8 { type CStruct = rosbridge_test_msgs__msg__TestUInt8 ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rosbridge_test_msgs__msg__TestUInt8 () } } fn create_msg () -> * mut rosbridge_test_msgs__msg__TestUInt8 { unsafe { rosbridge_test_msgs__msg__TestUInt8__create () } } fn destroy_msg (msg : * mut rosbridge_test_msgs__msg__TestUInt8) -> () { unsafe { rosbridge_test_msgs__msg__TestUInt8__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> TestUInt8 { TestUInt8 { data : msg . data . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . data . update (& self . data) ; } } impl Default for TestUInt8 { fn default () -> Self { let msg_native = WrappedNativeMsg :: < TestUInt8 > :: new () ; TestUInt8 :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct TestUInt8FixedSizeArray16 { pub data : Vec < u8 > } impl WrappedTypesupport for TestUInt8FixedSizeArray16 { type CStruct = rosbridge_test_msgs__msg__TestUInt8FixedSizeArray16 ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rosbridge_test_msgs__msg__TestUInt8FixedSizeArray16 () } } fn create_msg () -> * mut rosbridge_test_msgs__msg__TestUInt8FixedSizeArray16 { unsafe { rosbridge_test_msgs__msg__TestUInt8FixedSizeArray16__create () } } fn destroy_msg (msg : * mut rosbridge_test_msgs__msg__TestUInt8FixedSizeArray16) -> () { unsafe { rosbridge_test_msgs__msg__TestUInt8FixedSizeArray16__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> TestUInt8FixedSizeArray16 { TestUInt8FixedSizeArray16 { data : msg . data . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { assert_eq ! (self . data . len () , 16usize , "Field {} is fixed size of {}!" , "data" , 16usize) ; msg . data . copy_from_slice (& self . data [.. 16usize]) ; } } impl Default for TestUInt8FixedSizeArray16 { fn default () -> Self { let msg_native = WrappedNativeMsg :: < TestUInt8FixedSizeArray16 > :: new () ; TestUInt8FixedSizeArray16 :: from_native (& msg_native) } } } pub mod srv { # [allow (non_snake_case)] pub mod AddTwoInts { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__rosbridge_test_msgs__srv__AddTwoInts () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub a : i64 , pub b : i64 } impl WrappedTypesupport for Request { type CStruct = rosbridge_test_msgs__srv__AddTwoInts_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rosbridge_test_msgs__srv__AddTwoInts_Request () } } fn create_msg () -> * mut rosbridge_test_msgs__srv__AddTwoInts_Request { unsafe { rosbridge_test_msgs__srv__AddTwoInts_Request__create () } } fn destroy_msg (msg : * mut rosbridge_test_msgs__srv__AddTwoInts_Request) -> () { unsafe { rosbridge_test_msgs__srv__AddTwoInts_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { a : msg . a , b : msg . b , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . a = self . a ; msg . b = self . b ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub sum : i64 } impl WrappedTypesupport for Response { type CStruct = rosbridge_test_msgs__srv__AddTwoInts_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rosbridge_test_msgs__srv__AddTwoInts_Response () } } fn create_msg () -> * mut rosbridge_test_msgs__srv__AddTwoInts_Response { unsafe { rosbridge_test_msgs__srv__AddTwoInts_Response__create () } } fn destroy_msg (msg : * mut rosbridge_test_msgs__srv__AddTwoInts_Response) -> () { unsafe { rosbridge_test_msgs__srv__AddTwoInts_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { sum : msg . sum , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . sum = self . sum ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod SendBytes { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__rosbridge_test_msgs__srv__SendBytes () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub count : i64 } impl WrappedTypesupport for Request { type CStruct = rosbridge_test_msgs__srv__SendBytes_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rosbridge_test_msgs__srv__SendBytes_Request () } } fn create_msg () -> * mut rosbridge_test_msgs__srv__SendBytes_Request { unsafe { rosbridge_test_msgs__srv__SendBytes_Request__create () } } fn destroy_msg (msg : * mut rosbridge_test_msgs__srv__SendBytes_Request) -> () { unsafe { rosbridge_test_msgs__srv__SendBytes_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { count : msg . count , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . count = self . count ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub data : std :: string :: String } impl WrappedTypesupport for Response { type CStruct = rosbridge_test_msgs__srv__SendBytes_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rosbridge_test_msgs__srv__SendBytes_Response () } } fn create_msg () -> * mut rosbridge_test_msgs__srv__SendBytes_Response { unsafe { rosbridge_test_msgs__srv__SendBytes_Response__create () } } fn destroy_msg (msg : * mut rosbridge_test_msgs__srv__SendBytes_Response) -> () { unsafe { rosbridge_test_msgs__srv__SendBytes_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { data : msg . data . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . data . assign (& self . data) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod TestArrayRequest { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__rosbridge_test_msgs__srv__TestArrayRequest () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub int_values : Vec < i32 > } impl WrappedTypesupport for Request { type CStruct = rosbridge_test_msgs__srv__TestArrayRequest_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rosbridge_test_msgs__srv__TestArrayRequest_Request () } } fn create_msg () -> * mut rosbridge_test_msgs__srv__TestArrayRequest_Request { unsafe { rosbridge_test_msgs__srv__TestArrayRequest_Request__create () } } fn destroy_msg (msg : * mut rosbridge_test_msgs__srv__TestArrayRequest_Request) -> () { unsafe { rosbridge_test_msgs__srv__TestArrayRequest_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { int_values : msg . int_values . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . int_values . update (& self . int_values) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { } impl WrappedTypesupport for Response { type CStruct = rosbridge_test_msgs__srv__TestArrayRequest_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rosbridge_test_msgs__srv__TestArrayRequest_Response () } } fn create_msg () -> * mut rosbridge_test_msgs__srv__TestArrayRequest_Response { unsafe { rosbridge_test_msgs__srv__TestArrayRequest_Response__create () } } fn destroy_msg (msg : * mut rosbridge_test_msgs__srv__TestArrayRequest_Response) -> () { unsafe { rosbridge_test_msgs__srv__TestArrayRequest_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod TestEmpty { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__rosbridge_test_msgs__srv__TestEmpty () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { } impl WrappedTypesupport for Request { type CStruct = rosbridge_test_msgs__srv__TestEmpty_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rosbridge_test_msgs__srv__TestEmpty_Request () } } fn create_msg () -> * mut rosbridge_test_msgs__srv__TestEmpty_Request { unsafe { rosbridge_test_msgs__srv__TestEmpty_Request__create () } } fn destroy_msg (msg : * mut rosbridge_test_msgs__srv__TestEmpty_Request) -> () { unsafe { rosbridge_test_msgs__srv__TestEmpty_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { } impl WrappedTypesupport for Response { type CStruct = rosbridge_test_msgs__srv__TestEmpty_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rosbridge_test_msgs__srv__TestEmpty_Response () } } fn create_msg () -> * mut rosbridge_test_msgs__srv__TestEmpty_Response { unsafe { rosbridge_test_msgs__srv__TestEmpty_Response__create () } } fn destroy_msg (msg : * mut rosbridge_test_msgs__srv__TestEmpty_Response) -> () { unsafe { rosbridge_test_msgs__srv__TestEmpty_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod TestMultipleRequestFields { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__rosbridge_test_msgs__srv__TestMultipleRequestFields () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub int_value : i32 , pub float_value : f32 , pub string : std :: string :: String , pub bool_value : bool } impl WrappedTypesupport for Request { type CStruct = rosbridge_test_msgs__srv__TestMultipleRequestFields_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rosbridge_test_msgs__srv__TestMultipleRequestFields_Request () } } fn create_msg () -> * mut rosbridge_test_msgs__srv__TestMultipleRequestFields_Request { unsafe { rosbridge_test_msgs__srv__TestMultipleRequestFields_Request__create () } } fn destroy_msg (msg : * mut rosbridge_test_msgs__srv__TestMultipleRequestFields_Request) -> () { unsafe { rosbridge_test_msgs__srv__TestMultipleRequestFields_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { int_value : msg . int_value , float_value : msg . float_value , string : msg . string . to_str () . to_owned () , bool_value : msg . bool_value , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . int_value = self . int_value ; msg . float_value = self . float_value ; msg . string . assign (& self . string) ; msg . bool_value = self . bool_value ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { } impl WrappedTypesupport for Response { type CStruct = rosbridge_test_msgs__srv__TestMultipleRequestFields_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rosbridge_test_msgs__srv__TestMultipleRequestFields_Response () } } fn create_msg () -> * mut rosbridge_test_msgs__srv__TestMultipleRequestFields_Response { unsafe { rosbridge_test_msgs__srv__TestMultipleRequestFields_Response__create () } } fn destroy_msg (msg : * mut rosbridge_test_msgs__srv__TestMultipleRequestFields_Response) -> () { unsafe { rosbridge_test_msgs__srv__TestMultipleRequestFields_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod TestMultipleResponseFields { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__rosbridge_test_msgs__srv__TestMultipleResponseFields () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { } impl WrappedTypesupport for Request { type CStruct = rosbridge_test_msgs__srv__TestMultipleResponseFields_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rosbridge_test_msgs__srv__TestMultipleResponseFields_Request () } } fn create_msg () -> * mut rosbridge_test_msgs__srv__TestMultipleResponseFields_Request { unsafe { rosbridge_test_msgs__srv__TestMultipleResponseFields_Request__create () } } fn destroy_msg (msg : * mut rosbridge_test_msgs__srv__TestMultipleResponseFields_Request) -> () { unsafe { rosbridge_test_msgs__srv__TestMultipleResponseFields_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub int_value : i32 , pub float_value : f32 , pub string : std :: string :: String , pub bool_value : bool } impl WrappedTypesupport for Response { type CStruct = rosbridge_test_msgs__srv__TestMultipleResponseFields_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rosbridge_test_msgs__srv__TestMultipleResponseFields_Response () } } fn create_msg () -> * mut rosbridge_test_msgs__srv__TestMultipleResponseFields_Response { unsafe { rosbridge_test_msgs__srv__TestMultipleResponseFields_Response__create () } } fn destroy_msg (msg : * mut rosbridge_test_msgs__srv__TestMultipleResponseFields_Response) -> () { unsafe { rosbridge_test_msgs__srv__TestMultipleResponseFields_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { int_value : msg . int_value , float_value : msg . float_value , string : msg . string . to_str () . to_owned () , bool_value : msg . bool_value , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . int_value = self . int_value ; msg . float_value = self . float_value ; msg . string . assign (& self . string) ; msg . bool_value = self . bool_value ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod TestNestedService { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__rosbridge_test_msgs__srv__TestNestedService () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub pose : geometry_msgs :: msg :: Pose } impl WrappedTypesupport for Request { type CStruct = rosbridge_test_msgs__srv__TestNestedService_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rosbridge_test_msgs__srv__TestNestedService_Request () } } fn create_msg () -> * mut rosbridge_test_msgs__srv__TestNestedService_Request { unsafe { rosbridge_test_msgs__srv__TestNestedService_Request__create () } } fn destroy_msg (msg : * mut rosbridge_test_msgs__srv__TestNestedService_Request) -> () { unsafe { rosbridge_test_msgs__srv__TestNestedService_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { pose : geometry_msgs :: msg :: Pose :: from_native (& msg . pose) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . pose . copy_to_native (& mut msg . pose) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub data : std_msgs :: msg :: Float64 } impl WrappedTypesupport for Response { type CStruct = rosbridge_test_msgs__srv__TestNestedService_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rosbridge_test_msgs__srv__TestNestedService_Response () } } fn create_msg () -> * mut rosbridge_test_msgs__srv__TestNestedService_Response { unsafe { rosbridge_test_msgs__srv__TestNestedService_Response__create () } } fn destroy_msg (msg : * mut rosbridge_test_msgs__srv__TestNestedService_Response) -> () { unsafe { rosbridge_test_msgs__srv__TestNestedService_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { data : std_msgs :: msg :: Float64 :: from_native (& msg . data) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . data . copy_to_native (& mut msg . data) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod TestRequestAndResponse { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__rosbridge_test_msgs__srv__TestRequestAndResponse () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub data : i32 } impl WrappedTypesupport for Request { type CStruct = rosbridge_test_msgs__srv__TestRequestAndResponse_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rosbridge_test_msgs__srv__TestRequestAndResponse_Request () } } fn create_msg () -> * mut rosbridge_test_msgs__srv__TestRequestAndResponse_Request { unsafe { rosbridge_test_msgs__srv__TestRequestAndResponse_Request__create () } } fn destroy_msg (msg : * mut rosbridge_test_msgs__srv__TestRequestAndResponse_Request) -> () { unsafe { rosbridge_test_msgs__srv__TestRequestAndResponse_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { data : msg . data , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . data = self . data ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub data : i32 } impl WrappedTypesupport for Response { type CStruct = rosbridge_test_msgs__srv__TestRequestAndResponse_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rosbridge_test_msgs__srv__TestRequestAndResponse_Response () } } fn create_msg () -> * mut rosbridge_test_msgs__srv__TestRequestAndResponse_Response { unsafe { rosbridge_test_msgs__srv__TestRequestAndResponse_Response__create () } } fn destroy_msg (msg : * mut rosbridge_test_msgs__srv__TestRequestAndResponse_Response) -> () { unsafe { rosbridge_test_msgs__srv__TestRequestAndResponse_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { data : msg . data , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . data = self . data ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod TestRequestOnly { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__rosbridge_test_msgs__srv__TestRequestOnly () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub data : i32 } impl WrappedTypesupport for Request { type CStruct = rosbridge_test_msgs__srv__TestRequestOnly_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rosbridge_test_msgs__srv__TestRequestOnly_Request () } } fn create_msg () -> * mut rosbridge_test_msgs__srv__TestRequestOnly_Request { unsafe { rosbridge_test_msgs__srv__TestRequestOnly_Request__create () } } fn destroy_msg (msg : * mut rosbridge_test_msgs__srv__TestRequestOnly_Request) -> () { unsafe { rosbridge_test_msgs__srv__TestRequestOnly_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { data : msg . data , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . data = self . data ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { } impl WrappedTypesupport for Response { type CStruct = rosbridge_test_msgs__srv__TestRequestOnly_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rosbridge_test_msgs__srv__TestRequestOnly_Response () } } fn create_msg () -> * mut rosbridge_test_msgs__srv__TestRequestOnly_Response { unsafe { rosbridge_test_msgs__srv__TestRequestOnly_Response__create () } } fn destroy_msg (msg : * mut rosbridge_test_msgs__srv__TestRequestOnly_Response) -> () { unsafe { rosbridge_test_msgs__srv__TestRequestOnly_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod TestResponseOnly { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__rosbridge_test_msgs__srv__TestResponseOnly () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { } impl WrappedTypesupport for Request { type CStruct = rosbridge_test_msgs__srv__TestResponseOnly_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rosbridge_test_msgs__srv__TestResponseOnly_Request () } } fn create_msg () -> * mut rosbridge_test_msgs__srv__TestResponseOnly_Request { unsafe { rosbridge_test_msgs__srv__TestResponseOnly_Request__create () } } fn destroy_msg (msg : * mut rosbridge_test_msgs__srv__TestResponseOnly_Request) -> () { unsafe { rosbridge_test_msgs__srv__TestResponseOnly_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub data : i32 } impl WrappedTypesupport for Response { type CStruct = rosbridge_test_msgs__srv__TestResponseOnly_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__rosbridge_test_msgs__srv__TestResponseOnly_Response () } } fn create_msg () -> * mut rosbridge_test_msgs__srv__TestResponseOnly_Response { unsafe { rosbridge_test_msgs__srv__TestResponseOnly_Response__create () } } fn destroy_msg (msg : * mut rosbridge_test_msgs__srv__TestResponseOnly_Response) -> () { unsafe { rosbridge_test_msgs__srv__TestResponseOnly_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { data : msg . data , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . data = self . data ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } }