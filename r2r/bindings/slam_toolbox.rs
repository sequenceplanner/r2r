pub mod srv { # [allow (non_snake_case)] pub mod AddSubmap { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__slam_toolbox__srv__AddSubmap () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub filename : std :: string :: String } impl WrappedTypesupport for Request { type CStruct = slam_toolbox__srv__AddSubmap_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__slam_toolbox__srv__AddSubmap_Request () } } fn create_msg () -> * mut slam_toolbox__srv__AddSubmap_Request { unsafe { slam_toolbox__srv__AddSubmap_Request__create () } } fn destroy_msg (msg : * mut slam_toolbox__srv__AddSubmap_Request) -> () { unsafe { slam_toolbox__srv__AddSubmap_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { filename : msg . filename . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . filename . assign (& self . filename) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { } impl WrappedTypesupport for Response { type CStruct = slam_toolbox__srv__AddSubmap_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__slam_toolbox__srv__AddSubmap_Response () } } fn create_msg () -> * mut slam_toolbox__srv__AddSubmap_Response { unsafe { slam_toolbox__srv__AddSubmap_Response__create () } } fn destroy_msg (msg : * mut slam_toolbox__srv__AddSubmap_Response) -> () { unsafe { slam_toolbox__srv__AddSubmap_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod Clear { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__slam_toolbox__srv__Clear () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { } impl WrappedTypesupport for Request { type CStruct = slam_toolbox__srv__Clear_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__slam_toolbox__srv__Clear_Request () } } fn create_msg () -> * mut slam_toolbox__srv__Clear_Request { unsafe { slam_toolbox__srv__Clear_Request__create () } } fn destroy_msg (msg : * mut slam_toolbox__srv__Clear_Request) -> () { unsafe { slam_toolbox__srv__Clear_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { } impl WrappedTypesupport for Response { type CStruct = slam_toolbox__srv__Clear_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__slam_toolbox__srv__Clear_Response () } } fn create_msg () -> * mut slam_toolbox__srv__Clear_Response { unsafe { slam_toolbox__srv__Clear_Response__create () } } fn destroy_msg (msg : * mut slam_toolbox__srv__Clear_Response) -> () { unsafe { slam_toolbox__srv__Clear_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod ClearQueue { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__slam_toolbox__srv__ClearQueue () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { } impl WrappedTypesupport for Request { type CStruct = slam_toolbox__srv__ClearQueue_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__slam_toolbox__srv__ClearQueue_Request () } } fn create_msg () -> * mut slam_toolbox__srv__ClearQueue_Request { unsafe { slam_toolbox__srv__ClearQueue_Request__create () } } fn destroy_msg (msg : * mut slam_toolbox__srv__ClearQueue_Request) -> () { unsafe { slam_toolbox__srv__ClearQueue_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub status : bool } impl WrappedTypesupport for Response { type CStruct = slam_toolbox__srv__ClearQueue_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__slam_toolbox__srv__ClearQueue_Response () } } fn create_msg () -> * mut slam_toolbox__srv__ClearQueue_Response { unsafe { slam_toolbox__srv__ClearQueue_Response__create () } } fn destroy_msg (msg : * mut slam_toolbox__srv__ClearQueue_Response) -> () { unsafe { slam_toolbox__srv__ClearQueue_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { status : msg . status , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . status = self . status ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod DeserializePoseGraph { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__slam_toolbox__srv__DeserializePoseGraph () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub filename : std :: string :: String , pub match_type : i8 , pub initial_pose : geometry_msgs :: msg :: Pose2D } impl WrappedTypesupport for Request { type CStruct = slam_toolbox__srv__DeserializePoseGraph_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__slam_toolbox__srv__DeserializePoseGraph_Request () } } fn create_msg () -> * mut slam_toolbox__srv__DeserializePoseGraph_Request { unsafe { slam_toolbox__srv__DeserializePoseGraph_Request__create () } } fn destroy_msg (msg : * mut slam_toolbox__srv__DeserializePoseGraph_Request) -> () { unsafe { slam_toolbox__srv__DeserializePoseGraph_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { filename : msg . filename . to_str () . to_owned () , match_type : msg . match_type , initial_pose : geometry_msgs :: msg :: Pose2D :: from_native (& msg . initial_pose) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . filename . assign (& self . filename) ; msg . match_type = self . match_type ; self . initial_pose . copy_to_native (& mut msg . initial_pose) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl Request { pub const LOCALIZE_AT_POSE : _bindgen_ty_1662 = slam_toolbox__srv__DeserializePoseGraph_Request__LOCALIZE_AT_POSE ; pub const START_AT_FIRST_NODE : _bindgen_ty_1660 = slam_toolbox__srv__DeserializePoseGraph_Request__START_AT_FIRST_NODE ; pub const START_AT_GIVEN_POSE : _bindgen_ty_1661 = slam_toolbox__srv__DeserializePoseGraph_Request__START_AT_GIVEN_POSE ; pub const UNSET : _bindgen_ty_1659 = slam_toolbox__srv__DeserializePoseGraph_Request__UNSET ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { } impl WrappedTypesupport for Response { type CStruct = slam_toolbox__srv__DeserializePoseGraph_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__slam_toolbox__srv__DeserializePoseGraph_Response () } } fn create_msg () -> * mut slam_toolbox__srv__DeserializePoseGraph_Response { unsafe { slam_toolbox__srv__DeserializePoseGraph_Response__create () } } fn destroy_msg (msg : * mut slam_toolbox__srv__DeserializePoseGraph_Response) -> () { unsafe { slam_toolbox__srv__DeserializePoseGraph_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod LoopClosure { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__slam_toolbox__srv__LoopClosure () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { } impl WrappedTypesupport for Request { type CStruct = slam_toolbox__srv__LoopClosure_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__slam_toolbox__srv__LoopClosure_Request () } } fn create_msg () -> * mut slam_toolbox__srv__LoopClosure_Request { unsafe { slam_toolbox__srv__LoopClosure_Request__create () } } fn destroy_msg (msg : * mut slam_toolbox__srv__LoopClosure_Request) -> () { unsafe { slam_toolbox__srv__LoopClosure_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { } impl WrappedTypesupport for Response { type CStruct = slam_toolbox__srv__LoopClosure_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__slam_toolbox__srv__LoopClosure_Response () } } fn create_msg () -> * mut slam_toolbox__srv__LoopClosure_Response { unsafe { slam_toolbox__srv__LoopClosure_Response__create () } } fn destroy_msg (msg : * mut slam_toolbox__srv__LoopClosure_Response) -> () { unsafe { slam_toolbox__srv__LoopClosure_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod MergeMaps { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__slam_toolbox__srv__MergeMaps () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { } impl WrappedTypesupport for Request { type CStruct = slam_toolbox__srv__MergeMaps_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__slam_toolbox__srv__MergeMaps_Request () } } fn create_msg () -> * mut slam_toolbox__srv__MergeMaps_Request { unsafe { slam_toolbox__srv__MergeMaps_Request__create () } } fn destroy_msg (msg : * mut slam_toolbox__srv__MergeMaps_Request) -> () { unsafe { slam_toolbox__srv__MergeMaps_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { } impl WrappedTypesupport for Response { type CStruct = slam_toolbox__srv__MergeMaps_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__slam_toolbox__srv__MergeMaps_Response () } } fn create_msg () -> * mut slam_toolbox__srv__MergeMaps_Response { unsafe { slam_toolbox__srv__MergeMaps_Response__create () } } fn destroy_msg (msg : * mut slam_toolbox__srv__MergeMaps_Response) -> () { unsafe { slam_toolbox__srv__MergeMaps_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod Pause { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__slam_toolbox__srv__Pause () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { } impl WrappedTypesupport for Request { type CStruct = slam_toolbox__srv__Pause_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__slam_toolbox__srv__Pause_Request () } } fn create_msg () -> * mut slam_toolbox__srv__Pause_Request { unsafe { slam_toolbox__srv__Pause_Request__create () } } fn destroy_msg (msg : * mut slam_toolbox__srv__Pause_Request) -> () { unsafe { slam_toolbox__srv__Pause_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub status : bool } impl WrappedTypesupport for Response { type CStruct = slam_toolbox__srv__Pause_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__slam_toolbox__srv__Pause_Response () } } fn create_msg () -> * mut slam_toolbox__srv__Pause_Response { unsafe { slam_toolbox__srv__Pause_Response__create () } } fn destroy_msg (msg : * mut slam_toolbox__srv__Pause_Response) -> () { unsafe { slam_toolbox__srv__Pause_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { status : msg . status , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . status = self . status ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod SaveMap { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__slam_toolbox__srv__SaveMap () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub name : std_msgs :: msg :: String } impl WrappedTypesupport for Request { type CStruct = slam_toolbox__srv__SaveMap_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__slam_toolbox__srv__SaveMap_Request () } } fn create_msg () -> * mut slam_toolbox__srv__SaveMap_Request { unsafe { slam_toolbox__srv__SaveMap_Request__create () } } fn destroy_msg (msg : * mut slam_toolbox__srv__SaveMap_Request) -> () { unsafe { slam_toolbox__srv__SaveMap_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { name : std_msgs :: msg :: String :: from_native (& msg . name) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . name . copy_to_native (& mut msg . name) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { } impl WrappedTypesupport for Response { type CStruct = slam_toolbox__srv__SaveMap_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__slam_toolbox__srv__SaveMap_Response () } } fn create_msg () -> * mut slam_toolbox__srv__SaveMap_Response { unsafe { slam_toolbox__srv__SaveMap_Response__create () } } fn destroy_msg (msg : * mut slam_toolbox__srv__SaveMap_Response) -> () { unsafe { slam_toolbox__srv__SaveMap_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod SerializePoseGraph { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__slam_toolbox__srv__SerializePoseGraph () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub filename : std :: string :: String } impl WrappedTypesupport for Request { type CStruct = slam_toolbox__srv__SerializePoseGraph_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__slam_toolbox__srv__SerializePoseGraph_Request () } } fn create_msg () -> * mut slam_toolbox__srv__SerializePoseGraph_Request { unsafe { slam_toolbox__srv__SerializePoseGraph_Request__create () } } fn destroy_msg (msg : * mut slam_toolbox__srv__SerializePoseGraph_Request) -> () { unsafe { slam_toolbox__srv__SerializePoseGraph_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { filename : msg . filename . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . filename . assign (& self . filename) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { } impl WrappedTypesupport for Response { type CStruct = slam_toolbox__srv__SerializePoseGraph_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__slam_toolbox__srv__SerializePoseGraph_Response () } } fn create_msg () -> * mut slam_toolbox__srv__SerializePoseGraph_Response { unsafe { slam_toolbox__srv__SerializePoseGraph_Response__create () } } fn destroy_msg (msg : * mut slam_toolbox__srv__SerializePoseGraph_Response) -> () { unsafe { slam_toolbox__srv__SerializePoseGraph_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod ToggleInteractive { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__slam_toolbox__srv__ToggleInteractive () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { } impl WrappedTypesupport for Request { type CStruct = slam_toolbox__srv__ToggleInteractive_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__slam_toolbox__srv__ToggleInteractive_Request () } } fn create_msg () -> * mut slam_toolbox__srv__ToggleInteractive_Request { unsafe { slam_toolbox__srv__ToggleInteractive_Request__create () } } fn destroy_msg (msg : * mut slam_toolbox__srv__ToggleInteractive_Request) -> () { unsafe { slam_toolbox__srv__ToggleInteractive_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { } impl WrappedTypesupport for Response { type CStruct = slam_toolbox__srv__ToggleInteractive_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__slam_toolbox__srv__ToggleInteractive_Response () } } fn create_msg () -> * mut slam_toolbox__srv__ToggleInteractive_Response { unsafe { slam_toolbox__srv__ToggleInteractive_Response__create () } } fn destroy_msg (msg : * mut slam_toolbox__srv__ToggleInteractive_Response) -> () { unsafe { slam_toolbox__srv__ToggleInteractive_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } }