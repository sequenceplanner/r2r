pub mod srv { # [allow (non_snake_case)] pub mod CmdPoseService { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__naoqi_bridge_msgs__srv__CmdPoseService () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub pose : geometry_msgs :: msg :: Pose2D } impl WrappedTypesupport for Request { type CStruct = naoqi_bridge_msgs__srv__CmdPoseService_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__naoqi_bridge_msgs__srv__CmdPoseService_Request () } } fn create_msg () -> * mut naoqi_bridge_msgs__srv__CmdPoseService_Request { unsafe { naoqi_bridge_msgs__srv__CmdPoseService_Request__create () } } fn destroy_msg (msg : * mut naoqi_bridge_msgs__srv__CmdPoseService_Request) -> () { unsafe { naoqi_bridge_msgs__srv__CmdPoseService_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { pose : geometry_msgs :: msg :: Pose2D :: from_native (& msg . pose) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . pose . copy_to_native (& mut msg . pose) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { } impl WrappedTypesupport for Response { type CStruct = naoqi_bridge_msgs__srv__CmdPoseService_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__naoqi_bridge_msgs__srv__CmdPoseService_Response () } } fn create_msg () -> * mut naoqi_bridge_msgs__srv__CmdPoseService_Response { unsafe { naoqi_bridge_msgs__srv__CmdPoseService_Response__create () } } fn destroy_msg (msg : * mut naoqi_bridge_msgs__srv__CmdPoseService_Response) -> () { unsafe { naoqi_bridge_msgs__srv__CmdPoseService_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod CmdVelService { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__naoqi_bridge_msgs__srv__CmdVelService () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub twist : geometry_msgs :: msg :: Twist } impl WrappedTypesupport for Request { type CStruct = naoqi_bridge_msgs__srv__CmdVelService_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__naoqi_bridge_msgs__srv__CmdVelService_Request () } } fn create_msg () -> * mut naoqi_bridge_msgs__srv__CmdVelService_Request { unsafe { naoqi_bridge_msgs__srv__CmdVelService_Request__create () } } fn destroy_msg (msg : * mut naoqi_bridge_msgs__srv__CmdVelService_Request) -> () { unsafe { naoqi_bridge_msgs__srv__CmdVelService_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { twist : geometry_msgs :: msg :: Twist :: from_native (& msg . twist) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . twist . copy_to_native (& mut msg . twist) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { } impl WrappedTypesupport for Response { type CStruct = naoqi_bridge_msgs__srv__CmdVelService_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__naoqi_bridge_msgs__srv__CmdVelService_Response () } } fn create_msg () -> * mut naoqi_bridge_msgs__srv__CmdVelService_Response { unsafe { naoqi_bridge_msgs__srv__CmdVelService_Response__create () } } fn destroy_msg (msg : * mut naoqi_bridge_msgs__srv__CmdVelService_Response) -> () { unsafe { naoqi_bridge_msgs__srv__CmdVelService_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetBodyROI { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__naoqi_bridge_msgs__srv__GetBodyROI () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { } impl WrappedTypesupport for Request { type CStruct = naoqi_bridge_msgs__srv__GetBodyROI_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__naoqi_bridge_msgs__srv__GetBodyROI_Request () } } fn create_msg () -> * mut naoqi_bridge_msgs__srv__GetBodyROI_Request { unsafe { naoqi_bridge_msgs__srv__GetBodyROI_Request__create () } } fn destroy_msg (msg : * mut naoqi_bridge_msgs__srv__GetBodyROI_Request) -> () { unsafe { naoqi_bridge_msgs__srv__GetBodyROI_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub bodies : Vec < naoqi_bridge_msgs :: msg :: BodyROI > } impl WrappedTypesupport for Response { type CStruct = naoqi_bridge_msgs__srv__GetBodyROI_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__naoqi_bridge_msgs__srv__GetBodyROI_Response () } } fn create_msg () -> * mut naoqi_bridge_msgs__srv__GetBodyROI_Response { unsafe { naoqi_bridge_msgs__srv__GetBodyROI_Response__create () } } fn destroy_msg (msg : * mut naoqi_bridge_msgs__srv__GetBodyROI_Response) -> () { unsafe { naoqi_bridge_msgs__srv__GetBodyROI_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { bodies : { let mut temp = Vec :: with_capacity (msg . bodies . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . bodies . data , msg . bodies . size) } ; for s in slice { temp . push (naoqi_bridge_msgs :: msg :: BodyROI :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { unsafe { naoqi_bridge_msgs__msg__BodyROI__Sequence__fini (& mut msg . bodies) ; naoqi_bridge_msgs__msg__BodyROI__Sequence__init (& mut msg . bodies , self . bodies . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . bodies . data , msg . bodies . size) ; for (t , s) in slice . iter_mut () . zip (& self . bodies) { s . copy_to_native (t) ; } } } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetFacesROI { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__naoqi_bridge_msgs__srv__GetFacesROI () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { } impl WrappedTypesupport for Request { type CStruct = naoqi_bridge_msgs__srv__GetFacesROI_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__naoqi_bridge_msgs__srv__GetFacesROI_Request () } } fn create_msg () -> * mut naoqi_bridge_msgs__srv__GetFacesROI_Request { unsafe { naoqi_bridge_msgs__srv__GetFacesROI_Request__create () } } fn destroy_msg (msg : * mut naoqi_bridge_msgs__srv__GetFacesROI_Request) -> () { unsafe { naoqi_bridge_msgs__srv__GetFacesROI_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub faces : Vec < naoqi_bridge_msgs :: msg :: FaceROI > } impl WrappedTypesupport for Response { type CStruct = naoqi_bridge_msgs__srv__GetFacesROI_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__naoqi_bridge_msgs__srv__GetFacesROI_Response () } } fn create_msg () -> * mut naoqi_bridge_msgs__srv__GetFacesROI_Response { unsafe { naoqi_bridge_msgs__srv__GetFacesROI_Response__create () } } fn destroy_msg (msg : * mut naoqi_bridge_msgs__srv__GetFacesROI_Response) -> () { unsafe { naoqi_bridge_msgs__srv__GetFacesROI_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { faces : { let mut temp = Vec :: with_capacity (msg . faces . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . faces . data , msg . faces . size) } ; for s in slice { temp . push (naoqi_bridge_msgs :: msg :: FaceROI :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { unsafe { naoqi_bridge_msgs__msg__FaceROI__Sequence__fini (& mut msg . faces) ; naoqi_bridge_msgs__msg__FaceROI__Sequence__init (& mut msg . faces , self . faces . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . faces . data , msg . faces . size) ; for (t , s) in slice . iter_mut () . zip (& self . faces) { s . copy_to_native (t) ; } } } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetFloat { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__naoqi_bridge_msgs__srv__GetFloat () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { } impl WrappedTypesupport for Request { type CStruct = naoqi_bridge_msgs__srv__GetFloat_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__naoqi_bridge_msgs__srv__GetFloat_Request () } } fn create_msg () -> * mut naoqi_bridge_msgs__srv__GetFloat_Request { unsafe { naoqi_bridge_msgs__srv__GetFloat_Request__create () } } fn destroy_msg (msg : * mut naoqi_bridge_msgs__srv__GetFloat_Request) -> () { unsafe { naoqi_bridge_msgs__srv__GetFloat_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub data : f32 , pub message : std :: string :: String } impl WrappedTypesupport for Response { type CStruct = naoqi_bridge_msgs__srv__GetFloat_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__naoqi_bridge_msgs__srv__GetFloat_Response () } } fn create_msg () -> * mut naoqi_bridge_msgs__srv__GetFloat_Response { unsafe { naoqi_bridge_msgs__srv__GetFloat_Response__create () } } fn destroy_msg (msg : * mut naoqi_bridge_msgs__srv__GetFloat_Response) -> () { unsafe { naoqi_bridge_msgs__srv__GetFloat_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { data : msg . data , message : msg . message . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . data = self . data ; msg . message . assign (& self . message) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetInstalledBehaviors { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__naoqi_bridge_msgs__srv__GetInstalledBehaviors () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { } impl WrappedTypesupport for Request { type CStruct = naoqi_bridge_msgs__srv__GetInstalledBehaviors_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__naoqi_bridge_msgs__srv__GetInstalledBehaviors_Request () } } fn create_msg () -> * mut naoqi_bridge_msgs__srv__GetInstalledBehaviors_Request { unsafe { naoqi_bridge_msgs__srv__GetInstalledBehaviors_Request__create () } } fn destroy_msg (msg : * mut naoqi_bridge_msgs__srv__GetInstalledBehaviors_Request) -> () { unsafe { naoqi_bridge_msgs__srv__GetInstalledBehaviors_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub behaviors : Vec < std :: string :: String > } impl WrappedTypesupport for Response { type CStruct = naoqi_bridge_msgs__srv__GetInstalledBehaviors_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__naoqi_bridge_msgs__srv__GetInstalledBehaviors_Response () } } fn create_msg () -> * mut naoqi_bridge_msgs__srv__GetInstalledBehaviors_Response { unsafe { naoqi_bridge_msgs__srv__GetInstalledBehaviors_Response__create () } } fn destroy_msg (msg : * mut naoqi_bridge_msgs__srv__GetInstalledBehaviors_Response) -> () { unsafe { naoqi_bridge_msgs__srv__GetInstalledBehaviors_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { behaviors : msg . behaviors . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . behaviors . update (& self . behaviors) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetRobotInfo { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__naoqi_bridge_msgs__srv__GetRobotInfo () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { } impl WrappedTypesupport for Request { type CStruct = naoqi_bridge_msgs__srv__GetRobotInfo_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__naoqi_bridge_msgs__srv__GetRobotInfo_Request () } } fn create_msg () -> * mut naoqi_bridge_msgs__srv__GetRobotInfo_Request { unsafe { naoqi_bridge_msgs__srv__GetRobotInfo_Request__create () } } fn destroy_msg (msg : * mut naoqi_bridge_msgs__srv__GetRobotInfo_Request) -> () { unsafe { naoqi_bridge_msgs__srv__GetRobotInfo_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub info : naoqi_bridge_msgs :: msg :: RobotInfo } impl WrappedTypesupport for Response { type CStruct = naoqi_bridge_msgs__srv__GetRobotInfo_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__naoqi_bridge_msgs__srv__GetRobotInfo_Response () } } fn create_msg () -> * mut naoqi_bridge_msgs__srv__GetRobotInfo_Response { unsafe { naoqi_bridge_msgs__srv__GetRobotInfo_Response__create () } } fn destroy_msg (msg : * mut naoqi_bridge_msgs__srv__GetRobotInfo_Response) -> () { unsafe { naoqi_bridge_msgs__srv__GetRobotInfo_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { info : naoqi_bridge_msgs :: msg :: RobotInfo :: from_native (& msg . info) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . info . copy_to_native (& mut msg . info) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetString { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__naoqi_bridge_msgs__srv__GetString () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { } impl WrappedTypesupport for Request { type CStruct = naoqi_bridge_msgs__srv__GetString_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__naoqi_bridge_msgs__srv__GetString_Request () } } fn create_msg () -> * mut naoqi_bridge_msgs__srv__GetString_Request { unsafe { naoqi_bridge_msgs__srv__GetString_Request__create () } } fn destroy_msg (msg : * mut naoqi_bridge_msgs__srv__GetString_Request) -> () { unsafe { naoqi_bridge_msgs__srv__GetString_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub data : std :: string :: String } impl WrappedTypesupport for Response { type CStruct = naoqi_bridge_msgs__srv__GetString_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__naoqi_bridge_msgs__srv__GetString_Response () } } fn create_msg () -> * mut naoqi_bridge_msgs__srv__GetString_Response { unsafe { naoqi_bridge_msgs__srv__GetString_Response__create () } } fn destroy_msg (msg : * mut naoqi_bridge_msgs__srv__GetString_Response) -> () { unsafe { naoqi_bridge_msgs__srv__GetString_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { data : msg . data . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . data . assign (& self . data) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetTruepose { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__naoqi_bridge_msgs__srv__GetTruepose () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { } impl WrappedTypesupport for Request { type CStruct = naoqi_bridge_msgs__srv__GetTruepose_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__naoqi_bridge_msgs__srv__GetTruepose_Request () } } fn create_msg () -> * mut naoqi_bridge_msgs__srv__GetTruepose_Request { unsafe { naoqi_bridge_msgs__srv__GetTruepose_Request__create () } } fn destroy_msg (msg : * mut naoqi_bridge_msgs__srv__GetTruepose_Request) -> () { unsafe { naoqi_bridge_msgs__srv__GetTruepose_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub pose : geometry_msgs :: msg :: PoseWithCovarianceStamped } impl WrappedTypesupport for Response { type CStruct = naoqi_bridge_msgs__srv__GetTruepose_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__naoqi_bridge_msgs__srv__GetTruepose_Response () } } fn create_msg () -> * mut naoqi_bridge_msgs__srv__GetTruepose_Response { unsafe { naoqi_bridge_msgs__srv__GetTruepose_Response__create () } } fn destroy_msg (msg : * mut naoqi_bridge_msgs__srv__GetTruepose_Response) -> () { unsafe { naoqi_bridge_msgs__srv__GetTruepose_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { pose : geometry_msgs :: msg :: PoseWithCovarianceStamped :: from_native (& msg . pose) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . pose . copy_to_native (& mut msg . pose) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod OrthogonalSecurityDistance { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__naoqi_bridge_msgs__srv__OrthogonalSecurityDistance () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub orthogonal_distance : std_msgs :: msg :: Float32 } impl WrappedTypesupport for Request { type CStruct = naoqi_bridge_msgs__srv__OrthogonalSecurityDistance_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__naoqi_bridge_msgs__srv__OrthogonalSecurityDistance_Request () } } fn create_msg () -> * mut naoqi_bridge_msgs__srv__OrthogonalSecurityDistance_Request { unsafe { naoqi_bridge_msgs__srv__OrthogonalSecurityDistance_Request__create () } } fn destroy_msg (msg : * mut naoqi_bridge_msgs__srv__OrthogonalSecurityDistance_Request) -> () { unsafe { naoqi_bridge_msgs__srv__OrthogonalSecurityDistance_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { orthogonal_distance : std_msgs :: msg :: Float32 :: from_native (& msg . orthogonal_distance) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . orthogonal_distance . copy_to_native (& mut msg . orthogonal_distance) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { } impl WrappedTypesupport for Response { type CStruct = naoqi_bridge_msgs__srv__OrthogonalSecurityDistance_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__naoqi_bridge_msgs__srv__OrthogonalSecurityDistance_Response () } } fn create_msg () -> * mut naoqi_bridge_msgs__srv__OrthogonalSecurityDistance_Response { unsafe { naoqi_bridge_msgs__srv__OrthogonalSecurityDistance_Response__create () } } fn destroy_msg (msg : * mut naoqi_bridge_msgs__srv__OrthogonalSecurityDistance_Response) -> () { unsafe { naoqi_bridge_msgs__srv__OrthogonalSecurityDistance_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod SetArmsEnabled { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__naoqi_bridge_msgs__srv__SetArmsEnabled () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub left_arm : bool , pub right_arm : bool } impl WrappedTypesupport for Request { type CStruct = naoqi_bridge_msgs__srv__SetArmsEnabled_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__naoqi_bridge_msgs__srv__SetArmsEnabled_Request () } } fn create_msg () -> * mut naoqi_bridge_msgs__srv__SetArmsEnabled_Request { unsafe { naoqi_bridge_msgs__srv__SetArmsEnabled_Request__create () } } fn destroy_msg (msg : * mut naoqi_bridge_msgs__srv__SetArmsEnabled_Request) -> () { unsafe { naoqi_bridge_msgs__srv__SetArmsEnabled_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { left_arm : msg . left_arm , right_arm : msg . right_arm , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . left_arm = self . left_arm ; msg . right_arm = self . right_arm ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { } impl WrappedTypesupport for Response { type CStruct = naoqi_bridge_msgs__srv__SetArmsEnabled_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__naoqi_bridge_msgs__srv__SetArmsEnabled_Response () } } fn create_msg () -> * mut naoqi_bridge_msgs__srv__SetArmsEnabled_Response { unsafe { naoqi_bridge_msgs__srv__SetArmsEnabled_Response__create () } } fn destroy_msg (msg : * mut naoqi_bridge_msgs__srv__SetArmsEnabled_Response) -> () { unsafe { naoqi_bridge_msgs__srv__SetArmsEnabled_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod SetFloat { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__naoqi_bridge_msgs__srv__SetFloat () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub data : f32 } impl WrappedTypesupport for Request { type CStruct = naoqi_bridge_msgs__srv__SetFloat_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__naoqi_bridge_msgs__srv__SetFloat_Request () } } fn create_msg () -> * mut naoqi_bridge_msgs__srv__SetFloat_Request { unsafe { naoqi_bridge_msgs__srv__SetFloat_Request__create () } } fn destroy_msg (msg : * mut naoqi_bridge_msgs__srv__SetFloat_Request) -> () { unsafe { naoqi_bridge_msgs__srv__SetFloat_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { data : msg . data , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . data = self . data ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool , pub message : std :: string :: String } impl WrappedTypesupport for Response { type CStruct = naoqi_bridge_msgs__srv__SetFloat_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__naoqi_bridge_msgs__srv__SetFloat_Response () } } fn create_msg () -> * mut naoqi_bridge_msgs__srv__SetFloat_Response { unsafe { naoqi_bridge_msgs__srv__SetFloat_Response__create () } } fn destroy_msg (msg : * mut naoqi_bridge_msgs__srv__SetFloat_Response) -> () { unsafe { naoqi_bridge_msgs__srv__SetFloat_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , message : msg . message . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; msg . message . assign (& self . message) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod SetString { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__naoqi_bridge_msgs__srv__SetString () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub data : std :: string :: String } impl WrappedTypesupport for Request { type CStruct = naoqi_bridge_msgs__srv__SetString_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__naoqi_bridge_msgs__srv__SetString_Request () } } fn create_msg () -> * mut naoqi_bridge_msgs__srv__SetString_Request { unsafe { naoqi_bridge_msgs__srv__SetString_Request__create () } } fn destroy_msg (msg : * mut naoqi_bridge_msgs__srv__SetString_Request) -> () { unsafe { naoqi_bridge_msgs__srv__SetString_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { data : msg . data . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . data . assign (& self . data) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool } impl WrappedTypesupport for Response { type CStruct = naoqi_bridge_msgs__srv__SetString_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__naoqi_bridge_msgs__srv__SetString_Response () } } fn create_msg () -> * mut naoqi_bridge_msgs__srv__SetString_Response { unsafe { naoqi_bridge_msgs__srv__SetString_Response__create () } } fn destroy_msg (msg : * mut naoqi_bridge_msgs__srv__SetString_Response) -> () { unsafe { naoqi_bridge_msgs__srv__SetString_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod SetTransform { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__naoqi_bridge_msgs__srv__SetTransform () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub offset : geometry_msgs :: msg :: Transform } impl WrappedTypesupport for Request { type CStruct = naoqi_bridge_msgs__srv__SetTransform_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__naoqi_bridge_msgs__srv__SetTransform_Request () } } fn create_msg () -> * mut naoqi_bridge_msgs__srv__SetTransform_Request { unsafe { naoqi_bridge_msgs__srv__SetTransform_Request__create () } } fn destroy_msg (msg : * mut naoqi_bridge_msgs__srv__SetTransform_Request) -> () { unsafe { naoqi_bridge_msgs__srv__SetTransform_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { offset : geometry_msgs :: msg :: Transform :: from_native (& msg . offset) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . offset . copy_to_native (& mut msg . offset) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { } impl WrappedTypesupport for Response { type CStruct = naoqi_bridge_msgs__srv__SetTransform_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__naoqi_bridge_msgs__srv__SetTransform_Response () } } fn create_msg () -> * mut naoqi_bridge_msgs__srv__SetTransform_Response { unsafe { naoqi_bridge_msgs__srv__SetTransform_Response__create () } } fn destroy_msg (msg : * mut naoqi_bridge_msgs__srv__SetTransform_Response) -> () { unsafe { naoqi_bridge_msgs__srv__SetTransform_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod TangentialSecurityDistance { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__naoqi_bridge_msgs__srv__TangentialSecurityDistance () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub tangential_distance : std_msgs :: msg :: Float32 } impl WrappedTypesupport for Request { type CStruct = naoqi_bridge_msgs__srv__TangentialSecurityDistance_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__naoqi_bridge_msgs__srv__TangentialSecurityDistance_Request () } } fn create_msg () -> * mut naoqi_bridge_msgs__srv__TangentialSecurityDistance_Request { unsafe { naoqi_bridge_msgs__srv__TangentialSecurityDistance_Request__create () } } fn destroy_msg (msg : * mut naoqi_bridge_msgs__srv__TangentialSecurityDistance_Request) -> () { unsafe { naoqi_bridge_msgs__srv__TangentialSecurityDistance_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { tangential_distance : std_msgs :: msg :: Float32 :: from_native (& msg . tangential_distance) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . tangential_distance . copy_to_native (& mut msg . tangential_distance) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { } impl WrappedTypesupport for Response { type CStruct = naoqi_bridge_msgs__srv__TangentialSecurityDistance_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__naoqi_bridge_msgs__srv__TangentialSecurityDistance_Response () } } fn create_msg () -> * mut naoqi_bridge_msgs__srv__TangentialSecurityDistance_Response { unsafe { naoqi_bridge_msgs__srv__TangentialSecurityDistance_Response__create () } } fn destroy_msg (msg : * mut naoqi_bridge_msgs__srv__TangentialSecurityDistance_Response) -> () { unsafe { naoqi_bridge_msgs__srv__TangentialSecurityDistance_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } } pub mod msg { use super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct AudioBuffer { pub header : std_msgs :: msg :: Header , pub frequency : u16 , pub channel_map : Vec < u8 > , pub data : Vec < i16 > } impl WrappedTypesupport for AudioBuffer { type CStruct = naoqi_bridge_msgs__msg__AudioBuffer ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__naoqi_bridge_msgs__msg__AudioBuffer () } } fn create_msg () -> * mut naoqi_bridge_msgs__msg__AudioBuffer { unsafe { naoqi_bridge_msgs__msg__AudioBuffer__create () } } fn destroy_msg (msg : * mut naoqi_bridge_msgs__msg__AudioBuffer) -> () { unsafe { naoqi_bridge_msgs__msg__AudioBuffer__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> AudioBuffer { AudioBuffer { header : std_msgs :: msg :: Header :: from_native (& msg . header) , frequency : msg . frequency , channel_map : msg . channel_map . to_vec () , data : msg . data . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . frequency = self . frequency ; msg . channel_map . update (& self . channel_map) ; msg . data . update (& self . data) ; } } impl Default for AudioBuffer { fn default () -> Self { let msg_native = WrappedNativeMsg :: < AudioBuffer > :: new () ; AudioBuffer :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl AudioBuffer { pub const CHANNEL_FRONT_CENTER : _bindgen_ty_1084 = naoqi_bridge_msgs__msg__AudioBuffer__CHANNEL_FRONT_CENTER ; pub const CHANNEL_FRONT_LEFT : _bindgen_ty_1083 = naoqi_bridge_msgs__msg__AudioBuffer__CHANNEL_FRONT_LEFT ; pub const CHANNEL_FRONT_RIGHT : _bindgen_ty_1085 = naoqi_bridge_msgs__msg__AudioBuffer__CHANNEL_FRONT_RIGHT ; pub const CHANNEL_LFE : _bindgen_ty_1092 = naoqi_bridge_msgs__msg__AudioBuffer__CHANNEL_LFE ; pub const CHANNEL_REAR_CENTER : _bindgen_ty_1087 = naoqi_bridge_msgs__msg__AudioBuffer__CHANNEL_REAR_CENTER ; pub const CHANNEL_REAR_LEFT : _bindgen_ty_1086 = naoqi_bridge_msgs__msg__AudioBuffer__CHANNEL_REAR_LEFT ; pub const CHANNEL_REAR_RIGHT : _bindgen_ty_1088 = naoqi_bridge_msgs__msg__AudioBuffer__CHANNEL_REAR_RIGHT ; pub const CHANNEL_SUBWOOFER : _bindgen_ty_1091 = naoqi_bridge_msgs__msg__AudioBuffer__CHANNEL_SUBWOOFER ; pub const CHANNEL_SURROUND_LEFT : _bindgen_ty_1089 = naoqi_bridge_msgs__msg__AudioBuffer__CHANNEL_SURROUND_LEFT ; pub const CHANNEL_SURROUND_RIGHT : _bindgen_ty_1090 = naoqi_bridge_msgs__msg__AudioBuffer__CHANNEL_SURROUND_RIGHT ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct BodyROI { pub angle : f32 , pub cx : f32 , pub cy : f32 , pub height : f32 , pub width : f32 , pub confidence : f32 } impl WrappedTypesupport for BodyROI { type CStruct = naoqi_bridge_msgs__msg__BodyROI ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__naoqi_bridge_msgs__msg__BodyROI () } } fn create_msg () -> * mut naoqi_bridge_msgs__msg__BodyROI { unsafe { naoqi_bridge_msgs__msg__BodyROI__create () } } fn destroy_msg (msg : * mut naoqi_bridge_msgs__msg__BodyROI) -> () { unsafe { naoqi_bridge_msgs__msg__BodyROI__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> BodyROI { BodyROI { angle : msg . angle , cx : msg . cx , cy : msg . cy , height : msg . height , width : msg . width , confidence : msg . confidence , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . angle = self . angle ; msg . cx = self . cx ; msg . cy = self . cy ; msg . height = self . height ; msg . width = self . width ; msg . confidence = self . confidence ; } } impl Default for BodyROI { fn default () -> Self { let msg_native = WrappedNativeMsg :: < BodyROI > :: new () ; BodyROI :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct BoolStamped { pub header : std_msgs :: msg :: Header , pub data : bool } impl WrappedTypesupport for BoolStamped { type CStruct = naoqi_bridge_msgs__msg__BoolStamped ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__naoqi_bridge_msgs__msg__BoolStamped () } } fn create_msg () -> * mut naoqi_bridge_msgs__msg__BoolStamped { unsafe { naoqi_bridge_msgs__msg__BoolStamped__create () } } fn destroy_msg (msg : * mut naoqi_bridge_msgs__msg__BoolStamped) -> () { unsafe { naoqi_bridge_msgs__msg__BoolStamped__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> BoolStamped { BoolStamped { header : std_msgs :: msg :: Header :: from_native (& msg . header) , data : msg . data , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . data = self . data ; } } impl Default for BoolStamped { fn default () -> Self { let msg_native = WrappedNativeMsg :: < BoolStamped > :: new () ; BoolStamped :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Bumper { pub bumper : u8 , pub state : u8 } impl WrappedTypesupport for Bumper { type CStruct = naoqi_bridge_msgs__msg__Bumper ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__naoqi_bridge_msgs__msg__Bumper () } } fn create_msg () -> * mut naoqi_bridge_msgs__msg__Bumper { unsafe { naoqi_bridge_msgs__msg__Bumper__create () } } fn destroy_msg (msg : * mut naoqi_bridge_msgs__msg__Bumper) -> () { unsafe { naoqi_bridge_msgs__msg__Bumper__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Bumper { Bumper { bumper : msg . bumper , state : msg . state , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . bumper = self . bumper ; msg . state = self . state ; } } impl Default for Bumper { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Bumper > :: new () ; Bumper :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl Bumper { pub const BACK : _bindgen_ty_1095 = naoqi_bridge_msgs__msg__Bumper__BACK ; pub const LEFT : _bindgen_ty_1094 = naoqi_bridge_msgs__msg__Bumper__LEFT ; pub const RIGHT : _bindgen_ty_1093 = naoqi_bridge_msgs__msg__Bumper__RIGHT ; pub const STATE_PRESSED : _bindgen_ty_1097 = naoqi_bridge_msgs__msg__Bumper__STATE_PRESSED ; pub const STATE_RELEASED : _bindgen_ty_1096 = naoqi_bridge_msgs__msg__Bumper__STATE_RELEASED ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct EventStamped { pub header : std_msgs :: msg :: Header , pub name : std_msgs :: msg :: String , pub data : std_msgs :: msg :: String } impl WrappedTypesupport for EventStamped { type CStruct = naoqi_bridge_msgs__msg__EventStamped ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__naoqi_bridge_msgs__msg__EventStamped () } } fn create_msg () -> * mut naoqi_bridge_msgs__msg__EventStamped { unsafe { naoqi_bridge_msgs__msg__EventStamped__create () } } fn destroy_msg (msg : * mut naoqi_bridge_msgs__msg__EventStamped) -> () { unsafe { naoqi_bridge_msgs__msg__EventStamped__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> EventStamped { EventStamped { header : std_msgs :: msg :: Header :: from_native (& msg . header) , name : std_msgs :: msg :: String :: from_native (& msg . name) , data : std_msgs :: msg :: String :: from_native (& msg . data) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; self . name . copy_to_native (& mut msg . name) ; self . data . copy_to_native (& mut msg . data) ; } } impl Default for EventStamped { fn default () -> Self { let msg_native = WrappedNativeMsg :: < EventStamped > :: new () ; EventStamped :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct FaceROI { pub angle : f32 , pub cx : f32 , pub cy : f32 , pub height : f32 , pub width : f32 , pub confidence : f32 } impl WrappedTypesupport for FaceROI { type CStruct = naoqi_bridge_msgs__msg__FaceROI ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__naoqi_bridge_msgs__msg__FaceROI () } } fn create_msg () -> * mut naoqi_bridge_msgs__msg__FaceROI { unsafe { naoqi_bridge_msgs__msg__FaceROI__create () } } fn destroy_msg (msg : * mut naoqi_bridge_msgs__msg__FaceROI) -> () { unsafe { naoqi_bridge_msgs__msg__FaceROI__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> FaceROI { FaceROI { angle : msg . angle , cx : msg . cx , cy : msg . cy , height : msg . height , width : msg . width , confidence : msg . confidence , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . angle = self . angle ; msg . cx = self . cx ; msg . cy = self . cy ; msg . height = self . height ; msg . width = self . width ; msg . confidence = self . confidence ; } } impl Default for FaceROI { fn default () -> Self { let msg_native = WrappedNativeMsg :: < FaceROI > :: new () ; FaceROI :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct FadeRGB { pub led_name : std :: string :: String , pub color : std_msgs :: msg :: ColorRGBA , pub fade_duration : builtin_interfaces :: msg :: Duration } impl WrappedTypesupport for FadeRGB { type CStruct = naoqi_bridge_msgs__msg__FadeRGB ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__naoqi_bridge_msgs__msg__FadeRGB () } } fn create_msg () -> * mut naoqi_bridge_msgs__msg__FadeRGB { unsafe { naoqi_bridge_msgs__msg__FadeRGB__create () } } fn destroy_msg (msg : * mut naoqi_bridge_msgs__msg__FadeRGB) -> () { unsafe { naoqi_bridge_msgs__msg__FadeRGB__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> FadeRGB { FadeRGB { led_name : msg . led_name . to_str () . to_owned () , color : std_msgs :: msg :: ColorRGBA :: from_native (& msg . color) , fade_duration : builtin_interfaces :: msg :: Duration :: from_native (& msg . fade_duration) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . led_name . assign (& self . led_name) ; self . color . copy_to_native (& mut msg . color) ; self . fade_duration . copy_to_native (& mut msg . fade_duration) ; } } impl Default for FadeRGB { fn default () -> Self { let msg_native = WrappedNativeMsg :: < FadeRGB > :: new () ; FadeRGB :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct FloatArrayStamped { pub header : std_msgs :: msg :: Header , pub data : Vec < f32 > } impl WrappedTypesupport for FloatArrayStamped { type CStruct = naoqi_bridge_msgs__msg__FloatArrayStamped ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__naoqi_bridge_msgs__msg__FloatArrayStamped () } } fn create_msg () -> * mut naoqi_bridge_msgs__msg__FloatArrayStamped { unsafe { naoqi_bridge_msgs__msg__FloatArrayStamped__create () } } fn destroy_msg (msg : * mut naoqi_bridge_msgs__msg__FloatArrayStamped) -> () { unsafe { naoqi_bridge_msgs__msg__FloatArrayStamped__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> FloatArrayStamped { FloatArrayStamped { header : std_msgs :: msg :: Header :: from_native (& msg . header) , data : msg . data . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . data . update (& self . data) ; } } impl Default for FloatArrayStamped { fn default () -> Self { let msg_native = WrappedNativeMsg :: < FloatArrayStamped > :: new () ; FloatArrayStamped :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct FloatStamped { pub header : std_msgs :: msg :: Header , pub data : f32 } impl WrappedTypesupport for FloatStamped { type CStruct = naoqi_bridge_msgs__msg__FloatStamped ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__naoqi_bridge_msgs__msg__FloatStamped () } } fn create_msg () -> * mut naoqi_bridge_msgs__msg__FloatStamped { unsafe { naoqi_bridge_msgs__msg__FloatStamped__create () } } fn destroy_msg (msg : * mut naoqi_bridge_msgs__msg__FloatStamped) -> () { unsafe { naoqi_bridge_msgs__msg__FloatStamped__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> FloatStamped { FloatStamped { header : std_msgs :: msg :: Header :: from_native (& msg . header) , data : msg . data , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . data = self . data ; } } impl Default for FloatStamped { fn default () -> Self { let msg_native = WrappedNativeMsg :: < FloatStamped > :: new () ; FloatStamped :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct HandTouch { pub hand : u8 , pub state : u8 } impl WrappedTypesupport for HandTouch { type CStruct = naoqi_bridge_msgs__msg__HandTouch ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__naoqi_bridge_msgs__msg__HandTouch () } } fn create_msg () -> * mut naoqi_bridge_msgs__msg__HandTouch { unsafe { naoqi_bridge_msgs__msg__HandTouch__create () } } fn destroy_msg (msg : * mut naoqi_bridge_msgs__msg__HandTouch) -> () { unsafe { naoqi_bridge_msgs__msg__HandTouch__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> HandTouch { HandTouch { hand : msg . hand , state : msg . state , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . hand = self . hand ; msg . state = self . state ; } } impl Default for HandTouch { fn default () -> Self { let msg_native = WrappedNativeMsg :: < HandTouch > :: new () ; HandTouch :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl HandTouch { pub const LEFT_BACK : _bindgen_ty_1101 = naoqi_bridge_msgs__msg__HandTouch__LEFT_BACK ; pub const LEFT_LEFT : _bindgen_ty_1102 = naoqi_bridge_msgs__msg__HandTouch__LEFT_LEFT ; pub const LEFT_RIGHT : _bindgen_ty_1103 = naoqi_bridge_msgs__msg__HandTouch__LEFT_RIGHT ; pub const RIGHT_BACK : _bindgen_ty_1098 = naoqi_bridge_msgs__msg__HandTouch__RIGHT_BACK ; pub const RIGHT_LEFT : _bindgen_ty_1099 = naoqi_bridge_msgs__msg__HandTouch__RIGHT_LEFT ; pub const RIGHT_RIGHT : _bindgen_ty_1100 = naoqi_bridge_msgs__msg__HandTouch__RIGHT_RIGHT ; pub const STATE_PRESSED : _bindgen_ty_1105 = naoqi_bridge_msgs__msg__HandTouch__STATE_PRESSED ; pub const STATE_RELEASED : _bindgen_ty_1104 = naoqi_bridge_msgs__msg__HandTouch__STATE_RELEASED ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct HeadTouch { pub button : u8 , pub state : u8 } impl WrappedTypesupport for HeadTouch { type CStruct = naoqi_bridge_msgs__msg__HeadTouch ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__naoqi_bridge_msgs__msg__HeadTouch () } } fn create_msg () -> * mut naoqi_bridge_msgs__msg__HeadTouch { unsafe { naoqi_bridge_msgs__msg__HeadTouch__create () } } fn destroy_msg (msg : * mut naoqi_bridge_msgs__msg__HeadTouch) -> () { unsafe { naoqi_bridge_msgs__msg__HeadTouch__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> HeadTouch { HeadTouch { button : msg . button , state : msg . state , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . button = self . button ; msg . state = self . state ; } } impl Default for HeadTouch { fn default () -> Self { let msg_native = WrappedNativeMsg :: < HeadTouch > :: new () ; HeadTouch :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl HeadTouch { pub const BUTTON_FRONT : _bindgen_ty_1106 = naoqi_bridge_msgs__msg__HeadTouch__BUTTON_FRONT ; pub const BUTTON_MIDDLE : _bindgen_ty_1107 = naoqi_bridge_msgs__msg__HeadTouch__BUTTON_MIDDLE ; pub const BUTTON_REAR : _bindgen_ty_1108 = naoqi_bridge_msgs__msg__HeadTouch__BUTTON_REAR ; pub const STATE_PRESSED : _bindgen_ty_1110 = naoqi_bridge_msgs__msg__HeadTouch__STATE_PRESSED ; pub const STATE_RELEASED : _bindgen_ty_1109 = naoqi_bridge_msgs__msg__HeadTouch__STATE_RELEASED ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct IntArrayStamped { pub header : std_msgs :: msg :: Header , pub data : Vec < i32 > } impl WrappedTypesupport for IntArrayStamped { type CStruct = naoqi_bridge_msgs__msg__IntArrayStamped ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__naoqi_bridge_msgs__msg__IntArrayStamped () } } fn create_msg () -> * mut naoqi_bridge_msgs__msg__IntArrayStamped { unsafe { naoqi_bridge_msgs__msg__IntArrayStamped__create () } } fn destroy_msg (msg : * mut naoqi_bridge_msgs__msg__IntArrayStamped) -> () { unsafe { naoqi_bridge_msgs__msg__IntArrayStamped__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> IntArrayStamped { IntArrayStamped { header : std_msgs :: msg :: Header :: from_native (& msg . header) , data : msg . data . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . data . update (& self . data) ; } } impl Default for IntArrayStamped { fn default () -> Self { let msg_native = WrappedNativeMsg :: < IntArrayStamped > :: new () ; IntArrayStamped :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct IntStamped { pub header : std_msgs :: msg :: Header , pub data : i32 } impl WrappedTypesupport for IntStamped { type CStruct = naoqi_bridge_msgs__msg__IntStamped ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__naoqi_bridge_msgs__msg__IntStamped () } } fn create_msg () -> * mut naoqi_bridge_msgs__msg__IntStamped { unsafe { naoqi_bridge_msgs__msg__IntStamped__create () } } fn destroy_msg (msg : * mut naoqi_bridge_msgs__msg__IntStamped) -> () { unsafe { naoqi_bridge_msgs__msg__IntStamped__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> IntStamped { IntStamped { header : std_msgs :: msg :: Header :: from_native (& msg . header) , data : msg . data , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . data = self . data ; } } impl Default for IntStamped { fn default () -> Self { let msg_native = WrappedNativeMsg :: < IntStamped > :: new () ; IntStamped :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct JointAngleTrajectory { pub header : std_msgs :: msg :: Header , pub joint_names : Vec < std :: string :: String > , pub joint_angles : Vec < f32 > , pub times : Vec < f32 > , pub relative : u8 } impl WrappedTypesupport for JointAngleTrajectory { type CStruct = naoqi_bridge_msgs__msg__JointAngleTrajectory ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__naoqi_bridge_msgs__msg__JointAngleTrajectory () } } fn create_msg () -> * mut naoqi_bridge_msgs__msg__JointAngleTrajectory { unsafe { naoqi_bridge_msgs__msg__JointAngleTrajectory__create () } } fn destroy_msg (msg : * mut naoqi_bridge_msgs__msg__JointAngleTrajectory) -> () { unsafe { naoqi_bridge_msgs__msg__JointAngleTrajectory__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> JointAngleTrajectory { JointAngleTrajectory { header : std_msgs :: msg :: Header :: from_native (& msg . header) , joint_names : msg . joint_names . to_vec () , joint_angles : msg . joint_angles . to_vec () , times : msg . times . to_vec () , relative : msg . relative , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . joint_names . update (& self . joint_names) ; msg . joint_angles . update (& self . joint_angles) ; msg . times . update (& self . times) ; msg . relative = self . relative ; } } impl Default for JointAngleTrajectory { fn default () -> Self { let msg_native = WrappedNativeMsg :: < JointAngleTrajectory > :: new () ; JointAngleTrajectory :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct JointAnglesWithSpeed { pub header : std_msgs :: msg :: Header , pub joint_names : Vec < std :: string :: String > , pub joint_angles : Vec < f32 > , pub speed : f32 , pub relative : u8 } impl WrappedTypesupport for JointAnglesWithSpeed { type CStruct = naoqi_bridge_msgs__msg__JointAnglesWithSpeed ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__naoqi_bridge_msgs__msg__JointAnglesWithSpeed () } } fn create_msg () -> * mut naoqi_bridge_msgs__msg__JointAnglesWithSpeed { unsafe { naoqi_bridge_msgs__msg__JointAnglesWithSpeed__create () } } fn destroy_msg (msg : * mut naoqi_bridge_msgs__msg__JointAnglesWithSpeed) -> () { unsafe { naoqi_bridge_msgs__msg__JointAnglesWithSpeed__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> JointAnglesWithSpeed { JointAnglesWithSpeed { header : std_msgs :: msg :: Header :: from_native (& msg . header) , joint_names : msg . joint_names . to_vec () , joint_angles : msg . joint_angles . to_vec () , speed : msg . speed , relative : msg . relative , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . joint_names . update (& self . joint_names) ; msg . joint_angles . update (& self . joint_angles) ; msg . speed = self . speed ; msg . relative = self . relative ; } } impl Default for JointAnglesWithSpeed { fn default () -> Self { let msg_native = WrappedNativeMsg :: < JointAnglesWithSpeed > :: new () ; JointAnglesWithSpeed :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct MemoryList { pub header : std_msgs :: msg :: Header , pub strings : Vec < naoqi_bridge_msgs :: msg :: MemoryPairString > , pub ints : Vec < naoqi_bridge_msgs :: msg :: MemoryPairInt > , pub floats : Vec < naoqi_bridge_msgs :: msg :: MemoryPairFloat > } impl WrappedTypesupport for MemoryList { type CStruct = naoqi_bridge_msgs__msg__MemoryList ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__naoqi_bridge_msgs__msg__MemoryList () } } fn create_msg () -> * mut naoqi_bridge_msgs__msg__MemoryList { unsafe { naoqi_bridge_msgs__msg__MemoryList__create () } } fn destroy_msg (msg : * mut naoqi_bridge_msgs__msg__MemoryList) -> () { unsafe { naoqi_bridge_msgs__msg__MemoryList__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> MemoryList { MemoryList { header : std_msgs :: msg :: Header :: from_native (& msg . header) , strings : { let mut temp = Vec :: with_capacity (msg . strings . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . strings . data , msg . strings . size) } ; for s in slice { temp . push (naoqi_bridge_msgs :: msg :: MemoryPairString :: from_native (s)) ; } temp } , ints : { let mut temp = Vec :: with_capacity (msg . ints . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . ints . data , msg . ints . size) } ; for s in slice { temp . push (naoqi_bridge_msgs :: msg :: MemoryPairInt :: from_native (s)) ; } temp } , floats : { let mut temp = Vec :: with_capacity (msg . floats . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . floats . data , msg . floats . size) } ; for s in slice { temp . push (naoqi_bridge_msgs :: msg :: MemoryPairFloat :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; unsafe { naoqi_bridge_msgs__msg__MemoryPairString__Sequence__fini (& mut msg . strings) ; naoqi_bridge_msgs__msg__MemoryPairString__Sequence__init (& mut msg . strings , self . strings . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . strings . data , msg . strings . size) ; for (t , s) in slice . iter_mut () . zip (& self . strings) { s . copy_to_native (t) ; } } unsafe { naoqi_bridge_msgs__msg__MemoryPairInt__Sequence__fini (& mut msg . ints) ; naoqi_bridge_msgs__msg__MemoryPairInt__Sequence__init (& mut msg . ints , self . ints . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . ints . data , msg . ints . size) ; for (t , s) in slice . iter_mut () . zip (& self . ints) { s . copy_to_native (t) ; } } unsafe { naoqi_bridge_msgs__msg__MemoryPairFloat__Sequence__fini (& mut msg . floats) ; naoqi_bridge_msgs__msg__MemoryPairFloat__Sequence__init (& mut msg . floats , self . floats . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . floats . data , msg . floats . size) ; for (t , s) in slice . iter_mut () . zip (& self . floats) { s . copy_to_native (t) ; } } } } impl Default for MemoryList { fn default () -> Self { let msg_native = WrappedNativeMsg :: < MemoryList > :: new () ; MemoryList :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct MemoryPairFloat { pub memory_key : std :: string :: String , pub data : f32 } impl WrappedTypesupport for MemoryPairFloat { type CStruct = naoqi_bridge_msgs__msg__MemoryPairFloat ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__naoqi_bridge_msgs__msg__MemoryPairFloat () } } fn create_msg () -> * mut naoqi_bridge_msgs__msg__MemoryPairFloat { unsafe { naoqi_bridge_msgs__msg__MemoryPairFloat__create () } } fn destroy_msg (msg : * mut naoqi_bridge_msgs__msg__MemoryPairFloat) -> () { unsafe { naoqi_bridge_msgs__msg__MemoryPairFloat__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> MemoryPairFloat { MemoryPairFloat { memory_key : msg . memory_key . to_str () . to_owned () , data : msg . data , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . memory_key . assign (& self . memory_key) ; msg . data = self . data ; } } impl Default for MemoryPairFloat { fn default () -> Self { let msg_native = WrappedNativeMsg :: < MemoryPairFloat > :: new () ; MemoryPairFloat :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct MemoryPairInt { pub memory_key : std :: string :: String , pub data : i32 } impl WrappedTypesupport for MemoryPairInt { type CStruct = naoqi_bridge_msgs__msg__MemoryPairInt ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__naoqi_bridge_msgs__msg__MemoryPairInt () } } fn create_msg () -> * mut naoqi_bridge_msgs__msg__MemoryPairInt { unsafe { naoqi_bridge_msgs__msg__MemoryPairInt__create () } } fn destroy_msg (msg : * mut naoqi_bridge_msgs__msg__MemoryPairInt) -> () { unsafe { naoqi_bridge_msgs__msg__MemoryPairInt__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> MemoryPairInt { MemoryPairInt { memory_key : msg . memory_key . to_str () . to_owned () , data : msg . data , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . memory_key . assign (& self . memory_key) ; msg . data = self . data ; } } impl Default for MemoryPairInt { fn default () -> Self { let msg_native = WrappedNativeMsg :: < MemoryPairInt > :: new () ; MemoryPairInt :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct MemoryPairString { pub memory_key : std :: string :: String , pub data : std :: string :: String } impl WrappedTypesupport for MemoryPairString { type CStruct = naoqi_bridge_msgs__msg__MemoryPairString ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__naoqi_bridge_msgs__msg__MemoryPairString () } } fn create_msg () -> * mut naoqi_bridge_msgs__msg__MemoryPairString { unsafe { naoqi_bridge_msgs__msg__MemoryPairString__create () } } fn destroy_msg (msg : * mut naoqi_bridge_msgs__msg__MemoryPairString) -> () { unsafe { naoqi_bridge_msgs__msg__MemoryPairString__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> MemoryPairString { MemoryPairString { memory_key : msg . memory_key . to_str () . to_owned () , data : msg . data . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . memory_key . assign (& self . memory_key) ; msg . data . assign (& self . data) ; } } impl Default for MemoryPairString { fn default () -> Self { let msg_native = WrappedNativeMsg :: < MemoryPairString > :: new () ; MemoryPairString :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct PoseWithConfidenceStamped { pub header : std_msgs :: msg :: Header , pub pose : geometry_msgs :: msg :: Pose , pub confidence_index : f32 } impl WrappedTypesupport for PoseWithConfidenceStamped { type CStruct = naoqi_bridge_msgs__msg__PoseWithConfidenceStamped ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__naoqi_bridge_msgs__msg__PoseWithConfidenceStamped () } } fn create_msg () -> * mut naoqi_bridge_msgs__msg__PoseWithConfidenceStamped { unsafe { naoqi_bridge_msgs__msg__PoseWithConfidenceStamped__create () } } fn destroy_msg (msg : * mut naoqi_bridge_msgs__msg__PoseWithConfidenceStamped) -> () { unsafe { naoqi_bridge_msgs__msg__PoseWithConfidenceStamped__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> PoseWithConfidenceStamped { PoseWithConfidenceStamped { header : std_msgs :: msg :: Header :: from_native (& msg . header) , pose : geometry_msgs :: msg :: Pose :: from_native (& msg . pose) , confidence_index : msg . confidence_index , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; self . pose . copy_to_native (& mut msg . pose) ; msg . confidence_index = self . confidence_index ; } } impl Default for PoseWithConfidenceStamped { fn default () -> Self { let msg_native = WrappedNativeMsg :: < PoseWithConfidenceStamped > :: new () ; PoseWithConfidenceStamped :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct RobotInfo { # [serde (rename = "type")] pub type_ : u8 , pub model : std :: string :: String , pub head_version : std :: string :: String , pub body_version : std :: string :: String , pub arm_version : std :: string :: String , pub has_laser : bool , pub has_extended_arms : bool , pub number_of_legs : i32 , pub number_of_arms : i32 , pub number_of_hands : i32 } impl WrappedTypesupport for RobotInfo { type CStruct = naoqi_bridge_msgs__msg__RobotInfo ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__naoqi_bridge_msgs__msg__RobotInfo () } } fn create_msg () -> * mut naoqi_bridge_msgs__msg__RobotInfo { unsafe { naoqi_bridge_msgs__msg__RobotInfo__create () } } fn destroy_msg (msg : * mut naoqi_bridge_msgs__msg__RobotInfo) -> () { unsafe { naoqi_bridge_msgs__msg__RobotInfo__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> RobotInfo { RobotInfo { type_ : msg . type_ , model : msg . model . to_str () . to_owned () , head_version : msg . head_version . to_str () . to_owned () , body_version : msg . body_version . to_str () . to_owned () , arm_version : msg . arm_version . to_str () . to_owned () , has_laser : msg . has_laser , has_extended_arms : msg . has_extended_arms , number_of_legs : msg . number_of_legs , number_of_arms : msg . number_of_arms , number_of_hands : msg . number_of_hands , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . type_ = self . type_ ; msg . model . assign (& self . model) ; msg . head_version . assign (& self . head_version) ; msg . body_version . assign (& self . body_version) ; msg . arm_version . assign (& self . arm_version) ; msg . has_laser = self . has_laser ; msg . has_extended_arms = self . has_extended_arms ; msg . number_of_legs = self . number_of_legs ; msg . number_of_arms = self . number_of_arms ; msg . number_of_hands = self . number_of_hands ; } } impl Default for RobotInfo { fn default () -> Self { let msg_native = WrappedNativeMsg :: < RobotInfo > :: new () ; RobotInfo :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl RobotInfo { pub const NAO : _bindgen_ty_1111 = naoqi_bridge_msgs__msg__RobotInfo__NAO ; pub const PEPPER : _bindgen_ty_1113 = naoqi_bridge_msgs__msg__RobotInfo__PEPPER ; pub const ROMEO : _bindgen_ty_1112 = naoqi_bridge_msgs__msg__RobotInfo__ROMEO ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct SoundLocated { pub header : std_msgs :: msg :: Header , pub azimuth : f64 , pub elevation : f64 , pub confidence : f64 , pub energy : f64 , pub head_position_frame_torso : geometry_msgs :: msg :: Twist , pub head_position_frame_robot : geometry_msgs :: msg :: Twist } impl WrappedTypesupport for SoundLocated { type CStruct = naoqi_bridge_msgs__msg__SoundLocated ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__naoqi_bridge_msgs__msg__SoundLocated () } } fn create_msg () -> * mut naoqi_bridge_msgs__msg__SoundLocated { unsafe { naoqi_bridge_msgs__msg__SoundLocated__create () } } fn destroy_msg (msg : * mut naoqi_bridge_msgs__msg__SoundLocated) -> () { unsafe { naoqi_bridge_msgs__msg__SoundLocated__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> SoundLocated { SoundLocated { header : std_msgs :: msg :: Header :: from_native (& msg . header) , azimuth : msg . azimuth , elevation : msg . elevation , confidence : msg . confidence , energy : msg . energy , head_position_frame_torso : geometry_msgs :: msg :: Twist :: from_native (& msg . head_position_frame_torso) , head_position_frame_robot : geometry_msgs :: msg :: Twist :: from_native (& msg . head_position_frame_robot) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . azimuth = self . azimuth ; msg . elevation = self . elevation ; msg . confidence = self . confidence ; msg . energy = self . energy ; self . head_position_frame_torso . copy_to_native (& mut msg . head_position_frame_torso) ; self . head_position_frame_robot . copy_to_native (& mut msg . head_position_frame_robot) ; } } impl Default for SoundLocated { fn default () -> Self { let msg_native = WrappedNativeMsg :: < SoundLocated > :: new () ; SoundLocated :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct StatusChangeStamped { pub header : std_msgs :: msg :: Header , pub recharge_type : i16 , pub old_status : std_msgs :: msg :: String , pub new_status : std_msgs :: msg :: String } impl WrappedTypesupport for StatusChangeStamped { type CStruct = naoqi_bridge_msgs__msg__StatusChangeStamped ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__naoqi_bridge_msgs__msg__StatusChangeStamped () } } fn create_msg () -> * mut naoqi_bridge_msgs__msg__StatusChangeStamped { unsafe { naoqi_bridge_msgs__msg__StatusChangeStamped__create () } } fn destroy_msg (msg : * mut naoqi_bridge_msgs__msg__StatusChangeStamped) -> () { unsafe { naoqi_bridge_msgs__msg__StatusChangeStamped__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> StatusChangeStamped { StatusChangeStamped { header : std_msgs :: msg :: Header :: from_native (& msg . header) , recharge_type : msg . recharge_type , old_status : std_msgs :: msg :: String :: from_native (& msg . old_status) , new_status : std_msgs :: msg :: String :: from_native (& msg . new_status) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . recharge_type = self . recharge_type ; self . old_status . copy_to_native (& mut msg . old_status) ; self . new_status . copy_to_native (& mut msg . new_status) ; } } impl Default for StatusChangeStamped { fn default () -> Self { let msg_native = WrappedNativeMsg :: < StatusChangeStamped > :: new () ; StatusChangeStamped :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct StringArrayStamped { pub header : std_msgs :: msg :: Header , pub data : Vec < std :: string :: String > } impl WrappedTypesupport for StringArrayStamped { type CStruct = naoqi_bridge_msgs__msg__StringArrayStamped ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__naoqi_bridge_msgs__msg__StringArrayStamped () } } fn create_msg () -> * mut naoqi_bridge_msgs__msg__StringArrayStamped { unsafe { naoqi_bridge_msgs__msg__StringArrayStamped__create () } } fn destroy_msg (msg : * mut naoqi_bridge_msgs__msg__StringArrayStamped) -> () { unsafe { naoqi_bridge_msgs__msg__StringArrayStamped__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> StringArrayStamped { StringArrayStamped { header : std_msgs :: msg :: Header :: from_native (& msg . header) , data : msg . data . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . data . update (& self . data) ; } } impl Default for StringArrayStamped { fn default () -> Self { let msg_native = WrappedNativeMsg :: < StringArrayStamped > :: new () ; StringArrayStamped :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct StringStamped { pub header : std_msgs :: msg :: Header , pub data : std :: string :: String } impl WrappedTypesupport for StringStamped { type CStruct = naoqi_bridge_msgs__msg__StringStamped ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__naoqi_bridge_msgs__msg__StringStamped () } } fn create_msg () -> * mut naoqi_bridge_msgs__msg__StringStamped { unsafe { naoqi_bridge_msgs__msg__StringStamped__create () } } fn destroy_msg (msg : * mut naoqi_bridge_msgs__msg__StringStamped) -> () { unsafe { naoqi_bridge_msgs__msg__StringStamped__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> StringStamped { StringStamped { header : std_msgs :: msg :: Header :: from_native (& msg . header) , data : msg . data . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . data . assign (& self . data) ; } } impl Default for StringStamped { fn default () -> Self { let msg_native = WrappedNativeMsg :: < StringStamped > :: new () ; StringStamped :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct WordRecognized { pub words : Vec < std :: string :: String > , pub confidence_values : Vec < f32 > } impl WrappedTypesupport for WordRecognized { type CStruct = naoqi_bridge_msgs__msg__WordRecognized ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__naoqi_bridge_msgs__msg__WordRecognized () } } fn create_msg () -> * mut naoqi_bridge_msgs__msg__WordRecognized { unsafe { naoqi_bridge_msgs__msg__WordRecognized__create () } } fn destroy_msg (msg : * mut naoqi_bridge_msgs__msg__WordRecognized) -> () { unsafe { naoqi_bridge_msgs__msg__WordRecognized__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> WordRecognized { WordRecognized { words : msg . words . to_vec () , confidence_values : msg . confidence_values . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . words . update (& self . words) ; msg . confidence_values . update (& self . confidence_values) ; } } impl Default for WordRecognized { fn default () -> Self { let msg_native = WrappedNativeMsg :: < WordRecognized > :: new () ; WordRecognized :: from_native (& msg_native) } } }