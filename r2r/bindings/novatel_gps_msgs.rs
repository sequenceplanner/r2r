pub mod msg { use super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ClockSteering { pub source : std :: string :: String , pub steering_state : std :: string :: String , pub period : u32 , pub pulse_width : f64 , pub bandwidth : f64 , pub slope : f32 , pub offset : f64 , pub drift_rate : f64 } impl WrappedTypesupport for ClockSteering { type CStruct = novatel_gps_msgs__msg__ClockSteering ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__novatel_gps_msgs__msg__ClockSteering () } } fn create_msg () -> * mut novatel_gps_msgs__msg__ClockSteering { unsafe { novatel_gps_msgs__msg__ClockSteering__create () } } fn destroy_msg (msg : * mut novatel_gps_msgs__msg__ClockSteering) -> () { unsafe { novatel_gps_msgs__msg__ClockSteering__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ClockSteering { ClockSteering { source : msg . source . to_str () . to_owned () , steering_state : msg . steering_state . to_str () . to_owned () , period : msg . period , pulse_width : msg . pulse_width , bandwidth : msg . bandwidth , slope : msg . slope , offset : msg . offset , drift_rate : msg . drift_rate , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . source . assign (& self . source) ; msg . steering_state . assign (& self . steering_state) ; msg . period = self . period ; msg . pulse_width = self . pulse_width ; msg . bandwidth = self . bandwidth ; msg . slope = self . slope ; msg . offset = self . offset ; msg . drift_rate = self . drift_rate ; } } impl Default for ClockSteering { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ClockSteering > :: new () ; ClockSteering :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl ClockSteering { pub const CALIBRATE_CENTER_STEERING_STATE : _bindgen_ty_1135 = novatel_gps_msgs__msg__ClockSteering__CALIBRATE_CENTER_STEERING_STATE ; pub const CALIBRATE_HIGH_STEERING_STATE : _bindgen_ty_1133 = novatel_gps_msgs__msg__ClockSteering__CALIBRATE_HIGH_STEERING_STATE ; pub const CALIBRATE_LOW_STEERING_STATE : _bindgen_ty_1134 = novatel_gps_msgs__msg__ClockSteering__CALIBRATE_LOW_STEERING_STATE ; pub const EXTERNAL_SOURCE : _bindgen_ty_1130 = novatel_gps_msgs__msg__ClockSteering__EXTERNAL_SOURCE ; pub const FIRST_ORDER_STEERING_STATE : _bindgen_ty_1131 = novatel_gps_msgs__msg__ClockSteering__FIRST_ORDER_STEERING_STATE ; pub const INTERNAL_SOURCE : _bindgen_ty_1129 = novatel_gps_msgs__msg__ClockSteering__INTERNAL_SOURCE ; pub const SECOND_ORDER_STEERING_STATE : _bindgen_ty_1132 = novatel_gps_msgs__msg__ClockSteering__SECOND_ORDER_STEERING_STATE ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Gpgga { pub header : std_msgs :: msg :: Header , pub message_id : std :: string :: String , pub utc_seconds : f64 , pub lat : f64 , pub lon : f64 , pub lat_dir : std :: string :: String , pub lon_dir : std :: string :: String , pub gps_qual : u32 , pub num_sats : u32 , pub hdop : f32 , pub alt : f32 , pub altitude_units : std :: string :: String , pub undulation : f32 , pub undulation_units : std :: string :: String , pub diff_age : u32 , pub station_id : std :: string :: String } impl WrappedTypesupport for Gpgga { type CStruct = novatel_gps_msgs__msg__Gpgga ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__novatel_gps_msgs__msg__Gpgga () } } fn create_msg () -> * mut novatel_gps_msgs__msg__Gpgga { unsafe { novatel_gps_msgs__msg__Gpgga__create () } } fn destroy_msg (msg : * mut novatel_gps_msgs__msg__Gpgga) -> () { unsafe { novatel_gps_msgs__msg__Gpgga__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Gpgga { Gpgga { header : std_msgs :: msg :: Header :: from_native (& msg . header) , message_id : msg . message_id . to_str () . to_owned () , utc_seconds : msg . utc_seconds , lat : msg . lat , lon : msg . lon , lat_dir : msg . lat_dir . to_str () . to_owned () , lon_dir : msg . lon_dir . to_str () . to_owned () , gps_qual : msg . gps_qual , num_sats : msg . num_sats , hdop : msg . hdop , alt : msg . alt , altitude_units : msg . altitude_units . to_str () . to_owned () , undulation : msg . undulation , undulation_units : msg . undulation_units . to_str () . to_owned () , diff_age : msg . diff_age , station_id : msg . station_id . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . message_id . assign (& self . message_id) ; msg . utc_seconds = self . utc_seconds ; msg . lat = self . lat ; msg . lon = self . lon ; msg . lat_dir . assign (& self . lat_dir) ; msg . lon_dir . assign (& self . lon_dir) ; msg . gps_qual = self . gps_qual ; msg . num_sats = self . num_sats ; msg . hdop = self . hdop ; msg . alt = self . alt ; msg . altitude_units . assign (& self . altitude_units) ; msg . undulation = self . undulation ; msg . undulation_units . assign (& self . undulation_units) ; msg . diff_age = self . diff_age ; msg . station_id . assign (& self . station_id) ; } } impl Default for Gpgga { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Gpgga > :: new () ; Gpgga :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl Gpgga { pub const GPS_QUAL_DEAD_RECKONING_MODE : _bindgen_ty_1141 = novatel_gps_msgs__msg__Gpgga__GPS_QUAL_DEAD_RECKONING_MODE ; pub const GPS_QUAL_INVALID : _bindgen_ty_1136 = novatel_gps_msgs__msg__Gpgga__GPS_QUAL_INVALID ; pub const GPS_QUAL_MANUAL_INPUT_MODE : _bindgen_ty_1142 = novatel_gps_msgs__msg__Gpgga__GPS_QUAL_MANUAL_INPUT_MODE ; pub const GPS_QUAL_PSEUDORANGE_DIFFERENTIAL : _bindgen_ty_1138 = novatel_gps_msgs__msg__Gpgga__GPS_QUAL_PSEUDORANGE_DIFFERENTIAL ; pub const GPS_QUAL_RTK_FIXED_AMBIGUITY_SOLUTION : _bindgen_ty_1139 = novatel_gps_msgs__msg__Gpgga__GPS_QUAL_RTK_FIXED_AMBIGUITY_SOLUTION ; pub const GPS_QUAL_RTK_FLOATING_AMBIGUITY_SOLUTION : _bindgen_ty_1140 = novatel_gps_msgs__msg__Gpgga__GPS_QUAL_RTK_FLOATING_AMBIGUITY_SOLUTION ; pub const GPS_QUAL_SIMULATION_MODE : _bindgen_ty_1143 = novatel_gps_msgs__msg__Gpgga__GPS_QUAL_SIMULATION_MODE ; pub const GPS_QUAL_SINGLE_POINT : _bindgen_ty_1137 = novatel_gps_msgs__msg__Gpgga__GPS_QUAL_SINGLE_POINT ; pub const GPS_QUAL_WASS : _bindgen_ty_1144 = novatel_gps_msgs__msg__Gpgga__GPS_QUAL_WASS ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Gpgsa { pub header : std_msgs :: msg :: Header , pub message_id : std :: string :: String , pub auto_manual_mode : std :: string :: String , pub fix_mode : u8 , pub sv_ids : Vec < u8 > , pub pdop : f32 , pub hdop : f32 , pub vdop : f32 } impl WrappedTypesupport for Gpgsa { type CStruct = novatel_gps_msgs__msg__Gpgsa ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__novatel_gps_msgs__msg__Gpgsa () } } fn create_msg () -> * mut novatel_gps_msgs__msg__Gpgsa { unsafe { novatel_gps_msgs__msg__Gpgsa__create () } } fn destroy_msg (msg : * mut novatel_gps_msgs__msg__Gpgsa) -> () { unsafe { novatel_gps_msgs__msg__Gpgsa__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Gpgsa { Gpgsa { header : std_msgs :: msg :: Header :: from_native (& msg . header) , message_id : msg . message_id . to_str () . to_owned () , auto_manual_mode : msg . auto_manual_mode . to_str () . to_owned () , fix_mode : msg . fix_mode , sv_ids : msg . sv_ids . to_vec () , pdop : msg . pdop , hdop : msg . hdop , vdop : msg . vdop , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . message_id . assign (& self . message_id) ; msg . auto_manual_mode . assign (& self . auto_manual_mode) ; msg . fix_mode = self . fix_mode ; msg . sv_ids . update (& self . sv_ids) ; msg . pdop = self . pdop ; msg . hdop = self . hdop ; msg . vdop = self . vdop ; } } impl Default for Gpgsa { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Gpgsa > :: new () ; Gpgsa :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Gpgsv { pub header : std_msgs :: msg :: Header , pub message_id : std :: string :: String , pub n_msgs : u8 , pub msg_number : u8 , pub n_satellites : u8 , pub satellites : Vec < novatel_gps_msgs :: msg :: Satellite > } impl WrappedTypesupport for Gpgsv { type CStruct = novatel_gps_msgs__msg__Gpgsv ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__novatel_gps_msgs__msg__Gpgsv () } } fn create_msg () -> * mut novatel_gps_msgs__msg__Gpgsv { unsafe { novatel_gps_msgs__msg__Gpgsv__create () } } fn destroy_msg (msg : * mut novatel_gps_msgs__msg__Gpgsv) -> () { unsafe { novatel_gps_msgs__msg__Gpgsv__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Gpgsv { Gpgsv { header : std_msgs :: msg :: Header :: from_native (& msg . header) , message_id : msg . message_id . to_str () . to_owned () , n_msgs : msg . n_msgs , msg_number : msg . msg_number , n_satellites : msg . n_satellites , satellites : { let mut temp = Vec :: with_capacity (msg . satellites . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . satellites . data , msg . satellites . size) } ; for s in slice { temp . push (novatel_gps_msgs :: msg :: Satellite :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . message_id . assign (& self . message_id) ; msg . n_msgs = self . n_msgs ; msg . msg_number = self . msg_number ; msg . n_satellites = self . n_satellites ; unsafe { novatel_gps_msgs__msg__Satellite__Sequence__fini (& mut msg . satellites) ; novatel_gps_msgs__msg__Satellite__Sequence__init (& mut msg . satellites , self . satellites . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . satellites . data , msg . satellites . size) ; for (t , s) in slice . iter_mut () . zip (& self . satellites) { s . copy_to_native (t) ; } } } } impl Default for Gpgsv { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Gpgsv > :: new () ; Gpgsv :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Gphdt { pub header : std_msgs :: msg :: Header , pub message_id : std :: string :: String , pub heading : f64 , pub t : std :: string :: String } impl WrappedTypesupport for Gphdt { type CStruct = novatel_gps_msgs__msg__Gphdt ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__novatel_gps_msgs__msg__Gphdt () } } fn create_msg () -> * mut novatel_gps_msgs__msg__Gphdt { unsafe { novatel_gps_msgs__msg__Gphdt__create () } } fn destroy_msg (msg : * mut novatel_gps_msgs__msg__Gphdt) -> () { unsafe { novatel_gps_msgs__msg__Gphdt__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Gphdt { Gphdt { header : std_msgs :: msg :: Header :: from_native (& msg . header) , message_id : msg . message_id . to_str () . to_owned () , heading : msg . heading , t : msg . t . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . message_id . assign (& self . message_id) ; msg . heading = self . heading ; msg . t . assign (& self . t) ; } } impl Default for Gphdt { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Gphdt > :: new () ; Gphdt :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Gprmc { pub header : std_msgs :: msg :: Header , pub message_id : std :: string :: String , pub utc_seconds : f64 , pub position_status : std :: string :: String , pub lat : f64 , pub lon : f64 , pub lat_dir : std :: string :: String , pub lon_dir : std :: string :: String , pub speed : f32 , pub track : f32 , pub date : std :: string :: String , pub mag_var : f32 , pub mag_var_direction : std :: string :: String , pub mode_indicator : std :: string :: String } impl WrappedTypesupport for Gprmc { type CStruct = novatel_gps_msgs__msg__Gprmc ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__novatel_gps_msgs__msg__Gprmc () } } fn create_msg () -> * mut novatel_gps_msgs__msg__Gprmc { unsafe { novatel_gps_msgs__msg__Gprmc__create () } } fn destroy_msg (msg : * mut novatel_gps_msgs__msg__Gprmc) -> () { unsafe { novatel_gps_msgs__msg__Gprmc__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Gprmc { Gprmc { header : std_msgs :: msg :: Header :: from_native (& msg . header) , message_id : msg . message_id . to_str () . to_owned () , utc_seconds : msg . utc_seconds , position_status : msg . position_status . to_str () . to_owned () , lat : msg . lat , lon : msg . lon , lat_dir : msg . lat_dir . to_str () . to_owned () , lon_dir : msg . lon_dir . to_str () . to_owned () , speed : msg . speed , track : msg . track , date : msg . date . to_str () . to_owned () , mag_var : msg . mag_var , mag_var_direction : msg . mag_var_direction . to_str () . to_owned () , mode_indicator : msg . mode_indicator . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . message_id . assign (& self . message_id) ; msg . utc_seconds = self . utc_seconds ; msg . position_status . assign (& self . position_status) ; msg . lat = self . lat ; msg . lon = self . lon ; msg . lat_dir . assign (& self . lat_dir) ; msg . lon_dir . assign (& self . lon_dir) ; msg . speed = self . speed ; msg . track = self . track ; msg . date . assign (& self . date) ; msg . mag_var = self . mag_var ; msg . mag_var_direction . assign (& self . mag_var_direction) ; msg . mode_indicator . assign (& self . mode_indicator) ; } } impl Default for Gprmc { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Gprmc > :: new () ; Gprmc :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Inscov { pub header : std_msgs :: msg :: Header , pub novatel_msg_header : novatel_gps_msgs :: msg :: NovatelMessageHeader , pub week : u32 , pub seconds : f64 , pub position_covariance : Vec < f64 > , pub attitude_covariance : Vec < f64 > , pub velocity_covariance : Vec < f64 > } impl WrappedTypesupport for Inscov { type CStruct = novatel_gps_msgs__msg__Inscov ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__novatel_gps_msgs__msg__Inscov () } } fn create_msg () -> * mut novatel_gps_msgs__msg__Inscov { unsafe { novatel_gps_msgs__msg__Inscov__create () } } fn destroy_msg (msg : * mut novatel_gps_msgs__msg__Inscov) -> () { unsafe { novatel_gps_msgs__msg__Inscov__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Inscov { Inscov { header : std_msgs :: msg :: Header :: from_native (& msg . header) , novatel_msg_header : novatel_gps_msgs :: msg :: NovatelMessageHeader :: from_native (& msg . novatel_msg_header) , week : msg . week , seconds : msg . seconds , position_covariance : msg . position_covariance . to_vec () , attitude_covariance : msg . attitude_covariance . to_vec () , velocity_covariance : msg . velocity_covariance . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; self . novatel_msg_header . copy_to_native (& mut msg . novatel_msg_header) ; msg . week = self . week ; msg . seconds = self . seconds ; assert_eq ! (self . position_covariance . len () , 9usize , "Field {} is fixed size of {}!" , "position_covariance" , 9usize) ; msg . position_covariance . copy_from_slice (& self . position_covariance [.. 9usize]) ; assert_eq ! (self . attitude_covariance . len () , 9usize , "Field {} is fixed size of {}!" , "attitude_covariance" , 9usize) ; msg . attitude_covariance . copy_from_slice (& self . attitude_covariance [.. 9usize]) ; assert_eq ! (self . velocity_covariance . len () , 9usize , "Field {} is fixed size of {}!" , "velocity_covariance" , 9usize) ; msg . velocity_covariance . copy_from_slice (& self . velocity_covariance [.. 9usize]) ; } } impl Default for Inscov { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Inscov > :: new () ; Inscov :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Inspva { pub header : std_msgs :: msg :: Header , pub novatel_msg_header : novatel_gps_msgs :: msg :: NovatelMessageHeader , pub week : u32 , pub seconds : f64 , pub latitude : f64 , pub longitude : f64 , pub height : f64 , pub north_velocity : f64 , pub east_velocity : f64 , pub up_velocity : f64 , pub roll : f64 , pub pitch : f64 , pub azimuth : f64 , pub status : std :: string :: String } impl WrappedTypesupport for Inspva { type CStruct = novatel_gps_msgs__msg__Inspva ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__novatel_gps_msgs__msg__Inspva () } } fn create_msg () -> * mut novatel_gps_msgs__msg__Inspva { unsafe { novatel_gps_msgs__msg__Inspva__create () } } fn destroy_msg (msg : * mut novatel_gps_msgs__msg__Inspva) -> () { unsafe { novatel_gps_msgs__msg__Inspva__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Inspva { Inspva { header : std_msgs :: msg :: Header :: from_native (& msg . header) , novatel_msg_header : novatel_gps_msgs :: msg :: NovatelMessageHeader :: from_native (& msg . novatel_msg_header) , week : msg . week , seconds : msg . seconds , latitude : msg . latitude , longitude : msg . longitude , height : msg . height , north_velocity : msg . north_velocity , east_velocity : msg . east_velocity , up_velocity : msg . up_velocity , roll : msg . roll , pitch : msg . pitch , azimuth : msg . azimuth , status : msg . status . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; self . novatel_msg_header . copy_to_native (& mut msg . novatel_msg_header) ; msg . week = self . week ; msg . seconds = self . seconds ; msg . latitude = self . latitude ; msg . longitude = self . longitude ; msg . height = self . height ; msg . north_velocity = self . north_velocity ; msg . east_velocity = self . east_velocity ; msg . up_velocity = self . up_velocity ; msg . roll = self . roll ; msg . pitch = self . pitch ; msg . azimuth = self . azimuth ; msg . status . assign (& self . status) ; } } impl Default for Inspva { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Inspva > :: new () ; Inspva :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Inspvax { pub header : std_msgs :: msg :: Header , pub novatel_msg_header : novatel_gps_msgs :: msg :: NovatelMessageHeader , pub ins_status : std :: string :: String , pub position_type : std :: string :: String , pub latitude : f64 , pub longitude : f64 , pub altitude : f64 , pub undulation : f32 , pub north_velocity : f64 , pub east_velocity : f64 , pub up_velocity : f64 , pub roll : f64 , pub pitch : f64 , pub azimuth : f64 , pub latitude_std : f32 , pub longitude_std : f32 , pub altitude_std : f32 , pub north_velocity_std : f32 , pub east_velocity_std : f32 , pub up_velocity_std : f32 , pub roll_std : f32 , pub pitch_std : f32 , pub azimuth_std : f32 , pub extended_status : novatel_gps_msgs :: msg :: NovatelExtendedSolutionStatus , pub seconds_since_update : u16 } impl WrappedTypesupport for Inspvax { type CStruct = novatel_gps_msgs__msg__Inspvax ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__novatel_gps_msgs__msg__Inspvax () } } fn create_msg () -> * mut novatel_gps_msgs__msg__Inspvax { unsafe { novatel_gps_msgs__msg__Inspvax__create () } } fn destroy_msg (msg : * mut novatel_gps_msgs__msg__Inspvax) -> () { unsafe { novatel_gps_msgs__msg__Inspvax__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Inspvax { Inspvax { header : std_msgs :: msg :: Header :: from_native (& msg . header) , novatel_msg_header : novatel_gps_msgs :: msg :: NovatelMessageHeader :: from_native (& msg . novatel_msg_header) , ins_status : msg . ins_status . to_str () . to_owned () , position_type : msg . position_type . to_str () . to_owned () , latitude : msg . latitude , longitude : msg . longitude , altitude : msg . altitude , undulation : msg . undulation , north_velocity : msg . north_velocity , east_velocity : msg . east_velocity , up_velocity : msg . up_velocity , roll : msg . roll , pitch : msg . pitch , azimuth : msg . azimuth , latitude_std : msg . latitude_std , longitude_std : msg . longitude_std , altitude_std : msg . altitude_std , north_velocity_std : msg . north_velocity_std , east_velocity_std : msg . east_velocity_std , up_velocity_std : msg . up_velocity_std , roll_std : msg . roll_std , pitch_std : msg . pitch_std , azimuth_std : msg . azimuth_std , extended_status : novatel_gps_msgs :: msg :: NovatelExtendedSolutionStatus :: from_native (& msg . extended_status) , seconds_since_update : msg . seconds_since_update , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; self . novatel_msg_header . copy_to_native (& mut msg . novatel_msg_header) ; msg . ins_status . assign (& self . ins_status) ; msg . position_type . assign (& self . position_type) ; msg . latitude = self . latitude ; msg . longitude = self . longitude ; msg . altitude = self . altitude ; msg . undulation = self . undulation ; msg . north_velocity = self . north_velocity ; msg . east_velocity = self . east_velocity ; msg . up_velocity = self . up_velocity ; msg . roll = self . roll ; msg . pitch = self . pitch ; msg . azimuth = self . azimuth ; msg . latitude_std = self . latitude_std ; msg . longitude_std = self . longitude_std ; msg . altitude_std = self . altitude_std ; msg . north_velocity_std = self . north_velocity_std ; msg . east_velocity_std = self . east_velocity_std ; msg . up_velocity_std = self . up_velocity_std ; msg . roll_std = self . roll_std ; msg . pitch_std = self . pitch_std ; msg . azimuth_std = self . azimuth_std ; self . extended_status . copy_to_native (& mut msg . extended_status) ; msg . seconds_since_update = self . seconds_since_update ; } } impl Default for Inspvax { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Inspvax > :: new () ; Inspvax :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Insstdev { pub header : std_msgs :: msg :: Header , pub novatel_msg_header : novatel_gps_msgs :: msg :: NovatelMessageHeader , pub latitude_dev : f32 , pub longitude_dev : f32 , pub height_dev : f32 , pub north_velocity_dev : f32 , pub east_velocity_dev : f32 , pub up_velocity_dev : f32 , pub roll_dev : f32 , pub pitch_dev : f32 , pub azimuth_dev : f32 , pub extended_solution_status : novatel_gps_msgs :: msg :: NovatelExtendedSolutionStatus , pub time_since_update : u16 } impl WrappedTypesupport for Insstdev { type CStruct = novatel_gps_msgs__msg__Insstdev ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__novatel_gps_msgs__msg__Insstdev () } } fn create_msg () -> * mut novatel_gps_msgs__msg__Insstdev { unsafe { novatel_gps_msgs__msg__Insstdev__create () } } fn destroy_msg (msg : * mut novatel_gps_msgs__msg__Insstdev) -> () { unsafe { novatel_gps_msgs__msg__Insstdev__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Insstdev { Insstdev { header : std_msgs :: msg :: Header :: from_native (& msg . header) , novatel_msg_header : novatel_gps_msgs :: msg :: NovatelMessageHeader :: from_native (& msg . novatel_msg_header) , latitude_dev : msg . latitude_dev , longitude_dev : msg . longitude_dev , height_dev : msg . height_dev , north_velocity_dev : msg . north_velocity_dev , east_velocity_dev : msg . east_velocity_dev , up_velocity_dev : msg . up_velocity_dev , roll_dev : msg . roll_dev , pitch_dev : msg . pitch_dev , azimuth_dev : msg . azimuth_dev , extended_solution_status : novatel_gps_msgs :: msg :: NovatelExtendedSolutionStatus :: from_native (& msg . extended_solution_status) , time_since_update : msg . time_since_update , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; self . novatel_msg_header . copy_to_native (& mut msg . novatel_msg_header) ; msg . latitude_dev = self . latitude_dev ; msg . longitude_dev = self . longitude_dev ; msg . height_dev = self . height_dev ; msg . north_velocity_dev = self . north_velocity_dev ; msg . east_velocity_dev = self . east_velocity_dev ; msg . up_velocity_dev = self . up_velocity_dev ; msg . roll_dev = self . roll_dev ; msg . pitch_dev = self . pitch_dev ; msg . azimuth_dev = self . azimuth_dev ; self . extended_solution_status . copy_to_native (& mut msg . extended_solution_status) ; msg . time_since_update = self . time_since_update ; } } impl Default for Insstdev { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Insstdev > :: new () ; Insstdev :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct NovatelCorrectedImuData { pub header : std_msgs :: msg :: Header , pub novatel_msg_header : novatel_gps_msgs :: msg :: NovatelMessageHeader , pub gps_week_num : u32 , pub gps_seconds : f64 , pub pitch_rate : f64 , pub roll_rate : f64 , pub yaw_rate : f64 , pub lateral_acceleration : f64 , pub longitudinal_acceleration : f64 , pub vertical_acceleration : f64 } impl WrappedTypesupport for NovatelCorrectedImuData { type CStruct = novatel_gps_msgs__msg__NovatelCorrectedImuData ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__novatel_gps_msgs__msg__NovatelCorrectedImuData () } } fn create_msg () -> * mut novatel_gps_msgs__msg__NovatelCorrectedImuData { unsafe { novatel_gps_msgs__msg__NovatelCorrectedImuData__create () } } fn destroy_msg (msg : * mut novatel_gps_msgs__msg__NovatelCorrectedImuData) -> () { unsafe { novatel_gps_msgs__msg__NovatelCorrectedImuData__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> NovatelCorrectedImuData { NovatelCorrectedImuData { header : std_msgs :: msg :: Header :: from_native (& msg . header) , novatel_msg_header : novatel_gps_msgs :: msg :: NovatelMessageHeader :: from_native (& msg . novatel_msg_header) , gps_week_num : msg . gps_week_num , gps_seconds : msg . gps_seconds , pitch_rate : msg . pitch_rate , roll_rate : msg . roll_rate , yaw_rate : msg . yaw_rate , lateral_acceleration : msg . lateral_acceleration , longitudinal_acceleration : msg . longitudinal_acceleration , vertical_acceleration : msg . vertical_acceleration , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; self . novatel_msg_header . copy_to_native (& mut msg . novatel_msg_header) ; msg . gps_week_num = self . gps_week_num ; msg . gps_seconds = self . gps_seconds ; msg . pitch_rate = self . pitch_rate ; msg . roll_rate = self . roll_rate ; msg . yaw_rate = self . yaw_rate ; msg . lateral_acceleration = self . lateral_acceleration ; msg . longitudinal_acceleration = self . longitudinal_acceleration ; msg . vertical_acceleration = self . vertical_acceleration ; } } impl Default for NovatelCorrectedImuData { fn default () -> Self { let msg_native = WrappedNativeMsg :: < NovatelCorrectedImuData > :: new () ; NovatelCorrectedImuData :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct NovatelDualAntennaHeading { pub header : std_msgs :: msg :: Header , pub novatel_msg_header : novatel_gps_msgs :: msg :: NovatelMessageHeader , pub solution_status : std :: string :: String , pub position_type : std :: string :: String , pub baseline_length : f32 , pub heading : f32 , pub pitch : f32 , pub heading_sigma : f32 , pub pitch_sigma : f32 , pub station_id : std :: string :: String , pub num_satellites_tracked : u8 , pub num_satellites_used_in_solution : u8 , pub num_satellites_above_elevation_mask_angle : u8 , pub num_satellites_above_elevation_mask_angle_l2 : u8 , pub solution_source : u8 , pub extended_solution_status : novatel_gps_msgs :: msg :: NovatelExtendedSolutionStatus , pub signal_mask : novatel_gps_msgs :: msg :: NovatelSignalMask } impl WrappedTypesupport for NovatelDualAntennaHeading { type CStruct = novatel_gps_msgs__msg__NovatelDualAntennaHeading ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__novatel_gps_msgs__msg__NovatelDualAntennaHeading () } } fn create_msg () -> * mut novatel_gps_msgs__msg__NovatelDualAntennaHeading { unsafe { novatel_gps_msgs__msg__NovatelDualAntennaHeading__create () } } fn destroy_msg (msg : * mut novatel_gps_msgs__msg__NovatelDualAntennaHeading) -> () { unsafe { novatel_gps_msgs__msg__NovatelDualAntennaHeading__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> NovatelDualAntennaHeading { NovatelDualAntennaHeading { header : std_msgs :: msg :: Header :: from_native (& msg . header) , novatel_msg_header : novatel_gps_msgs :: msg :: NovatelMessageHeader :: from_native (& msg . novatel_msg_header) , solution_status : msg . solution_status . to_str () . to_owned () , position_type : msg . position_type . to_str () . to_owned () , baseline_length : msg . baseline_length , heading : msg . heading , pitch : msg . pitch , heading_sigma : msg . heading_sigma , pitch_sigma : msg . pitch_sigma , station_id : msg . station_id . to_str () . to_owned () , num_satellites_tracked : msg . num_satellites_tracked , num_satellites_used_in_solution : msg . num_satellites_used_in_solution , num_satellites_above_elevation_mask_angle : msg . num_satellites_above_elevation_mask_angle , num_satellites_above_elevation_mask_angle_l2 : msg . num_satellites_above_elevation_mask_angle_l2 , solution_source : msg . solution_source , extended_solution_status : novatel_gps_msgs :: msg :: NovatelExtendedSolutionStatus :: from_native (& msg . extended_solution_status) , signal_mask : novatel_gps_msgs :: msg :: NovatelSignalMask :: from_native (& msg . signal_mask) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; self . novatel_msg_header . copy_to_native (& mut msg . novatel_msg_header) ; msg . solution_status . assign (& self . solution_status) ; msg . position_type . assign (& self . position_type) ; msg . baseline_length = self . baseline_length ; msg . heading = self . heading ; msg . pitch = self . pitch ; msg . heading_sigma = self . heading_sigma ; msg . pitch_sigma = self . pitch_sigma ; msg . station_id . assign (& self . station_id) ; msg . num_satellites_tracked = self . num_satellites_tracked ; msg . num_satellites_used_in_solution = self . num_satellites_used_in_solution ; msg . num_satellites_above_elevation_mask_angle = self . num_satellites_above_elevation_mask_angle ; msg . num_satellites_above_elevation_mask_angle_l2 = self . num_satellites_above_elevation_mask_angle_l2 ; msg . solution_source = self . solution_source ; self . extended_solution_status . copy_to_native (& mut msg . extended_solution_status) ; self . signal_mask . copy_to_native (& mut msg . signal_mask) ; } } impl Default for NovatelDualAntennaHeading { fn default () -> Self { let msg_native = WrappedNativeMsg :: < NovatelDualAntennaHeading > :: new () ; NovatelDualAntennaHeading :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl NovatelDualAntennaHeading { pub const SOURCE_PRIMARY_ANTENNA : _bindgen_ty_1145 = novatel_gps_msgs__msg__NovatelDualAntennaHeading__SOURCE_PRIMARY_ANTENNA ; pub const SOURCE_SECONDARY_ANTENNA : _bindgen_ty_1146 = novatel_gps_msgs__msg__NovatelDualAntennaHeading__SOURCE_SECONDARY_ANTENNA ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct NovatelExtendedSolutionStatus { pub original_mask : u32 , pub advance_rtk_verified : bool , pub psuedorange_iono_correction : std :: string :: String } impl WrappedTypesupport for NovatelExtendedSolutionStatus { type CStruct = novatel_gps_msgs__msg__NovatelExtendedSolutionStatus ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__novatel_gps_msgs__msg__NovatelExtendedSolutionStatus () } } fn create_msg () -> * mut novatel_gps_msgs__msg__NovatelExtendedSolutionStatus { unsafe { novatel_gps_msgs__msg__NovatelExtendedSolutionStatus__create () } } fn destroy_msg (msg : * mut novatel_gps_msgs__msg__NovatelExtendedSolutionStatus) -> () { unsafe { novatel_gps_msgs__msg__NovatelExtendedSolutionStatus__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> NovatelExtendedSolutionStatus { NovatelExtendedSolutionStatus { original_mask : msg . original_mask , advance_rtk_verified : msg . advance_rtk_verified , psuedorange_iono_correction : msg . psuedorange_iono_correction . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . original_mask = self . original_mask ; msg . advance_rtk_verified = self . advance_rtk_verified ; msg . psuedorange_iono_correction . assign (& self . psuedorange_iono_correction) ; } } impl Default for NovatelExtendedSolutionStatus { fn default () -> Self { let msg_native = WrappedNativeMsg :: < NovatelExtendedSolutionStatus > :: new () ; NovatelExtendedSolutionStatus :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct NovatelHeading2 { pub header : std_msgs :: msg :: Header , pub novatel_msg_header : novatel_gps_msgs :: msg :: NovatelMessageHeader , pub solution_status : std :: string :: String , pub position_type : std :: string :: String , pub baseline_length : f32 , pub heading : f32 , pub pitch : f32 , pub heading_sigma : f32 , pub pitch_sigma : f32 , pub rover_station_id : std :: string :: String , pub master_station_id : std :: string :: String , pub num_satellites_tracked : u8 , pub num_satellites_used_in_solution : u8 , pub num_satellites_above_elevation_mask_angle : u8 , pub num_satellites_above_elevation_mask_angle_l2 : u8 , pub solution_source : u8 , pub extended_solution_status : novatel_gps_msgs :: msg :: NovatelExtendedSolutionStatus , pub signal_mask : novatel_gps_msgs :: msg :: NovatelSignalMask } impl WrappedTypesupport for NovatelHeading2 { type CStruct = novatel_gps_msgs__msg__NovatelHeading2 ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__novatel_gps_msgs__msg__NovatelHeading2 () } } fn create_msg () -> * mut novatel_gps_msgs__msg__NovatelHeading2 { unsafe { novatel_gps_msgs__msg__NovatelHeading2__create () } } fn destroy_msg (msg : * mut novatel_gps_msgs__msg__NovatelHeading2) -> () { unsafe { novatel_gps_msgs__msg__NovatelHeading2__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> NovatelHeading2 { NovatelHeading2 { header : std_msgs :: msg :: Header :: from_native (& msg . header) , novatel_msg_header : novatel_gps_msgs :: msg :: NovatelMessageHeader :: from_native (& msg . novatel_msg_header) , solution_status : msg . solution_status . to_str () . to_owned () , position_type : msg . position_type . to_str () . to_owned () , baseline_length : msg . baseline_length , heading : msg . heading , pitch : msg . pitch , heading_sigma : msg . heading_sigma , pitch_sigma : msg . pitch_sigma , rover_station_id : msg . rover_station_id . to_str () . to_owned () , master_station_id : msg . master_station_id . to_str () . to_owned () , num_satellites_tracked : msg . num_satellites_tracked , num_satellites_used_in_solution : msg . num_satellites_used_in_solution , num_satellites_above_elevation_mask_angle : msg . num_satellites_above_elevation_mask_angle , num_satellites_above_elevation_mask_angle_l2 : msg . num_satellites_above_elevation_mask_angle_l2 , solution_source : msg . solution_source , extended_solution_status : novatel_gps_msgs :: msg :: NovatelExtendedSolutionStatus :: from_native (& msg . extended_solution_status) , signal_mask : novatel_gps_msgs :: msg :: NovatelSignalMask :: from_native (& msg . signal_mask) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; self . novatel_msg_header . copy_to_native (& mut msg . novatel_msg_header) ; msg . solution_status . assign (& self . solution_status) ; msg . position_type . assign (& self . position_type) ; msg . baseline_length = self . baseline_length ; msg . heading = self . heading ; msg . pitch = self . pitch ; msg . heading_sigma = self . heading_sigma ; msg . pitch_sigma = self . pitch_sigma ; msg . rover_station_id . assign (& self . rover_station_id) ; msg . master_station_id . assign (& self . master_station_id) ; msg . num_satellites_tracked = self . num_satellites_tracked ; msg . num_satellites_used_in_solution = self . num_satellites_used_in_solution ; msg . num_satellites_above_elevation_mask_angle = self . num_satellites_above_elevation_mask_angle ; msg . num_satellites_above_elevation_mask_angle_l2 = self . num_satellites_above_elevation_mask_angle_l2 ; msg . solution_source = self . solution_source ; self . extended_solution_status . copy_to_native (& mut msg . extended_solution_status) ; self . signal_mask . copy_to_native (& mut msg . signal_mask) ; } } impl Default for NovatelHeading2 { fn default () -> Self { let msg_native = WrappedNativeMsg :: < NovatelHeading2 > :: new () ; NovatelHeading2 :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl NovatelHeading2 { pub const SOURCE_PRIMARY_ANTENNA : _bindgen_ty_1147 = novatel_gps_msgs__msg__NovatelHeading2__SOURCE_PRIMARY_ANTENNA ; pub const SOURCE_SECONDARY_ANTENNA : _bindgen_ty_1148 = novatel_gps_msgs__msg__NovatelHeading2__SOURCE_SECONDARY_ANTENNA ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct NovatelMessageHeader { pub message_name : std :: string :: String , pub port : std :: string :: String , pub sequence_num : u32 , pub percent_idle_time : f32 , pub gps_time_status : std :: string :: String , pub gps_week_num : u32 , pub gps_seconds : f64 , pub receiver_status : novatel_gps_msgs :: msg :: NovatelReceiverStatus , pub receiver_software_version : u32 } impl WrappedTypesupport for NovatelMessageHeader { type CStruct = novatel_gps_msgs__msg__NovatelMessageHeader ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__novatel_gps_msgs__msg__NovatelMessageHeader () } } fn create_msg () -> * mut novatel_gps_msgs__msg__NovatelMessageHeader { unsafe { novatel_gps_msgs__msg__NovatelMessageHeader__create () } } fn destroy_msg (msg : * mut novatel_gps_msgs__msg__NovatelMessageHeader) -> () { unsafe { novatel_gps_msgs__msg__NovatelMessageHeader__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> NovatelMessageHeader { NovatelMessageHeader { message_name : msg . message_name . to_str () . to_owned () , port : msg . port . to_str () . to_owned () , sequence_num : msg . sequence_num , percent_idle_time : msg . percent_idle_time , gps_time_status : msg . gps_time_status . to_str () . to_owned () , gps_week_num : msg . gps_week_num , gps_seconds : msg . gps_seconds , receiver_status : novatel_gps_msgs :: msg :: NovatelReceiverStatus :: from_native (& msg . receiver_status) , receiver_software_version : msg . receiver_software_version , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . message_name . assign (& self . message_name) ; msg . port . assign (& self . port) ; msg . sequence_num = self . sequence_num ; msg . percent_idle_time = self . percent_idle_time ; msg . gps_time_status . assign (& self . gps_time_status) ; msg . gps_week_num = self . gps_week_num ; msg . gps_seconds = self . gps_seconds ; self . receiver_status . copy_to_native (& mut msg . receiver_status) ; msg . receiver_software_version = self . receiver_software_version ; } } impl Default for NovatelMessageHeader { fn default () -> Self { let msg_native = WrappedNativeMsg :: < NovatelMessageHeader > :: new () ; NovatelMessageHeader :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct NovatelPosition { pub header : std_msgs :: msg :: Header , pub novatel_msg_header : novatel_gps_msgs :: msg :: NovatelMessageHeader , pub solution_status : std :: string :: String , pub position_type : std :: string :: String , pub lat : f64 , pub lon : f64 , pub height : f64 , pub undulation : f32 , pub datum_id : std :: string :: String , pub lat_sigma : f32 , pub lon_sigma : f32 , pub height_sigma : f32 , pub base_station_id : std :: string :: String , pub diff_age : f32 , pub solution_age : f32 , pub num_satellites_tracked : u8 , pub num_satellites_used_in_solution : u8 , pub num_gps_and_glonass_l1_used_in_solution : u8 , pub num_gps_and_glonass_l1_and_l2_used_in_solution : u8 , pub extended_solution_status : novatel_gps_msgs :: msg :: NovatelExtendedSolutionStatus , pub signal_mask : novatel_gps_msgs :: msg :: NovatelSignalMask } impl WrappedTypesupport for NovatelPosition { type CStruct = novatel_gps_msgs__msg__NovatelPosition ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__novatel_gps_msgs__msg__NovatelPosition () } } fn create_msg () -> * mut novatel_gps_msgs__msg__NovatelPosition { unsafe { novatel_gps_msgs__msg__NovatelPosition__create () } } fn destroy_msg (msg : * mut novatel_gps_msgs__msg__NovatelPosition) -> () { unsafe { novatel_gps_msgs__msg__NovatelPosition__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> NovatelPosition { NovatelPosition { header : std_msgs :: msg :: Header :: from_native (& msg . header) , novatel_msg_header : novatel_gps_msgs :: msg :: NovatelMessageHeader :: from_native (& msg . novatel_msg_header) , solution_status : msg . solution_status . to_str () . to_owned () , position_type : msg . position_type . to_str () . to_owned () , lat : msg . lat , lon : msg . lon , height : msg . height , undulation : msg . undulation , datum_id : msg . datum_id . to_str () . to_owned () , lat_sigma : msg . lat_sigma , lon_sigma : msg . lon_sigma , height_sigma : msg . height_sigma , base_station_id : msg . base_station_id . to_str () . to_owned () , diff_age : msg . diff_age , solution_age : msg . solution_age , num_satellites_tracked : msg . num_satellites_tracked , num_satellites_used_in_solution : msg . num_satellites_used_in_solution , num_gps_and_glonass_l1_used_in_solution : msg . num_gps_and_glonass_l1_used_in_solution , num_gps_and_glonass_l1_and_l2_used_in_solution : msg . num_gps_and_glonass_l1_and_l2_used_in_solution , extended_solution_status : novatel_gps_msgs :: msg :: NovatelExtendedSolutionStatus :: from_native (& msg . extended_solution_status) , signal_mask : novatel_gps_msgs :: msg :: NovatelSignalMask :: from_native (& msg . signal_mask) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; self . novatel_msg_header . copy_to_native (& mut msg . novatel_msg_header) ; msg . solution_status . assign (& self . solution_status) ; msg . position_type . assign (& self . position_type) ; msg . lat = self . lat ; msg . lon = self . lon ; msg . height = self . height ; msg . undulation = self . undulation ; msg . datum_id . assign (& self . datum_id) ; msg . lat_sigma = self . lat_sigma ; msg . lon_sigma = self . lon_sigma ; msg . height_sigma = self . height_sigma ; msg . base_station_id . assign (& self . base_station_id) ; msg . diff_age = self . diff_age ; msg . solution_age = self . solution_age ; msg . num_satellites_tracked = self . num_satellites_tracked ; msg . num_satellites_used_in_solution = self . num_satellites_used_in_solution ; msg . num_gps_and_glonass_l1_used_in_solution = self . num_gps_and_glonass_l1_used_in_solution ; msg . num_gps_and_glonass_l1_and_l2_used_in_solution = self . num_gps_and_glonass_l1_and_l2_used_in_solution ; self . extended_solution_status . copy_to_native (& mut msg . extended_solution_status) ; self . signal_mask . copy_to_native (& mut msg . signal_mask) ; } } impl Default for NovatelPosition { fn default () -> Self { let msg_native = WrappedNativeMsg :: < NovatelPosition > :: new () ; NovatelPosition :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct NovatelPsrdop2 { pub header : std_msgs :: msg :: Header , pub novatel_msg_header : novatel_gps_msgs :: msg :: NovatelMessageHeader , pub gdop : f32 , pub pdop : f32 , pub hdop : f32 , pub vdop : f32 , pub systems : Vec < novatel_gps_msgs :: msg :: NovatelPsrdop2System > } impl WrappedTypesupport for NovatelPsrdop2 { type CStruct = novatel_gps_msgs__msg__NovatelPsrdop2 ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__novatel_gps_msgs__msg__NovatelPsrdop2 () } } fn create_msg () -> * mut novatel_gps_msgs__msg__NovatelPsrdop2 { unsafe { novatel_gps_msgs__msg__NovatelPsrdop2__create () } } fn destroy_msg (msg : * mut novatel_gps_msgs__msg__NovatelPsrdop2) -> () { unsafe { novatel_gps_msgs__msg__NovatelPsrdop2__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> NovatelPsrdop2 { NovatelPsrdop2 { header : std_msgs :: msg :: Header :: from_native (& msg . header) , novatel_msg_header : novatel_gps_msgs :: msg :: NovatelMessageHeader :: from_native (& msg . novatel_msg_header) , gdop : msg . gdop , pdop : msg . pdop , hdop : msg . hdop , vdop : msg . vdop , systems : { let mut temp = Vec :: with_capacity (msg . systems . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . systems . data , msg . systems . size) } ; for s in slice { temp . push (novatel_gps_msgs :: msg :: NovatelPsrdop2System :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; self . novatel_msg_header . copy_to_native (& mut msg . novatel_msg_header) ; msg . gdop = self . gdop ; msg . pdop = self . pdop ; msg . hdop = self . hdop ; msg . vdop = self . vdop ; unsafe { novatel_gps_msgs__msg__NovatelPsrdop2System__Sequence__fini (& mut msg . systems) ; novatel_gps_msgs__msg__NovatelPsrdop2System__Sequence__init (& mut msg . systems , self . systems . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . systems . data , msg . systems . size) ; for (t , s) in slice . iter_mut () . zip (& self . systems) { s . copy_to_native (t) ; } } } } impl Default for NovatelPsrdop2 { fn default () -> Self { let msg_native = WrappedNativeMsg :: < NovatelPsrdop2 > :: new () ; NovatelPsrdop2 :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct NovatelPsrdop2System { pub system : std :: string :: String , pub tdop : f32 } impl WrappedTypesupport for NovatelPsrdop2System { type CStruct = novatel_gps_msgs__msg__NovatelPsrdop2System ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__novatel_gps_msgs__msg__NovatelPsrdop2System () } } fn create_msg () -> * mut novatel_gps_msgs__msg__NovatelPsrdop2System { unsafe { novatel_gps_msgs__msg__NovatelPsrdop2System__create () } } fn destroy_msg (msg : * mut novatel_gps_msgs__msg__NovatelPsrdop2System) -> () { unsafe { novatel_gps_msgs__msg__NovatelPsrdop2System__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> NovatelPsrdop2System { NovatelPsrdop2System { system : msg . system . to_str () . to_owned () , tdop : msg . tdop , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . system . assign (& self . system) ; msg . tdop = self . tdop ; } } impl Default for NovatelPsrdop2System { fn default () -> Self { let msg_native = WrappedNativeMsg :: < NovatelPsrdop2System > :: new () ; NovatelPsrdop2System :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct NovatelReceiverStatus { pub original_status_code : u32 , pub error_flag : bool , pub temperature_flag : bool , pub voltage_supply_flag : bool , pub antenna_powered : bool , pub antenna_is_open : bool , pub antenna_is_shorted : bool , pub cpu_overload_flag : bool , pub com1_buffer_overrun : bool , pub com2_buffer_overrun : bool , pub com3_buffer_overrun : bool , pub usb_buffer_overrun : bool , pub rf1_agc_flag : bool , pub rf2_agc_flag : bool , pub almanac_flag : bool , pub position_solution_flag : bool , pub position_fixed_flag : bool , pub clock_steering_status_enabled : bool , pub clock_model_flag : bool , pub oemv_external_oscillator_flag : bool , pub software_resource_flag : bool , pub aux1_status_event_flag : bool , pub aux2_status_event_flag : bool , pub aux3_status_event_flag : bool } impl WrappedTypesupport for NovatelReceiverStatus { type CStruct = novatel_gps_msgs__msg__NovatelReceiverStatus ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__novatel_gps_msgs__msg__NovatelReceiverStatus () } } fn create_msg () -> * mut novatel_gps_msgs__msg__NovatelReceiverStatus { unsafe { novatel_gps_msgs__msg__NovatelReceiverStatus__create () } } fn destroy_msg (msg : * mut novatel_gps_msgs__msg__NovatelReceiverStatus) -> () { unsafe { novatel_gps_msgs__msg__NovatelReceiverStatus__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> NovatelReceiverStatus { NovatelReceiverStatus { original_status_code : msg . original_status_code , error_flag : msg . error_flag , temperature_flag : msg . temperature_flag , voltage_supply_flag : msg . voltage_supply_flag , antenna_powered : msg . antenna_powered , antenna_is_open : msg . antenna_is_open , antenna_is_shorted : msg . antenna_is_shorted , cpu_overload_flag : msg . cpu_overload_flag , com1_buffer_overrun : msg . com1_buffer_overrun , com2_buffer_overrun : msg . com2_buffer_overrun , com3_buffer_overrun : msg . com3_buffer_overrun , usb_buffer_overrun : msg . usb_buffer_overrun , rf1_agc_flag : msg . rf1_agc_flag , rf2_agc_flag : msg . rf2_agc_flag , almanac_flag : msg . almanac_flag , position_solution_flag : msg . position_solution_flag , position_fixed_flag : msg . position_fixed_flag , clock_steering_status_enabled : msg . clock_steering_status_enabled , clock_model_flag : msg . clock_model_flag , oemv_external_oscillator_flag : msg . oemv_external_oscillator_flag , software_resource_flag : msg . software_resource_flag , aux1_status_event_flag : msg . aux1_status_event_flag , aux2_status_event_flag : msg . aux2_status_event_flag , aux3_status_event_flag : msg . aux3_status_event_flag , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . original_status_code = self . original_status_code ; msg . error_flag = self . error_flag ; msg . temperature_flag = self . temperature_flag ; msg . voltage_supply_flag = self . voltage_supply_flag ; msg . antenna_powered = self . antenna_powered ; msg . antenna_is_open = self . antenna_is_open ; msg . antenna_is_shorted = self . antenna_is_shorted ; msg . cpu_overload_flag = self . cpu_overload_flag ; msg . com1_buffer_overrun = self . com1_buffer_overrun ; msg . com2_buffer_overrun = self . com2_buffer_overrun ; msg . com3_buffer_overrun = self . com3_buffer_overrun ; msg . usb_buffer_overrun = self . usb_buffer_overrun ; msg . rf1_agc_flag = self . rf1_agc_flag ; msg . rf2_agc_flag = self . rf2_agc_flag ; msg . almanac_flag = self . almanac_flag ; msg . position_solution_flag = self . position_solution_flag ; msg . position_fixed_flag = self . position_fixed_flag ; msg . clock_steering_status_enabled = self . clock_steering_status_enabled ; msg . clock_model_flag = self . clock_model_flag ; msg . oemv_external_oscillator_flag = self . oemv_external_oscillator_flag ; msg . software_resource_flag = self . software_resource_flag ; msg . aux1_status_event_flag = self . aux1_status_event_flag ; msg . aux2_status_event_flag = self . aux2_status_event_flag ; msg . aux3_status_event_flag = self . aux3_status_event_flag ; } } impl Default for NovatelReceiverStatus { fn default () -> Self { let msg_native = WrappedNativeMsg :: < NovatelReceiverStatus > :: new () ; NovatelReceiverStatus :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct NovatelSignalMask { pub original_mask : u32 , pub gps_l1_used_in_solution : bool , pub gps_l2_used_in_solution : bool , pub gps_l3_used_in_solution : bool , pub glonass_l1_used_in_solution : bool , pub glonass_l2_used_in_solution : bool } impl WrappedTypesupport for NovatelSignalMask { type CStruct = novatel_gps_msgs__msg__NovatelSignalMask ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__novatel_gps_msgs__msg__NovatelSignalMask () } } fn create_msg () -> * mut novatel_gps_msgs__msg__NovatelSignalMask { unsafe { novatel_gps_msgs__msg__NovatelSignalMask__create () } } fn destroy_msg (msg : * mut novatel_gps_msgs__msg__NovatelSignalMask) -> () { unsafe { novatel_gps_msgs__msg__NovatelSignalMask__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> NovatelSignalMask { NovatelSignalMask { original_mask : msg . original_mask , gps_l1_used_in_solution : msg . gps_l1_used_in_solution , gps_l2_used_in_solution : msg . gps_l2_used_in_solution , gps_l3_used_in_solution : msg . gps_l3_used_in_solution , glonass_l1_used_in_solution : msg . glonass_l1_used_in_solution , glonass_l2_used_in_solution : msg . glonass_l2_used_in_solution , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . original_mask = self . original_mask ; msg . gps_l1_used_in_solution = self . gps_l1_used_in_solution ; msg . gps_l2_used_in_solution = self . gps_l2_used_in_solution ; msg . gps_l3_used_in_solution = self . gps_l3_used_in_solution ; msg . glonass_l1_used_in_solution = self . glonass_l1_used_in_solution ; msg . glonass_l2_used_in_solution = self . glonass_l2_used_in_solution ; } } impl Default for NovatelSignalMask { fn default () -> Self { let msg_native = WrappedNativeMsg :: < NovatelSignalMask > :: new () ; NovatelSignalMask :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct NovatelUtmPosition { pub header : std_msgs :: msg :: Header , pub novatel_msg_header : novatel_gps_msgs :: msg :: NovatelMessageHeader , pub solution_status : std :: string :: String , pub position_type : std :: string :: String , pub lon_zone_number : u32 , pub lat_zone_letter : std :: string :: String , pub northing : f64 , pub easting : f64 , pub height : f64 , pub undulation : f32 , pub datum_id : std :: string :: String , pub northing_sigma : f32 , pub easting_sigma : f32 , pub height_sigma : f32 , pub base_station_id : std :: string :: String , pub diff_age : f32 , pub solution_age : f32 , pub num_satellites_tracked : u8 , pub num_satellites_used_in_solution : u8 , pub num_gps_and_glonass_l1_used_in_solution : u8 , pub num_gps_and_glonass_l1_and_l2_used_in_solution : u8 , pub extended_solution_status : novatel_gps_msgs :: msg :: NovatelExtendedSolutionStatus , pub signal_mask : novatel_gps_msgs :: msg :: NovatelSignalMask } impl WrappedTypesupport for NovatelUtmPosition { type CStruct = novatel_gps_msgs__msg__NovatelUtmPosition ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__novatel_gps_msgs__msg__NovatelUtmPosition () } } fn create_msg () -> * mut novatel_gps_msgs__msg__NovatelUtmPosition { unsafe { novatel_gps_msgs__msg__NovatelUtmPosition__create () } } fn destroy_msg (msg : * mut novatel_gps_msgs__msg__NovatelUtmPosition) -> () { unsafe { novatel_gps_msgs__msg__NovatelUtmPosition__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> NovatelUtmPosition { NovatelUtmPosition { header : std_msgs :: msg :: Header :: from_native (& msg . header) , novatel_msg_header : novatel_gps_msgs :: msg :: NovatelMessageHeader :: from_native (& msg . novatel_msg_header) , solution_status : msg . solution_status . to_str () . to_owned () , position_type : msg . position_type . to_str () . to_owned () , lon_zone_number : msg . lon_zone_number , lat_zone_letter : msg . lat_zone_letter . to_str () . to_owned () , northing : msg . northing , easting : msg . easting , height : msg . height , undulation : msg . undulation , datum_id : msg . datum_id . to_str () . to_owned () , northing_sigma : msg . northing_sigma , easting_sigma : msg . easting_sigma , height_sigma : msg . height_sigma , base_station_id : msg . base_station_id . to_str () . to_owned () , diff_age : msg . diff_age , solution_age : msg . solution_age , num_satellites_tracked : msg . num_satellites_tracked , num_satellites_used_in_solution : msg . num_satellites_used_in_solution , num_gps_and_glonass_l1_used_in_solution : msg . num_gps_and_glonass_l1_used_in_solution , num_gps_and_glonass_l1_and_l2_used_in_solution : msg . num_gps_and_glonass_l1_and_l2_used_in_solution , extended_solution_status : novatel_gps_msgs :: msg :: NovatelExtendedSolutionStatus :: from_native (& msg . extended_solution_status) , signal_mask : novatel_gps_msgs :: msg :: NovatelSignalMask :: from_native (& msg . signal_mask) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; self . novatel_msg_header . copy_to_native (& mut msg . novatel_msg_header) ; msg . solution_status . assign (& self . solution_status) ; msg . position_type . assign (& self . position_type) ; msg . lon_zone_number = self . lon_zone_number ; msg . lat_zone_letter . assign (& self . lat_zone_letter) ; msg . northing = self . northing ; msg . easting = self . easting ; msg . height = self . height ; msg . undulation = self . undulation ; msg . datum_id . assign (& self . datum_id) ; msg . northing_sigma = self . northing_sigma ; msg . easting_sigma = self . easting_sigma ; msg . height_sigma = self . height_sigma ; msg . base_station_id . assign (& self . base_station_id) ; msg . diff_age = self . diff_age ; msg . solution_age = self . solution_age ; msg . num_satellites_tracked = self . num_satellites_tracked ; msg . num_satellites_used_in_solution = self . num_satellites_used_in_solution ; msg . num_gps_and_glonass_l1_used_in_solution = self . num_gps_and_glonass_l1_used_in_solution ; msg . num_gps_and_glonass_l1_and_l2_used_in_solution = self . num_gps_and_glonass_l1_and_l2_used_in_solution ; self . extended_solution_status . copy_to_native (& mut msg . extended_solution_status) ; self . signal_mask . copy_to_native (& mut msg . signal_mask) ; } } impl Default for NovatelUtmPosition { fn default () -> Self { let msg_native = WrappedNativeMsg :: < NovatelUtmPosition > :: new () ; NovatelUtmPosition :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct NovatelVelocity { pub header : std_msgs :: msg :: Header , pub novatel_msg_header : novatel_gps_msgs :: msg :: NovatelMessageHeader , pub solution_status : std :: string :: String , pub velocity_type : std :: string :: String , pub latency : f32 , pub age : f32 , pub horizontal_speed : f64 , pub track_ground : f64 , pub vertical_speed : f64 } impl WrappedTypesupport for NovatelVelocity { type CStruct = novatel_gps_msgs__msg__NovatelVelocity ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__novatel_gps_msgs__msg__NovatelVelocity () } } fn create_msg () -> * mut novatel_gps_msgs__msg__NovatelVelocity { unsafe { novatel_gps_msgs__msg__NovatelVelocity__create () } } fn destroy_msg (msg : * mut novatel_gps_msgs__msg__NovatelVelocity) -> () { unsafe { novatel_gps_msgs__msg__NovatelVelocity__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> NovatelVelocity { NovatelVelocity { header : std_msgs :: msg :: Header :: from_native (& msg . header) , novatel_msg_header : novatel_gps_msgs :: msg :: NovatelMessageHeader :: from_native (& msg . novatel_msg_header) , solution_status : msg . solution_status . to_str () . to_owned () , velocity_type : msg . velocity_type . to_str () . to_owned () , latency : msg . latency , age : msg . age , horizontal_speed : msg . horizontal_speed , track_ground : msg . track_ground , vertical_speed : msg . vertical_speed , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; self . novatel_msg_header . copy_to_native (& mut msg . novatel_msg_header) ; msg . solution_status . assign (& self . solution_status) ; msg . velocity_type . assign (& self . velocity_type) ; msg . latency = self . latency ; msg . age = self . age ; msg . horizontal_speed = self . horizontal_speed ; msg . track_ground = self . track_ground ; msg . vertical_speed = self . vertical_speed ; } } impl Default for NovatelVelocity { fn default () -> Self { let msg_native = WrappedNativeMsg :: < NovatelVelocity > :: new () ; NovatelVelocity :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct NovatelXYZ { pub header : std_msgs :: msg :: Header , pub novatel_msg_header : novatel_gps_msgs :: msg :: NovatelMessageHeader , pub solution_status : std :: string :: String , pub position_type : std :: string :: String , pub x : f64 , pub y : f64 , pub z : f64 , pub x_sigma : f32 , pub y_sigma : f32 , pub z_sigma : f32 , pub velocity_solution_status : std :: string :: String , pub velocity_type : std :: string :: String , pub x_vel : f64 , pub y_vel : f64 , pub z_vel : f64 , pub x_vel_sigma : f32 , pub y_vel_sigma : f32 , pub z_vel_sigma : f32 , pub base_station_id : std :: string :: String , pub velocity_latency : f32 , pub diff_age : f32 , pub solution_age : f32 , pub num_satellites_tracked : u8 , pub num_satellites_used_in_solution : u8 , pub num_gps_and_glonass_l1_used_in_solution : u8 , pub num_gps_and_glonass_l1_and_l2_used_in_solution : u8 , pub extended_solution_status : novatel_gps_msgs :: msg :: NovatelExtendedSolutionStatus , pub signal_mask : novatel_gps_msgs :: msg :: NovatelSignalMask } impl WrappedTypesupport for NovatelXYZ { type CStruct = novatel_gps_msgs__msg__NovatelXYZ ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__novatel_gps_msgs__msg__NovatelXYZ () } } fn create_msg () -> * mut novatel_gps_msgs__msg__NovatelXYZ { unsafe { novatel_gps_msgs__msg__NovatelXYZ__create () } } fn destroy_msg (msg : * mut novatel_gps_msgs__msg__NovatelXYZ) -> () { unsafe { novatel_gps_msgs__msg__NovatelXYZ__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> NovatelXYZ { NovatelXYZ { header : std_msgs :: msg :: Header :: from_native (& msg . header) , novatel_msg_header : novatel_gps_msgs :: msg :: NovatelMessageHeader :: from_native (& msg . novatel_msg_header) , solution_status : msg . solution_status . to_str () . to_owned () , position_type : msg . position_type . to_str () . to_owned () , x : msg . x , y : msg . y , z : msg . z , x_sigma : msg . x_sigma , y_sigma : msg . y_sigma , z_sigma : msg . z_sigma , velocity_solution_status : msg . velocity_solution_status . to_str () . to_owned () , velocity_type : msg . velocity_type . to_str () . to_owned () , x_vel : msg . x_vel , y_vel : msg . y_vel , z_vel : msg . z_vel , x_vel_sigma : msg . x_vel_sigma , y_vel_sigma : msg . y_vel_sigma , z_vel_sigma : msg . z_vel_sigma , base_station_id : msg . base_station_id . to_str () . to_owned () , velocity_latency : msg . velocity_latency , diff_age : msg . diff_age , solution_age : msg . solution_age , num_satellites_tracked : msg . num_satellites_tracked , num_satellites_used_in_solution : msg . num_satellites_used_in_solution , num_gps_and_glonass_l1_used_in_solution : msg . num_gps_and_glonass_l1_used_in_solution , num_gps_and_glonass_l1_and_l2_used_in_solution : msg . num_gps_and_glonass_l1_and_l2_used_in_solution , extended_solution_status : novatel_gps_msgs :: msg :: NovatelExtendedSolutionStatus :: from_native (& msg . extended_solution_status) , signal_mask : novatel_gps_msgs :: msg :: NovatelSignalMask :: from_native (& msg . signal_mask) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; self . novatel_msg_header . copy_to_native (& mut msg . novatel_msg_header) ; msg . solution_status . assign (& self . solution_status) ; msg . position_type . assign (& self . position_type) ; msg . x = self . x ; msg . y = self . y ; msg . z = self . z ; msg . x_sigma = self . x_sigma ; msg . y_sigma = self . y_sigma ; msg . z_sigma = self . z_sigma ; msg . velocity_solution_status . assign (& self . velocity_solution_status) ; msg . velocity_type . assign (& self . velocity_type) ; msg . x_vel = self . x_vel ; msg . y_vel = self . y_vel ; msg . z_vel = self . z_vel ; msg . x_vel_sigma = self . x_vel_sigma ; msg . y_vel_sigma = self . y_vel_sigma ; msg . z_vel_sigma = self . z_vel_sigma ; msg . base_station_id . assign (& self . base_station_id) ; msg . velocity_latency = self . velocity_latency ; msg . diff_age = self . diff_age ; msg . solution_age = self . solution_age ; msg . num_satellites_tracked = self . num_satellites_tracked ; msg . num_satellites_used_in_solution = self . num_satellites_used_in_solution ; msg . num_gps_and_glonass_l1_used_in_solution = self . num_gps_and_glonass_l1_used_in_solution ; msg . num_gps_and_glonass_l1_and_l2_used_in_solution = self . num_gps_and_glonass_l1_and_l2_used_in_solution ; self . extended_solution_status . copy_to_native (& mut msg . extended_solution_status) ; self . signal_mask . copy_to_native (& mut msg . signal_mask) ; } } impl Default for NovatelXYZ { fn default () -> Self { let msg_native = WrappedNativeMsg :: < NovatelXYZ > :: new () ; NovatelXYZ :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Range { pub header : std_msgs :: msg :: Header , pub novatel_msg_header : novatel_gps_msgs :: msg :: NovatelMessageHeader , pub numb_of_observ : i32 , pub info : Vec < novatel_gps_msgs :: msg :: RangeInformation > } impl WrappedTypesupport for Range { type CStruct = novatel_gps_msgs__msg__Range ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__novatel_gps_msgs__msg__Range () } } fn create_msg () -> * mut novatel_gps_msgs__msg__Range { unsafe { novatel_gps_msgs__msg__Range__create () } } fn destroy_msg (msg : * mut novatel_gps_msgs__msg__Range) -> () { unsafe { novatel_gps_msgs__msg__Range__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Range { Range { header : std_msgs :: msg :: Header :: from_native (& msg . header) , novatel_msg_header : novatel_gps_msgs :: msg :: NovatelMessageHeader :: from_native (& msg . novatel_msg_header) , numb_of_observ : msg . numb_of_observ , info : { let mut temp = Vec :: with_capacity (msg . info . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . info . data , msg . info . size) } ; for s in slice { temp . push (novatel_gps_msgs :: msg :: RangeInformation :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; self . novatel_msg_header . copy_to_native (& mut msg . novatel_msg_header) ; msg . numb_of_observ = self . numb_of_observ ; unsafe { novatel_gps_msgs__msg__RangeInformation__Sequence__fini (& mut msg . info) ; novatel_gps_msgs__msg__RangeInformation__Sequence__init (& mut msg . info , self . info . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . info . data , msg . info . size) ; for (t , s) in slice . iter_mut () . zip (& self . info) { s . copy_to_native (t) ; } } } } impl Default for Range { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Range > :: new () ; Range :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct RangeInformation { pub prn_number : u16 , pub glofreq : u16 , pub psr : f64 , pub psr_std : f32 , pub adr : f64 , pub adr_std : f32 , pub dopp : f32 , pub noise_density_ratio : f32 , pub locktime : f32 , pub tracking_status : u32 } impl WrappedTypesupport for RangeInformation { type CStruct = novatel_gps_msgs__msg__RangeInformation ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__novatel_gps_msgs__msg__RangeInformation () } } fn create_msg () -> * mut novatel_gps_msgs__msg__RangeInformation { unsafe { novatel_gps_msgs__msg__RangeInformation__create () } } fn destroy_msg (msg : * mut novatel_gps_msgs__msg__RangeInformation) -> () { unsafe { novatel_gps_msgs__msg__RangeInformation__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> RangeInformation { RangeInformation { prn_number : msg . prn_number , glofreq : msg . glofreq , psr : msg . psr , psr_std : msg . psr_std , adr : msg . adr , adr_std : msg . adr_std , dopp : msg . dopp , noise_density_ratio : msg . noise_density_ratio , locktime : msg . locktime , tracking_status : msg . tracking_status , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . prn_number = self . prn_number ; msg . glofreq = self . glofreq ; msg . psr = self . psr ; msg . psr_std = self . psr_std ; msg . adr = self . adr ; msg . adr_std = self . adr_std ; msg . dopp = self . dopp ; msg . noise_density_ratio = self . noise_density_ratio ; msg . locktime = self . locktime ; msg . tracking_status = self . tracking_status ; } } impl Default for RangeInformation { fn default () -> Self { let msg_native = WrappedNativeMsg :: < RangeInformation > :: new () ; RangeInformation :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Satellite { pub prn : u8 , pub elevation : u8 , pub azimuth : u16 , pub snr : i8 } impl WrappedTypesupport for Satellite { type CStruct = novatel_gps_msgs__msg__Satellite ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__novatel_gps_msgs__msg__Satellite () } } fn create_msg () -> * mut novatel_gps_msgs__msg__Satellite { unsafe { novatel_gps_msgs__msg__Satellite__create () } } fn destroy_msg (msg : * mut novatel_gps_msgs__msg__Satellite) -> () { unsafe { novatel_gps_msgs__msg__Satellite__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Satellite { Satellite { prn : msg . prn , elevation : msg . elevation , azimuth : msg . azimuth , snr : msg . snr , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . prn = self . prn ; msg . elevation = self . elevation ; msg . azimuth = self . azimuth ; msg . snr = self . snr ; } } impl Default for Satellite { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Satellite > :: new () ; Satellite :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Time { pub header : std_msgs :: msg :: Header , pub clock_status : std :: string :: String , pub offset : f64 , pub offset_std : f64 , pub utc_offset : f64 , pub utc_year : u32 , pub utc_month : u8 , pub utc_day : u8 , pub utc_hour : u8 , pub utc_minute : u8 , pub utc_millisecond : u32 , pub utc_status : std :: string :: String } impl WrappedTypesupport for Time { type CStruct = novatel_gps_msgs__msg__Time ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__novatel_gps_msgs__msg__Time () } } fn create_msg () -> * mut novatel_gps_msgs__msg__Time { unsafe { novatel_gps_msgs__msg__Time__create () } } fn destroy_msg (msg : * mut novatel_gps_msgs__msg__Time) -> () { unsafe { novatel_gps_msgs__msg__Time__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Time { Time { header : std_msgs :: msg :: Header :: from_native (& msg . header) , clock_status : msg . clock_status . to_str () . to_owned () , offset : msg . offset , offset_std : msg . offset_std , utc_offset : msg . utc_offset , utc_year : msg . utc_year , utc_month : msg . utc_month , utc_day : msg . utc_day , utc_hour : msg . utc_hour , utc_minute : msg . utc_minute , utc_millisecond : msg . utc_millisecond , utc_status : msg . utc_status . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . clock_status . assign (& self . clock_status) ; msg . offset = self . offset ; msg . offset_std = self . offset_std ; msg . utc_offset = self . utc_offset ; msg . utc_year = self . utc_year ; msg . utc_month = self . utc_month ; msg . utc_day = self . utc_day ; msg . utc_hour = self . utc_hour ; msg . utc_minute = self . utc_minute ; msg . utc_millisecond = self . utc_millisecond ; msg . utc_status . assign (& self . utc_status) ; } } impl Default for Time { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Time > :: new () ; Time :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Trackstat { pub header : std_msgs :: msg :: Header , pub solution_status : std :: string :: String , pub position_type : std :: string :: String , pub cutoff : f32 , pub channels : Vec < novatel_gps_msgs :: msg :: TrackstatChannel > } impl WrappedTypesupport for Trackstat { type CStruct = novatel_gps_msgs__msg__Trackstat ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__novatel_gps_msgs__msg__Trackstat () } } fn create_msg () -> * mut novatel_gps_msgs__msg__Trackstat { unsafe { novatel_gps_msgs__msg__Trackstat__create () } } fn destroy_msg (msg : * mut novatel_gps_msgs__msg__Trackstat) -> () { unsafe { novatel_gps_msgs__msg__Trackstat__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Trackstat { Trackstat { header : std_msgs :: msg :: Header :: from_native (& msg . header) , solution_status : msg . solution_status . to_str () . to_owned () , position_type : msg . position_type . to_str () . to_owned () , cutoff : msg . cutoff , channels : { let mut temp = Vec :: with_capacity (msg . channels . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . channels . data , msg . channels . size) } ; for s in slice { temp . push (novatel_gps_msgs :: msg :: TrackstatChannel :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . solution_status . assign (& self . solution_status) ; msg . position_type . assign (& self . position_type) ; msg . cutoff = self . cutoff ; unsafe { novatel_gps_msgs__msg__TrackstatChannel__Sequence__fini (& mut msg . channels) ; novatel_gps_msgs__msg__TrackstatChannel__Sequence__init (& mut msg . channels , self . channels . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . channels . data , msg . channels . size) ; for (t , s) in slice . iter_mut () . zip (& self . channels) { s . copy_to_native (t) ; } } } } impl Default for Trackstat { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Trackstat > :: new () ; Trackstat :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct TrackstatChannel { pub prn : i16 , pub glofreq : i16 , pub ch_tr_status : u32 , pub psr : f64 , pub doppler : f32 , pub c_no : f32 , pub locktime : f32 , pub psr_res : f32 , pub reject : std :: string :: String , pub psr_weight : f32 } impl WrappedTypesupport for TrackstatChannel { type CStruct = novatel_gps_msgs__msg__TrackstatChannel ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__novatel_gps_msgs__msg__TrackstatChannel () } } fn create_msg () -> * mut novatel_gps_msgs__msg__TrackstatChannel { unsafe { novatel_gps_msgs__msg__TrackstatChannel__create () } } fn destroy_msg (msg : * mut novatel_gps_msgs__msg__TrackstatChannel) -> () { unsafe { novatel_gps_msgs__msg__TrackstatChannel__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> TrackstatChannel { TrackstatChannel { prn : msg . prn , glofreq : msg . glofreq , ch_tr_status : msg . ch_tr_status , psr : msg . psr , doppler : msg . doppler , c_no : msg . c_no , locktime : msg . locktime , psr_res : msg . psr_res , reject : msg . reject . to_str () . to_owned () , psr_weight : msg . psr_weight , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . prn = self . prn ; msg . glofreq = self . glofreq ; msg . ch_tr_status = self . ch_tr_status ; msg . psr = self . psr ; msg . doppler = self . doppler ; msg . c_no = self . c_no ; msg . locktime = self . locktime ; msg . psr_res = self . psr_res ; msg . reject . assign (& self . reject) ; msg . psr_weight = self . psr_weight ; } } impl Default for TrackstatChannel { fn default () -> Self { let msg_native = WrappedNativeMsg :: < TrackstatChannel > :: new () ; TrackstatChannel :: from_native (& msg_native) } } } pub mod srv { # [allow (non_snake_case)] pub mod NovatelFRESET { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__novatel_gps_msgs__srv__NovatelFRESET () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub target : std :: string :: String } impl WrappedTypesupport for Request { type CStruct = novatel_gps_msgs__srv__NovatelFRESET_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__novatel_gps_msgs__srv__NovatelFRESET_Request () } } fn create_msg () -> * mut novatel_gps_msgs__srv__NovatelFRESET_Request { unsafe { novatel_gps_msgs__srv__NovatelFRESET_Request__create () } } fn destroy_msg (msg : * mut novatel_gps_msgs__srv__NovatelFRESET_Request) -> () { unsafe { novatel_gps_msgs__srv__NovatelFRESET_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { target : msg . target . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . target . assign (& self . target) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool } impl WrappedTypesupport for Response { type CStruct = novatel_gps_msgs__srv__NovatelFRESET_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__novatel_gps_msgs__srv__NovatelFRESET_Response () } } fn create_msg () -> * mut novatel_gps_msgs__srv__NovatelFRESET_Response { unsafe { novatel_gps_msgs__srv__NovatelFRESET_Response__create () } } fn destroy_msg (msg : * mut novatel_gps_msgs__srv__NovatelFRESET_Response) -> () { unsafe { novatel_gps_msgs__srv__NovatelFRESET_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } }