pub mod srv { # [allow (non_snake_case)] pub mod DeviceReport { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__microstrain_inertial_msgs__srv__DeviceReport () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { } impl WrappedTypesupport for Request { type CStruct = microstrain_inertial_msgs__srv__DeviceReport_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__DeviceReport_Request () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__DeviceReport_Request { unsafe { microstrain_inertial_msgs__srv__DeviceReport_Request__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__DeviceReport_Request) -> () { unsafe { microstrain_inertial_msgs__srv__DeviceReport_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub model_name : std :: string :: String , pub model_number : std :: string :: String , pub serial_number : std :: string :: String , pub options : std :: string :: String , pub firmware_version : std :: string :: String , pub success : bool } impl WrappedTypesupport for Response { type CStruct = microstrain_inertial_msgs__srv__DeviceReport_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__DeviceReport_Response () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__DeviceReport_Response { unsafe { microstrain_inertial_msgs__srv__DeviceReport_Response__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__DeviceReport_Response) -> () { unsafe { microstrain_inertial_msgs__srv__DeviceReport_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { model_name : msg . model_name . to_str () . to_owned () , model_number : msg . model_number . to_str () . to_owned () , serial_number : msg . serial_number . to_str () . to_owned () , options : msg . options . to_str () . to_owned () , firmware_version : msg . firmware_version . to_str () . to_owned () , success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . model_name . assign (& self . model_name) ; msg . model_number . assign (& self . model_number) ; msg . serial_number . assign (& self . serial_number) ; msg . options . assign (& self . options) ; msg . firmware_version . assign (& self . firmware_version) ; msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod DeviceSettings { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__microstrain_inertial_msgs__srv__DeviceSettings () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub function_selector : u8 } impl WrappedTypesupport for Request { type CStruct = microstrain_inertial_msgs__srv__DeviceSettings_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__DeviceSettings_Request () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__DeviceSettings_Request { unsafe { microstrain_inertial_msgs__srv__DeviceSettings_Request__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__DeviceSettings_Request) -> () { unsafe { microstrain_inertial_msgs__srv__DeviceSettings_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { function_selector : msg . function_selector , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . function_selector = self . function_selector ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool } impl WrappedTypesupport for Response { type CStruct = microstrain_inertial_msgs__srv__DeviceSettings_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__DeviceSettings_Response () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__DeviceSettings_Response { unsafe { microstrain_inertial_msgs__srv__DeviceSettings_Response__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__DeviceSettings_Response) -> () { unsafe { microstrain_inertial_msgs__srv__DeviceSettings_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod ExternalHeadingUpdate { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__microstrain_inertial_msgs__srv__ExternalHeadingUpdate () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub gps_tow : f64 , pub gps_week_number : u16 , pub heading_rad : f32 , pub heading_1sigma_rad : f32 , pub heading_type : u16 , pub use_time : bool } impl WrappedTypesupport for Request { type CStruct = microstrain_inertial_msgs__srv__ExternalHeadingUpdate_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__ExternalHeadingUpdate_Request () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__ExternalHeadingUpdate_Request { unsafe { microstrain_inertial_msgs__srv__ExternalHeadingUpdate_Request__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__ExternalHeadingUpdate_Request) -> () { unsafe { microstrain_inertial_msgs__srv__ExternalHeadingUpdate_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { gps_tow : msg . gps_tow , gps_week_number : msg . gps_week_number , heading_rad : msg . heading_rad , heading_1sigma_rad : msg . heading_1sigma_rad , heading_type : msg . heading_type , use_time : msg . use_time , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . gps_tow = self . gps_tow ; msg . gps_week_number = self . gps_week_number ; msg . heading_rad = self . heading_rad ; msg . heading_1sigma_rad = self . heading_1sigma_rad ; msg . heading_type = self . heading_type ; msg . use_time = self . use_time ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl Request { pub const HEADING_TYPE_MAGNETIC : _bindgen_ty_899 = microstrain_inertial_msgs__srv__ExternalHeadingUpdate_Request__HEADING_TYPE_MAGNETIC ; pub const HEADING_TYPE_TRUE : _bindgen_ty_898 = microstrain_inertial_msgs__srv__ExternalHeadingUpdate_Request__HEADING_TYPE_TRUE ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool } impl WrappedTypesupport for Response { type CStruct = microstrain_inertial_msgs__srv__ExternalHeadingUpdate_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__ExternalHeadingUpdate_Response () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__ExternalHeadingUpdate_Response { unsafe { microstrain_inertial_msgs__srv__ExternalHeadingUpdate_Response__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__ExternalHeadingUpdate_Response) -> () { unsafe { microstrain_inertial_msgs__srv__ExternalHeadingUpdate_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetAccelAdaptiveVals { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__microstrain_inertial_msgs__srv__GetAccelAdaptiveVals () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { } impl WrappedTypesupport for Request { type CStruct = microstrain_inertial_msgs__srv__GetAccelAdaptiveVals_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__GetAccelAdaptiveVals_Request () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__GetAccelAdaptiveVals_Request { unsafe { microstrain_inertial_msgs__srv__GetAccelAdaptiveVals_Request__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__GetAccelAdaptiveVals_Request) -> () { unsafe { microstrain_inertial_msgs__srv__GetAccelAdaptiveVals_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub enable : f32 , pub low_pass_cutoff : f32 , pub min_1sigma : f32 , pub low_limit : f32 , pub high_limit : f32 , pub low_limit_1sigma : f32 , pub high_limit_1sigma : f32 , pub success : bool } impl WrappedTypesupport for Response { type CStruct = microstrain_inertial_msgs__srv__GetAccelAdaptiveVals_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__GetAccelAdaptiveVals_Response () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__GetAccelAdaptiveVals_Response { unsafe { microstrain_inertial_msgs__srv__GetAccelAdaptiveVals_Response__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__GetAccelAdaptiveVals_Response) -> () { unsafe { microstrain_inertial_msgs__srv__GetAccelAdaptiveVals_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { enable : msg . enable , low_pass_cutoff : msg . low_pass_cutoff , min_1sigma : msg . min_1sigma , low_limit : msg . low_limit , high_limit : msg . high_limit , low_limit_1sigma : msg . low_limit_1sigma , high_limit_1sigma : msg . high_limit_1sigma , success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . enable = self . enable ; msg . low_pass_cutoff = self . low_pass_cutoff ; msg . min_1sigma = self . min_1sigma ; msg . low_limit = self . low_limit ; msg . high_limit = self . high_limit ; msg . low_limit_1sigma = self . low_limit_1sigma ; msg . high_limit_1sigma = self . high_limit_1sigma ; msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetAccelBias { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__microstrain_inertial_msgs__srv__GetAccelBias () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { } impl WrappedTypesupport for Request { type CStruct = microstrain_inertial_msgs__srv__GetAccelBias_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__GetAccelBias_Request () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__GetAccelBias_Request { unsafe { microstrain_inertial_msgs__srv__GetAccelBias_Request__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__GetAccelBias_Request) -> () { unsafe { microstrain_inertial_msgs__srv__GetAccelBias_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub bias : geometry_msgs :: msg :: Vector3 , pub success : bool } impl WrappedTypesupport for Response { type CStruct = microstrain_inertial_msgs__srv__GetAccelBias_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__GetAccelBias_Response () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__GetAccelBias_Response { unsafe { microstrain_inertial_msgs__srv__GetAccelBias_Response__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__GetAccelBias_Response) -> () { unsafe { microstrain_inertial_msgs__srv__GetAccelBias_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { bias : geometry_msgs :: msg :: Vector3 :: from_native (& msg . bias) , success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . bias . copy_to_native (& mut msg . bias) ; msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetAccelBiasModel { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__microstrain_inertial_msgs__srv__GetAccelBiasModel () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { } impl WrappedTypesupport for Request { type CStruct = microstrain_inertial_msgs__srv__GetAccelBiasModel_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__GetAccelBiasModel_Request () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__GetAccelBiasModel_Request { unsafe { microstrain_inertial_msgs__srv__GetAccelBiasModel_Request__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__GetAccelBiasModel_Request) -> () { unsafe { microstrain_inertial_msgs__srv__GetAccelBiasModel_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub noise_vector : geometry_msgs :: msg :: Vector3 , pub beta_vector : geometry_msgs :: msg :: Vector3 , pub success : bool } impl WrappedTypesupport for Response { type CStruct = microstrain_inertial_msgs__srv__GetAccelBiasModel_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__GetAccelBiasModel_Response () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__GetAccelBiasModel_Response { unsafe { microstrain_inertial_msgs__srv__GetAccelBiasModel_Response__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__GetAccelBiasModel_Response) -> () { unsafe { microstrain_inertial_msgs__srv__GetAccelBiasModel_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { noise_vector : geometry_msgs :: msg :: Vector3 :: from_native (& msg . noise_vector) , beta_vector : geometry_msgs :: msg :: Vector3 :: from_native (& msg . beta_vector) , success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . noise_vector . copy_to_native (& mut msg . noise_vector) ; self . beta_vector . copy_to_native (& mut msg . beta_vector) ; msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetAccelNoise { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__microstrain_inertial_msgs__srv__GetAccelNoise () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { } impl WrappedTypesupport for Request { type CStruct = microstrain_inertial_msgs__srv__GetAccelNoise_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__GetAccelNoise_Request () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__GetAccelNoise_Request { unsafe { microstrain_inertial_msgs__srv__GetAccelNoise_Request__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__GetAccelNoise_Request) -> () { unsafe { microstrain_inertial_msgs__srv__GetAccelNoise_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub noise : geometry_msgs :: msg :: Vector3 , pub success : bool } impl WrappedTypesupport for Response { type CStruct = microstrain_inertial_msgs__srv__GetAccelNoise_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__GetAccelNoise_Response () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__GetAccelNoise_Response { unsafe { microstrain_inertial_msgs__srv__GetAccelNoise_Response__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__GetAccelNoise_Response) -> () { unsafe { microstrain_inertial_msgs__srv__GetAccelNoise_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { noise : geometry_msgs :: msg :: Vector3 :: from_native (& msg . noise) , success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . noise . copy_to_native (& mut msg . noise) ; msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetComplementaryFilter { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__microstrain_inertial_msgs__srv__GetComplementaryFilter () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { } impl WrappedTypesupport for Request { type CStruct = microstrain_inertial_msgs__srv__GetComplementaryFilter_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__GetComplementaryFilter_Request () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__GetComplementaryFilter_Request { unsafe { microstrain_inertial_msgs__srv__GetComplementaryFilter_Request__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__GetComplementaryFilter_Request) -> () { unsafe { microstrain_inertial_msgs__srv__GetComplementaryFilter_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub north_comp_enable : i8 , pub up_comp_enable : i8 , pub north_comp_time_const : f32 , pub up_comp_time_const : f32 , pub success : bool } impl WrappedTypesupport for Response { type CStruct = microstrain_inertial_msgs__srv__GetComplementaryFilter_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__GetComplementaryFilter_Response () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__GetComplementaryFilter_Response { unsafe { microstrain_inertial_msgs__srv__GetComplementaryFilter_Response__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__GetComplementaryFilter_Response) -> () { unsafe { microstrain_inertial_msgs__srv__GetComplementaryFilter_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { north_comp_enable : msg . north_comp_enable , up_comp_enable : msg . up_comp_enable , north_comp_time_const : msg . north_comp_time_const , up_comp_time_const : msg . up_comp_time_const , success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . north_comp_enable = self . north_comp_enable ; msg . up_comp_enable = self . up_comp_enable ; msg . north_comp_time_const = self . north_comp_time_const ; msg . up_comp_time_const = self . up_comp_time_const ; msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetConingScullingComp { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__microstrain_inertial_msgs__srv__GetConingScullingComp () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { } impl WrappedTypesupport for Request { type CStruct = microstrain_inertial_msgs__srv__GetConingScullingComp_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__GetConingScullingComp_Request () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__GetConingScullingComp_Request { unsafe { microstrain_inertial_msgs__srv__GetConingScullingComp_Request__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__GetConingScullingComp_Request) -> () { unsafe { microstrain_inertial_msgs__srv__GetConingScullingComp_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub enable : i8 , pub success : bool } impl WrappedTypesupport for Response { type CStruct = microstrain_inertial_msgs__srv__GetConingScullingComp_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__GetConingScullingComp_Response () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__GetConingScullingComp_Response { unsafe { microstrain_inertial_msgs__srv__GetConingScullingComp_Response__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__GetConingScullingComp_Response) -> () { unsafe { microstrain_inertial_msgs__srv__GetConingScullingComp_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { enable : msg . enable , success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . enable = self . enable ; msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetDynamicsMode { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__microstrain_inertial_msgs__srv__GetDynamicsMode () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { } impl WrappedTypesupport for Request { type CStruct = microstrain_inertial_msgs__srv__GetDynamicsMode_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__GetDynamicsMode_Request () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__GetDynamicsMode_Request { unsafe { microstrain_inertial_msgs__srv__GetDynamicsMode_Request__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__GetDynamicsMode_Request) -> () { unsafe { microstrain_inertial_msgs__srv__GetDynamicsMode_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub mode : i8 , pub success : bool } impl WrappedTypesupport for Response { type CStruct = microstrain_inertial_msgs__srv__GetDynamicsMode_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__GetDynamicsMode_Response () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__GetDynamicsMode_Response { unsafe { microstrain_inertial_msgs__srv__GetDynamicsMode_Response__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__GetDynamicsMode_Response) -> () { unsafe { microstrain_inertial_msgs__srv__GetDynamicsMode_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { mode : msg . mode , success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . mode = self . mode ; msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetEstimationControlFlags { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__microstrain_inertial_msgs__srv__GetEstimationControlFlags () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { } impl WrappedTypesupport for Request { type CStruct = microstrain_inertial_msgs__srv__GetEstimationControlFlags_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__GetEstimationControlFlags_Request () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__GetEstimationControlFlags_Request { unsafe { microstrain_inertial_msgs__srv__GetEstimationControlFlags_Request__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__GetEstimationControlFlags_Request) -> () { unsafe { microstrain_inertial_msgs__srv__GetEstimationControlFlags_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub flags : i8 , pub success : bool } impl WrappedTypesupport for Response { type CStruct = microstrain_inertial_msgs__srv__GetEstimationControlFlags_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__GetEstimationControlFlags_Response () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__GetEstimationControlFlags_Response { unsafe { microstrain_inertial_msgs__srv__GetEstimationControlFlags_Response__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__GetEstimationControlFlags_Response) -> () { unsafe { microstrain_inertial_msgs__srv__GetEstimationControlFlags_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { flags : msg . flags , success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . flags = self . flags ; msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetGravityAdaptiveVals { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__microstrain_inertial_msgs__srv__GetGravityAdaptiveVals () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { } impl WrappedTypesupport for Request { type CStruct = microstrain_inertial_msgs__srv__GetGravityAdaptiveVals_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__GetGravityAdaptiveVals_Request () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__GetGravityAdaptiveVals_Request { unsafe { microstrain_inertial_msgs__srv__GetGravityAdaptiveVals_Request__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__GetGravityAdaptiveVals_Request) -> () { unsafe { microstrain_inertial_msgs__srv__GetGravityAdaptiveVals_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub enable : f32 , pub low_pass_cutoff : f32 , pub min_1sigma : f32 , pub low_limit : f32 , pub high_limit : f32 , pub low_limit_1sigma : f32 , pub high_limit_1sigma : f32 , pub success : bool } impl WrappedTypesupport for Response { type CStruct = microstrain_inertial_msgs__srv__GetGravityAdaptiveVals_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__GetGravityAdaptiveVals_Response () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__GetGravityAdaptiveVals_Response { unsafe { microstrain_inertial_msgs__srv__GetGravityAdaptiveVals_Response__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__GetGravityAdaptiveVals_Response) -> () { unsafe { microstrain_inertial_msgs__srv__GetGravityAdaptiveVals_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { enable : msg . enable , low_pass_cutoff : msg . low_pass_cutoff , min_1sigma : msg . min_1sigma , low_limit : msg . low_limit , high_limit : msg . high_limit , low_limit_1sigma : msg . low_limit_1sigma , high_limit_1sigma : msg . high_limit_1sigma , success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . enable = self . enable ; msg . low_pass_cutoff = self . low_pass_cutoff ; msg . min_1sigma = self . min_1sigma ; msg . low_limit = self . low_limit ; msg . high_limit = self . high_limit ; msg . low_limit_1sigma = self . low_limit_1sigma ; msg . high_limit_1sigma = self . high_limit_1sigma ; msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetGyroBias { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__microstrain_inertial_msgs__srv__GetGyroBias () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { } impl WrappedTypesupport for Request { type CStruct = microstrain_inertial_msgs__srv__GetGyroBias_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__GetGyroBias_Request () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__GetGyroBias_Request { unsafe { microstrain_inertial_msgs__srv__GetGyroBias_Request__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__GetGyroBias_Request) -> () { unsafe { microstrain_inertial_msgs__srv__GetGyroBias_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub bias : geometry_msgs :: msg :: Vector3 , pub success : bool } impl WrappedTypesupport for Response { type CStruct = microstrain_inertial_msgs__srv__GetGyroBias_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__GetGyroBias_Response () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__GetGyroBias_Response { unsafe { microstrain_inertial_msgs__srv__GetGyroBias_Response__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__GetGyroBias_Response) -> () { unsafe { microstrain_inertial_msgs__srv__GetGyroBias_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { bias : geometry_msgs :: msg :: Vector3 :: from_native (& msg . bias) , success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . bias . copy_to_native (& mut msg . bias) ; msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetGyroBiasModel { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__microstrain_inertial_msgs__srv__GetGyroBiasModel () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { } impl WrappedTypesupport for Request { type CStruct = microstrain_inertial_msgs__srv__GetGyroBiasModel_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__GetGyroBiasModel_Request () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__GetGyroBiasModel_Request { unsafe { microstrain_inertial_msgs__srv__GetGyroBiasModel_Request__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__GetGyroBiasModel_Request) -> () { unsafe { microstrain_inertial_msgs__srv__GetGyroBiasModel_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub noise_vector : geometry_msgs :: msg :: Vector3 , pub beta_vector : geometry_msgs :: msg :: Vector3 , pub success : bool } impl WrappedTypesupport for Response { type CStruct = microstrain_inertial_msgs__srv__GetGyroBiasModel_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__GetGyroBiasModel_Response () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__GetGyroBiasModel_Response { unsafe { microstrain_inertial_msgs__srv__GetGyroBiasModel_Response__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__GetGyroBiasModel_Response) -> () { unsafe { microstrain_inertial_msgs__srv__GetGyroBiasModel_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { noise_vector : geometry_msgs :: msg :: Vector3 :: from_native (& msg . noise_vector) , beta_vector : geometry_msgs :: msg :: Vector3 :: from_native (& msg . beta_vector) , success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . noise_vector . copy_to_native (& mut msg . noise_vector) ; self . beta_vector . copy_to_native (& mut msg . beta_vector) ; msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetGyroNoise { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__microstrain_inertial_msgs__srv__GetGyroNoise () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { } impl WrappedTypesupport for Request { type CStruct = microstrain_inertial_msgs__srv__GetGyroNoise_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__GetGyroNoise_Request () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__GetGyroNoise_Request { unsafe { microstrain_inertial_msgs__srv__GetGyroNoise_Request__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__GetGyroNoise_Request) -> () { unsafe { microstrain_inertial_msgs__srv__GetGyroNoise_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub noise : geometry_msgs :: msg :: Vector3 , pub success : bool } impl WrappedTypesupport for Response { type CStruct = microstrain_inertial_msgs__srv__GetGyroNoise_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__GetGyroNoise_Response () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__GetGyroNoise_Response { unsafe { microstrain_inertial_msgs__srv__GetGyroNoise_Response__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__GetGyroNoise_Response) -> () { unsafe { microstrain_inertial_msgs__srv__GetGyroNoise_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { noise : geometry_msgs :: msg :: Vector3 :: from_native (& msg . noise) , success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . noise . copy_to_native (& mut msg . noise) ; msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetHardIronValues { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__microstrain_inertial_msgs__srv__GetHardIronValues () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { } impl WrappedTypesupport for Request { type CStruct = microstrain_inertial_msgs__srv__GetHardIronValues_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__GetHardIronValues_Request () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__GetHardIronValues_Request { unsafe { microstrain_inertial_msgs__srv__GetHardIronValues_Request__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__GetHardIronValues_Request) -> () { unsafe { microstrain_inertial_msgs__srv__GetHardIronValues_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub bias : geometry_msgs :: msg :: Vector3 , pub success : bool } impl WrappedTypesupport for Response { type CStruct = microstrain_inertial_msgs__srv__GetHardIronValues_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__GetHardIronValues_Response () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__GetHardIronValues_Response { unsafe { microstrain_inertial_msgs__srv__GetHardIronValues_Response__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__GetHardIronValues_Response) -> () { unsafe { microstrain_inertial_msgs__srv__GetHardIronValues_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { bias : geometry_msgs :: msg :: Vector3 :: from_native (& msg . bias) , success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . bias . copy_to_native (& mut msg . bias) ; msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetHeadingSource { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__microstrain_inertial_msgs__srv__GetHeadingSource () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { } impl WrappedTypesupport for Request { type CStruct = microstrain_inertial_msgs__srv__GetHeadingSource_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__GetHeadingSource_Request () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__GetHeadingSource_Request { unsafe { microstrain_inertial_msgs__srv__GetHeadingSource_Request__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__GetHeadingSource_Request) -> () { unsafe { microstrain_inertial_msgs__srv__GetHeadingSource_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub heading_source : i8 , pub success : bool } impl WrappedTypesupport for Response { type CStruct = microstrain_inertial_msgs__srv__GetHeadingSource_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__GetHeadingSource_Response () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__GetHeadingSource_Response { unsafe { microstrain_inertial_msgs__srv__GetHeadingSource_Response__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__GetHeadingSource_Response) -> () { unsafe { microstrain_inertial_msgs__srv__GetHeadingSource_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { heading_source : msg . heading_source , success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . heading_source = self . heading_source ; msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetMagAdaptiveVals { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__microstrain_inertial_msgs__srv__GetMagAdaptiveVals () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { } impl WrappedTypesupport for Request { type CStruct = microstrain_inertial_msgs__srv__GetMagAdaptiveVals_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__GetMagAdaptiveVals_Request () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__GetMagAdaptiveVals_Request { unsafe { microstrain_inertial_msgs__srv__GetMagAdaptiveVals_Request__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__GetMagAdaptiveVals_Request) -> () { unsafe { microstrain_inertial_msgs__srv__GetMagAdaptiveVals_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub enable : f32 , pub low_pass_cutoff : f32 , pub min_1sigma : f32 , pub low_limit : f32 , pub high_limit : f32 , pub low_limit_1sigma : f32 , pub high_limit_1sigma : f32 , pub success : bool } impl WrappedTypesupport for Response { type CStruct = microstrain_inertial_msgs__srv__GetMagAdaptiveVals_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__GetMagAdaptiveVals_Response () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__GetMagAdaptiveVals_Response { unsafe { microstrain_inertial_msgs__srv__GetMagAdaptiveVals_Response__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__GetMagAdaptiveVals_Response) -> () { unsafe { microstrain_inertial_msgs__srv__GetMagAdaptiveVals_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { enable : msg . enable , low_pass_cutoff : msg . low_pass_cutoff , min_1sigma : msg . min_1sigma , low_limit : msg . low_limit , high_limit : msg . high_limit , low_limit_1sigma : msg . low_limit_1sigma , high_limit_1sigma : msg . high_limit_1sigma , success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . enable = self . enable ; msg . low_pass_cutoff = self . low_pass_cutoff ; msg . min_1sigma = self . min_1sigma ; msg . low_limit = self . low_limit ; msg . high_limit = self . high_limit ; msg . low_limit_1sigma = self . low_limit_1sigma ; msg . high_limit_1sigma = self . high_limit_1sigma ; msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetMagDipAdaptiveVals { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__microstrain_inertial_msgs__srv__GetMagDipAdaptiveVals () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { } impl WrappedTypesupport for Request { type CStruct = microstrain_inertial_msgs__srv__GetMagDipAdaptiveVals_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__GetMagDipAdaptiveVals_Request () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__GetMagDipAdaptiveVals_Request { unsafe { microstrain_inertial_msgs__srv__GetMagDipAdaptiveVals_Request__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__GetMagDipAdaptiveVals_Request) -> () { unsafe { microstrain_inertial_msgs__srv__GetMagDipAdaptiveVals_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub enable : f32 , pub low_pass_cutoff : f32 , pub min_1sigma : f32 , pub high_limit : f32 , pub high_limit_1sigma : f32 , pub success : bool } impl WrappedTypesupport for Response { type CStruct = microstrain_inertial_msgs__srv__GetMagDipAdaptiveVals_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__GetMagDipAdaptiveVals_Response () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__GetMagDipAdaptiveVals_Response { unsafe { microstrain_inertial_msgs__srv__GetMagDipAdaptiveVals_Response__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__GetMagDipAdaptiveVals_Response) -> () { unsafe { microstrain_inertial_msgs__srv__GetMagDipAdaptiveVals_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { enable : msg . enable , low_pass_cutoff : msg . low_pass_cutoff , min_1sigma : msg . min_1sigma , high_limit : msg . high_limit , high_limit_1sigma : msg . high_limit_1sigma , success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . enable = self . enable ; msg . low_pass_cutoff = self . low_pass_cutoff ; msg . min_1sigma = self . min_1sigma ; msg . high_limit = self . high_limit ; msg . high_limit_1sigma = self . high_limit_1sigma ; msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetMagNoise { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__microstrain_inertial_msgs__srv__GetMagNoise () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { } impl WrappedTypesupport for Request { type CStruct = microstrain_inertial_msgs__srv__GetMagNoise_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__GetMagNoise_Request () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__GetMagNoise_Request { unsafe { microstrain_inertial_msgs__srv__GetMagNoise_Request__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__GetMagNoise_Request) -> () { unsafe { microstrain_inertial_msgs__srv__GetMagNoise_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub noise : geometry_msgs :: msg :: Vector3 , pub success : bool } impl WrappedTypesupport for Response { type CStruct = microstrain_inertial_msgs__srv__GetMagNoise_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__GetMagNoise_Response () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__GetMagNoise_Response { unsafe { microstrain_inertial_msgs__srv__GetMagNoise_Response__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__GetMagNoise_Response) -> () { unsafe { microstrain_inertial_msgs__srv__GetMagNoise_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { noise : geometry_msgs :: msg :: Vector3 :: from_native (& msg . noise) , success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . noise . copy_to_native (& mut msg . noise) ; msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetReferencePosition { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__microstrain_inertial_msgs__srv__GetReferencePosition () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { } impl WrappedTypesupport for Request { type CStruct = microstrain_inertial_msgs__srv__GetReferencePosition_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__GetReferencePosition_Request () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__GetReferencePosition_Request { unsafe { microstrain_inertial_msgs__srv__GetReferencePosition_Request__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__GetReferencePosition_Request) -> () { unsafe { microstrain_inertial_msgs__srv__GetReferencePosition_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub position : geometry_msgs :: msg :: Vector3 , pub success : bool } impl WrappedTypesupport for Response { type CStruct = microstrain_inertial_msgs__srv__GetReferencePosition_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__GetReferencePosition_Response () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__GetReferencePosition_Response { unsafe { microstrain_inertial_msgs__srv__GetReferencePosition_Response__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__GetReferencePosition_Response) -> () { unsafe { microstrain_inertial_msgs__srv__GetReferencePosition_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { position : geometry_msgs :: msg :: Vector3 :: from_native (& msg . position) , success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . position . copy_to_native (& mut msg . position) ; msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetRelativePositionReference { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__microstrain_inertial_msgs__srv__GetRelativePositionReference () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { } impl WrappedTypesupport for Request { type CStruct = microstrain_inertial_msgs__srv__GetRelativePositionReference_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__GetRelativePositionReference_Request () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__GetRelativePositionReference_Request { unsafe { microstrain_inertial_msgs__srv__GetRelativePositionReference_Request__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__GetRelativePositionReference_Request) -> () { unsafe { microstrain_inertial_msgs__srv__GetRelativePositionReference_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub source : u8 , pub frame : u8 , pub position : geometry_msgs :: msg :: Vector3 , pub success : bool } impl WrappedTypesupport for Response { type CStruct = microstrain_inertial_msgs__srv__GetRelativePositionReference_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__GetRelativePositionReference_Response () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__GetRelativePositionReference_Response { unsafe { microstrain_inertial_msgs__srv__GetRelativePositionReference_Response__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__GetRelativePositionReference_Response) -> () { unsafe { microstrain_inertial_msgs__srv__GetRelativePositionReference_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { source : msg . source , frame : msg . frame , position : geometry_msgs :: msg :: Vector3 :: from_native (& msg . position) , success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . source = self . source ; msg . frame = self . frame ; self . position . copy_to_native (& mut msg . position) ; msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl Response { pub const FRAME_ECEF : _bindgen_ty_902 = microstrain_inertial_msgs__srv__GetRelativePositionReference_Response__FRAME_ECEF ; pub const FRAME_LLH : _bindgen_ty_903 = microstrain_inertial_msgs__srv__GetRelativePositionReference_Response__FRAME_LLH ; pub const SOURCE_AUTO : _bindgen_ty_900 = microstrain_inertial_msgs__srv__GetRelativePositionReference_Response__SOURCE_AUTO ; pub const SOURCE_MANUAL : _bindgen_ty_901 = microstrain_inertial_msgs__srv__GetRelativePositionReference_Response__SOURCE_MANUAL ; } } # [allow (non_snake_case)] pub mod GetSensor2VehicleOffset { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__microstrain_inertial_msgs__srv__GetSensor2VehicleOffset () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { } impl WrappedTypesupport for Request { type CStruct = microstrain_inertial_msgs__srv__GetSensor2VehicleOffset_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__GetSensor2VehicleOffset_Request () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__GetSensor2VehicleOffset_Request { unsafe { microstrain_inertial_msgs__srv__GetSensor2VehicleOffset_Request__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__GetSensor2VehicleOffset_Request) -> () { unsafe { microstrain_inertial_msgs__srv__GetSensor2VehicleOffset_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub offset : geometry_msgs :: msg :: Vector3 , pub success : bool } impl WrappedTypesupport for Response { type CStruct = microstrain_inertial_msgs__srv__GetSensor2VehicleOffset_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__GetSensor2VehicleOffset_Response () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__GetSensor2VehicleOffset_Response { unsafe { microstrain_inertial_msgs__srv__GetSensor2VehicleOffset_Response__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__GetSensor2VehicleOffset_Response) -> () { unsafe { microstrain_inertial_msgs__srv__GetSensor2VehicleOffset_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { offset : geometry_msgs :: msg :: Vector3 :: from_native (& msg . offset) , success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . offset . copy_to_native (& mut msg . offset) ; msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetSensor2VehicleRotation { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__microstrain_inertial_msgs__srv__GetSensor2VehicleRotation () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { } impl WrappedTypesupport for Request { type CStruct = microstrain_inertial_msgs__srv__GetSensor2VehicleRotation_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__GetSensor2VehicleRotation_Request () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__GetSensor2VehicleRotation_Request { unsafe { microstrain_inertial_msgs__srv__GetSensor2VehicleRotation_Request__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__GetSensor2VehicleRotation_Request) -> () { unsafe { microstrain_inertial_msgs__srv__GetSensor2VehicleRotation_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub angle : geometry_msgs :: msg :: Vector3 , pub success : bool } impl WrappedTypesupport for Response { type CStruct = microstrain_inertial_msgs__srv__GetSensor2VehicleRotation_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__GetSensor2VehicleRotation_Response () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__GetSensor2VehicleRotation_Response { unsafe { microstrain_inertial_msgs__srv__GetSensor2VehicleRotation_Response__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__GetSensor2VehicleRotation_Response) -> () { unsafe { microstrain_inertial_msgs__srv__GetSensor2VehicleRotation_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { angle : geometry_msgs :: msg :: Vector3 :: from_native (& msg . angle) , success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . angle . copy_to_native (& mut msg . angle) ; msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetSensor2VehicleTransformation { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__microstrain_inertial_msgs__srv__GetSensor2VehicleTransformation () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { } impl WrappedTypesupport for Request { type CStruct = microstrain_inertial_msgs__srv__GetSensor2VehicleTransformation_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__GetSensor2VehicleTransformation_Request () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__GetSensor2VehicleTransformation_Request { unsafe { microstrain_inertial_msgs__srv__GetSensor2VehicleTransformation_Request__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__GetSensor2VehicleTransformation_Request) -> () { unsafe { microstrain_inertial_msgs__srv__GetSensor2VehicleTransformation_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub offset : geometry_msgs :: msg :: Vector3 , pub rotation : geometry_msgs :: msg :: Quaternion , pub success : bool } impl WrappedTypesupport for Response { type CStruct = microstrain_inertial_msgs__srv__GetSensor2VehicleTransformation_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__GetSensor2VehicleTransformation_Response () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__GetSensor2VehicleTransformation_Response { unsafe { microstrain_inertial_msgs__srv__GetSensor2VehicleTransformation_Response__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__GetSensor2VehicleTransformation_Response) -> () { unsafe { microstrain_inertial_msgs__srv__GetSensor2VehicleTransformation_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { offset : geometry_msgs :: msg :: Vector3 :: from_native (& msg . offset) , rotation : geometry_msgs :: msg :: Quaternion :: from_native (& msg . rotation) , success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . offset . copy_to_native (& mut msg . offset) ; self . rotation . copy_to_native (& mut msg . rotation) ; msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetSoftIronMatrix { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__microstrain_inertial_msgs__srv__GetSoftIronMatrix () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { } impl WrappedTypesupport for Request { type CStruct = microstrain_inertial_msgs__srv__GetSoftIronMatrix_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__GetSoftIronMatrix_Request () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__GetSoftIronMatrix_Request { unsafe { microstrain_inertial_msgs__srv__GetSoftIronMatrix_Request__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__GetSoftIronMatrix_Request) -> () { unsafe { microstrain_inertial_msgs__srv__GetSoftIronMatrix_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub soft_iron_1 : geometry_msgs :: msg :: Vector3 , pub soft_iron_2 : geometry_msgs :: msg :: Vector3 , pub soft_iron_3 : geometry_msgs :: msg :: Vector3 , pub success : bool } impl WrappedTypesupport for Response { type CStruct = microstrain_inertial_msgs__srv__GetSoftIronMatrix_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__GetSoftIronMatrix_Response () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__GetSoftIronMatrix_Response { unsafe { microstrain_inertial_msgs__srv__GetSoftIronMatrix_Response__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__GetSoftIronMatrix_Response) -> () { unsafe { microstrain_inertial_msgs__srv__GetSoftIronMatrix_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { soft_iron_1 : geometry_msgs :: msg :: Vector3 :: from_native (& msg . soft_iron_1) , soft_iron_2 : geometry_msgs :: msg :: Vector3 :: from_native (& msg . soft_iron_2) , soft_iron_3 : geometry_msgs :: msg :: Vector3 :: from_native (& msg . soft_iron_3) , success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . soft_iron_1 . copy_to_native (& mut msg . soft_iron_1) ; self . soft_iron_2 . copy_to_native (& mut msg . soft_iron_2) ; self . soft_iron_3 . copy_to_native (& mut msg . soft_iron_3) ; msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetTareOrientation { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__microstrain_inertial_msgs__srv__GetTareOrientation () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { } impl WrappedTypesupport for Request { type CStruct = microstrain_inertial_msgs__srv__GetTareOrientation_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__GetTareOrientation_Request () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__GetTareOrientation_Request { unsafe { microstrain_inertial_msgs__srv__GetTareOrientation_Request__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__GetTareOrientation_Request) -> () { unsafe { microstrain_inertial_msgs__srv__GetTareOrientation_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub axis : i8 , pub success : bool } impl WrappedTypesupport for Response { type CStruct = microstrain_inertial_msgs__srv__GetTareOrientation_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__GetTareOrientation_Response () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__GetTareOrientation_Response { unsafe { microstrain_inertial_msgs__srv__GetTareOrientation_Response__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__GetTareOrientation_Response) -> () { unsafe { microstrain_inertial_msgs__srv__GetTareOrientation_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { axis : msg . axis , success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . axis = self . axis ; msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetZeroAngleUpdateThreshold { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__microstrain_inertial_msgs__srv__GetZeroAngleUpdateThreshold () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { } impl WrappedTypesupport for Request { type CStruct = microstrain_inertial_msgs__srv__GetZeroAngleUpdateThreshold_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__GetZeroAngleUpdateThreshold_Request () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__GetZeroAngleUpdateThreshold_Request { unsafe { microstrain_inertial_msgs__srv__GetZeroAngleUpdateThreshold_Request__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__GetZeroAngleUpdateThreshold_Request) -> () { unsafe { microstrain_inertial_msgs__srv__GetZeroAngleUpdateThreshold_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub enable : i8 , pub threshold : f32 , pub success : bool } impl WrappedTypesupport for Response { type CStruct = microstrain_inertial_msgs__srv__GetZeroAngleUpdateThreshold_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__GetZeroAngleUpdateThreshold_Response () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__GetZeroAngleUpdateThreshold_Response { unsafe { microstrain_inertial_msgs__srv__GetZeroAngleUpdateThreshold_Response__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__GetZeroAngleUpdateThreshold_Response) -> () { unsafe { microstrain_inertial_msgs__srv__GetZeroAngleUpdateThreshold_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { enable : msg . enable , threshold : msg . threshold , success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . enable = self . enable ; msg . threshold = self . threshold ; msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod GetZeroVelocityUpdateThreshold { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__microstrain_inertial_msgs__srv__GetZeroVelocityUpdateThreshold () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { } impl WrappedTypesupport for Request { type CStruct = microstrain_inertial_msgs__srv__GetZeroVelocityUpdateThreshold_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__GetZeroVelocityUpdateThreshold_Request () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__GetZeroVelocityUpdateThreshold_Request { unsafe { microstrain_inertial_msgs__srv__GetZeroVelocityUpdateThreshold_Request__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__GetZeroVelocityUpdateThreshold_Request) -> () { unsafe { microstrain_inertial_msgs__srv__GetZeroVelocityUpdateThreshold_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub enable : i8 , pub threshold : f32 , pub success : bool } impl WrappedTypesupport for Response { type CStruct = microstrain_inertial_msgs__srv__GetZeroVelocityUpdateThreshold_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__GetZeroVelocityUpdateThreshold_Response () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__GetZeroVelocityUpdateThreshold_Response { unsafe { microstrain_inertial_msgs__srv__GetZeroVelocityUpdateThreshold_Response__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__GetZeroVelocityUpdateThreshold_Response) -> () { unsafe { microstrain_inertial_msgs__srv__GetZeroVelocityUpdateThreshold_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { enable : msg . enable , threshold : msg . threshold , success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . enable = self . enable ; msg . threshold = self . threshold ; msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod InitFilterEuler { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__microstrain_inertial_msgs__srv__InitFilterEuler () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub angle : geometry_msgs :: msg :: Vector3 } impl WrappedTypesupport for Request { type CStruct = microstrain_inertial_msgs__srv__InitFilterEuler_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__InitFilterEuler_Request () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__InitFilterEuler_Request { unsafe { microstrain_inertial_msgs__srv__InitFilterEuler_Request__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__InitFilterEuler_Request) -> () { unsafe { microstrain_inertial_msgs__srv__InitFilterEuler_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { angle : geometry_msgs :: msg :: Vector3 :: from_native (& msg . angle) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . angle . copy_to_native (& mut msg . angle) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool } impl WrappedTypesupport for Response { type CStruct = microstrain_inertial_msgs__srv__InitFilterEuler_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__InitFilterEuler_Response () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__InitFilterEuler_Response { unsafe { microstrain_inertial_msgs__srv__InitFilterEuler_Response__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__InitFilterEuler_Response) -> () { unsafe { microstrain_inertial_msgs__srv__InitFilterEuler_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod InitFilterHeading { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__microstrain_inertial_msgs__srv__InitFilterHeading () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub angle : f32 } impl WrappedTypesupport for Request { type CStruct = microstrain_inertial_msgs__srv__InitFilterHeading_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__InitFilterHeading_Request () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__InitFilterHeading_Request { unsafe { microstrain_inertial_msgs__srv__InitFilterHeading_Request__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__InitFilterHeading_Request) -> () { unsafe { microstrain_inertial_msgs__srv__InitFilterHeading_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { angle : msg . angle , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . angle = self . angle ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool } impl WrappedTypesupport for Response { type CStruct = microstrain_inertial_msgs__srv__InitFilterHeading_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__InitFilterHeading_Response () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__InitFilterHeading_Response { unsafe { microstrain_inertial_msgs__srv__InitFilterHeading_Response__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__InitFilterHeading_Response) -> () { unsafe { microstrain_inertial_msgs__srv__InitFilterHeading_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod SetAccelAdaptiveVals { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__microstrain_inertial_msgs__srv__SetAccelAdaptiveVals () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub enable : f32 , pub low_pass_cutoff : f32 , pub min_1sigma : f32 , pub low_limit : f32 , pub high_limit : f32 , pub low_limit_1sigma : f32 , pub high_limit_1sigma : f32 } impl WrappedTypesupport for Request { type CStruct = microstrain_inertial_msgs__srv__SetAccelAdaptiveVals_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__SetAccelAdaptiveVals_Request () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__SetAccelAdaptiveVals_Request { unsafe { microstrain_inertial_msgs__srv__SetAccelAdaptiveVals_Request__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__SetAccelAdaptiveVals_Request) -> () { unsafe { microstrain_inertial_msgs__srv__SetAccelAdaptiveVals_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { enable : msg . enable , low_pass_cutoff : msg . low_pass_cutoff , min_1sigma : msg . min_1sigma , low_limit : msg . low_limit , high_limit : msg . high_limit , low_limit_1sigma : msg . low_limit_1sigma , high_limit_1sigma : msg . high_limit_1sigma , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . enable = self . enable ; msg . low_pass_cutoff = self . low_pass_cutoff ; msg . min_1sigma = self . min_1sigma ; msg . low_limit = self . low_limit ; msg . high_limit = self . high_limit ; msg . low_limit_1sigma = self . low_limit_1sigma ; msg . high_limit_1sigma = self . high_limit_1sigma ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool } impl WrappedTypesupport for Response { type CStruct = microstrain_inertial_msgs__srv__SetAccelAdaptiveVals_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__SetAccelAdaptiveVals_Response () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__SetAccelAdaptiveVals_Response { unsafe { microstrain_inertial_msgs__srv__SetAccelAdaptiveVals_Response__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__SetAccelAdaptiveVals_Response) -> () { unsafe { microstrain_inertial_msgs__srv__SetAccelAdaptiveVals_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod SetAccelBias { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__microstrain_inertial_msgs__srv__SetAccelBias () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub bias : geometry_msgs :: msg :: Vector3 } impl WrappedTypesupport for Request { type CStruct = microstrain_inertial_msgs__srv__SetAccelBias_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__SetAccelBias_Request () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__SetAccelBias_Request { unsafe { microstrain_inertial_msgs__srv__SetAccelBias_Request__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__SetAccelBias_Request) -> () { unsafe { microstrain_inertial_msgs__srv__SetAccelBias_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { bias : geometry_msgs :: msg :: Vector3 :: from_native (& msg . bias) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . bias . copy_to_native (& mut msg . bias) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool } impl WrappedTypesupport for Response { type CStruct = microstrain_inertial_msgs__srv__SetAccelBias_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__SetAccelBias_Response () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__SetAccelBias_Response { unsafe { microstrain_inertial_msgs__srv__SetAccelBias_Response__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__SetAccelBias_Response) -> () { unsafe { microstrain_inertial_msgs__srv__SetAccelBias_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod SetAccelBiasModel { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__microstrain_inertial_msgs__srv__SetAccelBiasModel () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub noise_vector : geometry_msgs :: msg :: Vector3 , pub beta_vector : geometry_msgs :: msg :: Vector3 } impl WrappedTypesupport for Request { type CStruct = microstrain_inertial_msgs__srv__SetAccelBiasModel_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__SetAccelBiasModel_Request () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__SetAccelBiasModel_Request { unsafe { microstrain_inertial_msgs__srv__SetAccelBiasModel_Request__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__SetAccelBiasModel_Request) -> () { unsafe { microstrain_inertial_msgs__srv__SetAccelBiasModel_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { noise_vector : geometry_msgs :: msg :: Vector3 :: from_native (& msg . noise_vector) , beta_vector : geometry_msgs :: msg :: Vector3 :: from_native (& msg . beta_vector) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . noise_vector . copy_to_native (& mut msg . noise_vector) ; self . beta_vector . copy_to_native (& mut msg . beta_vector) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool } impl WrappedTypesupport for Response { type CStruct = microstrain_inertial_msgs__srv__SetAccelBiasModel_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__SetAccelBiasModel_Response () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__SetAccelBiasModel_Response { unsafe { microstrain_inertial_msgs__srv__SetAccelBiasModel_Response__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__SetAccelBiasModel_Response) -> () { unsafe { microstrain_inertial_msgs__srv__SetAccelBiasModel_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod SetAccelNoise { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__microstrain_inertial_msgs__srv__SetAccelNoise () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub noise : geometry_msgs :: msg :: Vector3 } impl WrappedTypesupport for Request { type CStruct = microstrain_inertial_msgs__srv__SetAccelNoise_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__SetAccelNoise_Request () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__SetAccelNoise_Request { unsafe { microstrain_inertial_msgs__srv__SetAccelNoise_Request__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__SetAccelNoise_Request) -> () { unsafe { microstrain_inertial_msgs__srv__SetAccelNoise_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { noise : geometry_msgs :: msg :: Vector3 :: from_native (& msg . noise) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . noise . copy_to_native (& mut msg . noise) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool } impl WrappedTypesupport for Response { type CStruct = microstrain_inertial_msgs__srv__SetAccelNoise_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__SetAccelNoise_Response () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__SetAccelNoise_Response { unsafe { microstrain_inertial_msgs__srv__SetAccelNoise_Response__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__SetAccelNoise_Response) -> () { unsafe { microstrain_inertial_msgs__srv__SetAccelNoise_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod SetComplementaryFilter { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__microstrain_inertial_msgs__srv__SetComplementaryFilter () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub north_comp_enable : i8 , pub up_comp_enable : i8 , pub north_comp_time_const : f32 , pub up_comp_time_const : f32 } impl WrappedTypesupport for Request { type CStruct = microstrain_inertial_msgs__srv__SetComplementaryFilter_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__SetComplementaryFilter_Request () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__SetComplementaryFilter_Request { unsafe { microstrain_inertial_msgs__srv__SetComplementaryFilter_Request__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__SetComplementaryFilter_Request) -> () { unsafe { microstrain_inertial_msgs__srv__SetComplementaryFilter_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { north_comp_enable : msg . north_comp_enable , up_comp_enable : msg . up_comp_enable , north_comp_time_const : msg . north_comp_time_const , up_comp_time_const : msg . up_comp_time_const , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . north_comp_enable = self . north_comp_enable ; msg . up_comp_enable = self . up_comp_enable ; msg . north_comp_time_const = self . north_comp_time_const ; msg . up_comp_time_const = self . up_comp_time_const ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool } impl WrappedTypesupport for Response { type CStruct = microstrain_inertial_msgs__srv__SetComplementaryFilter_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__SetComplementaryFilter_Response () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__SetComplementaryFilter_Response { unsafe { microstrain_inertial_msgs__srv__SetComplementaryFilter_Response__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__SetComplementaryFilter_Response) -> () { unsafe { microstrain_inertial_msgs__srv__SetComplementaryFilter_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod SetConingScullingComp { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__microstrain_inertial_msgs__srv__SetConingScullingComp () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub enable : i8 } impl WrappedTypesupport for Request { type CStruct = microstrain_inertial_msgs__srv__SetConingScullingComp_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__SetConingScullingComp_Request () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__SetConingScullingComp_Request { unsafe { microstrain_inertial_msgs__srv__SetConingScullingComp_Request__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__SetConingScullingComp_Request) -> () { unsafe { microstrain_inertial_msgs__srv__SetConingScullingComp_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { enable : msg . enable , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . enable = self . enable ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool } impl WrappedTypesupport for Response { type CStruct = microstrain_inertial_msgs__srv__SetConingScullingComp_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__SetConingScullingComp_Response () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__SetConingScullingComp_Response { unsafe { microstrain_inertial_msgs__srv__SetConingScullingComp_Response__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__SetConingScullingComp_Response) -> () { unsafe { microstrain_inertial_msgs__srv__SetConingScullingComp_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod SetDynamicsMode { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__microstrain_inertial_msgs__srv__SetDynamicsMode () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub mode : i8 } impl WrappedTypesupport for Request { type CStruct = microstrain_inertial_msgs__srv__SetDynamicsMode_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__SetDynamicsMode_Request () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__SetDynamicsMode_Request { unsafe { microstrain_inertial_msgs__srv__SetDynamicsMode_Request__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__SetDynamicsMode_Request) -> () { unsafe { microstrain_inertial_msgs__srv__SetDynamicsMode_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { mode : msg . mode , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . mode = self . mode ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl Request { pub const AIRBORNE : _bindgen_ty_906 = microstrain_inertial_msgs__srv__SetDynamicsMode_Request__AIRBORNE ; pub const AUTOMOTIVE : _bindgen_ty_905 = microstrain_inertial_msgs__srv__SetDynamicsMode_Request__AUTOMOTIVE ; pub const PORTABLE : _bindgen_ty_904 = microstrain_inertial_msgs__srv__SetDynamicsMode_Request__PORTABLE ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool } impl WrappedTypesupport for Response { type CStruct = microstrain_inertial_msgs__srv__SetDynamicsMode_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__SetDynamicsMode_Response () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__SetDynamicsMode_Response { unsafe { microstrain_inertial_msgs__srv__SetDynamicsMode_Response__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__SetDynamicsMode_Response) -> () { unsafe { microstrain_inertial_msgs__srv__SetDynamicsMode_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod SetEstimationControlFlags { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__microstrain_inertial_msgs__srv__SetEstimationControlFlags () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub flags : i8 } impl WrappedTypesupport for Request { type CStruct = microstrain_inertial_msgs__srv__SetEstimationControlFlags_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__SetEstimationControlFlags_Request () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__SetEstimationControlFlags_Request { unsafe { microstrain_inertial_msgs__srv__SetEstimationControlFlags_Request__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__SetEstimationControlFlags_Request) -> () { unsafe { microstrain_inertial_msgs__srv__SetEstimationControlFlags_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { flags : msg . flags , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . flags = self . flags ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl Request { pub const GYRO_BIAS_ESTIMATION : _bindgen_ty_907 = microstrain_inertial_msgs__srv__SetEstimationControlFlags_Request__GYRO_BIAS_ESTIMATION ; pub const HARD_IRON_AUTO_CALIBRATION : _bindgen_ty_908 = microstrain_inertial_msgs__srv__SetEstimationControlFlags_Request__HARD_IRON_AUTO_CALIBRATION ; pub const SOFT_IRON_AUTO_CALIBRATION : _bindgen_ty_909 = microstrain_inertial_msgs__srv__SetEstimationControlFlags_Request__SOFT_IRON_AUTO_CALIBRATION ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool } impl WrappedTypesupport for Response { type CStruct = microstrain_inertial_msgs__srv__SetEstimationControlFlags_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__SetEstimationControlFlags_Response () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__SetEstimationControlFlags_Response { unsafe { microstrain_inertial_msgs__srv__SetEstimationControlFlags_Response__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__SetEstimationControlFlags_Response) -> () { unsafe { microstrain_inertial_msgs__srv__SetEstimationControlFlags_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod SetFilterSpeedLeverArm { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__microstrain_inertial_msgs__srv__SetFilterSpeedLeverArm () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub offset : geometry_msgs :: msg :: Vector3 } impl WrappedTypesupport for Request { type CStruct = microstrain_inertial_msgs__srv__SetFilterSpeedLeverArm_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__SetFilterSpeedLeverArm_Request () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__SetFilterSpeedLeverArm_Request { unsafe { microstrain_inertial_msgs__srv__SetFilterSpeedLeverArm_Request__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__SetFilterSpeedLeverArm_Request) -> () { unsafe { microstrain_inertial_msgs__srv__SetFilterSpeedLeverArm_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { offset : geometry_msgs :: msg :: Vector3 :: from_native (& msg . offset) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . offset . copy_to_native (& mut msg . offset) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool } impl WrappedTypesupport for Response { type CStruct = microstrain_inertial_msgs__srv__SetFilterSpeedLeverArm_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__SetFilterSpeedLeverArm_Response () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__SetFilterSpeedLeverArm_Response { unsafe { microstrain_inertial_msgs__srv__SetFilterSpeedLeverArm_Response__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__SetFilterSpeedLeverArm_Response) -> () { unsafe { microstrain_inertial_msgs__srv__SetFilterSpeedLeverArm_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod SetGravityAdaptiveVals { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__microstrain_inertial_msgs__srv__SetGravityAdaptiveVals () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub enable : f32 , pub low_pass_cutoff : f32 , pub min_1sigma : f32 , pub low_limit : f32 , pub high_limit : f32 , pub low_limit_1sigma : f32 , pub high_limit_1sigma : f32 } impl WrappedTypesupport for Request { type CStruct = microstrain_inertial_msgs__srv__SetGravityAdaptiveVals_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__SetGravityAdaptiveVals_Request () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__SetGravityAdaptiveVals_Request { unsafe { microstrain_inertial_msgs__srv__SetGravityAdaptiveVals_Request__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__SetGravityAdaptiveVals_Request) -> () { unsafe { microstrain_inertial_msgs__srv__SetGravityAdaptiveVals_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { enable : msg . enable , low_pass_cutoff : msg . low_pass_cutoff , min_1sigma : msg . min_1sigma , low_limit : msg . low_limit , high_limit : msg . high_limit , low_limit_1sigma : msg . low_limit_1sigma , high_limit_1sigma : msg . high_limit_1sigma , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . enable = self . enable ; msg . low_pass_cutoff = self . low_pass_cutoff ; msg . min_1sigma = self . min_1sigma ; msg . low_limit = self . low_limit ; msg . high_limit = self . high_limit ; msg . low_limit_1sigma = self . low_limit_1sigma ; msg . high_limit_1sigma = self . high_limit_1sigma ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool } impl WrappedTypesupport for Response { type CStruct = microstrain_inertial_msgs__srv__SetGravityAdaptiveVals_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__SetGravityAdaptiveVals_Response () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__SetGravityAdaptiveVals_Response { unsafe { microstrain_inertial_msgs__srv__SetGravityAdaptiveVals_Response__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__SetGravityAdaptiveVals_Response) -> () { unsafe { microstrain_inertial_msgs__srv__SetGravityAdaptiveVals_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod SetGyroBias { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__microstrain_inertial_msgs__srv__SetGyroBias () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub bias : geometry_msgs :: msg :: Vector3 } impl WrappedTypesupport for Request { type CStruct = microstrain_inertial_msgs__srv__SetGyroBias_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__SetGyroBias_Request () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__SetGyroBias_Request { unsafe { microstrain_inertial_msgs__srv__SetGyroBias_Request__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__SetGyroBias_Request) -> () { unsafe { microstrain_inertial_msgs__srv__SetGyroBias_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { bias : geometry_msgs :: msg :: Vector3 :: from_native (& msg . bias) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . bias . copy_to_native (& mut msg . bias) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool } impl WrappedTypesupport for Response { type CStruct = microstrain_inertial_msgs__srv__SetGyroBias_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__SetGyroBias_Response () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__SetGyroBias_Response { unsafe { microstrain_inertial_msgs__srv__SetGyroBias_Response__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__SetGyroBias_Response) -> () { unsafe { microstrain_inertial_msgs__srv__SetGyroBias_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod SetGyroBiasModel { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__microstrain_inertial_msgs__srv__SetGyroBiasModel () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub noise_vector : geometry_msgs :: msg :: Vector3 , pub beta_vector : geometry_msgs :: msg :: Vector3 } impl WrappedTypesupport for Request { type CStruct = microstrain_inertial_msgs__srv__SetGyroBiasModel_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__SetGyroBiasModel_Request () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__SetGyroBiasModel_Request { unsafe { microstrain_inertial_msgs__srv__SetGyroBiasModel_Request__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__SetGyroBiasModel_Request) -> () { unsafe { microstrain_inertial_msgs__srv__SetGyroBiasModel_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { noise_vector : geometry_msgs :: msg :: Vector3 :: from_native (& msg . noise_vector) , beta_vector : geometry_msgs :: msg :: Vector3 :: from_native (& msg . beta_vector) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . noise_vector . copy_to_native (& mut msg . noise_vector) ; self . beta_vector . copy_to_native (& mut msg . beta_vector) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool } impl WrappedTypesupport for Response { type CStruct = microstrain_inertial_msgs__srv__SetGyroBiasModel_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__SetGyroBiasModel_Response () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__SetGyroBiasModel_Response { unsafe { microstrain_inertial_msgs__srv__SetGyroBiasModel_Response__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__SetGyroBiasModel_Response) -> () { unsafe { microstrain_inertial_msgs__srv__SetGyroBiasModel_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod SetGyroNoise { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__microstrain_inertial_msgs__srv__SetGyroNoise () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub noise : geometry_msgs :: msg :: Vector3 } impl WrappedTypesupport for Request { type CStruct = microstrain_inertial_msgs__srv__SetGyroNoise_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__SetGyroNoise_Request () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__SetGyroNoise_Request { unsafe { microstrain_inertial_msgs__srv__SetGyroNoise_Request__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__SetGyroNoise_Request) -> () { unsafe { microstrain_inertial_msgs__srv__SetGyroNoise_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { noise : geometry_msgs :: msg :: Vector3 :: from_native (& msg . noise) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . noise . copy_to_native (& mut msg . noise) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool } impl WrappedTypesupport for Response { type CStruct = microstrain_inertial_msgs__srv__SetGyroNoise_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__SetGyroNoise_Response () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__SetGyroNoise_Response { unsafe { microstrain_inertial_msgs__srv__SetGyroNoise_Response__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__SetGyroNoise_Response) -> () { unsafe { microstrain_inertial_msgs__srv__SetGyroNoise_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod SetHardIronValues { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__microstrain_inertial_msgs__srv__SetHardIronValues () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub bias : geometry_msgs :: msg :: Vector3 } impl WrappedTypesupport for Request { type CStruct = microstrain_inertial_msgs__srv__SetHardIronValues_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__SetHardIronValues_Request () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__SetHardIronValues_Request { unsafe { microstrain_inertial_msgs__srv__SetHardIronValues_Request__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__SetHardIronValues_Request) -> () { unsafe { microstrain_inertial_msgs__srv__SetHardIronValues_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { bias : geometry_msgs :: msg :: Vector3 :: from_native (& msg . bias) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . bias . copy_to_native (& mut msg . bias) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool } impl WrappedTypesupport for Response { type CStruct = microstrain_inertial_msgs__srv__SetHardIronValues_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__SetHardIronValues_Response () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__SetHardIronValues_Response { unsafe { microstrain_inertial_msgs__srv__SetHardIronValues_Response__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__SetHardIronValues_Response) -> () { unsafe { microstrain_inertial_msgs__srv__SetHardIronValues_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod SetHeadingSource { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__microstrain_inertial_msgs__srv__SetHeadingSource () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub heading_source : i8 } impl WrappedTypesupport for Request { type CStruct = microstrain_inertial_msgs__srv__SetHeadingSource_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__SetHeadingSource_Request () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__SetHeadingSource_Request { unsafe { microstrain_inertial_msgs__srv__SetHeadingSource_Request__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__SetHeadingSource_Request) -> () { unsafe { microstrain_inertial_msgs__srv__SetHeadingSource_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { heading_source : msg . heading_source , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . heading_source = self . heading_source ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool } impl WrappedTypesupport for Response { type CStruct = microstrain_inertial_msgs__srv__SetHeadingSource_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__SetHeadingSource_Response () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__SetHeadingSource_Response { unsafe { microstrain_inertial_msgs__srv__SetHeadingSource_Response__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__SetHeadingSource_Response) -> () { unsafe { microstrain_inertial_msgs__srv__SetHeadingSource_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod SetMagAdaptiveVals { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__microstrain_inertial_msgs__srv__SetMagAdaptiveVals () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub enable : f32 , pub low_pass_cutoff : f32 , pub min_1sigma : f32 , pub low_limit : f32 , pub high_limit : f32 , pub low_limit_1sigma : f32 , pub high_limit_1sigma : f32 } impl WrappedTypesupport for Request { type CStruct = microstrain_inertial_msgs__srv__SetMagAdaptiveVals_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__SetMagAdaptiveVals_Request () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__SetMagAdaptiveVals_Request { unsafe { microstrain_inertial_msgs__srv__SetMagAdaptiveVals_Request__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__SetMagAdaptiveVals_Request) -> () { unsafe { microstrain_inertial_msgs__srv__SetMagAdaptiveVals_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { enable : msg . enable , low_pass_cutoff : msg . low_pass_cutoff , min_1sigma : msg . min_1sigma , low_limit : msg . low_limit , high_limit : msg . high_limit , low_limit_1sigma : msg . low_limit_1sigma , high_limit_1sigma : msg . high_limit_1sigma , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . enable = self . enable ; msg . low_pass_cutoff = self . low_pass_cutoff ; msg . min_1sigma = self . min_1sigma ; msg . low_limit = self . low_limit ; msg . high_limit = self . high_limit ; msg . low_limit_1sigma = self . low_limit_1sigma ; msg . high_limit_1sigma = self . high_limit_1sigma ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool } impl WrappedTypesupport for Response { type CStruct = microstrain_inertial_msgs__srv__SetMagAdaptiveVals_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__SetMagAdaptiveVals_Response () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__SetMagAdaptiveVals_Response { unsafe { microstrain_inertial_msgs__srv__SetMagAdaptiveVals_Response__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__SetMagAdaptiveVals_Response) -> () { unsafe { microstrain_inertial_msgs__srv__SetMagAdaptiveVals_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod SetMagDipAdaptiveVals { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__microstrain_inertial_msgs__srv__SetMagDipAdaptiveVals () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub enable : f32 , pub low_pass_cutoff : f32 , pub min_1sigma : f32 , pub high_limit : f32 , pub high_limit_1sigma : f32 } impl WrappedTypesupport for Request { type CStruct = microstrain_inertial_msgs__srv__SetMagDipAdaptiveVals_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__SetMagDipAdaptiveVals_Request () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__SetMagDipAdaptiveVals_Request { unsafe { microstrain_inertial_msgs__srv__SetMagDipAdaptiveVals_Request__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__SetMagDipAdaptiveVals_Request) -> () { unsafe { microstrain_inertial_msgs__srv__SetMagDipAdaptiveVals_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { enable : msg . enable , low_pass_cutoff : msg . low_pass_cutoff , min_1sigma : msg . min_1sigma , high_limit : msg . high_limit , high_limit_1sigma : msg . high_limit_1sigma , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . enable = self . enable ; msg . low_pass_cutoff = self . low_pass_cutoff ; msg . min_1sigma = self . min_1sigma ; msg . high_limit = self . high_limit ; msg . high_limit_1sigma = self . high_limit_1sigma ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool } impl WrappedTypesupport for Response { type CStruct = microstrain_inertial_msgs__srv__SetMagDipAdaptiveVals_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__SetMagDipAdaptiveVals_Response () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__SetMagDipAdaptiveVals_Response { unsafe { microstrain_inertial_msgs__srv__SetMagDipAdaptiveVals_Response__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__SetMagDipAdaptiveVals_Response) -> () { unsafe { microstrain_inertial_msgs__srv__SetMagDipAdaptiveVals_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod SetMagNoise { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__microstrain_inertial_msgs__srv__SetMagNoise () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub noise : geometry_msgs :: msg :: Vector3 } impl WrappedTypesupport for Request { type CStruct = microstrain_inertial_msgs__srv__SetMagNoise_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__SetMagNoise_Request () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__SetMagNoise_Request { unsafe { microstrain_inertial_msgs__srv__SetMagNoise_Request__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__SetMagNoise_Request) -> () { unsafe { microstrain_inertial_msgs__srv__SetMagNoise_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { noise : geometry_msgs :: msg :: Vector3 :: from_native (& msg . noise) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . noise . copy_to_native (& mut msg . noise) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool } impl WrappedTypesupport for Response { type CStruct = microstrain_inertial_msgs__srv__SetMagNoise_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__SetMagNoise_Response () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__SetMagNoise_Response { unsafe { microstrain_inertial_msgs__srv__SetMagNoise_Response__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__SetMagNoise_Response) -> () { unsafe { microstrain_inertial_msgs__srv__SetMagNoise_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod SetReferencePosition { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__microstrain_inertial_msgs__srv__SetReferencePosition () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub position : geometry_msgs :: msg :: Vector3 } impl WrappedTypesupport for Request { type CStruct = microstrain_inertial_msgs__srv__SetReferencePosition_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__SetReferencePosition_Request () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__SetReferencePosition_Request { unsafe { microstrain_inertial_msgs__srv__SetReferencePosition_Request__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__SetReferencePosition_Request) -> () { unsafe { microstrain_inertial_msgs__srv__SetReferencePosition_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { position : geometry_msgs :: msg :: Vector3 :: from_native (& msg . position) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . position . copy_to_native (& mut msg . position) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool } impl WrappedTypesupport for Response { type CStruct = microstrain_inertial_msgs__srv__SetReferencePosition_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__SetReferencePosition_Response () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__SetReferencePosition_Response { unsafe { microstrain_inertial_msgs__srv__SetReferencePosition_Response__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__SetReferencePosition_Response) -> () { unsafe { microstrain_inertial_msgs__srv__SetReferencePosition_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod SetRelativePositionReference { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__microstrain_inertial_msgs__srv__SetRelativePositionReference () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub source : u8 , pub frame : u8 , pub position : geometry_msgs :: msg :: Vector3 } impl WrappedTypesupport for Request { type CStruct = microstrain_inertial_msgs__srv__SetRelativePositionReference_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__SetRelativePositionReference_Request () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__SetRelativePositionReference_Request { unsafe { microstrain_inertial_msgs__srv__SetRelativePositionReference_Request__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__SetRelativePositionReference_Request) -> () { unsafe { microstrain_inertial_msgs__srv__SetRelativePositionReference_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { source : msg . source , frame : msg . frame , position : geometry_msgs :: msg :: Vector3 :: from_native (& msg . position) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . source = self . source ; msg . frame = self . frame ; self . position . copy_to_native (& mut msg . position) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl Request { pub const FRAME_ECEF : _bindgen_ty_912 = microstrain_inertial_msgs__srv__SetRelativePositionReference_Request__FRAME_ECEF ; pub const FRAME_LLH : _bindgen_ty_913 = microstrain_inertial_msgs__srv__SetRelativePositionReference_Request__FRAME_LLH ; pub const SOURCE_AUTO : _bindgen_ty_910 = microstrain_inertial_msgs__srv__SetRelativePositionReference_Request__SOURCE_AUTO ; pub const SOURCE_MANUAL : _bindgen_ty_911 = microstrain_inertial_msgs__srv__SetRelativePositionReference_Request__SOURCE_MANUAL ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool } impl WrappedTypesupport for Response { type CStruct = microstrain_inertial_msgs__srv__SetRelativePositionReference_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__SetRelativePositionReference_Response () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__SetRelativePositionReference_Response { unsafe { microstrain_inertial_msgs__srv__SetRelativePositionReference_Response__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__SetRelativePositionReference_Response) -> () { unsafe { microstrain_inertial_msgs__srv__SetRelativePositionReference_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod SetSensor2VehicleOffset { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__microstrain_inertial_msgs__srv__SetSensor2VehicleOffset () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub offset : geometry_msgs :: msg :: Vector3 } impl WrappedTypesupport for Request { type CStruct = microstrain_inertial_msgs__srv__SetSensor2VehicleOffset_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__SetSensor2VehicleOffset_Request () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__SetSensor2VehicleOffset_Request { unsafe { microstrain_inertial_msgs__srv__SetSensor2VehicleOffset_Request__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__SetSensor2VehicleOffset_Request) -> () { unsafe { microstrain_inertial_msgs__srv__SetSensor2VehicleOffset_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { offset : geometry_msgs :: msg :: Vector3 :: from_native (& msg . offset) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . offset . copy_to_native (& mut msg . offset) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool } impl WrappedTypesupport for Response { type CStruct = microstrain_inertial_msgs__srv__SetSensor2VehicleOffset_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__SetSensor2VehicleOffset_Response () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__SetSensor2VehicleOffset_Response { unsafe { microstrain_inertial_msgs__srv__SetSensor2VehicleOffset_Response__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__SetSensor2VehicleOffset_Response) -> () { unsafe { microstrain_inertial_msgs__srv__SetSensor2VehicleOffset_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod SetSensor2VehicleRotation { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__microstrain_inertial_msgs__srv__SetSensor2VehicleRotation () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub angle : geometry_msgs :: msg :: Vector3 } impl WrappedTypesupport for Request { type CStruct = microstrain_inertial_msgs__srv__SetSensor2VehicleRotation_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__SetSensor2VehicleRotation_Request () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__SetSensor2VehicleRotation_Request { unsafe { microstrain_inertial_msgs__srv__SetSensor2VehicleRotation_Request__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__SetSensor2VehicleRotation_Request) -> () { unsafe { microstrain_inertial_msgs__srv__SetSensor2VehicleRotation_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { angle : geometry_msgs :: msg :: Vector3 :: from_native (& msg . angle) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . angle . copy_to_native (& mut msg . angle) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool } impl WrappedTypesupport for Response { type CStruct = microstrain_inertial_msgs__srv__SetSensor2VehicleRotation_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__SetSensor2VehicleRotation_Response () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__SetSensor2VehicleRotation_Response { unsafe { microstrain_inertial_msgs__srv__SetSensor2VehicleRotation_Response__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__SetSensor2VehicleRotation_Response) -> () { unsafe { microstrain_inertial_msgs__srv__SetSensor2VehicleRotation_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod SetSoftIronMatrix { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__microstrain_inertial_msgs__srv__SetSoftIronMatrix () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub soft_iron_1 : geometry_msgs :: msg :: Vector3 , pub soft_iron_2 : geometry_msgs :: msg :: Vector3 , pub soft_iron_3 : geometry_msgs :: msg :: Vector3 } impl WrappedTypesupport for Request { type CStruct = microstrain_inertial_msgs__srv__SetSoftIronMatrix_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__SetSoftIronMatrix_Request () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__SetSoftIronMatrix_Request { unsafe { microstrain_inertial_msgs__srv__SetSoftIronMatrix_Request__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__SetSoftIronMatrix_Request) -> () { unsafe { microstrain_inertial_msgs__srv__SetSoftIronMatrix_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { soft_iron_1 : geometry_msgs :: msg :: Vector3 :: from_native (& msg . soft_iron_1) , soft_iron_2 : geometry_msgs :: msg :: Vector3 :: from_native (& msg . soft_iron_2) , soft_iron_3 : geometry_msgs :: msg :: Vector3 :: from_native (& msg . soft_iron_3) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . soft_iron_1 . copy_to_native (& mut msg . soft_iron_1) ; self . soft_iron_2 . copy_to_native (& mut msg . soft_iron_2) ; self . soft_iron_3 . copy_to_native (& mut msg . soft_iron_3) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool } impl WrappedTypesupport for Response { type CStruct = microstrain_inertial_msgs__srv__SetSoftIronMatrix_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__SetSoftIronMatrix_Response () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__SetSoftIronMatrix_Response { unsafe { microstrain_inertial_msgs__srv__SetSoftIronMatrix_Response__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__SetSoftIronMatrix_Response) -> () { unsafe { microstrain_inertial_msgs__srv__SetSoftIronMatrix_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod SetTareOrientation { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__microstrain_inertial_msgs__srv__SetTareOrientation () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub axis : i8 } impl WrappedTypesupport for Request { type CStruct = microstrain_inertial_msgs__srv__SetTareOrientation_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__SetTareOrientation_Request () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__SetTareOrientation_Request { unsafe { microstrain_inertial_msgs__srv__SetTareOrientation_Request__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__SetTareOrientation_Request) -> () { unsafe { microstrain_inertial_msgs__srv__SetTareOrientation_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { axis : msg . axis , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . axis = self . axis ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool } impl WrappedTypesupport for Response { type CStruct = microstrain_inertial_msgs__srv__SetTareOrientation_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__SetTareOrientation_Response () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__SetTareOrientation_Response { unsafe { microstrain_inertial_msgs__srv__SetTareOrientation_Response__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__SetTareOrientation_Response) -> () { unsafe { microstrain_inertial_msgs__srv__SetTareOrientation_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod SetZeroAngleUpdateThreshold { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__microstrain_inertial_msgs__srv__SetZeroAngleUpdateThreshold () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub enable : i8 , pub threshold : f32 } impl WrappedTypesupport for Request { type CStruct = microstrain_inertial_msgs__srv__SetZeroAngleUpdateThreshold_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__SetZeroAngleUpdateThreshold_Request () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__SetZeroAngleUpdateThreshold_Request { unsafe { microstrain_inertial_msgs__srv__SetZeroAngleUpdateThreshold_Request__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__SetZeroAngleUpdateThreshold_Request) -> () { unsafe { microstrain_inertial_msgs__srv__SetZeroAngleUpdateThreshold_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { enable : msg . enable , threshold : msg . threshold , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . enable = self . enable ; msg . threshold = self . threshold ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool } impl WrappedTypesupport for Response { type CStruct = microstrain_inertial_msgs__srv__SetZeroAngleUpdateThreshold_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__SetZeroAngleUpdateThreshold_Response () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__SetZeroAngleUpdateThreshold_Response { unsafe { microstrain_inertial_msgs__srv__SetZeroAngleUpdateThreshold_Response__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__SetZeroAngleUpdateThreshold_Response) -> () { unsafe { microstrain_inertial_msgs__srv__SetZeroAngleUpdateThreshold_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod SetZeroVelocityUpdateThreshold { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__microstrain_inertial_msgs__srv__SetZeroVelocityUpdateThreshold () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub enable : i8 , pub threshold : f32 } impl WrappedTypesupport for Request { type CStruct = microstrain_inertial_msgs__srv__SetZeroVelocityUpdateThreshold_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__SetZeroVelocityUpdateThreshold_Request () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__SetZeroVelocityUpdateThreshold_Request { unsafe { microstrain_inertial_msgs__srv__SetZeroVelocityUpdateThreshold_Request__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__SetZeroVelocityUpdateThreshold_Request) -> () { unsafe { microstrain_inertial_msgs__srv__SetZeroVelocityUpdateThreshold_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { enable : msg . enable , threshold : msg . threshold , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . enable = self . enable ; msg . threshold = self . threshold ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool } impl WrappedTypesupport for Response { type CStruct = microstrain_inertial_msgs__srv__SetZeroVelocityUpdateThreshold_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__srv__SetZeroVelocityUpdateThreshold_Response () } } fn create_msg () -> * mut microstrain_inertial_msgs__srv__SetZeroVelocityUpdateThreshold_Response { unsafe { microstrain_inertial_msgs__srv__SetZeroVelocityUpdateThreshold_Response__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__srv__SetZeroVelocityUpdateThreshold_Response) -> () { unsafe { microstrain_inertial_msgs__srv__SetZeroVelocityUpdateThreshold_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } } pub mod msg { use super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct FilterAidingMeasurementSummary { pub gps_tow : f64 , pub gnss1 : microstrain_inertial_msgs :: msg :: FilterAidingMeasurementSummaryIndicator , pub gnss2 : microstrain_inertial_msgs :: msg :: FilterAidingMeasurementSummaryIndicator , pub dual_antenna : microstrain_inertial_msgs :: msg :: FilterAidingMeasurementSummaryIndicator , pub heading : microstrain_inertial_msgs :: msg :: FilterAidingMeasurementSummaryIndicator , pub pressure : microstrain_inertial_msgs :: msg :: FilterAidingMeasurementSummaryIndicator , pub magnetometer : microstrain_inertial_msgs :: msg :: FilterAidingMeasurementSummaryIndicator , pub speed : microstrain_inertial_msgs :: msg :: FilterAidingMeasurementSummaryIndicator } impl WrappedTypesupport for FilterAidingMeasurementSummary { type CStruct = microstrain_inertial_msgs__msg__FilterAidingMeasurementSummary ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__msg__FilterAidingMeasurementSummary () } } fn create_msg () -> * mut microstrain_inertial_msgs__msg__FilterAidingMeasurementSummary { unsafe { microstrain_inertial_msgs__msg__FilterAidingMeasurementSummary__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__msg__FilterAidingMeasurementSummary) -> () { unsafe { microstrain_inertial_msgs__msg__FilterAidingMeasurementSummary__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> FilterAidingMeasurementSummary { FilterAidingMeasurementSummary { gps_tow : msg . gps_tow , gnss1 : microstrain_inertial_msgs :: msg :: FilterAidingMeasurementSummaryIndicator :: from_native (& msg . gnss1) , gnss2 : microstrain_inertial_msgs :: msg :: FilterAidingMeasurementSummaryIndicator :: from_native (& msg . gnss2) , dual_antenna : microstrain_inertial_msgs :: msg :: FilterAidingMeasurementSummaryIndicator :: from_native (& msg . dual_antenna) , heading : microstrain_inertial_msgs :: msg :: FilterAidingMeasurementSummaryIndicator :: from_native (& msg . heading) , pressure : microstrain_inertial_msgs :: msg :: FilterAidingMeasurementSummaryIndicator :: from_native (& msg . pressure) , magnetometer : microstrain_inertial_msgs :: msg :: FilterAidingMeasurementSummaryIndicator :: from_native (& msg . magnetometer) , speed : microstrain_inertial_msgs :: msg :: FilterAidingMeasurementSummaryIndicator :: from_native (& msg . speed) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . gps_tow = self . gps_tow ; self . gnss1 . copy_to_native (& mut msg . gnss1) ; self . gnss2 . copy_to_native (& mut msg . gnss2) ; self . dual_antenna . copy_to_native (& mut msg . dual_antenna) ; self . heading . copy_to_native (& mut msg . heading) ; self . pressure . copy_to_native (& mut msg . pressure) ; self . magnetometer . copy_to_native (& mut msg . magnetometer) ; self . speed . copy_to_native (& mut msg . speed) ; } } impl Default for FilterAidingMeasurementSummary { fn default () -> Self { let msg_native = WrappedNativeMsg :: < FilterAidingMeasurementSummary > :: new () ; FilterAidingMeasurementSummary :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct FilterAidingMeasurementSummaryIndicator { pub enabled : bool , pub used : bool , pub residual_high_warning : bool , pub sample_time_warning : bool , pub configuration_error : bool , pub max_num_meas_exceeded : bool } impl WrappedTypesupport for FilterAidingMeasurementSummaryIndicator { type CStruct = microstrain_inertial_msgs__msg__FilterAidingMeasurementSummaryIndicator ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__msg__FilterAidingMeasurementSummaryIndicator () } } fn create_msg () -> * mut microstrain_inertial_msgs__msg__FilterAidingMeasurementSummaryIndicator { unsafe { microstrain_inertial_msgs__msg__FilterAidingMeasurementSummaryIndicator__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__msg__FilterAidingMeasurementSummaryIndicator) -> () { unsafe { microstrain_inertial_msgs__msg__FilterAidingMeasurementSummaryIndicator__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> FilterAidingMeasurementSummaryIndicator { FilterAidingMeasurementSummaryIndicator { enabled : msg . enabled , used : msg . used , residual_high_warning : msg . residual_high_warning , sample_time_warning : msg . sample_time_warning , configuration_error : msg . configuration_error , max_num_meas_exceeded : msg . max_num_meas_exceeded , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . enabled = self . enabled ; msg . used = self . used ; msg . residual_high_warning = self . residual_high_warning ; msg . sample_time_warning = self . sample_time_warning ; msg . configuration_error = self . configuration_error ; msg . max_num_meas_exceeded = self . max_num_meas_exceeded ; } } impl Default for FilterAidingMeasurementSummaryIndicator { fn default () -> Self { let msg_native = WrappedNativeMsg :: < FilterAidingMeasurementSummaryIndicator > :: new () ; FilterAidingMeasurementSummaryIndicator :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct FilterHeading { pub heading_deg : f32 , pub heading_rad : f32 , pub status_flags : u16 } impl WrappedTypesupport for FilterHeading { type CStruct = microstrain_inertial_msgs__msg__FilterHeading ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__msg__FilterHeading () } } fn create_msg () -> * mut microstrain_inertial_msgs__msg__FilterHeading { unsafe { microstrain_inertial_msgs__msg__FilterHeading__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__msg__FilterHeading) -> () { unsafe { microstrain_inertial_msgs__msg__FilterHeading__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> FilterHeading { FilterHeading { heading_deg : msg . heading_deg , heading_rad : msg . heading_rad , status_flags : msg . status_flags , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . heading_deg = self . heading_deg ; msg . heading_rad = self . heading_rad ; msg . status_flags = self . status_flags ; } } impl Default for FilterHeading { fn default () -> Self { let msg_native = WrappedNativeMsg :: < FilterHeading > :: new () ; FilterHeading :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct FilterHeadingState { pub heading_rad : f32 , pub heading_uncertainty : f32 , pub source : u16 , pub status_flags : u16 } impl WrappedTypesupport for FilterHeadingState { type CStruct = microstrain_inertial_msgs__msg__FilterHeadingState ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__msg__FilterHeadingState () } } fn create_msg () -> * mut microstrain_inertial_msgs__msg__FilterHeadingState { unsafe { microstrain_inertial_msgs__msg__FilterHeadingState__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__msg__FilterHeadingState) -> () { unsafe { microstrain_inertial_msgs__msg__FilterHeadingState__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> FilterHeadingState { FilterHeadingState { heading_rad : msg . heading_rad , heading_uncertainty : msg . heading_uncertainty , source : msg . source , status_flags : msg . status_flags , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . heading_rad = self . heading_rad ; msg . heading_uncertainty = self . heading_uncertainty ; msg . source = self . source ; msg . status_flags = self . status_flags ; } } impl Default for FilterHeadingState { fn default () -> Self { let msg_native = WrappedNativeMsg :: < FilterHeadingState > :: new () ; FilterHeadingState :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct FilterStatus { pub filter_state : u16 , pub dynamics_mode : u16 , pub status_flags : u16 } impl WrappedTypesupport for FilterStatus { type CStruct = microstrain_inertial_msgs__msg__FilterStatus ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__msg__FilterStatus () } } fn create_msg () -> * mut microstrain_inertial_msgs__msg__FilterStatus { unsafe { microstrain_inertial_msgs__msg__FilterStatus__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__msg__FilterStatus) -> () { unsafe { microstrain_inertial_msgs__msg__FilterStatus__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> FilterStatus { FilterStatus { filter_state : msg . filter_state , dynamics_mode : msg . dynamics_mode , status_flags : msg . status_flags , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . filter_state = self . filter_state ; msg . dynamics_mode = self . dynamics_mode ; msg . status_flags = self . status_flags ; } } impl Default for FilterStatus { fn default () -> Self { let msg_native = WrappedNativeMsg :: < FilterStatus > :: new () ; FilterStatus :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct GNSSAidingStatus { pub gps_tow : f64 , pub has_position_fix : bool , pub tight_coupling : bool , pub differential_corrections : bool , pub integer_fix : bool , pub using_gps : bool , pub using_glonass : bool , pub using_galileo : bool , pub using_beidou : bool } impl WrappedTypesupport for GNSSAidingStatus { type CStruct = microstrain_inertial_msgs__msg__GNSSAidingStatus ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__msg__GNSSAidingStatus () } } fn create_msg () -> * mut microstrain_inertial_msgs__msg__GNSSAidingStatus { unsafe { microstrain_inertial_msgs__msg__GNSSAidingStatus__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__msg__GNSSAidingStatus) -> () { unsafe { microstrain_inertial_msgs__msg__GNSSAidingStatus__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> GNSSAidingStatus { GNSSAidingStatus { gps_tow : msg . gps_tow , has_position_fix : msg . has_position_fix , tight_coupling : msg . tight_coupling , differential_corrections : msg . differential_corrections , integer_fix : msg . integer_fix , using_gps : msg . using_gps , using_glonass : msg . using_glonass , using_galileo : msg . using_galileo , using_beidou : msg . using_beidou , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . gps_tow = self . gps_tow ; msg . has_position_fix = self . has_position_fix ; msg . tight_coupling = self . tight_coupling ; msg . differential_corrections = self . differential_corrections ; msg . integer_fix = self . integer_fix ; msg . using_gps = self . using_gps ; msg . using_glonass = self . using_glonass ; msg . using_galileo = self . using_galileo ; msg . using_beidou = self . using_beidou ; } } impl Default for GNSSAidingStatus { fn default () -> Self { let msg_native = WrappedNativeMsg :: < GNSSAidingStatus > :: new () ; GNSSAidingStatus :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct GNSSDualAntennaStatus { pub gps_tow : f32 , pub heading : f32 , pub heading_uncertainty : f32 , pub fix_type : u8 , pub rcv_1_valid : u8 , pub rcv_2_valid : u8 , pub antenna_offsets_valid : u8 } impl WrappedTypesupport for GNSSDualAntennaStatus { type CStruct = microstrain_inertial_msgs__msg__GNSSDualAntennaStatus ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__msg__GNSSDualAntennaStatus () } } fn create_msg () -> * mut microstrain_inertial_msgs__msg__GNSSDualAntennaStatus { unsafe { microstrain_inertial_msgs__msg__GNSSDualAntennaStatus__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__msg__GNSSDualAntennaStatus) -> () { unsafe { microstrain_inertial_msgs__msg__GNSSDualAntennaStatus__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> GNSSDualAntennaStatus { GNSSDualAntennaStatus { gps_tow : msg . gps_tow , heading : msg . heading , heading_uncertainty : msg . heading_uncertainty , fix_type : msg . fix_type , rcv_1_valid : msg . rcv_1_valid , rcv_2_valid : msg . rcv_2_valid , antenna_offsets_valid : msg . antenna_offsets_valid , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . gps_tow = self . gps_tow ; msg . heading = self . heading ; msg . heading_uncertainty = self . heading_uncertainty ; msg . fix_type = self . fix_type ; msg . rcv_1_valid = self . rcv_1_valid ; msg . rcv_2_valid = self . rcv_2_valid ; msg . antenna_offsets_valid = self . antenna_offsets_valid ; } } impl Default for GNSSDualAntennaStatus { fn default () -> Self { let msg_native = WrappedNativeMsg :: < GNSSDualAntennaStatus > :: new () ; GNSSDualAntennaStatus :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct GNSSFixInfo { pub fix_type : u8 , pub num_sv : u8 , pub sbas_used : bool , pub dngss_used : bool } impl WrappedTypesupport for GNSSFixInfo { type CStruct = microstrain_inertial_msgs__msg__GNSSFixInfo ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__msg__GNSSFixInfo () } } fn create_msg () -> * mut microstrain_inertial_msgs__msg__GNSSFixInfo { unsafe { microstrain_inertial_msgs__msg__GNSSFixInfo__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__msg__GNSSFixInfo) -> () { unsafe { microstrain_inertial_msgs__msg__GNSSFixInfo__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> GNSSFixInfo { GNSSFixInfo { fix_type : msg . fix_type , num_sv : msg . num_sv , sbas_used : msg . sbas_used , dngss_used : msg . dngss_used , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . fix_type = self . fix_type ; msg . num_sv = self . num_sv ; msg . sbas_used = self . sbas_used ; msg . dngss_used = self . dngss_used ; } } impl Default for GNSSFixInfo { fn default () -> Self { let msg_native = WrappedNativeMsg :: < GNSSFixInfo > :: new () ; GNSSFixInfo :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl GNSSFixInfo { pub const FIX_2D : _bindgen_ty_875 = microstrain_inertial_msgs__msg__GNSSFixInfo__FIX_2D ; pub const FIX_3D : _bindgen_ty_874 = microstrain_inertial_msgs__msg__GNSSFixInfo__FIX_3D ; pub const FIX_INVALID : _bindgen_ty_878 = microstrain_inertial_msgs__msg__GNSSFixInfo__FIX_INVALID ; pub const FIX_NONE : _bindgen_ty_877 = microstrain_inertial_msgs__msg__GNSSFixInfo__FIX_NONE ; pub const FIX_RTK_FIXED : _bindgen_ty_880 = microstrain_inertial_msgs__msg__GNSSFixInfo__FIX_RTK_FIXED ; pub const FIX_RTK_FLOAT : _bindgen_ty_879 = microstrain_inertial_msgs__msg__GNSSFixInfo__FIX_RTK_FLOAT ; pub const FIX_TIME_ONLY : _bindgen_ty_876 = microstrain_inertial_msgs__msg__GNSSFixInfo__FIX_TIME_ONLY ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct GPSCorrelationTimestamp { pub gps_tow : f64 , pub gps_week_number : u16 , pub timestamp_flags : u16 } impl WrappedTypesupport for GPSCorrelationTimestamp { type CStruct = microstrain_inertial_msgs__msg__GPSCorrelationTimestamp ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__msg__GPSCorrelationTimestamp () } } fn create_msg () -> * mut microstrain_inertial_msgs__msg__GPSCorrelationTimestamp { unsafe { microstrain_inertial_msgs__msg__GPSCorrelationTimestamp__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__msg__GPSCorrelationTimestamp) -> () { unsafe { microstrain_inertial_msgs__msg__GPSCorrelationTimestamp__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> GPSCorrelationTimestamp { GPSCorrelationTimestamp { gps_tow : msg . gps_tow , gps_week_number : msg . gps_week_number , timestamp_flags : msg . timestamp_flags , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . gps_tow = self . gps_tow ; msg . gps_week_number = self . gps_week_number ; msg . timestamp_flags = self . timestamp_flags ; } } impl Default for GPSCorrelationTimestamp { fn default () -> Self { let msg_native = WrappedNativeMsg :: < GPSCorrelationTimestamp > :: new () ; GPSCorrelationTimestamp :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl GPSCorrelationTimestamp { pub const TIMESTAMP_FLAG_GPS_INITALIZED : _bindgen_ty_883 = microstrain_inertial_msgs__msg__GPSCorrelationTimestamp__TIMESTAMP_FLAG_GPS_INITALIZED ; pub const TIMESTAMP_FLAG_GPS_REFRESH : _bindgen_ty_882 = microstrain_inertial_msgs__msg__GPSCorrelationTimestamp__TIMESTAMP_FLAG_GPS_REFRESH ; pub const TIMESTAMP_FLAG_PPS_GOOD : _bindgen_ty_881 = microstrain_inertial_msgs__msg__GPSCorrelationTimestamp__TIMESTAMP_FLAG_PPS_GOOD ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct GPSCorrelationTimestampStamped { pub header : std_msgs :: msg :: Header , pub gps_cor : microstrain_inertial_msgs :: msg :: GPSCorrelationTimestamp } impl WrappedTypesupport for GPSCorrelationTimestampStamped { type CStruct = microstrain_inertial_msgs__msg__GPSCorrelationTimestampStamped ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__msg__GPSCorrelationTimestampStamped () } } fn create_msg () -> * mut microstrain_inertial_msgs__msg__GPSCorrelationTimestampStamped { unsafe { microstrain_inertial_msgs__msg__GPSCorrelationTimestampStamped__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__msg__GPSCorrelationTimestampStamped) -> () { unsafe { microstrain_inertial_msgs__msg__GPSCorrelationTimestampStamped__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> GPSCorrelationTimestampStamped { GPSCorrelationTimestampStamped { header : std_msgs :: msg :: Header :: from_native (& msg . header) , gps_cor : microstrain_inertial_msgs :: msg :: GPSCorrelationTimestamp :: from_native (& msg . gps_cor) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; self . gps_cor . copy_to_native (& mut msg . gps_cor) ; } } impl Default for GPSCorrelationTimestampStamped { fn default () -> Self { let msg_native = WrappedNativeMsg :: < GPSCorrelationTimestampStamped > :: new () ; GPSCorrelationTimestampStamped :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct InputSpeedMeasurement { pub gps_tow : f32 , pub speed : f32 , pub speed_uncertainty : f32 } impl WrappedTypesupport for InputSpeedMeasurement { type CStruct = microstrain_inertial_msgs__msg__InputSpeedMeasurement ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__msg__InputSpeedMeasurement () } } fn create_msg () -> * mut microstrain_inertial_msgs__msg__InputSpeedMeasurement { unsafe { microstrain_inertial_msgs__msg__InputSpeedMeasurement__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__msg__InputSpeedMeasurement) -> () { unsafe { microstrain_inertial_msgs__msg__InputSpeedMeasurement__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> InputSpeedMeasurement { InputSpeedMeasurement { gps_tow : msg . gps_tow , speed : msg . speed , speed_uncertainty : msg . speed_uncertainty , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . gps_tow = self . gps_tow ; msg . speed = self . speed ; msg . speed_uncertainty = self . speed_uncertainty ; } } impl Default for InputSpeedMeasurement { fn default () -> Self { let msg_native = WrappedNativeMsg :: < InputSpeedMeasurement > :: new () ; InputSpeedMeasurement :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct RTKStatus { pub gps_tow : f64 , pub gps_week : u16 , pub epoch_status : u16 , pub dongle_version : u8 , pub dongle_modem_state : u8 , pub dongle_connection_type : u8 , pub dongle_rssi : i8 , pub dongle_signal_quality : u8 , pub dongle_tower_change_indicator : u8 , pub dongle_nmea_timeout : bool , pub dongle_server_timeout : bool , pub dongle_rtcm_timeout : bool , pub dongle_out_of_range : bool , pub dongle_corrections_unavailable : bool , pub gps_correction_latency : f32 , pub glonass_correction_latency : f32 , pub galileo_correction_latency : f32 , pub beidou_correction_latency : f32 , pub raw_status_flags : u32 } impl WrappedTypesupport for RTKStatus { type CStruct = microstrain_inertial_msgs__msg__RTKStatus ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__msg__RTKStatus () } } fn create_msg () -> * mut microstrain_inertial_msgs__msg__RTKStatus { unsafe { microstrain_inertial_msgs__msg__RTKStatus__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__msg__RTKStatus) -> () { unsafe { microstrain_inertial_msgs__msg__RTKStatus__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> RTKStatus { RTKStatus { gps_tow : msg . gps_tow , gps_week : msg . gps_week , epoch_status : msg . epoch_status , dongle_version : msg . dongle_version , dongle_modem_state : msg . dongle_modem_state , dongle_connection_type : msg . dongle_connection_type , dongle_rssi : msg . dongle_rssi , dongle_signal_quality : msg . dongle_signal_quality , dongle_tower_change_indicator : msg . dongle_tower_change_indicator , dongle_nmea_timeout : msg . dongle_nmea_timeout , dongle_server_timeout : msg . dongle_server_timeout , dongle_rtcm_timeout : msg . dongle_rtcm_timeout , dongle_out_of_range : msg . dongle_out_of_range , dongle_corrections_unavailable : msg . dongle_corrections_unavailable , gps_correction_latency : msg . gps_correction_latency , glonass_correction_latency : msg . glonass_correction_latency , galileo_correction_latency : msg . galileo_correction_latency , beidou_correction_latency : msg . beidou_correction_latency , raw_status_flags : msg . raw_status_flags , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . gps_tow = self . gps_tow ; msg . gps_week = self . gps_week ; msg . epoch_status = self . epoch_status ; msg . dongle_version = self . dongle_version ; msg . dongle_modem_state = self . dongle_modem_state ; msg . dongle_connection_type = self . dongle_connection_type ; msg . dongle_rssi = self . dongle_rssi ; msg . dongle_signal_quality = self . dongle_signal_quality ; msg . dongle_tower_change_indicator = self . dongle_tower_change_indicator ; msg . dongle_nmea_timeout = self . dongle_nmea_timeout ; msg . dongle_server_timeout = self . dongle_server_timeout ; msg . dongle_rtcm_timeout = self . dongle_rtcm_timeout ; msg . dongle_out_of_range = self . dongle_out_of_range ; msg . dongle_corrections_unavailable = self . dongle_corrections_unavailable ; msg . gps_correction_latency = self . gps_correction_latency ; msg . glonass_correction_latency = self . glonass_correction_latency ; msg . galileo_correction_latency = self . galileo_correction_latency ; msg . beidou_correction_latency = self . beidou_correction_latency ; msg . raw_status_flags = self . raw_status_flags ; } } impl Default for RTKStatus { fn default () -> Self { let msg_native = WrappedNativeMsg :: < RTKStatus > :: new () ; RTKStatus :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl RTKStatus { pub const CONNECTION_TYPE_CONNECTION_2G : _bindgen_ty_894 = microstrain_inertial_msgs__msg__RTKStatus__CONNECTION_TYPE_CONNECTION_2G ; pub const CONNECTION_TYPE_CONNECTION_3G : _bindgen_ty_895 = microstrain_inertial_msgs__msg__RTKStatus__CONNECTION_TYPE_CONNECTION_3G ; pub const CONNECTION_TYPE_CONNECTION_4G : _bindgen_ty_896 = microstrain_inertial_msgs__msg__RTKStatus__CONNECTION_TYPE_CONNECTION_4G ; pub const CONNECTION_TYPE_CONNECTION_5G : _bindgen_ty_897 = microstrain_inertial_msgs__msg__RTKStatus__CONNECTION_TYPE_CONNECTION_5G ; pub const CONNECTION_TYPE_NO_CONNECTION : _bindgen_ty_893 = microstrain_inertial_msgs__msg__RTKStatus__CONNECTION_TYPE_NO_CONNECTION ; pub const MODEM_STATE_ACTIVATING_DATA_CONTEXT : _bindgen_ty_888 = microstrain_inertial_msgs__msg__RTKStatus__MODEM_STATE_ACTIVATING_DATA_CONTEXT ; pub const MODEM_STATE_CONFIGURING_DATA_CONTEXT : _bindgen_ty_887 = microstrain_inertial_msgs__msg__RTKStatus__MODEM_STATE_CONFIGURING_DATA_CONTEXT ; pub const MODEM_STATE_CONFIGURING_SOCKET : _bindgen_ty_889 = microstrain_inertial_msgs__msg__RTKStatus__MODEM_STATE_CONFIGURING_SOCKET ; pub const MODEM_STATE_CONNECTED_AND_IDLE : _bindgen_ty_891 = microstrain_inertial_msgs__msg__RTKStatus__MODEM_STATE_CONNECTED_AND_IDLE ; pub const MODEM_STATE_CONNECTED_AND_STREAMING : _bindgen_ty_892 = microstrain_inertial_msgs__msg__RTKStatus__MODEM_STATE_CONNECTED_AND_STREAMING ; pub const MODEM_STATE_NETWORK_CONNECTED : _bindgen_ty_886 = microstrain_inertial_msgs__msg__RTKStatus__MODEM_STATE_NETWORK_CONNECTED ; pub const MODEM_STATE_NO_NETWORK : _bindgen_ty_885 = microstrain_inertial_msgs__msg__RTKStatus__MODEM_STATE_NO_NETWORK ; pub const MODEM_STATE_OFF : _bindgen_ty_884 = microstrain_inertial_msgs__msg__RTKStatus__MODEM_STATE_OFF ; pub const MODEM_STATE_WAITING_ON_SERVER_HANDSHAKE : _bindgen_ty_890 = microstrain_inertial_msgs__msg__RTKStatus__MODEM_STATE_WAITING_ON_SERVER_HANDSHAKE ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct RTKStatusV1 { pub gps_tow : f64 , pub gps_week : u16 , pub epoch_status : u16 , pub dongle_version : u8 , pub dongle_controller_state : u8 , pub dongle_platform_state : u8 , pub dongle_controller_status : u8 , pub dongle_platform_status : u8 , pub dongle_reset_reason : u8 , pub dongle_signal_quality : u8 , pub gps_correction_latency : f32 , pub glonass_correction_latency : f32 , pub galileo_correction_latency : f32 , pub beidou_correction_latency : f32 , pub raw_status_flags : u32 } impl WrappedTypesupport for RTKStatusV1 { type CStruct = microstrain_inertial_msgs__msg__RTKStatusV1 ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__msg__RTKStatusV1 () } } fn create_msg () -> * mut microstrain_inertial_msgs__msg__RTKStatusV1 { unsafe { microstrain_inertial_msgs__msg__RTKStatusV1__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__msg__RTKStatusV1) -> () { unsafe { microstrain_inertial_msgs__msg__RTKStatusV1__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> RTKStatusV1 { RTKStatusV1 { gps_tow : msg . gps_tow , gps_week : msg . gps_week , epoch_status : msg . epoch_status , dongle_version : msg . dongle_version , dongle_controller_state : msg . dongle_controller_state , dongle_platform_state : msg . dongle_platform_state , dongle_controller_status : msg . dongle_controller_status , dongle_platform_status : msg . dongle_platform_status , dongle_reset_reason : msg . dongle_reset_reason , dongle_signal_quality : msg . dongle_signal_quality , gps_correction_latency : msg . gps_correction_latency , glonass_correction_latency : msg . glonass_correction_latency , galileo_correction_latency : msg . galileo_correction_latency , beidou_correction_latency : msg . beidou_correction_latency , raw_status_flags : msg . raw_status_flags , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . gps_tow = self . gps_tow ; msg . gps_week = self . gps_week ; msg . epoch_status = self . epoch_status ; msg . dongle_version = self . dongle_version ; msg . dongle_controller_state = self . dongle_controller_state ; msg . dongle_platform_state = self . dongle_platform_state ; msg . dongle_controller_status = self . dongle_controller_status ; msg . dongle_platform_status = self . dongle_platform_status ; msg . dongle_reset_reason = self . dongle_reset_reason ; msg . dongle_signal_quality = self . dongle_signal_quality ; msg . gps_correction_latency = self . gps_correction_latency ; msg . glonass_correction_latency = self . glonass_correction_latency ; msg . galileo_correction_latency = self . galileo_correction_latency ; msg . beidou_correction_latency = self . beidou_correction_latency ; msg . raw_status_flags = self . raw_status_flags ; } } impl Default for RTKStatusV1 { fn default () -> Self { let msg_native = WrappedNativeMsg :: < RTKStatusV1 > :: new () ; RTKStatusV1 :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Status { pub device_model : u16 , pub status_selector : u8 , pub status_flags : u32 , pub system_state : u16 , pub system_timer_ms : u32 , pub gps_power_on : u8 , pub num_gps_pps_triggers : u32 , pub last_gps_pps_trigger_ms : u32 , pub imu_stream_enabled : u8 , pub gps_stream_enabled : u8 , pub filter_stream_enabled : u8 , pub imu_dropped_packets : u32 , pub gps_dropped_packets : u32 , pub filter_dropped_packets : u32 , pub com1_port_bytes_written : u32 , pub com1_port_bytes_read : u32 , pub com1_port_write_overruns : u32 , pub com1_port_read_overruns : u32 , pub imu_parser_errors : u32 , pub imu_message_count : u32 , pub imu_last_message_ms : u32 , pub gps_parser_errors : u32 , pub gps_message_count : u32 , pub gps_last_message_ms : u32 } impl WrappedTypesupport for Status { type CStruct = microstrain_inertial_msgs__msg__Status ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__microstrain_inertial_msgs__msg__Status () } } fn create_msg () -> * mut microstrain_inertial_msgs__msg__Status { unsafe { microstrain_inertial_msgs__msg__Status__create () } } fn destroy_msg (msg : * mut microstrain_inertial_msgs__msg__Status) -> () { unsafe { microstrain_inertial_msgs__msg__Status__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Status { Status { device_model : msg . device_model , status_selector : msg . status_selector , status_flags : msg . status_flags , system_state : msg . system_state , system_timer_ms : msg . system_timer_ms , gps_power_on : msg . gps_power_on , num_gps_pps_triggers : msg . num_gps_pps_triggers , last_gps_pps_trigger_ms : msg . last_gps_pps_trigger_ms , imu_stream_enabled : msg . imu_stream_enabled , gps_stream_enabled : msg . gps_stream_enabled , filter_stream_enabled : msg . filter_stream_enabled , imu_dropped_packets : msg . imu_dropped_packets , gps_dropped_packets : msg . gps_dropped_packets , filter_dropped_packets : msg . filter_dropped_packets , com1_port_bytes_written : msg . com1_port_bytes_written , com1_port_bytes_read : msg . com1_port_bytes_read , com1_port_write_overruns : msg . com1_port_write_overruns , com1_port_read_overruns : msg . com1_port_read_overruns , imu_parser_errors : msg . imu_parser_errors , imu_message_count : msg . imu_message_count , imu_last_message_ms : msg . imu_last_message_ms , gps_parser_errors : msg . gps_parser_errors , gps_message_count : msg . gps_message_count , gps_last_message_ms : msg . gps_last_message_ms , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . device_model = self . device_model ; msg . status_selector = self . status_selector ; msg . status_flags = self . status_flags ; msg . system_state = self . system_state ; msg . system_timer_ms = self . system_timer_ms ; msg . gps_power_on = self . gps_power_on ; msg . num_gps_pps_triggers = self . num_gps_pps_triggers ; msg . last_gps_pps_trigger_ms = self . last_gps_pps_trigger_ms ; msg . imu_stream_enabled = self . imu_stream_enabled ; msg . gps_stream_enabled = self . gps_stream_enabled ; msg . filter_stream_enabled = self . filter_stream_enabled ; msg . imu_dropped_packets = self . imu_dropped_packets ; msg . gps_dropped_packets = self . gps_dropped_packets ; msg . filter_dropped_packets = self . filter_dropped_packets ; msg . com1_port_bytes_written = self . com1_port_bytes_written ; msg . com1_port_bytes_read = self . com1_port_bytes_read ; msg . com1_port_write_overruns = self . com1_port_write_overruns ; msg . com1_port_read_overruns = self . com1_port_read_overruns ; msg . imu_parser_errors = self . imu_parser_errors ; msg . imu_message_count = self . imu_message_count ; msg . imu_last_message_ms = self . imu_last_message_ms ; msg . gps_parser_errors = self . gps_parser_errors ; msg . gps_message_count = self . gps_message_count ; msg . gps_last_message_ms = self . gps_last_message_ms ; } } impl Default for Status { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Status > :: new () ; Status :: from_native (& msg_native) } } }