pub mod msg { use super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct UserButton { pub button : Vec < bool > } impl WrappedTypesupport for UserButton { type CStruct = turtlebot4_msgs__msg__UserButton ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__turtlebot4_msgs__msg__UserButton () } } fn create_msg () -> * mut turtlebot4_msgs__msg__UserButton { unsafe { turtlebot4_msgs__msg__UserButton__create () } } fn destroy_msg (msg : * mut turtlebot4_msgs__msg__UserButton) -> () { unsafe { turtlebot4_msgs__msg__UserButton__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> UserButton { UserButton { button : msg . button . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { assert_eq ! (self . button . len () , 4usize , "Field {} is fixed size of {}!" , "button" , 4usize) ; msg . button . copy_from_slice (& self . button [.. 4usize]) ; } } impl Default for UserButton { fn default () -> Self { let msg_native = WrappedNativeMsg :: < UserButton > :: new () ; UserButton :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct UserDisplay { pub ip : std :: string :: String , pub battery : std :: string :: String , pub entries : Vec < std :: string :: String > , pub selected_entry : i32 } impl WrappedTypesupport for UserDisplay { type CStruct = turtlebot4_msgs__msg__UserDisplay ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__turtlebot4_msgs__msg__UserDisplay () } } fn create_msg () -> * mut turtlebot4_msgs__msg__UserDisplay { unsafe { turtlebot4_msgs__msg__UserDisplay__create () } } fn destroy_msg (msg : * mut turtlebot4_msgs__msg__UserDisplay) -> () { unsafe { turtlebot4_msgs__msg__UserDisplay__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> UserDisplay { UserDisplay { ip : msg . ip . to_str () . to_owned () , battery : msg . battery . to_str () . to_owned () , entries : msg . entries . iter () . map (| s | s . to_str () . to_owned ()) . collect () , selected_entry : msg . selected_entry , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . ip . assign (& self . ip) ; msg . battery . assign (& self . battery) ; assert_eq ! (self . entries . len () , 5usize , "Field {} is fixed size of {}!" , "entries" , 5usize) ; for (t , s) in msg . entries . iter_mut () . zip (& self . entries) { t . assign (& s) ; } msg . selected_entry = self . selected_entry ; } } impl Default for UserDisplay { fn default () -> Self { let msg_native = WrappedNativeMsg :: < UserDisplay > :: new () ; UserDisplay :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct UserLed { pub led : u8 , pub color : u8 , pub blink_period : u32 , pub duty_cycle : f64 } impl WrappedTypesupport for UserLed { type CStruct = turtlebot4_msgs__msg__UserLed ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__turtlebot4_msgs__msg__UserLed () } } fn create_msg () -> * mut turtlebot4_msgs__msg__UserLed { unsafe { turtlebot4_msgs__msg__UserLed__create () } } fn destroy_msg (msg : * mut turtlebot4_msgs__msg__UserLed) -> () { unsafe { turtlebot4_msgs__msg__UserLed__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> UserLed { UserLed { led : msg . led , color : msg . color , blink_period : msg . blink_period , duty_cycle : msg . duty_cycle , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . led = self . led ; msg . color = self . color ; msg . blink_period = self . blink_period ; msg . duty_cycle = self . duty_cycle ; } } impl Default for UserLed { fn default () -> Self { let msg_native = WrappedNativeMsg :: < UserLed > :: new () ; UserLed :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl UserLed { pub const COLOR_GREEN : _bindgen_ty_1751 = turtlebot4_msgs__msg__UserLed__COLOR_GREEN ; pub const COLOR_OFF : _bindgen_ty_1750 = turtlebot4_msgs__msg__UserLed__COLOR_OFF ; pub const COLOR_RED : _bindgen_ty_1752 = turtlebot4_msgs__msg__UserLed__COLOR_RED ; pub const COLOR_YELLOW : _bindgen_ty_1753 = turtlebot4_msgs__msg__UserLed__COLOR_YELLOW ; pub const USER_LED_1 : _bindgen_ty_1748 = turtlebot4_msgs__msg__UserLed__USER_LED_1 ; pub const USER_LED_2 : _bindgen_ty_1749 = turtlebot4_msgs__msg__UserLed__USER_LED_2 ; } }