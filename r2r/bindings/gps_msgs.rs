pub mod msg { use super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct GPSFix { pub header : std_msgs :: msg :: Header , pub status : gps_msgs :: msg :: GPSStatus , pub latitude : f64 , pub longitude : f64 , pub altitude : f64 , pub track : f64 , pub speed : f64 , pub climb : f64 , pub pitch : f64 , pub roll : f64 , pub dip : f64 , pub time : f64 , pub gdop : f64 , pub pdop : f64 , pub hdop : f64 , pub vdop : f64 , pub tdop : f64 , pub err : f64 , pub err_horz : f64 , pub err_vert : f64 , pub err_track : f64 , pub err_speed : f64 , pub err_climb : f64 , pub err_time : f64 , pub err_pitch : f64 , pub err_roll : f64 , pub err_dip : f64 , pub position_covariance : Vec < f64 > , pub position_covariance_type : u8 } impl WrappedTypesupport for GPSFix { type CStruct = gps_msgs__msg__GPSFix ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__gps_msgs__msg__GPSFix () } } fn create_msg () -> * mut gps_msgs__msg__GPSFix { unsafe { gps_msgs__msg__GPSFix__create () } } fn destroy_msg (msg : * mut gps_msgs__msg__GPSFix) -> () { unsafe { gps_msgs__msg__GPSFix__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> GPSFix { GPSFix { header : std_msgs :: msg :: Header :: from_native (& msg . header) , status : gps_msgs :: msg :: GPSStatus :: from_native (& msg . status) , latitude : msg . latitude , longitude : msg . longitude , altitude : msg . altitude , track : msg . track , speed : msg . speed , climb : msg . climb , pitch : msg . pitch , roll : msg . roll , dip : msg . dip , time : msg . time , gdop : msg . gdop , pdop : msg . pdop , hdop : msg . hdop , vdop : msg . vdop , tdop : msg . tdop , err : msg . err , err_horz : msg . err_horz , err_vert : msg . err_vert , err_track : msg . err_track , err_speed : msg . err_speed , err_climb : msg . err_climb , err_time : msg . err_time , err_pitch : msg . err_pitch , err_roll : msg . err_roll , err_dip : msg . err_dip , position_covariance : msg . position_covariance . to_vec () , position_covariance_type : msg . position_covariance_type , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; self . status . copy_to_native (& mut msg . status) ; msg . latitude = self . latitude ; msg . longitude = self . longitude ; msg . altitude = self . altitude ; msg . track = self . track ; msg . speed = self . speed ; msg . climb = self . climb ; msg . pitch = self . pitch ; msg . roll = self . roll ; msg . dip = self . dip ; msg . time = self . time ; msg . gdop = self . gdop ; msg . pdop = self . pdop ; msg . hdop = self . hdop ; msg . vdop = self . vdop ; msg . tdop = self . tdop ; msg . err = self . err ; msg . err_horz = self . err_horz ; msg . err_vert = self . err_vert ; msg . err_track = self . err_track ; msg . err_speed = self . err_speed ; msg . err_climb = self . err_climb ; msg . err_time = self . err_time ; msg . err_pitch = self . err_pitch ; msg . err_roll = self . err_roll ; msg . err_dip = self . err_dip ; assert_eq ! (self . position_covariance . len () , 9usize , "Field {} is fixed size of {}!" , "position_covariance" , 9usize) ; msg . position_covariance . copy_from_slice (& self . position_covariance [.. 9usize]) ; msg . position_covariance_type = self . position_covariance_type ; } } impl Default for GPSFix { fn default () -> Self { let msg_native = WrappedNativeMsg :: < GPSFix > :: new () ; GPSFix :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl GPSFix { pub const COVARIANCE_TYPE_APPROXIMATED : _bindgen_ty_226 = gps_msgs__msg__GPSFix__COVARIANCE_TYPE_APPROXIMATED ; pub const COVARIANCE_TYPE_DIAGONAL_KNOWN : _bindgen_ty_227 = gps_msgs__msg__GPSFix__COVARIANCE_TYPE_DIAGONAL_KNOWN ; pub const COVARIANCE_TYPE_KNOWN : _bindgen_ty_228 = gps_msgs__msg__GPSFix__COVARIANCE_TYPE_KNOWN ; pub const COVARIANCE_TYPE_UNKNOWN : _bindgen_ty_225 = gps_msgs__msg__GPSFix__COVARIANCE_TYPE_UNKNOWN ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct GPSStatus { pub header : std_msgs :: msg :: Header , pub satellites_used : u16 , pub satellite_used_prn : Vec < i32 > , pub satellites_visible : u16 , pub satellite_visible_prn : Vec < i32 > , pub satellite_visible_z : Vec < i32 > , pub satellite_visible_azimuth : Vec < i32 > , pub satellite_visible_snr : Vec < i32 > , pub status : i16 , pub motion_source : u16 , pub orientation_source : u16 , pub position_source : u16 } impl WrappedTypesupport for GPSStatus { type CStruct = gps_msgs__msg__GPSStatus ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__gps_msgs__msg__GPSStatus () } } fn create_msg () -> * mut gps_msgs__msg__GPSStatus { unsafe { gps_msgs__msg__GPSStatus__create () } } fn destroy_msg (msg : * mut gps_msgs__msg__GPSStatus) -> () { unsafe { gps_msgs__msg__GPSStatus__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> GPSStatus { GPSStatus { header : std_msgs :: msg :: Header :: from_native (& msg . header) , satellites_used : msg . satellites_used , satellite_used_prn : msg . satellite_used_prn . to_vec () , satellites_visible : msg . satellites_visible , satellite_visible_prn : msg . satellite_visible_prn . to_vec () , satellite_visible_z : msg . satellite_visible_z . to_vec () , satellite_visible_azimuth : msg . satellite_visible_azimuth . to_vec () , satellite_visible_snr : msg . satellite_visible_snr . to_vec () , status : msg . status , motion_source : msg . motion_source , orientation_source : msg . orientation_source , position_source : msg . position_source , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . satellites_used = self . satellites_used ; msg . satellite_used_prn . update (& self . satellite_used_prn) ; msg . satellites_visible = self . satellites_visible ; msg . satellite_visible_prn . update (& self . satellite_visible_prn) ; msg . satellite_visible_z . update (& self . satellite_visible_z) ; msg . satellite_visible_azimuth . update (& self . satellite_visible_azimuth) ; msg . satellite_visible_snr . update (& self . satellite_visible_snr) ; msg . status = self . status ; msg . motion_source = self . motion_source ; msg . orientation_source = self . orientation_source ; msg . position_source = self . position_source ; } } impl Default for GPSStatus { fn default () -> Self { let msg_native = WrappedNativeMsg :: < GPSStatus > :: new () ; GPSStatus :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl GPSStatus { pub const SOURCE_ACCEL : _bindgen_ty_242 = gps_msgs__msg__GPSStatus__SOURCE_ACCEL ; pub const SOURCE_ALTIMETER : _bindgen_ty_239 = gps_msgs__msg__GPSStatus__SOURCE_ALTIMETER ; pub const SOURCE_DOPPLER : _bindgen_ty_238 = gps_msgs__msg__GPSStatus__SOURCE_DOPPLER ; pub const SOURCE_GPS : _bindgen_ty_236 = gps_msgs__msg__GPSStatus__SOURCE_GPS ; pub const SOURCE_GYRO : _bindgen_ty_241 = gps_msgs__msg__GPSStatus__SOURCE_GYRO ; pub const SOURCE_MAGNETIC : _bindgen_ty_240 = gps_msgs__msg__GPSStatus__SOURCE_MAGNETIC ; pub const SOURCE_NONE : _bindgen_ty_235 = gps_msgs__msg__GPSStatus__SOURCE_NONE ; pub const SOURCE_POINTS : _bindgen_ty_237 = gps_msgs__msg__GPSStatus__SOURCE_POINTS ; pub const STATUS_DGPS_FIX : _bindgen_ty_233 = gps_msgs__msg__GPSStatus__STATUS_DGPS_FIX ; pub const STATUS_FIX : _bindgen_ty_230 = gps_msgs__msg__GPSStatus__STATUS_FIX ; pub const STATUS_GBAS_FIX : _bindgen_ty_232 = gps_msgs__msg__GPSStatus__STATUS_GBAS_FIX ; pub const STATUS_NO_FIX : _bindgen_ty_229 = gps_msgs__msg__GPSStatus__STATUS_NO_FIX ; pub const STATUS_SBAS_FIX : _bindgen_ty_231 = gps_msgs__msg__GPSStatus__STATUS_SBAS_FIX ; pub const STATUS_WAAS_FIX : _bindgen_ty_234 = gps_msgs__msg__GPSStatus__STATUS_WAAS_FIX ; } }