pub mod msg { use super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ADSBVehicle { pub header : std_msgs :: msg :: Header , pub icao_address : u32 , pub callsign : std :: string :: String , pub latitude : f64 , pub longitude : f64 , pub altitude : f32 , pub heading : f32 , pub hor_velocity : f32 , pub ver_velocity : f32 , pub altitude_type : u8 , pub emitter_type : u8 , pub tslc : builtin_interfaces :: msg :: Duration , pub flags : u16 , pub squawk : u16 } impl WrappedTypesupport for ADSBVehicle { type CStruct = mavros_msgs__msg__ADSBVehicle ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__msg__ADSBVehicle () } } fn create_msg () -> * mut mavros_msgs__msg__ADSBVehicle { unsafe { mavros_msgs__msg__ADSBVehicle__create () } } fn destroy_msg (msg : * mut mavros_msgs__msg__ADSBVehicle) -> () { unsafe { mavros_msgs__msg__ADSBVehicle__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ADSBVehicle { ADSBVehicle { header : std_msgs :: msg :: Header :: from_native (& msg . header) , icao_address : msg . icao_address , callsign : msg . callsign . to_str () . to_owned () , latitude : msg . latitude , longitude : msg . longitude , altitude : msg . altitude , heading : msg . heading , hor_velocity : msg . hor_velocity , ver_velocity : msg . ver_velocity , altitude_type : msg . altitude_type , emitter_type : msg . emitter_type , tslc : builtin_interfaces :: msg :: Duration :: from_native (& msg . tslc) , flags : msg . flags , squawk : msg . squawk , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . icao_address = self . icao_address ; msg . callsign . assign (& self . callsign) ; msg . latitude = self . latitude ; msg . longitude = self . longitude ; msg . altitude = self . altitude ; msg . heading = self . heading ; msg . hor_velocity = self . hor_velocity ; msg . ver_velocity = self . ver_velocity ; msg . altitude_type = self . altitude_type ; msg . emitter_type = self . emitter_type ; self . tslc . copy_to_native (& mut msg . tslc) ; msg . flags = self . flags ; msg . squawk = self . squawk ; } } impl Default for ADSBVehicle { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ADSBVehicle > :: new () ; ADSBVehicle :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl ADSBVehicle { pub const ALT_GEOMETRIC : _bindgen_ty_461 = mavros_msgs__msg__ADSBVehicle__ALT_GEOMETRIC ; pub const ALT_PRESSURE_QNH : _bindgen_ty_460 = mavros_msgs__msg__ADSBVehicle__ALT_PRESSURE_QNH ; pub const EMITTER_EMERGENCY_SURFACE : _bindgen_ty_479 = mavros_msgs__msg__ADSBVehicle__EMITTER_EMERGENCY_SURFACE ; pub const EMITTER_GLIDER : _bindgen_ty_471 = mavros_msgs__msg__ADSBVehicle__EMITTER_GLIDER ; pub const EMITTER_HEAVY : _bindgen_ty_467 = mavros_msgs__msg__ADSBVehicle__EMITTER_HEAVY ; pub const EMITTER_HIGHLY_MANUV : _bindgen_ty_468 = mavros_msgs__msg__ADSBVehicle__EMITTER_HIGHLY_MANUV ; pub const EMITTER_HIGH_VORTEX_LARGE : _bindgen_ty_466 = mavros_msgs__msg__ADSBVehicle__EMITTER_HIGH_VORTEX_LARGE ; pub const EMITTER_LARGE : _bindgen_ty_465 = mavros_msgs__msg__ADSBVehicle__EMITTER_LARGE ; pub const EMITTER_LIGHT : _bindgen_ty_463 = mavros_msgs__msg__ADSBVehicle__EMITTER_LIGHT ; pub const EMITTER_LIGHTER_AIR : _bindgen_ty_472 = mavros_msgs__msg__ADSBVehicle__EMITTER_LIGHTER_AIR ; pub const EMITTER_NO_INFO : _bindgen_ty_462 = mavros_msgs__msg__ADSBVehicle__EMITTER_NO_INFO ; pub const EMITTER_PARACHUTE : _bindgen_ty_473 = mavros_msgs__msg__ADSBVehicle__EMITTER_PARACHUTE ; pub const EMITTER_POINT_OBSTACLE : _bindgen_ty_481 = mavros_msgs__msg__ADSBVehicle__EMITTER_POINT_OBSTACLE ; pub const EMITTER_ROTOCRAFT : _bindgen_ty_469 = mavros_msgs__msg__ADSBVehicle__EMITTER_ROTOCRAFT ; pub const EMITTER_SERVICE_SURFACE : _bindgen_ty_480 = mavros_msgs__msg__ADSBVehicle__EMITTER_SERVICE_SURFACE ; pub const EMITTER_SMALL : _bindgen_ty_464 = mavros_msgs__msg__ADSBVehicle__EMITTER_SMALL ; pub const EMITTER_SPACE : _bindgen_ty_477 = mavros_msgs__msg__ADSBVehicle__EMITTER_SPACE ; pub const EMITTER_UAV : _bindgen_ty_476 = mavros_msgs__msg__ADSBVehicle__EMITTER_UAV ; pub const EMITTER_ULTRA_LIGHT : _bindgen_ty_474 = mavros_msgs__msg__ADSBVehicle__EMITTER_ULTRA_LIGHT ; pub const EMITTER_UNASSGINED3 : _bindgen_ty_478 = mavros_msgs__msg__ADSBVehicle__EMITTER_UNASSGINED3 ; pub const EMITTER_UNASSIGNED : _bindgen_ty_470 = mavros_msgs__msg__ADSBVehicle__EMITTER_UNASSIGNED ; pub const EMITTER_UNASSIGNED2 : _bindgen_ty_475 = mavros_msgs__msg__ADSBVehicle__EMITTER_UNASSIGNED2 ; pub const FLAG_BARO_VALID : _bindgen_ty_490 = mavros_msgs__msg__ADSBVehicle__FLAG_BARO_VALID ; pub const FLAG_SIMULATED : _bindgen_ty_488 = mavros_msgs__msg__ADSBVehicle__FLAG_SIMULATED ; pub const FLAG_SOURCE_UAT : _bindgen_ty_491 = mavros_msgs__msg__ADSBVehicle__FLAG_SOURCE_UAT ; pub const FLAG_VALID_ALTITUDE : _bindgen_ty_483 = mavros_msgs__msg__ADSBVehicle__FLAG_VALID_ALTITUDE ; pub const FLAG_VALID_CALLSIGN : _bindgen_ty_486 = mavros_msgs__msg__ADSBVehicle__FLAG_VALID_CALLSIGN ; pub const FLAG_VALID_COORDS : _bindgen_ty_482 = mavros_msgs__msg__ADSBVehicle__FLAG_VALID_COORDS ; pub const FLAG_VALID_HEADING : _bindgen_ty_484 = mavros_msgs__msg__ADSBVehicle__FLAG_VALID_HEADING ; pub const FLAG_VALID_SQUAWK : _bindgen_ty_487 = mavros_msgs__msg__ADSBVehicle__FLAG_VALID_SQUAWK ; pub const FLAG_VALID_VELOCITY : _bindgen_ty_485 = mavros_msgs__msg__ADSBVehicle__FLAG_VALID_VELOCITY ; pub const FLAG_VERTICAL_VELOCITY_VALID : _bindgen_ty_489 = mavros_msgs__msg__ADSBVehicle__FLAG_VERTICAL_VELOCITY_VALID ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ActuatorControl { pub header : std_msgs :: msg :: Header , pub group_mix : u8 , pub controls : Vec < f32 > } impl WrappedTypesupport for ActuatorControl { type CStruct = mavros_msgs__msg__ActuatorControl ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__msg__ActuatorControl () } } fn create_msg () -> * mut mavros_msgs__msg__ActuatorControl { unsafe { mavros_msgs__msg__ActuatorControl__create () } } fn destroy_msg (msg : * mut mavros_msgs__msg__ActuatorControl) -> () { unsafe { mavros_msgs__msg__ActuatorControl__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ActuatorControl { ActuatorControl { header : std_msgs :: msg :: Header :: from_native (& msg . header) , group_mix : msg . group_mix , controls : msg . controls . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . group_mix = self . group_mix ; assert_eq ! (self . controls . len () , 8usize , "Field {} is fixed size of {}!" , "controls" , 8usize) ; msg . controls . copy_from_slice (& self . controls [.. 8usize]) ; } } impl Default for ActuatorControl { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ActuatorControl > :: new () ; ActuatorControl :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl ActuatorControl { pub const PX4_MIX_FLIGHT_CONTROL : _bindgen_ty_456 = mavros_msgs__msg__ActuatorControl__PX4_MIX_FLIGHT_CONTROL ; pub const PX4_MIX_FLIGHT_CONTROL_VTOL_ALT : _bindgen_ty_457 = mavros_msgs__msg__ActuatorControl__PX4_MIX_FLIGHT_CONTROL_VTOL_ALT ; pub const PX4_MIX_MANUAL_PASSTHROUGH : _bindgen_ty_459 = mavros_msgs__msg__ActuatorControl__PX4_MIX_MANUAL_PASSTHROUGH ; pub const PX4_MIX_PAYLOAD : _bindgen_ty_458 = mavros_msgs__msg__ActuatorControl__PX4_MIX_PAYLOAD ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Altitude { pub header : std_msgs :: msg :: Header , pub monotonic : f32 , pub amsl : f32 , pub local : f32 , pub relative : f32 , pub terrain : f32 , pub bottom_clearance : f32 } impl WrappedTypesupport for Altitude { type CStruct = mavros_msgs__msg__Altitude ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__msg__Altitude () } } fn create_msg () -> * mut mavros_msgs__msg__Altitude { unsafe { mavros_msgs__msg__Altitude__create () } } fn destroy_msg (msg : * mut mavros_msgs__msg__Altitude) -> () { unsafe { mavros_msgs__msg__Altitude__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Altitude { Altitude { header : std_msgs :: msg :: Header :: from_native (& msg . header) , monotonic : msg . monotonic , amsl : msg . amsl , local : msg . local , relative : msg . relative , terrain : msg . terrain , bottom_clearance : msg . bottom_clearance , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . monotonic = self . monotonic ; msg . amsl = self . amsl ; msg . local = self . local ; msg . relative = self . relative ; msg . terrain = self . terrain ; msg . bottom_clearance = self . bottom_clearance ; } } impl Default for Altitude { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Altitude > :: new () ; Altitude :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct AttitudeTarget { pub header : std_msgs :: msg :: Header , pub type_mask : u8 , pub orientation : geometry_msgs :: msg :: Quaternion , pub body_rate : geometry_msgs :: msg :: Vector3 , pub thrust : f32 } impl WrappedTypesupport for AttitudeTarget { type CStruct = mavros_msgs__msg__AttitudeTarget ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__msg__AttitudeTarget () } } fn create_msg () -> * mut mavros_msgs__msg__AttitudeTarget { unsafe { mavros_msgs__msg__AttitudeTarget__create () } } fn destroy_msg (msg : * mut mavros_msgs__msg__AttitudeTarget) -> () { unsafe { mavros_msgs__msg__AttitudeTarget__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> AttitudeTarget { AttitudeTarget { header : std_msgs :: msg :: Header :: from_native (& msg . header) , type_mask : msg . type_mask , orientation : geometry_msgs :: msg :: Quaternion :: from_native (& msg . orientation) , body_rate : geometry_msgs :: msg :: Vector3 :: from_native (& msg . body_rate) , thrust : msg . thrust , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . type_mask = self . type_mask ; self . orientation . copy_to_native (& mut msg . orientation) ; self . body_rate . copy_to_native (& mut msg . body_rate) ; msg . thrust = self . thrust ; } } impl Default for AttitudeTarget { fn default () -> Self { let msg_native = WrappedNativeMsg :: < AttitudeTarget > :: new () ; AttitudeTarget :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl AttitudeTarget { pub const IGNORE_ATTITUDE : _bindgen_ty_496 = mavros_msgs__msg__AttitudeTarget__IGNORE_ATTITUDE ; pub const IGNORE_PITCH_RATE : _bindgen_ty_493 = mavros_msgs__msg__AttitudeTarget__IGNORE_PITCH_RATE ; pub const IGNORE_ROLL_RATE : _bindgen_ty_492 = mavros_msgs__msg__AttitudeTarget__IGNORE_ROLL_RATE ; pub const IGNORE_THRUST : _bindgen_ty_495 = mavros_msgs__msg__AttitudeTarget__IGNORE_THRUST ; pub const IGNORE_YAW_RATE : _bindgen_ty_494 = mavros_msgs__msg__AttitudeTarget__IGNORE_YAW_RATE ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct CamIMUStamp { pub frame_stamp : builtin_interfaces :: msg :: Time , pub frame_seq_id : i32 } impl WrappedTypesupport for CamIMUStamp { type CStruct = mavros_msgs__msg__CamIMUStamp ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__msg__CamIMUStamp () } } fn create_msg () -> * mut mavros_msgs__msg__CamIMUStamp { unsafe { mavros_msgs__msg__CamIMUStamp__create () } } fn destroy_msg (msg : * mut mavros_msgs__msg__CamIMUStamp) -> () { unsafe { mavros_msgs__msg__CamIMUStamp__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> CamIMUStamp { CamIMUStamp { frame_stamp : builtin_interfaces :: msg :: Time :: from_native (& msg . frame_stamp) , frame_seq_id : msg . frame_seq_id , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . frame_stamp . copy_to_native (& mut msg . frame_stamp) ; msg . frame_seq_id = self . frame_seq_id ; } } impl Default for CamIMUStamp { fn default () -> Self { let msg_native = WrappedNativeMsg :: < CamIMUStamp > :: new () ; CamIMUStamp :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct CameraImageCaptured { pub header : std_msgs :: msg :: Header , pub orientation : geometry_msgs :: msg :: Quaternion , pub geo : geographic_msgs :: msg :: GeoPoint , pub relative_alt : f32 , pub image_index : i32 , pub capture_result : i8 , pub file_url : std :: string :: String } impl WrappedTypesupport for CameraImageCaptured { type CStruct = mavros_msgs__msg__CameraImageCaptured ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__msg__CameraImageCaptured () } } fn create_msg () -> * mut mavros_msgs__msg__CameraImageCaptured { unsafe { mavros_msgs__msg__CameraImageCaptured__create () } } fn destroy_msg (msg : * mut mavros_msgs__msg__CameraImageCaptured) -> () { unsafe { mavros_msgs__msg__CameraImageCaptured__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> CameraImageCaptured { CameraImageCaptured { header : std_msgs :: msg :: Header :: from_native (& msg . header) , orientation : geometry_msgs :: msg :: Quaternion :: from_native (& msg . orientation) , geo : geographic_msgs :: msg :: GeoPoint :: from_native (& msg . geo) , relative_alt : msg . relative_alt , image_index : msg . image_index , capture_result : msg . capture_result , file_url : msg . file_url . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; self . orientation . copy_to_native (& mut msg . orientation) ; self . geo . copy_to_native (& mut msg . geo) ; msg . relative_alt = self . relative_alt ; msg . image_index = self . image_index ; msg . capture_result = self . capture_result ; msg . file_url . assign (& self . file_url) ; } } impl Default for CameraImageCaptured { fn default () -> Self { let msg_native = WrappedNativeMsg :: < CameraImageCaptured > :: new () ; CameraImageCaptured :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct CellularStatus { pub status : u8 , pub failure_reason : u8 , # [serde (rename = "type")] pub type_ : u8 , pub quality : u8 , pub mcc : u16 , pub mnc : u16 , pub lac : u16 } impl WrappedTypesupport for CellularStatus { type CStruct = mavros_msgs__msg__CellularStatus ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__msg__CellularStatus () } } fn create_msg () -> * mut mavros_msgs__msg__CellularStatus { unsafe { mavros_msgs__msg__CellularStatus__create () } } fn destroy_msg (msg : * mut mavros_msgs__msg__CellularStatus) -> () { unsafe { mavros_msgs__msg__CellularStatus__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> CellularStatus { CellularStatus { status : msg . status , failure_reason : msg . failure_reason , type_ : msg . type_ , quality : msg . quality , mcc : msg . mcc , mnc : msg . mnc , lac : msg . lac , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . status = self . status ; msg . failure_reason = self . failure_reason ; msg . type_ = self . type_ ; msg . quality = self . quality ; msg . mcc = self . mcc ; msg . mnc = self . mnc ; msg . lac = self . lac ; } } impl Default for CellularStatus { fn default () -> Self { let msg_native = WrappedNativeMsg :: < CellularStatus > :: new () ; CellularStatus :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct CommandCode { } impl WrappedTypesupport for CommandCode { type CStruct = mavros_msgs__msg__CommandCode ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__msg__CommandCode () } } fn create_msg () -> * mut mavros_msgs__msg__CommandCode { unsafe { mavros_msgs__msg__CommandCode__create () } } fn destroy_msg (msg : * mut mavros_msgs__msg__CommandCode) -> () { unsafe { mavros_msgs__msg__CommandCode__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> CommandCode { CommandCode { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for CommandCode { fn default () -> Self { let msg_native = WrappedNativeMsg :: < CommandCode > :: new () ; CommandCode :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl CommandCode { pub const AIRFRAME_CONFIGURATION : _bindgen_ty_497 = mavros_msgs__msg__CommandCode__AIRFRAME_CONFIGURATION ; pub const ARM_AUTHORIZATION_REQUEST : _bindgen_ty_498 = mavros_msgs__msg__CommandCode__ARM_AUTHORIZATION_REQUEST ; pub const COMPONENT_ARM_DISARM : _bindgen_ty_499 = mavros_msgs__msg__CommandCode__COMPONENT_ARM_DISARM ; pub const CONDITION_CHANGE_ALT : _bindgen_ty_501 = mavros_msgs__msg__CommandCode__CONDITION_CHANGE_ALT ; pub const CONDITION_DELAY : _bindgen_ty_500 = mavros_msgs__msg__CommandCode__CONDITION_DELAY ; pub const CONDITION_DISTANCE : _bindgen_ty_502 = mavros_msgs__msg__CommandCode__CONDITION_DISTANCE ; pub const CONDITION_LAST : _bindgen_ty_504 = mavros_msgs__msg__CommandCode__CONDITION_LAST ; pub const CONDITION_YAW : _bindgen_ty_503 = mavros_msgs__msg__CommandCode__CONDITION_YAW ; pub const CONTROL_HIGH_LATENCY : _bindgen_ty_505 = mavros_msgs__msg__CommandCode__CONTROL_HIGH_LATENCY ; pub const DO_ADSB_OUT_IDENT : _bindgen_ty_552 = mavros_msgs__msg__CommandCode__DO_ADSB_OUT_IDENT ; pub const DO_AUTOTUNE_ENABLE : _bindgen_ty_541 = mavros_msgs__msg__CommandCode__DO_AUTOTUNE_ENABLE ; pub const DO_CHANGE_ALTITUDE : _bindgen_ty_518 = mavros_msgs__msg__CommandCode__DO_CHANGE_ALTITUDE ; pub const DO_CHANGE_SPEED : _bindgen_ty_510 = mavros_msgs__msg__CommandCode__DO_CHANGE_SPEED ; pub const DO_CONTROL_VIDEO : _bindgen_ty_529 = mavros_msgs__msg__CommandCode__DO_CONTROL_VIDEO ; pub const DO_DIGICAM_CONFIGURE : _bindgen_ty_531 = mavros_msgs__msg__CommandCode__DO_DIGICAM_CONFIGURE ; pub const DO_DIGICAM_CONTROL : _bindgen_ty_532 = mavros_msgs__msg__CommandCode__DO_DIGICAM_CONTROL ; pub const DO_ENGINE_CONTROL : _bindgen_ty_546 = mavros_msgs__msg__CommandCode__DO_ENGINE_CONTROL ; pub const DO_FENCE_ENABLE : _bindgen_ty_536 = mavros_msgs__msg__CommandCode__DO_FENCE_ENABLE ; pub const DO_FLIGHTTERMINATION : _bindgen_ty_517 = mavros_msgs__msg__CommandCode__DO_FLIGHTTERMINATION ; pub const DO_FOLLOW : _bindgen_ty_506 = mavros_msgs__msg__CommandCode__DO_FOLLOW ; pub const DO_FOLLOW_REPOSITION : _bindgen_ty_507 = mavros_msgs__msg__CommandCode__DO_FOLLOW_REPOSITION ; pub const DO_GO_AROUND : _bindgen_ty_521 = mavros_msgs__msg__CommandCode__DO_GO_AROUND ; pub const DO_GRIPPER : _bindgen_ty_540 = mavros_msgs__msg__CommandCode__DO_GRIPPER ; pub const DO_GUIDED_LIMITS : _bindgen_ty_545 = mavros_msgs__msg__CommandCode__DO_GUIDED_LIMITS ; pub const DO_GUIDED_MASTER : _bindgen_ty_544 = mavros_msgs__msg__CommandCode__DO_GUIDED_MASTER ; pub const DO_INVERTED_FLIGHT : _bindgen_ty_539 = mavros_msgs__msg__CommandCode__DO_INVERTED_FLIGHT ; pub const DO_JUMP : _bindgen_ty_509 = mavros_msgs__msg__CommandCode__DO_JUMP ; pub const DO_JUMP_TAG : _bindgen_ty_549 = mavros_msgs__msg__CommandCode__DO_JUMP_TAG ; pub const DO_LAND_START : _bindgen_ty_519 = mavros_msgs__msg__CommandCode__DO_LAND_START ; pub const DO_LAST : _bindgen_ty_548 = mavros_msgs__msg__CommandCode__DO_LAST ; pub const DO_MOTOR_TEST : _bindgen_ty_538 = mavros_msgs__msg__CommandCode__DO_MOTOR_TEST ; pub const DO_MOUNT_CONFIGURE : _bindgen_ty_533 = mavros_msgs__msg__CommandCode__DO_MOUNT_CONFIGURE ; pub const DO_MOUNT_CONTROL : _bindgen_ty_534 = mavros_msgs__msg__CommandCode__DO_MOUNT_CONTROL ; pub const DO_MOUNT_CONTROL_QUAT : _bindgen_ty_543 = mavros_msgs__msg__CommandCode__DO_MOUNT_CONTROL_QUAT ; pub const DO_PARACHUTE : _bindgen_ty_537 = mavros_msgs__msg__CommandCode__DO_PARACHUTE ; pub const DO_PAUSE_CONTINUE : _bindgen_ty_523 = mavros_msgs__msg__CommandCode__DO_PAUSE_CONTINUE ; pub const DO_RALLY_LAND : _bindgen_ty_520 = mavros_msgs__msg__CommandCode__DO_RALLY_LAND ; pub const DO_REPEAT_RELAY : _bindgen_ty_514 = mavros_msgs__msg__CommandCode__DO_REPEAT_RELAY ; pub const DO_REPEAT_SERVO : _bindgen_ty_516 = mavros_msgs__msg__CommandCode__DO_REPEAT_SERVO ; pub const DO_REPOSITION : _bindgen_ty_522 = mavros_msgs__msg__CommandCode__DO_REPOSITION ; pub const DO_SET_CAM_TRIGG_DIST : _bindgen_ty_535 = mavros_msgs__msg__CommandCode__DO_SET_CAM_TRIGG_DIST ; pub const DO_SET_CAM_TRIGG_INTERVAL : _bindgen_ty_542 = mavros_msgs__msg__CommandCode__DO_SET_CAM_TRIGG_INTERVAL ; pub const DO_SET_HOME : _bindgen_ty_511 = mavros_msgs__msg__CommandCode__DO_SET_HOME ; pub const DO_SET_MISSION_CURRENT : _bindgen_ty_547 = mavros_msgs__msg__CommandCode__DO_SET_MISSION_CURRENT ; pub const DO_SET_MODE : _bindgen_ty_508 = mavros_msgs__msg__CommandCode__DO_SET_MODE ; pub const DO_SET_PARAMETER : _bindgen_ty_512 = mavros_msgs__msg__CommandCode__DO_SET_PARAMETER ; pub const DO_SET_RELAY : _bindgen_ty_513 = mavros_msgs__msg__CommandCode__DO_SET_RELAY ; pub const DO_SET_REVERSE : _bindgen_ty_524 = mavros_msgs__msg__CommandCode__DO_SET_REVERSE ; pub const DO_SET_ROI : _bindgen_ty_530 = mavros_msgs__msg__CommandCode__DO_SET_ROI ; pub const DO_SET_ROI_LOCATION : _bindgen_ty_525 = mavros_msgs__msg__CommandCode__DO_SET_ROI_LOCATION ; pub const DO_SET_ROI_NONE : _bindgen_ty_527 = mavros_msgs__msg__CommandCode__DO_SET_ROI_NONE ; pub const DO_SET_ROI_SYSID : _bindgen_ty_528 = mavros_msgs__msg__CommandCode__DO_SET_ROI_SYSID ; pub const DO_SET_ROI_WPNEXT_OFFSET : _bindgen_ty_526 = mavros_msgs__msg__CommandCode__DO_SET_ROI_WPNEXT_OFFSET ; pub const DO_SET_SERVO : _bindgen_ty_515 = mavros_msgs__msg__CommandCode__DO_SET_SERVO ; pub const DO_TRIGGER_CONTROL : _bindgen_ty_550 = mavros_msgs__msg__CommandCode__DO_TRIGGER_CONTROL ; pub const DO_VTOL_TRANSITION : _bindgen_ty_551 = mavros_msgs__msg__CommandCode__DO_VTOL_TRANSITION ; pub const DO_WINCH : _bindgen_ty_553 = mavros_msgs__msg__CommandCode__DO_WINCH ; pub const FIXED_MAG_CAL_YAW : _bindgen_ty_554 = mavros_msgs__msg__CommandCode__FIXED_MAG_CAL_YAW ; pub const GET_HOME_POSITION : _bindgen_ty_555 = mavros_msgs__msg__CommandCode__GET_HOME_POSITION ; pub const GET_MESSAGE_INTERVAL : _bindgen_ty_556 = mavros_msgs__msg__CommandCode__GET_MESSAGE_INTERVAL ; pub const IMAGE_START_CAPTURE : _bindgen_ty_557 = mavros_msgs__msg__CommandCode__IMAGE_START_CAPTURE ; pub const IMAGE_STOP_CAPTURE : _bindgen_ty_558 = mavros_msgs__msg__CommandCode__IMAGE_STOP_CAPTURE ; pub const JUMP_TAG : _bindgen_ty_559 = mavros_msgs__msg__CommandCode__JUMP_TAG ; pub const LOGGING_START : _bindgen_ty_560 = mavros_msgs__msg__CommandCode__LOGGING_START ; pub const LOGGING_STOP : _bindgen_ty_561 = mavros_msgs__msg__CommandCode__LOGGING_STOP ; pub const MISSION_START : _bindgen_ty_562 = mavros_msgs__msg__CommandCode__MISSION_START ; pub const NAV_CONTINUE_AND_CHANGE_ALT : _bindgen_ty_573 = mavros_msgs__msg__CommandCode__NAV_CONTINUE_AND_CHANGE_ALT ; pub const NAV_DELAY : _bindgen_ty_581 = mavros_msgs__msg__CommandCode__NAV_DELAY ; pub const NAV_FENCE_CIRCLE_EXCLUSION : _bindgen_ty_589 = mavros_msgs__msg__CommandCode__NAV_FENCE_CIRCLE_EXCLUSION ; pub const NAV_FENCE_CIRCLE_INCLUSION : _bindgen_ty_588 = mavros_msgs__msg__CommandCode__NAV_FENCE_CIRCLE_INCLUSION ; pub const NAV_FENCE_POLYGON_VERTEX_EXCLUSION : _bindgen_ty_587 = mavros_msgs__msg__CommandCode__NAV_FENCE_POLYGON_VERTEX_EXCLUSION ; pub const NAV_FENCE_POLYGON_VERTEX_INCLUSION : _bindgen_ty_586 = mavros_msgs__msg__CommandCode__NAV_FENCE_POLYGON_VERTEX_INCLUSION ; pub const NAV_FENCE_RETURN_POINT : _bindgen_ty_585 = mavros_msgs__msg__CommandCode__NAV_FENCE_RETURN_POINT ; pub const NAV_FOLLOW : _bindgen_ty_572 = mavros_msgs__msg__CommandCode__NAV_FOLLOW ; pub const NAV_GUIDED_ENABLE : _bindgen_ty_580 = mavros_msgs__msg__CommandCode__NAV_GUIDED_ENABLE ; pub const NAV_LAND : _bindgen_ty_568 = mavros_msgs__msg__CommandCode__NAV_LAND ; pub const NAV_LAND_LOCAL : _bindgen_ty_570 = mavros_msgs__msg__CommandCode__NAV_LAND_LOCAL ; pub const NAV_LAST : _bindgen_ty_583 = mavros_msgs__msg__CommandCode__NAV_LAST ; pub const NAV_LOITER_TIME : _bindgen_ty_566 = mavros_msgs__msg__CommandCode__NAV_LOITER_TIME ; pub const NAV_LOITER_TO_ALT : _bindgen_ty_574 = mavros_msgs__msg__CommandCode__NAV_LOITER_TO_ALT ; pub const NAV_LOITER_TURNS : _bindgen_ty_565 = mavros_msgs__msg__CommandCode__NAV_LOITER_TURNS ; pub const NAV_LOITER_UNLIM : _bindgen_ty_564 = mavros_msgs__msg__CommandCode__NAV_LOITER_UNLIM ; pub const NAV_PATHPLANNING : _bindgen_ty_576 = mavros_msgs__msg__CommandCode__NAV_PATHPLANNING ; pub const NAV_PAYLOAD_PLACE : _bindgen_ty_582 = mavros_msgs__msg__CommandCode__NAV_PAYLOAD_PLACE ; pub const NAV_RALLY_POINT : _bindgen_ty_590 = mavros_msgs__msg__CommandCode__NAV_RALLY_POINT ; pub const NAV_RETURN_TO_LAUNCH : _bindgen_ty_567 = mavros_msgs__msg__CommandCode__NAV_RETURN_TO_LAUNCH ; pub const NAV_ROI : _bindgen_ty_575 = mavros_msgs__msg__CommandCode__NAV_ROI ; pub const NAV_SET_YAW_SPEED : _bindgen_ty_584 = mavros_msgs__msg__CommandCode__NAV_SET_YAW_SPEED ; pub const NAV_SPLINE_WAYPOINT : _bindgen_ty_577 = mavros_msgs__msg__CommandCode__NAV_SPLINE_WAYPOINT ; pub const NAV_TAKEOFF : _bindgen_ty_569 = mavros_msgs__msg__CommandCode__NAV_TAKEOFF ; pub const NAV_TAKEOFF_LOCAL : _bindgen_ty_571 = mavros_msgs__msg__CommandCode__NAV_TAKEOFF_LOCAL ; pub const NAV_VTOL_LAND : _bindgen_ty_579 = mavros_msgs__msg__CommandCode__NAV_VTOL_LAND ; pub const NAV_VTOL_TAKEOFF : _bindgen_ty_578 = mavros_msgs__msg__CommandCode__NAV_VTOL_TAKEOFF ; pub const NAV_WAYPOINT : _bindgen_ty_563 = mavros_msgs__msg__CommandCode__NAV_WAYPOINT ; pub const OBLIQUE_SURVEY : _bindgen_ty_591 = mavros_msgs__msg__CommandCode__OBLIQUE_SURVEY ; pub const OVERRIDE_GOTO : _bindgen_ty_592 = mavros_msgs__msg__CommandCode__OVERRIDE_GOTO ; pub const PANORAMA_CREATE : _bindgen_ty_593 = mavros_msgs__msg__CommandCode__PANORAMA_CREATE ; pub const PAYLOAD_CONTROL_DEPLOY : _bindgen_ty_595 = mavros_msgs__msg__CommandCode__PAYLOAD_CONTROL_DEPLOY ; pub const PAYLOAD_PREPARE_DEPLOY : _bindgen_ty_594 = mavros_msgs__msg__CommandCode__PAYLOAD_PREPARE_DEPLOY ; pub const PREFLIGHT_CALIBRATION : _bindgen_ty_596 = mavros_msgs__msg__CommandCode__PREFLIGHT_CALIBRATION ; pub const PREFLIGHT_REBOOT_SHUTDOWN : _bindgen_ty_600 = mavros_msgs__msg__CommandCode__PREFLIGHT_REBOOT_SHUTDOWN ; pub const PREFLIGHT_SET_SENSOR_OFFSETS : _bindgen_ty_597 = mavros_msgs__msg__CommandCode__PREFLIGHT_SET_SENSOR_OFFSETS ; pub const PREFLIGHT_STORAGE : _bindgen_ty_599 = mavros_msgs__msg__CommandCode__PREFLIGHT_STORAGE ; pub const PREFLIGHT_UAVCAN : _bindgen_ty_598 = mavros_msgs__msg__CommandCode__PREFLIGHT_UAVCAN ; pub const REQUEST_AUTOPILOT_CAPABILITIES : _bindgen_ty_603 = mavros_msgs__msg__CommandCode__REQUEST_AUTOPILOT_CAPABILITIES ; pub const REQUEST_CAMERA_CAPTURE_STATUS : _bindgen_ty_607 = mavros_msgs__msg__CommandCode__REQUEST_CAMERA_CAPTURE_STATUS ; pub const REQUEST_CAMERA_INFORMATION : _bindgen_ty_604 = mavros_msgs__msg__CommandCode__REQUEST_CAMERA_INFORMATION ; pub const REQUEST_CAMERA_SETTINGS : _bindgen_ty_605 = mavros_msgs__msg__CommandCode__REQUEST_CAMERA_SETTINGS ; pub const REQUEST_FLIGHT_INFORMATION : _bindgen_ty_608 = mavros_msgs__msg__CommandCode__REQUEST_FLIGHT_INFORMATION ; pub const REQUEST_MESSAGE : _bindgen_ty_601 = mavros_msgs__msg__CommandCode__REQUEST_MESSAGE ; pub const REQUEST_PROTOCOL_VERSION : _bindgen_ty_602 = mavros_msgs__msg__CommandCode__REQUEST_PROTOCOL_VERSION ; pub const REQUEST_STORAGE_INFORMATION : _bindgen_ty_606 = mavros_msgs__msg__CommandCode__REQUEST_STORAGE_INFORMATION ; pub const REQUEST_VIDEO_STREAM_INFORMATION : _bindgen_ty_609 = mavros_msgs__msg__CommandCode__REQUEST_VIDEO_STREAM_INFORMATION ; pub const REQUEST_VIDEO_STREAM_STATUS : _bindgen_ty_610 = mavros_msgs__msg__CommandCode__REQUEST_VIDEO_STREAM_STATUS ; pub const RESET_CAMERA_SETTINGS : _bindgen_ty_611 = mavros_msgs__msg__CommandCode__RESET_CAMERA_SETTINGS ; pub const RUN_PREARM_CHECKS : _bindgen_ty_612 = mavros_msgs__msg__CommandCode__RUN_PREARM_CHECKS ; pub const SET_CAMERA_MODE : _bindgen_ty_614 = mavros_msgs__msg__CommandCode__SET_CAMERA_MODE ; pub const SET_GUIDED_SUBMODE_CIRCLE : _bindgen_ty_616 = mavros_msgs__msg__CommandCode__SET_GUIDED_SUBMODE_CIRCLE ; pub const SET_GUIDED_SUBMODE_STANDARD : _bindgen_ty_615 = mavros_msgs__msg__CommandCode__SET_GUIDED_SUBMODE_STANDARD ; pub const SET_MESSAGE_INTERVAL : _bindgen_ty_613 = mavros_msgs__msg__CommandCode__SET_MESSAGE_INTERVAL ; pub const SPATIAL_USER_1 : _bindgen_ty_617 = mavros_msgs__msg__CommandCode__SPATIAL_USER_1 ; pub const SPATIAL_USER_2 : _bindgen_ty_618 = mavros_msgs__msg__CommandCode__SPATIAL_USER_2 ; pub const SPATIAL_USER_3 : _bindgen_ty_619 = mavros_msgs__msg__CommandCode__SPATIAL_USER_3 ; pub const SPATIAL_USER_4 : _bindgen_ty_620 = mavros_msgs__msg__CommandCode__SPATIAL_USER_4 ; pub const SPATIAL_USER_5 : _bindgen_ty_621 = mavros_msgs__msg__CommandCode__SPATIAL_USER_5 ; pub const START_RX_PAIR : _bindgen_ty_622 = mavros_msgs__msg__CommandCode__START_RX_PAIR ; pub const STORAGE_FORMAT : _bindgen_ty_623 = mavros_msgs__msg__CommandCode__STORAGE_FORMAT ; pub const UAVCAN_GET_NODE_INFO : _bindgen_ty_624 = mavros_msgs__msg__CommandCode__UAVCAN_GET_NODE_INFO ; pub const USER_1 : _bindgen_ty_625 = mavros_msgs__msg__CommandCode__USER_1 ; pub const USER_2 : _bindgen_ty_626 = mavros_msgs__msg__CommandCode__USER_2 ; pub const USER_3 : _bindgen_ty_627 = mavros_msgs__msg__CommandCode__USER_3 ; pub const USER_4 : _bindgen_ty_628 = mavros_msgs__msg__CommandCode__USER_4 ; pub const USER_5 : _bindgen_ty_629 = mavros_msgs__msg__CommandCode__USER_5 ; pub const VIDEO_START_CAPTURE : _bindgen_ty_630 = mavros_msgs__msg__CommandCode__VIDEO_START_CAPTURE ; pub const VIDEO_START_STREAMING : _bindgen_ty_632 = mavros_msgs__msg__CommandCode__VIDEO_START_STREAMING ; pub const VIDEO_STOP_CAPTURE : _bindgen_ty_631 = mavros_msgs__msg__CommandCode__VIDEO_STOP_CAPTURE ; pub const VIDEO_STOP_STREAMING : _bindgen_ty_633 = mavros_msgs__msg__CommandCode__VIDEO_STOP_STREAMING ; pub const WAYPOINT_USER_1 : _bindgen_ty_634 = mavros_msgs__msg__CommandCode__WAYPOINT_USER_1 ; pub const WAYPOINT_USER_2 : _bindgen_ty_635 = mavros_msgs__msg__CommandCode__WAYPOINT_USER_2 ; pub const WAYPOINT_USER_3 : _bindgen_ty_636 = mavros_msgs__msg__CommandCode__WAYPOINT_USER_3 ; pub const WAYPOINT_USER_4 : _bindgen_ty_637 = mavros_msgs__msg__CommandCode__WAYPOINT_USER_4 ; pub const WAYPOINT_USER_5 : _bindgen_ty_638 = mavros_msgs__msg__CommandCode__WAYPOINT_USER_5 ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct CompanionProcessStatus { pub header : std_msgs :: msg :: Header , pub state : u8 , pub component : u8 } impl WrappedTypesupport for CompanionProcessStatus { type CStruct = mavros_msgs__msg__CompanionProcessStatus ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__msg__CompanionProcessStatus () } } fn create_msg () -> * mut mavros_msgs__msg__CompanionProcessStatus { unsafe { mavros_msgs__msg__CompanionProcessStatus__create () } } fn destroy_msg (msg : * mut mavros_msgs__msg__CompanionProcessStatus) -> () { unsafe { mavros_msgs__msg__CompanionProcessStatus__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> CompanionProcessStatus { CompanionProcessStatus { header : std_msgs :: msg :: Header :: from_native (& msg . header) , state : msg . state , component : msg . component , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . state = self . state ; msg . component = self . component ; } } impl Default for CompanionProcessStatus { fn default () -> Self { let msg_native = WrappedNativeMsg :: < CompanionProcessStatus > :: new () ; CompanionProcessStatus :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl CompanionProcessStatus { pub const MAV_COMP_ID_OBSTACLE_AVOIDANCE : _bindgen_ty_648 = mavros_msgs__msg__CompanionProcessStatus__MAV_COMP_ID_OBSTACLE_AVOIDANCE ; pub const MAV_COMP_ID_VISUAL_INERTIAL_ODOMETRY : _bindgen_ty_649 = mavros_msgs__msg__CompanionProcessStatus__MAV_COMP_ID_VISUAL_INERTIAL_ODOMETRY ; pub const MAV_STATE_ACTIVE : _bindgen_ty_643 = mavros_msgs__msg__CompanionProcessStatus__MAV_STATE_ACTIVE ; pub const MAV_STATE_BOOT : _bindgen_ty_640 = mavros_msgs__msg__CompanionProcessStatus__MAV_STATE_BOOT ; pub const MAV_STATE_CALIBRATING : _bindgen_ty_641 = mavros_msgs__msg__CompanionProcessStatus__MAV_STATE_CALIBRATING ; pub const MAV_STATE_CRITICAL : _bindgen_ty_644 = mavros_msgs__msg__CompanionProcessStatus__MAV_STATE_CRITICAL ; pub const MAV_STATE_EMERGENCY : _bindgen_ty_645 = mavros_msgs__msg__CompanionProcessStatus__MAV_STATE_EMERGENCY ; pub const MAV_STATE_FLIGHT_TERMINATION : _bindgen_ty_647 = mavros_msgs__msg__CompanionProcessStatus__MAV_STATE_FLIGHT_TERMINATION ; pub const MAV_STATE_POWEROFF : _bindgen_ty_646 = mavros_msgs__msg__CompanionProcessStatus__MAV_STATE_POWEROFF ; pub const MAV_STATE_STANDBY : _bindgen_ty_642 = mavros_msgs__msg__CompanionProcessStatus__MAV_STATE_STANDBY ; pub const MAV_STATE_UNINIT : _bindgen_ty_639 = mavros_msgs__msg__CompanionProcessStatus__MAV_STATE_UNINIT ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct DebugValue { pub header : std_msgs :: msg :: Header , pub index : i32 , pub name : std :: string :: String , pub value_float : f32 , pub value_int : i32 , pub data : Vec < f32 > , # [serde (rename = "type")] pub type_ : u8 } impl WrappedTypesupport for DebugValue { type CStruct = mavros_msgs__msg__DebugValue ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__msg__DebugValue () } } fn create_msg () -> * mut mavros_msgs__msg__DebugValue { unsafe { mavros_msgs__msg__DebugValue__create () } } fn destroy_msg (msg : * mut mavros_msgs__msg__DebugValue) -> () { unsafe { mavros_msgs__msg__DebugValue__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> DebugValue { DebugValue { header : std_msgs :: msg :: Header :: from_native (& msg . header) , index : msg . index , name : msg . name . to_str () . to_owned () , value_float : msg . value_float , value_int : msg . value_int , data : msg . data . to_vec () , type_ : msg . type_ , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . index = self . index ; msg . name . assign (& self . name) ; msg . value_float = self . value_float ; msg . value_int = self . value_int ; msg . data . update (& self . data) ; msg . type_ = self . type_ ; } } impl Default for DebugValue { fn default () -> Self { let msg_native = WrappedNativeMsg :: < DebugValue > :: new () ; DebugValue :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl DebugValue { pub const TYPE_DEBUG : _bindgen_ty_650 = mavros_msgs__msg__DebugValue__TYPE_DEBUG ; pub const TYPE_DEBUG_ARRAY : _bindgen_ty_652 = mavros_msgs__msg__DebugValue__TYPE_DEBUG_ARRAY ; pub const TYPE_DEBUG_VECT : _bindgen_ty_651 = mavros_msgs__msg__DebugValue__TYPE_DEBUG_VECT ; pub const TYPE_NAMED_VALUE_FLOAT : _bindgen_ty_653 = mavros_msgs__msg__DebugValue__TYPE_NAMED_VALUE_FLOAT ; pub const TYPE_NAMED_VALUE_INT : _bindgen_ty_654 = mavros_msgs__msg__DebugValue__TYPE_NAMED_VALUE_INT ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ESCInfo { pub header : std_msgs :: msg :: Header , pub counter : u16 , pub count : u8 , pub connection_type : u8 , pub info : u8 , pub esc_info : Vec < mavros_msgs :: msg :: ESCInfoItem > } impl WrappedTypesupport for ESCInfo { type CStruct = mavros_msgs__msg__ESCInfo ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__msg__ESCInfo () } } fn create_msg () -> * mut mavros_msgs__msg__ESCInfo { unsafe { mavros_msgs__msg__ESCInfo__create () } } fn destroy_msg (msg : * mut mavros_msgs__msg__ESCInfo) -> () { unsafe { mavros_msgs__msg__ESCInfo__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ESCInfo { ESCInfo { header : std_msgs :: msg :: Header :: from_native (& msg . header) , counter : msg . counter , count : msg . count , connection_type : msg . connection_type , info : msg . info , esc_info : { let mut temp = Vec :: with_capacity (msg . esc_info . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . esc_info . data , msg . esc_info . size) } ; for s in slice { temp . push (mavros_msgs :: msg :: ESCInfoItem :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . counter = self . counter ; msg . count = self . count ; msg . connection_type = self . connection_type ; msg . info = self . info ; unsafe { mavros_msgs__msg__ESCInfoItem__Sequence__fini (& mut msg . esc_info) ; mavros_msgs__msg__ESCInfoItem__Sequence__init (& mut msg . esc_info , self . esc_info . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . esc_info . data , msg . esc_info . size) ; for (t , s) in slice . iter_mut () . zip (& self . esc_info) { s . copy_to_native (t) ; } } } } impl Default for ESCInfo { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ESCInfo > :: new () ; ESCInfo :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ESCInfoItem { pub header : std_msgs :: msg :: Header , pub failure_flags : u16 , pub error_count : u32 , pub temperature : i32 } impl WrappedTypesupport for ESCInfoItem { type CStruct = mavros_msgs__msg__ESCInfoItem ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__msg__ESCInfoItem () } } fn create_msg () -> * mut mavros_msgs__msg__ESCInfoItem { unsafe { mavros_msgs__msg__ESCInfoItem__create () } } fn destroy_msg (msg : * mut mavros_msgs__msg__ESCInfoItem) -> () { unsafe { mavros_msgs__msg__ESCInfoItem__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ESCInfoItem { ESCInfoItem { header : std_msgs :: msg :: Header :: from_native (& msg . header) , failure_flags : msg . failure_flags , error_count : msg . error_count , temperature : msg . temperature , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . failure_flags = self . failure_flags ; msg . error_count = self . error_count ; msg . temperature = self . temperature ; } } impl Default for ESCInfoItem { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ESCInfoItem > :: new () ; ESCInfoItem :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ESCStatus { pub header : std_msgs :: msg :: Header , pub esc_status : Vec < mavros_msgs :: msg :: ESCStatusItem > } impl WrappedTypesupport for ESCStatus { type CStruct = mavros_msgs__msg__ESCStatus ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__msg__ESCStatus () } } fn create_msg () -> * mut mavros_msgs__msg__ESCStatus { unsafe { mavros_msgs__msg__ESCStatus__create () } } fn destroy_msg (msg : * mut mavros_msgs__msg__ESCStatus) -> () { unsafe { mavros_msgs__msg__ESCStatus__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ESCStatus { ESCStatus { header : std_msgs :: msg :: Header :: from_native (& msg . header) , esc_status : { let mut temp = Vec :: with_capacity (msg . esc_status . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . esc_status . data , msg . esc_status . size) } ; for s in slice { temp . push (mavros_msgs :: msg :: ESCStatusItem :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; unsafe { mavros_msgs__msg__ESCStatusItem__Sequence__fini (& mut msg . esc_status) ; mavros_msgs__msg__ESCStatusItem__Sequence__init (& mut msg . esc_status , self . esc_status . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . esc_status . data , msg . esc_status . size) ; for (t , s) in slice . iter_mut () . zip (& self . esc_status) { s . copy_to_native (t) ; } } } } impl Default for ESCStatus { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ESCStatus > :: new () ; ESCStatus :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ESCStatusItem { pub header : std_msgs :: msg :: Header , pub rpm : i32 , pub voltage : f32 , pub current : f32 } impl WrappedTypesupport for ESCStatusItem { type CStruct = mavros_msgs__msg__ESCStatusItem ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__msg__ESCStatusItem () } } fn create_msg () -> * mut mavros_msgs__msg__ESCStatusItem { unsafe { mavros_msgs__msg__ESCStatusItem__create () } } fn destroy_msg (msg : * mut mavros_msgs__msg__ESCStatusItem) -> () { unsafe { mavros_msgs__msg__ESCStatusItem__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ESCStatusItem { ESCStatusItem { header : std_msgs :: msg :: Header :: from_native (& msg . header) , rpm : msg . rpm , voltage : msg . voltage , current : msg . current , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . rpm = self . rpm ; msg . voltage = self . voltage ; msg . current = self . current ; } } impl Default for ESCStatusItem { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ESCStatusItem > :: new () ; ESCStatusItem :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ESCTelemetry { pub header : std_msgs :: msg :: Header , pub esc_telemetry : Vec < mavros_msgs :: msg :: ESCTelemetryItem > } impl WrappedTypesupport for ESCTelemetry { type CStruct = mavros_msgs__msg__ESCTelemetry ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__msg__ESCTelemetry () } } fn create_msg () -> * mut mavros_msgs__msg__ESCTelemetry { unsafe { mavros_msgs__msg__ESCTelemetry__create () } } fn destroy_msg (msg : * mut mavros_msgs__msg__ESCTelemetry) -> () { unsafe { mavros_msgs__msg__ESCTelemetry__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ESCTelemetry { ESCTelemetry { header : std_msgs :: msg :: Header :: from_native (& msg . header) , esc_telemetry : { let mut temp = Vec :: with_capacity (msg . esc_telemetry . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . esc_telemetry . data , msg . esc_telemetry . size) } ; for s in slice { temp . push (mavros_msgs :: msg :: ESCTelemetryItem :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; unsafe { mavros_msgs__msg__ESCTelemetryItem__Sequence__fini (& mut msg . esc_telemetry) ; mavros_msgs__msg__ESCTelemetryItem__Sequence__init (& mut msg . esc_telemetry , self . esc_telemetry . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . esc_telemetry . data , msg . esc_telemetry . size) ; for (t , s) in slice . iter_mut () . zip (& self . esc_telemetry) { s . copy_to_native (t) ; } } } } impl Default for ESCTelemetry { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ESCTelemetry > :: new () ; ESCTelemetry :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ESCTelemetryItem { pub header : std_msgs :: msg :: Header , pub temperature : f32 , pub voltage : f32 , pub current : f32 , pub totalcurrent : f32 , pub rpm : i32 , pub count : u16 } impl WrappedTypesupport for ESCTelemetryItem { type CStruct = mavros_msgs__msg__ESCTelemetryItem ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__msg__ESCTelemetryItem () } } fn create_msg () -> * mut mavros_msgs__msg__ESCTelemetryItem { unsafe { mavros_msgs__msg__ESCTelemetryItem__create () } } fn destroy_msg (msg : * mut mavros_msgs__msg__ESCTelemetryItem) -> () { unsafe { mavros_msgs__msg__ESCTelemetryItem__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ESCTelemetryItem { ESCTelemetryItem { header : std_msgs :: msg :: Header :: from_native (& msg . header) , temperature : msg . temperature , voltage : msg . voltage , current : msg . current , totalcurrent : msg . totalcurrent , rpm : msg . rpm , count : msg . count , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . temperature = self . temperature ; msg . voltage = self . voltage ; msg . current = self . current ; msg . totalcurrent = self . totalcurrent ; msg . rpm = self . rpm ; msg . count = self . count ; } } impl Default for ESCTelemetryItem { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ESCTelemetryItem > :: new () ; ESCTelemetryItem :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct EstimatorStatus { pub header : std_msgs :: msg :: Header , pub attitude_status_flag : bool , pub velocity_horiz_status_flag : bool , pub velocity_vert_status_flag : bool , pub pos_horiz_rel_status_flag : bool , pub pos_horiz_abs_status_flag : bool , pub pos_vert_abs_status_flag : bool , pub pos_vert_agl_status_flag : bool , pub const_pos_mode_status_flag : bool , pub pred_pos_horiz_rel_status_flag : bool , pub pred_pos_horiz_abs_status_flag : bool , pub gps_glitch_status_flag : bool , pub accel_error_status_flag : bool } impl WrappedTypesupport for EstimatorStatus { type CStruct = mavros_msgs__msg__EstimatorStatus ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__msg__EstimatorStatus () } } fn create_msg () -> * mut mavros_msgs__msg__EstimatorStatus { unsafe { mavros_msgs__msg__EstimatorStatus__create () } } fn destroy_msg (msg : * mut mavros_msgs__msg__EstimatorStatus) -> () { unsafe { mavros_msgs__msg__EstimatorStatus__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> EstimatorStatus { EstimatorStatus { header : std_msgs :: msg :: Header :: from_native (& msg . header) , attitude_status_flag : msg . attitude_status_flag , velocity_horiz_status_flag : msg . velocity_horiz_status_flag , velocity_vert_status_flag : msg . velocity_vert_status_flag , pos_horiz_rel_status_flag : msg . pos_horiz_rel_status_flag , pos_horiz_abs_status_flag : msg . pos_horiz_abs_status_flag , pos_vert_abs_status_flag : msg . pos_vert_abs_status_flag , pos_vert_agl_status_flag : msg . pos_vert_agl_status_flag , const_pos_mode_status_flag : msg . const_pos_mode_status_flag , pred_pos_horiz_rel_status_flag : msg . pred_pos_horiz_rel_status_flag , pred_pos_horiz_abs_status_flag : msg . pred_pos_horiz_abs_status_flag , gps_glitch_status_flag : msg . gps_glitch_status_flag , accel_error_status_flag : msg . accel_error_status_flag , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . attitude_status_flag = self . attitude_status_flag ; msg . velocity_horiz_status_flag = self . velocity_horiz_status_flag ; msg . velocity_vert_status_flag = self . velocity_vert_status_flag ; msg . pos_horiz_rel_status_flag = self . pos_horiz_rel_status_flag ; msg . pos_horiz_abs_status_flag = self . pos_horiz_abs_status_flag ; msg . pos_vert_abs_status_flag = self . pos_vert_abs_status_flag ; msg . pos_vert_agl_status_flag = self . pos_vert_agl_status_flag ; msg . const_pos_mode_status_flag = self . const_pos_mode_status_flag ; msg . pred_pos_horiz_rel_status_flag = self . pred_pos_horiz_rel_status_flag ; msg . pred_pos_horiz_abs_status_flag = self . pred_pos_horiz_abs_status_flag ; msg . gps_glitch_status_flag = self . gps_glitch_status_flag ; msg . accel_error_status_flag = self . accel_error_status_flag ; } } impl Default for EstimatorStatus { fn default () -> Self { let msg_native = WrappedNativeMsg :: < EstimatorStatus > :: new () ; EstimatorStatus :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ExtendedState { pub header : std_msgs :: msg :: Header , pub vtol_state : u8 , pub landed_state : u8 } impl WrappedTypesupport for ExtendedState { type CStruct = mavros_msgs__msg__ExtendedState ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__msg__ExtendedState () } } fn create_msg () -> * mut mavros_msgs__msg__ExtendedState { unsafe { mavros_msgs__msg__ExtendedState__create () } } fn destroy_msg (msg : * mut mavros_msgs__msg__ExtendedState) -> () { unsafe { mavros_msgs__msg__ExtendedState__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ExtendedState { ExtendedState { header : std_msgs :: msg :: Header :: from_native (& msg . header) , vtol_state : msg . vtol_state , landed_state : msg . landed_state , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . vtol_state = self . vtol_state ; msg . landed_state = self . landed_state ; } } impl Default for ExtendedState { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ExtendedState > :: new () ; ExtendedState :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl ExtendedState { pub const LANDED_STATE_IN_AIR : _bindgen_ty_662 = mavros_msgs__msg__ExtendedState__LANDED_STATE_IN_AIR ; pub const LANDED_STATE_LANDING : _bindgen_ty_664 = mavros_msgs__msg__ExtendedState__LANDED_STATE_LANDING ; pub const LANDED_STATE_ON_GROUND : _bindgen_ty_661 = mavros_msgs__msg__ExtendedState__LANDED_STATE_ON_GROUND ; pub const LANDED_STATE_TAKEOFF : _bindgen_ty_663 = mavros_msgs__msg__ExtendedState__LANDED_STATE_TAKEOFF ; pub const LANDED_STATE_UNDEFINED : _bindgen_ty_660 = mavros_msgs__msg__ExtendedState__LANDED_STATE_UNDEFINED ; pub const VTOL_STATE_FW : _bindgen_ty_659 = mavros_msgs__msg__ExtendedState__VTOL_STATE_FW ; pub const VTOL_STATE_MC : _bindgen_ty_658 = mavros_msgs__msg__ExtendedState__VTOL_STATE_MC ; pub const VTOL_STATE_TRANSITION_TO_FW : _bindgen_ty_656 = mavros_msgs__msg__ExtendedState__VTOL_STATE_TRANSITION_TO_FW ; pub const VTOL_STATE_TRANSITION_TO_MC : _bindgen_ty_657 = mavros_msgs__msg__ExtendedState__VTOL_STATE_TRANSITION_TO_MC ; pub const VTOL_STATE_UNDEFINED : _bindgen_ty_655 = mavros_msgs__msg__ExtendedState__VTOL_STATE_UNDEFINED ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct FileEntry { pub name : std :: string :: String , # [serde (rename = "type")] pub type_ : u8 , pub size : u64 } impl WrappedTypesupport for FileEntry { type CStruct = mavros_msgs__msg__FileEntry ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__msg__FileEntry () } } fn create_msg () -> * mut mavros_msgs__msg__FileEntry { unsafe { mavros_msgs__msg__FileEntry__create () } } fn destroy_msg (msg : * mut mavros_msgs__msg__FileEntry) -> () { unsafe { mavros_msgs__msg__FileEntry__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> FileEntry { FileEntry { name : msg . name . to_str () . to_owned () , type_ : msg . type_ , size : msg . size , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . name . assign (& self . name) ; msg . type_ = self . type_ ; msg . size = self . size ; } } impl Default for FileEntry { fn default () -> Self { let msg_native = WrappedNativeMsg :: < FileEntry > :: new () ; FileEntry :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl FileEntry { pub const TYPE_DIRECTORY : _bindgen_ty_666 = mavros_msgs__msg__FileEntry__TYPE_DIRECTORY ; pub const TYPE_FILE : _bindgen_ty_665 = mavros_msgs__msg__FileEntry__TYPE_FILE ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct GPSINPUT { pub header : std_msgs :: msg :: Header , pub fix_type : u8 , pub gps_id : u8 , pub ignore_flags : u16 , pub time_week_ms : u32 , pub time_week : u16 , pub lat : i32 , pub lon : i32 , pub alt : f32 , pub hdop : f32 , pub vdop : f32 , pub vn : f32 , pub ve : f32 , pub vd : f32 , pub speed_accuracy : f32 , pub horiz_accuracy : f32 , pub vert_accuracy : f32 , pub satellites_visible : u8 , pub yaw : u16 } impl WrappedTypesupport for GPSINPUT { type CStruct = mavros_msgs__msg__GPSINPUT ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__msg__GPSINPUT () } } fn create_msg () -> * mut mavros_msgs__msg__GPSINPUT { unsafe { mavros_msgs__msg__GPSINPUT__create () } } fn destroy_msg (msg : * mut mavros_msgs__msg__GPSINPUT) -> () { unsafe { mavros_msgs__msg__GPSINPUT__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> GPSINPUT { GPSINPUT { header : std_msgs :: msg :: Header :: from_native (& msg . header) , fix_type : msg . fix_type , gps_id : msg . gps_id , ignore_flags : msg . ignore_flags , time_week_ms : msg . time_week_ms , time_week : msg . time_week , lat : msg . lat , lon : msg . lon , alt : msg . alt , hdop : msg . hdop , vdop : msg . vdop , vn : msg . vn , ve : msg . ve , vd : msg . vd , speed_accuracy : msg . speed_accuracy , horiz_accuracy : msg . horiz_accuracy , vert_accuracy : msg . vert_accuracy , satellites_visible : msg . satellites_visible , yaw : msg . yaw , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . fix_type = self . fix_type ; msg . gps_id = self . gps_id ; msg . ignore_flags = self . ignore_flags ; msg . time_week_ms = self . time_week_ms ; msg . time_week = self . time_week ; msg . lat = self . lat ; msg . lon = self . lon ; msg . alt = self . alt ; msg . hdop = self . hdop ; msg . vdop = self . vdop ; msg . vn = self . vn ; msg . ve = self . ve ; msg . vd = self . vd ; msg . speed_accuracy = self . speed_accuracy ; msg . horiz_accuracy = self . horiz_accuracy ; msg . vert_accuracy = self . vert_accuracy ; msg . satellites_visible = self . satellites_visible ; msg . yaw = self . yaw ; } } impl Default for GPSINPUT { fn default () -> Self { let msg_native = WrappedNativeMsg :: < GPSINPUT > :: new () ; GPSINPUT :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl GPSINPUT { pub const GPS_FIX_TYPE_2D_FIX : _bindgen_ty_684 = mavros_msgs__msg__GPSINPUT__GPS_FIX_TYPE_2D_FIX ; pub const GPS_FIX_TYPE_3D_FIX : _bindgen_ty_685 = mavros_msgs__msg__GPSINPUT__GPS_FIX_TYPE_3D_FIX ; pub const GPS_FIX_TYPE_DGPS : _bindgen_ty_686 = mavros_msgs__msg__GPSINPUT__GPS_FIX_TYPE_DGPS ; pub const GPS_FIX_TYPE_NO_FIX : _bindgen_ty_683 = mavros_msgs__msg__GPSINPUT__GPS_FIX_TYPE_NO_FIX ; pub const GPS_FIX_TYPE_NO_GPS : _bindgen_ty_682 = mavros_msgs__msg__GPSINPUT__GPS_FIX_TYPE_NO_GPS ; pub const GPS_FIX_TYPE_PPP : _bindgen_ty_690 = mavros_msgs__msg__GPSINPUT__GPS_FIX_TYPE_PPP ; pub const GPS_FIX_TYPE_RTK_FIXEDR : _bindgen_ty_688 = mavros_msgs__msg__GPSINPUT__GPS_FIX_TYPE_RTK_FIXEDR ; pub const GPS_FIX_TYPE_RTK_FLOATR : _bindgen_ty_687 = mavros_msgs__msg__GPSINPUT__GPS_FIX_TYPE_RTK_FLOATR ; pub const GPS_FIX_TYPE_STATIC : _bindgen_ty_689 = mavros_msgs__msg__GPSINPUT__GPS_FIX_TYPE_STATIC ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct GPSRAW { pub header : std_msgs :: msg :: Header , pub fix_type : u8 , pub lat : i32 , pub lon : i32 , pub alt : i32 , pub eph : u16 , pub epv : u16 , pub vel : u16 , pub cog : u16 , pub satellites_visible : u8 , pub alt_ellipsoid : i32 , pub h_acc : u32 , pub v_acc : u32 , pub vel_acc : u32 , pub hdg_acc : i32 , pub yaw : u16 , pub dgps_numch : u8 , pub dgps_age : u32 } impl WrappedTypesupport for GPSRAW { type CStruct = mavros_msgs__msg__GPSRAW ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__msg__GPSRAW () } } fn create_msg () -> * mut mavros_msgs__msg__GPSRAW { unsafe { mavros_msgs__msg__GPSRAW__create () } } fn destroy_msg (msg : * mut mavros_msgs__msg__GPSRAW) -> () { unsafe { mavros_msgs__msg__GPSRAW__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> GPSRAW { GPSRAW { header : std_msgs :: msg :: Header :: from_native (& msg . header) , fix_type : msg . fix_type , lat : msg . lat , lon : msg . lon , alt : msg . alt , eph : msg . eph , epv : msg . epv , vel : msg . vel , cog : msg . cog , satellites_visible : msg . satellites_visible , alt_ellipsoid : msg . alt_ellipsoid , h_acc : msg . h_acc , v_acc : msg . v_acc , vel_acc : msg . vel_acc , hdg_acc : msg . hdg_acc , yaw : msg . yaw , dgps_numch : msg . dgps_numch , dgps_age : msg . dgps_age , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . fix_type = self . fix_type ; msg . lat = self . lat ; msg . lon = self . lon ; msg . alt = self . alt ; msg . eph = self . eph ; msg . epv = self . epv ; msg . vel = self . vel ; msg . cog = self . cog ; msg . satellites_visible = self . satellites_visible ; msg . alt_ellipsoid = self . alt_ellipsoid ; msg . h_acc = self . h_acc ; msg . v_acc = self . v_acc ; msg . vel_acc = self . vel_acc ; msg . hdg_acc = self . hdg_acc ; msg . yaw = self . yaw ; msg . dgps_numch = self . dgps_numch ; msg . dgps_age = self . dgps_age ; } } impl Default for GPSRAW { fn default () -> Self { let msg_native = WrappedNativeMsg :: < GPSRAW > :: new () ; GPSRAW :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl GPSRAW { pub const GPS_FIX_TYPE_2D_FIX : _bindgen_ty_693 = mavros_msgs__msg__GPSRAW__GPS_FIX_TYPE_2D_FIX ; pub const GPS_FIX_TYPE_3D_FIX : _bindgen_ty_694 = mavros_msgs__msg__GPSRAW__GPS_FIX_TYPE_3D_FIX ; pub const GPS_FIX_TYPE_DGPS : _bindgen_ty_695 = mavros_msgs__msg__GPSRAW__GPS_FIX_TYPE_DGPS ; pub const GPS_FIX_TYPE_NO_FIX : _bindgen_ty_692 = mavros_msgs__msg__GPSRAW__GPS_FIX_TYPE_NO_FIX ; pub const GPS_FIX_TYPE_NO_GPS : _bindgen_ty_691 = mavros_msgs__msg__GPSRAW__GPS_FIX_TYPE_NO_GPS ; pub const GPS_FIX_TYPE_PPP : _bindgen_ty_699 = mavros_msgs__msg__GPSRAW__GPS_FIX_TYPE_PPP ; pub const GPS_FIX_TYPE_RTK_FIXEDR : _bindgen_ty_697 = mavros_msgs__msg__GPSRAW__GPS_FIX_TYPE_RTK_FIXEDR ; pub const GPS_FIX_TYPE_RTK_FLOATR : _bindgen_ty_696 = mavros_msgs__msg__GPSRAW__GPS_FIX_TYPE_RTK_FLOATR ; pub const GPS_FIX_TYPE_STATIC : _bindgen_ty_698 = mavros_msgs__msg__GPSRAW__GPS_FIX_TYPE_STATIC ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct GPSRTK { pub header : std_msgs :: msg :: Header , pub rtk_receiver_id : u8 , pub wn : i16 , pub tow : u32 , pub rtk_health : u8 , pub rtk_rate : u8 , pub nsats : u8 , pub baseline_a : i32 , pub baseline_b : i32 , pub baseline_c : i32 , pub accuracy : u32 , pub iar_num_hypotheses : i32 } impl WrappedTypesupport for GPSRTK { type CStruct = mavros_msgs__msg__GPSRTK ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__msg__GPSRTK () } } fn create_msg () -> * mut mavros_msgs__msg__GPSRTK { unsafe { mavros_msgs__msg__GPSRTK__create () } } fn destroy_msg (msg : * mut mavros_msgs__msg__GPSRTK) -> () { unsafe { mavros_msgs__msg__GPSRTK__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> GPSRTK { GPSRTK { header : std_msgs :: msg :: Header :: from_native (& msg . header) , rtk_receiver_id : msg . rtk_receiver_id , wn : msg . wn , tow : msg . tow , rtk_health : msg . rtk_health , rtk_rate : msg . rtk_rate , nsats : msg . nsats , baseline_a : msg . baseline_a , baseline_b : msg . baseline_b , baseline_c : msg . baseline_c , accuracy : msg . accuracy , iar_num_hypotheses : msg . iar_num_hypotheses , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . rtk_receiver_id = self . rtk_receiver_id ; msg . wn = self . wn ; msg . tow = self . tow ; msg . rtk_health = self . rtk_health ; msg . rtk_rate = self . rtk_rate ; msg . nsats = self . nsats ; msg . baseline_a = self . baseline_a ; msg . baseline_b = self . baseline_b ; msg . baseline_c = self . baseline_c ; msg . accuracy = self . accuracy ; msg . iar_num_hypotheses = self . iar_num_hypotheses ; } } impl Default for GPSRTK { fn default () -> Self { let msg_native = WrappedNativeMsg :: < GPSRTK > :: new () ; GPSRTK :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct GlobalPositionTarget { pub header : std_msgs :: msg :: Header , pub coordinate_frame : u8 , pub type_mask : u16 , pub latitude : f64 , pub longitude : f64 , pub altitude : f32 , pub velocity : geometry_msgs :: msg :: Vector3 , pub acceleration_or_force : geometry_msgs :: msg :: Vector3 , pub yaw : f32 , pub yaw_rate : f32 } impl WrappedTypesupport for GlobalPositionTarget { type CStruct = mavros_msgs__msg__GlobalPositionTarget ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__msg__GlobalPositionTarget () } } fn create_msg () -> * mut mavros_msgs__msg__GlobalPositionTarget { unsafe { mavros_msgs__msg__GlobalPositionTarget__create () } } fn destroy_msg (msg : * mut mavros_msgs__msg__GlobalPositionTarget) -> () { unsafe { mavros_msgs__msg__GlobalPositionTarget__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> GlobalPositionTarget { GlobalPositionTarget { header : std_msgs :: msg :: Header :: from_native (& msg . header) , coordinate_frame : msg . coordinate_frame , type_mask : msg . type_mask , latitude : msg . latitude , longitude : msg . longitude , altitude : msg . altitude , velocity : geometry_msgs :: msg :: Vector3 :: from_native (& msg . velocity) , acceleration_or_force : geometry_msgs :: msg :: Vector3 :: from_native (& msg . acceleration_or_force) , yaw : msg . yaw , yaw_rate : msg . yaw_rate , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . coordinate_frame = self . coordinate_frame ; msg . type_mask = self . type_mask ; msg . latitude = self . latitude ; msg . longitude = self . longitude ; msg . altitude = self . altitude ; self . velocity . copy_to_native (& mut msg . velocity) ; self . acceleration_or_force . copy_to_native (& mut msg . acceleration_or_force) ; msg . yaw = self . yaw ; msg . yaw_rate = self . yaw_rate ; } } impl Default for GlobalPositionTarget { fn default () -> Self { let msg_native = WrappedNativeMsg :: < GlobalPositionTarget > :: new () ; GlobalPositionTarget :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl GlobalPositionTarget { pub const FORCE : _bindgen_ty_679 = mavros_msgs__msg__GlobalPositionTarget__FORCE ; pub const FRAME_GLOBAL_INT : _bindgen_ty_667 = mavros_msgs__msg__GlobalPositionTarget__FRAME_GLOBAL_INT ; pub const FRAME_GLOBAL_REL_ALT : _bindgen_ty_668 = mavros_msgs__msg__GlobalPositionTarget__FRAME_GLOBAL_REL_ALT ; pub const FRAME_GLOBAL_TERRAIN_ALT : _bindgen_ty_669 = mavros_msgs__msg__GlobalPositionTarget__FRAME_GLOBAL_TERRAIN_ALT ; pub const IGNORE_AFX : _bindgen_ty_676 = mavros_msgs__msg__GlobalPositionTarget__IGNORE_AFX ; pub const IGNORE_AFY : _bindgen_ty_677 = mavros_msgs__msg__GlobalPositionTarget__IGNORE_AFY ; pub const IGNORE_AFZ : _bindgen_ty_678 = mavros_msgs__msg__GlobalPositionTarget__IGNORE_AFZ ; pub const IGNORE_ALTITUDE : _bindgen_ty_672 = mavros_msgs__msg__GlobalPositionTarget__IGNORE_ALTITUDE ; pub const IGNORE_LATITUDE : _bindgen_ty_670 = mavros_msgs__msg__GlobalPositionTarget__IGNORE_LATITUDE ; pub const IGNORE_LONGITUDE : _bindgen_ty_671 = mavros_msgs__msg__GlobalPositionTarget__IGNORE_LONGITUDE ; pub const IGNORE_VX : _bindgen_ty_673 = mavros_msgs__msg__GlobalPositionTarget__IGNORE_VX ; pub const IGNORE_VY : _bindgen_ty_674 = mavros_msgs__msg__GlobalPositionTarget__IGNORE_VY ; pub const IGNORE_VZ : _bindgen_ty_675 = mavros_msgs__msg__GlobalPositionTarget__IGNORE_VZ ; pub const IGNORE_YAW : _bindgen_ty_680 = mavros_msgs__msg__GlobalPositionTarget__IGNORE_YAW ; pub const IGNORE_YAW_RATE : _bindgen_ty_681 = mavros_msgs__msg__GlobalPositionTarget__IGNORE_YAW_RATE ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct HilActuatorControls { pub header : std_msgs :: msg :: Header , pub controls : Vec < f32 > , pub mode : u8 , pub flags : u64 } impl WrappedTypesupport for HilActuatorControls { type CStruct = mavros_msgs__msg__HilActuatorControls ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__msg__HilActuatorControls () } } fn create_msg () -> * mut mavros_msgs__msg__HilActuatorControls { unsafe { mavros_msgs__msg__HilActuatorControls__create () } } fn destroy_msg (msg : * mut mavros_msgs__msg__HilActuatorControls) -> () { unsafe { mavros_msgs__msg__HilActuatorControls__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> HilActuatorControls { HilActuatorControls { header : std_msgs :: msg :: Header :: from_native (& msg . header) , controls : msg . controls . to_vec () , mode : msg . mode , flags : msg . flags , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; assert_eq ! (self . controls . len () , 16usize , "Field {} is fixed size of {}!" , "controls" , 16usize) ; msg . controls . copy_from_slice (& self . controls [.. 16usize]) ; msg . mode = self . mode ; msg . flags = self . flags ; } } impl Default for HilActuatorControls { fn default () -> Self { let msg_native = WrappedNativeMsg :: < HilActuatorControls > :: new () ; HilActuatorControls :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct HilControls { pub header : std_msgs :: msg :: Header , pub roll_ailerons : f32 , pub pitch_elevator : f32 , pub yaw_rudder : f32 , pub throttle : f32 , pub aux1 : f32 , pub aux2 : f32 , pub aux3 : f32 , pub aux4 : f32 , pub mode : u8 , pub nav_mode : u8 } impl WrappedTypesupport for HilControls { type CStruct = mavros_msgs__msg__HilControls ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__msg__HilControls () } } fn create_msg () -> * mut mavros_msgs__msg__HilControls { unsafe { mavros_msgs__msg__HilControls__create () } } fn destroy_msg (msg : * mut mavros_msgs__msg__HilControls) -> () { unsafe { mavros_msgs__msg__HilControls__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> HilControls { HilControls { header : std_msgs :: msg :: Header :: from_native (& msg . header) , roll_ailerons : msg . roll_ailerons , pitch_elevator : msg . pitch_elevator , yaw_rudder : msg . yaw_rudder , throttle : msg . throttle , aux1 : msg . aux1 , aux2 : msg . aux2 , aux3 : msg . aux3 , aux4 : msg . aux4 , mode : msg . mode , nav_mode : msg . nav_mode , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . roll_ailerons = self . roll_ailerons ; msg . pitch_elevator = self . pitch_elevator ; msg . yaw_rudder = self . yaw_rudder ; msg . throttle = self . throttle ; msg . aux1 = self . aux1 ; msg . aux2 = self . aux2 ; msg . aux3 = self . aux3 ; msg . aux4 = self . aux4 ; msg . mode = self . mode ; msg . nav_mode = self . nav_mode ; } } impl Default for HilControls { fn default () -> Self { let msg_native = WrappedNativeMsg :: < HilControls > :: new () ; HilControls :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct HilGPS { pub header : std_msgs :: msg :: Header , pub fix_type : u8 , pub geo : geographic_msgs :: msg :: GeoPoint , pub eph : u16 , pub epv : u16 , pub vel : u16 , pub vn : i16 , pub ve : i16 , pub vd : i16 , pub cog : u16 , pub satellites_visible : u8 } impl WrappedTypesupport for HilGPS { type CStruct = mavros_msgs__msg__HilGPS ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__msg__HilGPS () } } fn create_msg () -> * mut mavros_msgs__msg__HilGPS { unsafe { mavros_msgs__msg__HilGPS__create () } } fn destroy_msg (msg : * mut mavros_msgs__msg__HilGPS) -> () { unsafe { mavros_msgs__msg__HilGPS__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> HilGPS { HilGPS { header : std_msgs :: msg :: Header :: from_native (& msg . header) , fix_type : msg . fix_type , geo : geographic_msgs :: msg :: GeoPoint :: from_native (& msg . geo) , eph : msg . eph , epv : msg . epv , vel : msg . vel , vn : msg . vn , ve : msg . ve , vd : msg . vd , cog : msg . cog , satellites_visible : msg . satellites_visible , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . fix_type = self . fix_type ; self . geo . copy_to_native (& mut msg . geo) ; msg . eph = self . eph ; msg . epv = self . epv ; msg . vel = self . vel ; msg . vn = self . vn ; msg . ve = self . ve ; msg . vd = self . vd ; msg . cog = self . cog ; msg . satellites_visible = self . satellites_visible ; } } impl Default for HilGPS { fn default () -> Self { let msg_native = WrappedNativeMsg :: < HilGPS > :: new () ; HilGPS :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct HilSensor { pub header : std_msgs :: msg :: Header , pub acc : geometry_msgs :: msg :: Vector3 , pub gyro : geometry_msgs :: msg :: Vector3 , pub mag : geometry_msgs :: msg :: Vector3 , pub abs_pressure : f32 , pub diff_pressure : f32 , pub pressure_alt : f32 , pub temperature : f32 , pub fields_updated : u32 } impl WrappedTypesupport for HilSensor { type CStruct = mavros_msgs__msg__HilSensor ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__msg__HilSensor () } } fn create_msg () -> * mut mavros_msgs__msg__HilSensor { unsafe { mavros_msgs__msg__HilSensor__create () } } fn destroy_msg (msg : * mut mavros_msgs__msg__HilSensor) -> () { unsafe { mavros_msgs__msg__HilSensor__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> HilSensor { HilSensor { header : std_msgs :: msg :: Header :: from_native (& msg . header) , acc : geometry_msgs :: msg :: Vector3 :: from_native (& msg . acc) , gyro : geometry_msgs :: msg :: Vector3 :: from_native (& msg . gyro) , mag : geometry_msgs :: msg :: Vector3 :: from_native (& msg . mag) , abs_pressure : msg . abs_pressure , diff_pressure : msg . diff_pressure , pressure_alt : msg . pressure_alt , temperature : msg . temperature , fields_updated : msg . fields_updated , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; self . acc . copy_to_native (& mut msg . acc) ; self . gyro . copy_to_native (& mut msg . gyro) ; self . mag . copy_to_native (& mut msg . mag) ; msg . abs_pressure = self . abs_pressure ; msg . diff_pressure = self . diff_pressure ; msg . pressure_alt = self . pressure_alt ; msg . temperature = self . temperature ; msg . fields_updated = self . fields_updated ; } } impl Default for HilSensor { fn default () -> Self { let msg_native = WrappedNativeMsg :: < HilSensor > :: new () ; HilSensor :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct HilStateQuaternion { pub header : std_msgs :: msg :: Header , pub orientation : geometry_msgs :: msg :: Quaternion , pub angular_velocity : geometry_msgs :: msg :: Vector3 , pub linear_acceleration : geometry_msgs :: msg :: Vector3 , pub linear_velocity : geometry_msgs :: msg :: Vector3 , pub geo : geographic_msgs :: msg :: GeoPoint , pub ind_airspeed : f32 , pub true_airspeed : f32 } impl WrappedTypesupport for HilStateQuaternion { type CStruct = mavros_msgs__msg__HilStateQuaternion ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__msg__HilStateQuaternion () } } fn create_msg () -> * mut mavros_msgs__msg__HilStateQuaternion { unsafe { mavros_msgs__msg__HilStateQuaternion__create () } } fn destroy_msg (msg : * mut mavros_msgs__msg__HilStateQuaternion) -> () { unsafe { mavros_msgs__msg__HilStateQuaternion__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> HilStateQuaternion { HilStateQuaternion { header : std_msgs :: msg :: Header :: from_native (& msg . header) , orientation : geometry_msgs :: msg :: Quaternion :: from_native (& msg . orientation) , angular_velocity : geometry_msgs :: msg :: Vector3 :: from_native (& msg . angular_velocity) , linear_acceleration : geometry_msgs :: msg :: Vector3 :: from_native (& msg . linear_acceleration) , linear_velocity : geometry_msgs :: msg :: Vector3 :: from_native (& msg . linear_velocity) , geo : geographic_msgs :: msg :: GeoPoint :: from_native (& msg . geo) , ind_airspeed : msg . ind_airspeed , true_airspeed : msg . true_airspeed , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; self . orientation . copy_to_native (& mut msg . orientation) ; self . angular_velocity . copy_to_native (& mut msg . angular_velocity) ; self . linear_acceleration . copy_to_native (& mut msg . linear_acceleration) ; self . linear_velocity . copy_to_native (& mut msg . linear_velocity) ; self . geo . copy_to_native (& mut msg . geo) ; msg . ind_airspeed = self . ind_airspeed ; msg . true_airspeed = self . true_airspeed ; } } impl Default for HilStateQuaternion { fn default () -> Self { let msg_native = WrappedNativeMsg :: < HilStateQuaternion > :: new () ; HilStateQuaternion :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct HomePosition { pub header : std_msgs :: msg :: Header , pub geo : geographic_msgs :: msg :: GeoPoint , pub position : geometry_msgs :: msg :: Point , pub orientation : geometry_msgs :: msg :: Quaternion , pub approach : geometry_msgs :: msg :: Vector3 } impl WrappedTypesupport for HomePosition { type CStruct = mavros_msgs__msg__HomePosition ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__msg__HomePosition () } } fn create_msg () -> * mut mavros_msgs__msg__HomePosition { unsafe { mavros_msgs__msg__HomePosition__create () } } fn destroy_msg (msg : * mut mavros_msgs__msg__HomePosition) -> () { unsafe { mavros_msgs__msg__HomePosition__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> HomePosition { HomePosition { header : std_msgs :: msg :: Header :: from_native (& msg . header) , geo : geographic_msgs :: msg :: GeoPoint :: from_native (& msg . geo) , position : geometry_msgs :: msg :: Point :: from_native (& msg . position) , orientation : geometry_msgs :: msg :: Quaternion :: from_native (& msg . orientation) , approach : geometry_msgs :: msg :: Vector3 :: from_native (& msg . approach) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; self . geo . copy_to_native (& mut msg . geo) ; self . position . copy_to_native (& mut msg . position) ; self . orientation . copy_to_native (& mut msg . orientation) ; self . approach . copy_to_native (& mut msg . approach) ; } } impl Default for HomePosition { fn default () -> Self { let msg_native = WrappedNativeMsg :: < HomePosition > :: new () ; HomePosition :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct LandingTarget { pub header : std_msgs :: msg :: Header , pub target_num : u8 , pub frame : u8 , pub angle : Vec < f32 > , pub distance : f32 , pub size : Vec < f32 > , pub pose : geometry_msgs :: msg :: Pose , # [serde (rename = "type")] pub type_ : u8 } impl WrappedTypesupport for LandingTarget { type CStruct = mavros_msgs__msg__LandingTarget ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__msg__LandingTarget () } } fn create_msg () -> * mut mavros_msgs__msg__LandingTarget { unsafe { mavros_msgs__msg__LandingTarget__create () } } fn destroy_msg (msg : * mut mavros_msgs__msg__LandingTarget) -> () { unsafe { mavros_msgs__msg__LandingTarget__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> LandingTarget { LandingTarget { header : std_msgs :: msg :: Header :: from_native (& msg . header) , target_num : msg . target_num , frame : msg . frame , angle : msg . angle . to_vec () , distance : msg . distance , size : msg . size . to_vec () , pose : geometry_msgs :: msg :: Pose :: from_native (& msg . pose) , type_ : msg . type_ , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . target_num = self . target_num ; msg . frame = self . frame ; assert_eq ! (self . angle . len () , 2usize , "Field {} is fixed size of {}!" , "angle" , 2usize) ; msg . angle . copy_from_slice (& self . angle [.. 2usize]) ; msg . distance = self . distance ; assert_eq ! (self . size . len () , 2usize , "Field {} is fixed size of {}!" , "size" , 2usize) ; msg . size . copy_from_slice (& self . size [.. 2usize]) ; self . pose . copy_to_native (& mut msg . pose) ; msg . type_ = self . type_ ; } } impl Default for LandingTarget { fn default () -> Self { let msg_native = WrappedNativeMsg :: < LandingTarget > :: new () ; LandingTarget :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl LandingTarget { pub const BODY_NED : _bindgen_ty_708 = mavros_msgs__msg__LandingTarget__BODY_NED ; pub const BODY_OFFSET_NED : _bindgen_ty_709 = mavros_msgs__msg__LandingTarget__BODY_OFFSET_NED ; pub const GLOBAL : _bindgen_ty_700 = mavros_msgs__msg__LandingTarget__GLOBAL ; pub const GLOBAL_INT : _bindgen_ty_705 = mavros_msgs__msg__LandingTarget__GLOBAL_INT ; pub const GLOBAL_RELATIVE_ALT : _bindgen_ty_703 = mavros_msgs__msg__LandingTarget__GLOBAL_RELATIVE_ALT ; pub const GLOBAL_RELATIVE_ALT_INT : _bindgen_ty_706 = mavros_msgs__msg__LandingTarget__GLOBAL_RELATIVE_ALT_INT ; pub const GLOBAL_TERRAIN_ALT : _bindgen_ty_710 = mavros_msgs__msg__LandingTarget__GLOBAL_TERRAIN_ALT ; pub const GLOBAL_TERRAIN_ALT_INT : _bindgen_ty_711 = mavros_msgs__msg__LandingTarget__GLOBAL_TERRAIN_ALT_INT ; pub const LIGHT_BEACON : _bindgen_ty_712 = mavros_msgs__msg__LandingTarget__LIGHT_BEACON ; pub const LOCAL_ENU : _bindgen_ty_704 = mavros_msgs__msg__LandingTarget__LOCAL_ENU ; pub const LOCAL_NED : _bindgen_ty_701 = mavros_msgs__msg__LandingTarget__LOCAL_NED ; pub const LOCAL_OFFSET_NED : _bindgen_ty_707 = mavros_msgs__msg__LandingTarget__LOCAL_OFFSET_NED ; pub const MISSION : _bindgen_ty_702 = mavros_msgs__msg__LandingTarget__MISSION ; pub const RADIO_BEACON : _bindgen_ty_713 = mavros_msgs__msg__LandingTarget__RADIO_BEACON ; pub const VISION_FIDUCIAL : _bindgen_ty_714 = mavros_msgs__msg__LandingTarget__VISION_FIDUCIAL ; pub const VISION_OTHER : _bindgen_ty_715 = mavros_msgs__msg__LandingTarget__VISION_OTHER ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct LogData { pub header : std_msgs :: msg :: Header , pub id : u16 , pub offset : u32 , pub data : Vec < u8 > } impl WrappedTypesupport for LogData { type CStruct = mavros_msgs__msg__LogData ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__msg__LogData () } } fn create_msg () -> * mut mavros_msgs__msg__LogData { unsafe { mavros_msgs__msg__LogData__create () } } fn destroy_msg (msg : * mut mavros_msgs__msg__LogData) -> () { unsafe { mavros_msgs__msg__LogData__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> LogData { LogData { header : std_msgs :: msg :: Header :: from_native (& msg . header) , id : msg . id , offset : msg . offset , data : msg . data . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . id = self . id ; msg . offset = self . offset ; msg . data . update (& self . data) ; } } impl Default for LogData { fn default () -> Self { let msg_native = WrappedNativeMsg :: < LogData > :: new () ; LogData :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct LogEntry { pub header : std_msgs :: msg :: Header , pub id : u16 , pub num_logs : u16 , pub last_log_num : u16 , pub time_utc : builtin_interfaces :: msg :: Time , pub size : u32 } impl WrappedTypesupport for LogEntry { type CStruct = mavros_msgs__msg__LogEntry ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__msg__LogEntry () } } fn create_msg () -> * mut mavros_msgs__msg__LogEntry { unsafe { mavros_msgs__msg__LogEntry__create () } } fn destroy_msg (msg : * mut mavros_msgs__msg__LogEntry) -> () { unsafe { mavros_msgs__msg__LogEntry__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> LogEntry { LogEntry { header : std_msgs :: msg :: Header :: from_native (& msg . header) , id : msg . id , num_logs : msg . num_logs , last_log_num : msg . last_log_num , time_utc : builtin_interfaces :: msg :: Time :: from_native (& msg . time_utc) , size : msg . size , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . id = self . id ; msg . num_logs = self . num_logs ; msg . last_log_num = self . last_log_num ; self . time_utc . copy_to_native (& mut msg . time_utc) ; msg . size = self . size ; } } impl Default for LogEntry { fn default () -> Self { let msg_native = WrappedNativeMsg :: < LogEntry > :: new () ; LogEntry :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct MagnetometerReporter { pub header : std_msgs :: msg :: Header , pub report : u8 , pub confidence : f32 } impl WrappedTypesupport for MagnetometerReporter { type CStruct = mavros_msgs__msg__MagnetometerReporter ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__msg__MagnetometerReporter () } } fn create_msg () -> * mut mavros_msgs__msg__MagnetometerReporter { unsafe { mavros_msgs__msg__MagnetometerReporter__create () } } fn destroy_msg (msg : * mut mavros_msgs__msg__MagnetometerReporter) -> () { unsafe { mavros_msgs__msg__MagnetometerReporter__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> MagnetometerReporter { MagnetometerReporter { header : std_msgs :: msg :: Header :: from_native (& msg . header) , report : msg . report , confidence : msg . confidence , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . report = self . report ; msg . confidence = self . confidence ; } } impl Default for MagnetometerReporter { fn default () -> Self { let msg_native = WrappedNativeMsg :: < MagnetometerReporter > :: new () ; MagnetometerReporter :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ManualControl { pub header : std_msgs :: msg :: Header , pub x : f32 , pub y : f32 , pub z : f32 , pub r : f32 , pub buttons : u16 } impl WrappedTypesupport for ManualControl { type CStruct = mavros_msgs__msg__ManualControl ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__msg__ManualControl () } } fn create_msg () -> * mut mavros_msgs__msg__ManualControl { unsafe { mavros_msgs__msg__ManualControl__create () } } fn destroy_msg (msg : * mut mavros_msgs__msg__ManualControl) -> () { unsafe { mavros_msgs__msg__ManualControl__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ManualControl { ManualControl { header : std_msgs :: msg :: Header :: from_native (& msg . header) , x : msg . x , y : msg . y , z : msg . z , r : msg . r , buttons : msg . buttons , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . x = self . x ; msg . y = self . y ; msg . z = self . z ; msg . r = self . r ; msg . buttons = self . buttons ; } } impl Default for ManualControl { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ManualControl > :: new () ; ManualControl :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Mavlink { pub header : std_msgs :: msg :: Header , pub framing_status : u8 , pub magic : u8 , pub len : u8 , pub incompat_flags : u8 , pub compat_flags : u8 , pub seq : u8 , pub sysid : u8 , pub compid : u8 , pub msgid : u32 , pub checksum : u16 , pub payload64 : Vec < u64 > , pub signature : Vec < u8 > } impl WrappedTypesupport for Mavlink { type CStruct = mavros_msgs__msg__Mavlink ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__msg__Mavlink () } } fn create_msg () -> * mut mavros_msgs__msg__Mavlink { unsafe { mavros_msgs__msg__Mavlink__create () } } fn destroy_msg (msg : * mut mavros_msgs__msg__Mavlink) -> () { unsafe { mavros_msgs__msg__Mavlink__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Mavlink { Mavlink { header : std_msgs :: msg :: Header :: from_native (& msg . header) , framing_status : msg . framing_status , magic : msg . magic , len : msg . len , incompat_flags : msg . incompat_flags , compat_flags : msg . compat_flags , seq : msg . seq , sysid : msg . sysid , compid : msg . compid , msgid : msg . msgid , checksum : msg . checksum , payload64 : msg . payload64 . to_vec () , signature : msg . signature . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . framing_status = self . framing_status ; msg . magic = self . magic ; msg . len = self . len ; msg . incompat_flags = self . incompat_flags ; msg . compat_flags = self . compat_flags ; msg . seq = self . seq ; msg . sysid = self . sysid ; msg . compid = self . compid ; msg . msgid = self . msgid ; msg . checksum = self . checksum ; assert ! (self . payload64 . len () <= 33usize , "Field {} is upper bounded by {}!" , "payload64" , 33usize) ; msg . payload64 . update (& self . payload64) ; assert ! (self . signature . len () <= 13usize , "Field {} is upper bounded by {}!" , "signature" , 13usize) ; msg . signature . update (& self . signature) ; } } impl Default for Mavlink { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Mavlink > :: new () ; Mavlink :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl Mavlink { pub const FRAMING_BAD_CRC : _bindgen_ty_717 = mavros_msgs__msg__Mavlink__FRAMING_BAD_CRC ; pub const FRAMING_BAD_SIGNATURE : _bindgen_ty_718 = mavros_msgs__msg__Mavlink__FRAMING_BAD_SIGNATURE ; pub const FRAMING_OK : _bindgen_ty_716 = mavros_msgs__msg__Mavlink__FRAMING_OK ; pub const MAVLINK_V10 : _bindgen_ty_719 = mavros_msgs__msg__Mavlink__MAVLINK_V10 ; pub const MAVLINK_V20 : _bindgen_ty_720 = mavros_msgs__msg__Mavlink__MAVLINK_V20 ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct MountControl { pub header : std_msgs :: msg :: Header , pub mode : u8 , pub pitch : f32 , pub roll : f32 , pub yaw : f32 , pub altitude : f32 , pub latitude : f32 , pub longitude : f32 } impl WrappedTypesupport for MountControl { type CStruct = mavros_msgs__msg__MountControl ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__msg__MountControl () } } fn create_msg () -> * mut mavros_msgs__msg__MountControl { unsafe { mavros_msgs__msg__MountControl__create () } } fn destroy_msg (msg : * mut mavros_msgs__msg__MountControl) -> () { unsafe { mavros_msgs__msg__MountControl__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> MountControl { MountControl { header : std_msgs :: msg :: Header :: from_native (& msg . header) , mode : msg . mode , pitch : msg . pitch , roll : msg . roll , yaw : msg . yaw , altitude : msg . altitude , latitude : msg . latitude , longitude : msg . longitude , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . mode = self . mode ; msg . pitch = self . pitch ; msg . roll = self . roll ; msg . yaw = self . yaw ; msg . altitude = self . altitude ; msg . latitude = self . latitude ; msg . longitude = self . longitude ; } } impl Default for MountControl { fn default () -> Self { let msg_native = WrappedNativeMsg :: < MountControl > :: new () ; MountControl :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl MountControl { pub const MAV_MOUNT_MODE_GPS_POINT : _bindgen_ty_727 = mavros_msgs__msg__MountControl__MAV_MOUNT_MODE_GPS_POINT ; pub const MAV_MOUNT_MODE_MAVLINK_TARGETING : _bindgen_ty_725 = mavros_msgs__msg__MountControl__MAV_MOUNT_MODE_MAVLINK_TARGETING ; pub const MAV_MOUNT_MODE_NEUTRAL : _bindgen_ty_724 = mavros_msgs__msg__MountControl__MAV_MOUNT_MODE_NEUTRAL ; pub const MAV_MOUNT_MODE_RC_TARGETING : _bindgen_ty_726 = mavros_msgs__msg__MountControl__MAV_MOUNT_MODE_RC_TARGETING ; pub const MAV_MOUNT_MODE_RETRACT : _bindgen_ty_723 = mavros_msgs__msg__MountControl__MAV_MOUNT_MODE_RETRACT ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct NavControllerOutput { pub header : std_msgs :: msg :: Header , pub nav_roll : f32 , pub nav_pitch : f32 , pub nav_bearing : i16 , pub target_bearing : i16 , pub wp_dist : u16 , pub alt_error : f32 , pub aspd_error : f32 , pub xtrack_error : f32 } impl WrappedTypesupport for NavControllerOutput { type CStruct = mavros_msgs__msg__NavControllerOutput ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__msg__NavControllerOutput () } } fn create_msg () -> * mut mavros_msgs__msg__NavControllerOutput { unsafe { mavros_msgs__msg__NavControllerOutput__create () } } fn destroy_msg (msg : * mut mavros_msgs__msg__NavControllerOutput) -> () { unsafe { mavros_msgs__msg__NavControllerOutput__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> NavControllerOutput { NavControllerOutput { header : std_msgs :: msg :: Header :: from_native (& msg . header) , nav_roll : msg . nav_roll , nav_pitch : msg . nav_pitch , nav_bearing : msg . nav_bearing , target_bearing : msg . target_bearing , wp_dist : msg . wp_dist , alt_error : msg . alt_error , aspd_error : msg . aspd_error , xtrack_error : msg . xtrack_error , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . nav_roll = self . nav_roll ; msg . nav_pitch = self . nav_pitch ; msg . nav_bearing = self . nav_bearing ; msg . target_bearing = self . target_bearing ; msg . wp_dist = self . wp_dist ; msg . alt_error = self . alt_error ; msg . aspd_error = self . aspd_error ; msg . xtrack_error = self . xtrack_error ; } } impl Default for NavControllerOutput { fn default () -> Self { let msg_native = WrappedNativeMsg :: < NavControllerOutput > :: new () ; NavControllerOutput :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct OnboardComputerStatus { pub header : std_msgs :: msg :: Header , pub component : u8 , pub uptime : u32 , # [serde (rename = "type")] pub type_ : u8 , pub cpu_cores : Vec < u8 > , pub cpu_combined : Vec < u8 > , pub gpu_cores : Vec < u8 > , pub gpu_combined : Vec < u8 > , pub temperature_board : i8 , pub temperature_core : Vec < i8 > , pub fan_speed : Vec < i16 > , pub ram_usage : u32 , pub ram_total : u32 , pub storage_type : Vec < u32 > , pub storage_usage : Vec < u32 > , pub storage_total : Vec < u32 > , pub link_type : Vec < u32 > , pub link_tx_rate : Vec < u32 > , pub link_rx_rate : Vec < u32 > , pub link_tx_max : Vec < u32 > , pub link_rx_max : Vec < u32 > } impl WrappedTypesupport for OnboardComputerStatus { type CStruct = mavros_msgs__msg__OnboardComputerStatus ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__msg__OnboardComputerStatus () } } fn create_msg () -> * mut mavros_msgs__msg__OnboardComputerStatus { unsafe { mavros_msgs__msg__OnboardComputerStatus__create () } } fn destroy_msg (msg : * mut mavros_msgs__msg__OnboardComputerStatus) -> () { unsafe { mavros_msgs__msg__OnboardComputerStatus__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> OnboardComputerStatus { OnboardComputerStatus { header : std_msgs :: msg :: Header :: from_native (& msg . header) , component : msg . component , uptime : msg . uptime , type_ : msg . type_ , cpu_cores : msg . cpu_cores . to_vec () , cpu_combined : msg . cpu_combined . to_vec () , gpu_cores : msg . gpu_cores . to_vec () , gpu_combined : msg . gpu_combined . to_vec () , temperature_board : msg . temperature_board , temperature_core : msg . temperature_core . to_vec () , fan_speed : msg . fan_speed . to_vec () , ram_usage : msg . ram_usage , ram_total : msg . ram_total , storage_type : msg . storage_type . to_vec () , storage_usage : msg . storage_usage . to_vec () , storage_total : msg . storage_total . to_vec () , link_type : msg . link_type . to_vec () , link_tx_rate : msg . link_tx_rate . to_vec () , link_rx_rate : msg . link_rx_rate . to_vec () , link_tx_max : msg . link_tx_max . to_vec () , link_rx_max : msg . link_rx_max . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . component = self . component ; msg . uptime = self . uptime ; msg . type_ = self . type_ ; assert_eq ! (self . cpu_cores . len () , 8usize , "Field {} is fixed size of {}!" , "cpu_cores" , 8usize) ; msg . cpu_cores . copy_from_slice (& self . cpu_cores [.. 8usize]) ; assert_eq ! (self . cpu_combined . len () , 10usize , "Field {} is fixed size of {}!" , "cpu_combined" , 10usize) ; msg . cpu_combined . copy_from_slice (& self . cpu_combined [.. 10usize]) ; assert_eq ! (self . gpu_cores . len () , 4usize , "Field {} is fixed size of {}!" , "gpu_cores" , 4usize) ; msg . gpu_cores . copy_from_slice (& self . gpu_cores [.. 4usize]) ; assert_eq ! (self . gpu_combined . len () , 10usize , "Field {} is fixed size of {}!" , "gpu_combined" , 10usize) ; msg . gpu_combined . copy_from_slice (& self . gpu_combined [.. 10usize]) ; msg . temperature_board = self . temperature_board ; assert_eq ! (self . temperature_core . len () , 8usize , "Field {} is fixed size of {}!" , "temperature_core" , 8usize) ; msg . temperature_core . copy_from_slice (& self . temperature_core [.. 8usize]) ; assert_eq ! (self . fan_speed . len () , 4usize , "Field {} is fixed size of {}!" , "fan_speed" , 4usize) ; msg . fan_speed . copy_from_slice (& self . fan_speed [.. 4usize]) ; msg . ram_usage = self . ram_usage ; msg . ram_total = self . ram_total ; assert_eq ! (self . storage_type . len () , 4usize , "Field {} is fixed size of {}!" , "storage_type" , 4usize) ; msg . storage_type . copy_from_slice (& self . storage_type [.. 4usize]) ; assert_eq ! (self . storage_usage . len () , 4usize , "Field {} is fixed size of {}!" , "storage_usage" , 4usize) ; msg . storage_usage . copy_from_slice (& self . storage_usage [.. 4usize]) ; assert_eq ! (self . storage_total . len () , 4usize , "Field {} is fixed size of {}!" , "storage_total" , 4usize) ; msg . storage_total . copy_from_slice (& self . storage_total [.. 4usize]) ; assert_eq ! (self . link_type . len () , 6usize , "Field {} is fixed size of {}!" , "link_type" , 6usize) ; msg . link_type . copy_from_slice (& self . link_type [.. 6usize]) ; assert_eq ! (self . link_tx_rate . len () , 6usize , "Field {} is fixed size of {}!" , "link_tx_rate" , 6usize) ; msg . link_tx_rate . copy_from_slice (& self . link_tx_rate [.. 6usize]) ; assert_eq ! (self . link_rx_rate . len () , 6usize , "Field {} is fixed size of {}!" , "link_rx_rate" , 6usize) ; msg . link_rx_rate . copy_from_slice (& self . link_rx_rate [.. 6usize]) ; assert_eq ! (self . link_tx_max . len () , 6usize , "Field {} is fixed size of {}!" , "link_tx_max" , 6usize) ; msg . link_tx_max . copy_from_slice (& self . link_tx_max [.. 6usize]) ; assert_eq ! (self . link_rx_max . len () , 6usize , "Field {} is fixed size of {}!" , "link_rx_max" , 6usize) ; msg . link_rx_max . copy_from_slice (& self . link_rx_max [.. 6usize]) ; } } impl Default for OnboardComputerStatus { fn default () -> Self { let msg_native = WrappedNativeMsg :: < OnboardComputerStatus > :: new () ; OnboardComputerStatus :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct OpticalFlowRad { pub header : std_msgs :: msg :: Header , pub integration_time_us : u32 , pub integrated_x : f32 , pub integrated_y : f32 , pub integrated_xgyro : f32 , pub integrated_ygyro : f32 , pub integrated_zgyro : f32 , pub temperature : i16 , pub quality : u8 , pub time_delta_distance_us : u32 , pub distance : f32 } impl WrappedTypesupport for OpticalFlowRad { type CStruct = mavros_msgs__msg__OpticalFlowRad ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__msg__OpticalFlowRad () } } fn create_msg () -> * mut mavros_msgs__msg__OpticalFlowRad { unsafe { mavros_msgs__msg__OpticalFlowRad__create () } } fn destroy_msg (msg : * mut mavros_msgs__msg__OpticalFlowRad) -> () { unsafe { mavros_msgs__msg__OpticalFlowRad__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> OpticalFlowRad { OpticalFlowRad { header : std_msgs :: msg :: Header :: from_native (& msg . header) , integration_time_us : msg . integration_time_us , integrated_x : msg . integrated_x , integrated_y : msg . integrated_y , integrated_xgyro : msg . integrated_xgyro , integrated_ygyro : msg . integrated_ygyro , integrated_zgyro : msg . integrated_zgyro , temperature : msg . temperature , quality : msg . quality , time_delta_distance_us : msg . time_delta_distance_us , distance : msg . distance , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . integration_time_us = self . integration_time_us ; msg . integrated_x = self . integrated_x ; msg . integrated_y = self . integrated_y ; msg . integrated_xgyro = self . integrated_xgyro ; msg . integrated_ygyro = self . integrated_ygyro ; msg . integrated_zgyro = self . integrated_zgyro ; msg . temperature = self . temperature ; msg . quality = self . quality ; msg . time_delta_distance_us = self . time_delta_distance_us ; msg . distance = self . distance ; } } impl Default for OpticalFlowRad { fn default () -> Self { let msg_native = WrappedNativeMsg :: < OpticalFlowRad > :: new () ; OpticalFlowRad :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct OverrideRCIn { pub channels : Vec < u16 > } impl WrappedTypesupport for OverrideRCIn { type CStruct = mavros_msgs__msg__OverrideRCIn ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__msg__OverrideRCIn () } } fn create_msg () -> * mut mavros_msgs__msg__OverrideRCIn { unsafe { mavros_msgs__msg__OverrideRCIn__create () } } fn destroy_msg (msg : * mut mavros_msgs__msg__OverrideRCIn) -> () { unsafe { mavros_msgs__msg__OverrideRCIn__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> OverrideRCIn { OverrideRCIn { channels : msg . channels . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { assert_eq ! (self . channels . len () , 18usize , "Field {} is fixed size of {}!" , "channels" , 18usize) ; msg . channels . copy_from_slice (& self . channels [.. 18usize]) ; } } impl Default for OverrideRCIn { fn default () -> Self { let msg_native = WrappedNativeMsg :: < OverrideRCIn > :: new () ; OverrideRCIn :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl OverrideRCIn { pub const CHAN_NOCHANGE : _bindgen_ty_729 = mavros_msgs__msg__OverrideRCIn__CHAN_NOCHANGE ; pub const CHAN_RELEASE : _bindgen_ty_728 = mavros_msgs__msg__OverrideRCIn__CHAN_RELEASE ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Param { pub header : std_msgs :: msg :: Header , pub param_id : std :: string :: String , pub value : mavros_msgs :: msg :: ParamValue , pub param_index : u16 , pub param_count : u16 } impl WrappedTypesupport for Param { type CStruct = mavros_msgs__msg__Param ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__msg__Param () } } fn create_msg () -> * mut mavros_msgs__msg__Param { unsafe { mavros_msgs__msg__Param__create () } } fn destroy_msg (msg : * mut mavros_msgs__msg__Param) -> () { unsafe { mavros_msgs__msg__Param__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Param { Param { header : std_msgs :: msg :: Header :: from_native (& msg . header) , param_id : msg . param_id . to_str () . to_owned () , value : mavros_msgs :: msg :: ParamValue :: from_native (& msg . value) , param_index : msg . param_index , param_count : msg . param_count , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . param_id . assign (& self . param_id) ; self . value . copy_to_native (& mut msg . value) ; msg . param_index = self . param_index ; msg . param_count = self . param_count ; } } impl Default for Param { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Param > :: new () ; Param :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ParamEvent { pub header : std_msgs :: msg :: Header , pub param_id : std :: string :: String , pub value : rcl_interfaces :: msg :: ParameterValue , pub param_index : u16 , pub param_count : u16 } impl WrappedTypesupport for ParamEvent { type CStruct = mavros_msgs__msg__ParamEvent ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__msg__ParamEvent () } } fn create_msg () -> * mut mavros_msgs__msg__ParamEvent { unsafe { mavros_msgs__msg__ParamEvent__create () } } fn destroy_msg (msg : * mut mavros_msgs__msg__ParamEvent) -> () { unsafe { mavros_msgs__msg__ParamEvent__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ParamEvent { ParamEvent { header : std_msgs :: msg :: Header :: from_native (& msg . header) , param_id : msg . param_id . to_str () . to_owned () , value : rcl_interfaces :: msg :: ParameterValue :: from_native (& msg . value) , param_index : msg . param_index , param_count : msg . param_count , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . param_id . assign (& self . param_id) ; self . value . copy_to_native (& mut msg . value) ; msg . param_index = self . param_index ; msg . param_count = self . param_count ; } } impl Default for ParamEvent { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ParamEvent > :: new () ; ParamEvent :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ParamValue { pub integer : i64 , pub real : f64 } impl WrappedTypesupport for ParamValue { type CStruct = mavros_msgs__msg__ParamValue ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__msg__ParamValue () } } fn create_msg () -> * mut mavros_msgs__msg__ParamValue { unsafe { mavros_msgs__msg__ParamValue__create () } } fn destroy_msg (msg : * mut mavros_msgs__msg__ParamValue) -> () { unsafe { mavros_msgs__msg__ParamValue__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ParamValue { ParamValue { integer : msg . integer , real : msg . real , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . integer = self . integer ; msg . real = self . real ; } } impl Default for ParamValue { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ParamValue > :: new () ; ParamValue :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct PlayTuneV2 { pub format : u8 , pub tune : std :: string :: String } impl WrappedTypesupport for PlayTuneV2 { type CStruct = mavros_msgs__msg__PlayTuneV2 ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__msg__PlayTuneV2 () } } fn create_msg () -> * mut mavros_msgs__msg__PlayTuneV2 { unsafe { mavros_msgs__msg__PlayTuneV2__create () } } fn destroy_msg (msg : * mut mavros_msgs__msg__PlayTuneV2) -> () { unsafe { mavros_msgs__msg__PlayTuneV2__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> PlayTuneV2 { PlayTuneV2 { format : msg . format , tune : msg . tune . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . format = self . format ; msg . tune . assign (& self . tune) ; } } impl Default for PlayTuneV2 { fn default () -> Self { let msg_native = WrappedNativeMsg :: < PlayTuneV2 > :: new () ; PlayTuneV2 :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl PlayTuneV2 { pub const MML_MODERN : _bindgen_ty_731 = mavros_msgs__msg__PlayTuneV2__MML_MODERN ; pub const QBASIC1_1 : _bindgen_ty_730 = mavros_msgs__msg__PlayTuneV2__QBASIC1_1 ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct PositionTarget { pub header : std_msgs :: msg :: Header , pub coordinate_frame : u8 , pub type_mask : u16 , pub position : geometry_msgs :: msg :: Point , pub velocity : geometry_msgs :: msg :: Vector3 , pub acceleration_or_force : geometry_msgs :: msg :: Vector3 , pub yaw : f32 , pub yaw_rate : f32 } impl WrappedTypesupport for PositionTarget { type CStruct = mavros_msgs__msg__PositionTarget ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__msg__PositionTarget () } } fn create_msg () -> * mut mavros_msgs__msg__PositionTarget { unsafe { mavros_msgs__msg__PositionTarget__create () } } fn destroy_msg (msg : * mut mavros_msgs__msg__PositionTarget) -> () { unsafe { mavros_msgs__msg__PositionTarget__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> PositionTarget { PositionTarget { header : std_msgs :: msg :: Header :: from_native (& msg . header) , coordinate_frame : msg . coordinate_frame , type_mask : msg . type_mask , position : geometry_msgs :: msg :: Point :: from_native (& msg . position) , velocity : geometry_msgs :: msg :: Vector3 :: from_native (& msg . velocity) , acceleration_or_force : geometry_msgs :: msg :: Vector3 :: from_native (& msg . acceleration_or_force) , yaw : msg . yaw , yaw_rate : msg . yaw_rate , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . coordinate_frame = self . coordinate_frame ; msg . type_mask = self . type_mask ; self . position . copy_to_native (& mut msg . position) ; self . velocity . copy_to_native (& mut msg . velocity) ; self . acceleration_or_force . copy_to_native (& mut msg . acceleration_or_force) ; msg . yaw = self . yaw ; msg . yaw_rate = self . yaw_rate ; } } impl Default for PositionTarget { fn default () -> Self { let msg_native = WrappedNativeMsg :: < PositionTarget > :: new () ; PositionTarget :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl PositionTarget { pub const FORCE : _bindgen_ty_745 = mavros_msgs__msg__PositionTarget__FORCE ; pub const FRAME_BODY_NED : _bindgen_ty_734 = mavros_msgs__msg__PositionTarget__FRAME_BODY_NED ; pub const FRAME_BODY_OFFSET_NED : _bindgen_ty_735 = mavros_msgs__msg__PositionTarget__FRAME_BODY_OFFSET_NED ; pub const FRAME_LOCAL_NED : _bindgen_ty_732 = mavros_msgs__msg__PositionTarget__FRAME_LOCAL_NED ; pub const FRAME_LOCAL_OFFSET_NED : _bindgen_ty_733 = mavros_msgs__msg__PositionTarget__FRAME_LOCAL_OFFSET_NED ; pub const IGNORE_AFX : _bindgen_ty_742 = mavros_msgs__msg__PositionTarget__IGNORE_AFX ; pub const IGNORE_AFY : _bindgen_ty_743 = mavros_msgs__msg__PositionTarget__IGNORE_AFY ; pub const IGNORE_AFZ : _bindgen_ty_744 = mavros_msgs__msg__PositionTarget__IGNORE_AFZ ; pub const IGNORE_PX : _bindgen_ty_736 = mavros_msgs__msg__PositionTarget__IGNORE_PX ; pub const IGNORE_PY : _bindgen_ty_737 = mavros_msgs__msg__PositionTarget__IGNORE_PY ; pub const IGNORE_PZ : _bindgen_ty_738 = mavros_msgs__msg__PositionTarget__IGNORE_PZ ; pub const IGNORE_VX : _bindgen_ty_739 = mavros_msgs__msg__PositionTarget__IGNORE_VX ; pub const IGNORE_VY : _bindgen_ty_740 = mavros_msgs__msg__PositionTarget__IGNORE_VY ; pub const IGNORE_VZ : _bindgen_ty_741 = mavros_msgs__msg__PositionTarget__IGNORE_VZ ; pub const IGNORE_YAW : _bindgen_ty_746 = mavros_msgs__msg__PositionTarget__IGNORE_YAW ; pub const IGNORE_YAW_RATE : _bindgen_ty_747 = mavros_msgs__msg__PositionTarget__IGNORE_YAW_RATE ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct RCIn { pub header : std_msgs :: msg :: Header , pub rssi : u8 , pub channels : Vec < u16 > } impl WrappedTypesupport for RCIn { type CStruct = mavros_msgs__msg__RCIn ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__msg__RCIn () } } fn create_msg () -> * mut mavros_msgs__msg__RCIn { unsafe { mavros_msgs__msg__RCIn__create () } } fn destroy_msg (msg : * mut mavros_msgs__msg__RCIn) -> () { unsafe { mavros_msgs__msg__RCIn__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> RCIn { RCIn { header : std_msgs :: msg :: Header :: from_native (& msg . header) , rssi : msg . rssi , channels : msg . channels . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . rssi = self . rssi ; msg . channels . update (& self . channels) ; } } impl Default for RCIn { fn default () -> Self { let msg_native = WrappedNativeMsg :: < RCIn > :: new () ; RCIn :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct RCOut { pub header : std_msgs :: msg :: Header , pub channels : Vec < u16 > } impl WrappedTypesupport for RCOut { type CStruct = mavros_msgs__msg__RCOut ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__msg__RCOut () } } fn create_msg () -> * mut mavros_msgs__msg__RCOut { unsafe { mavros_msgs__msg__RCOut__create () } } fn destroy_msg (msg : * mut mavros_msgs__msg__RCOut) -> () { unsafe { mavros_msgs__msg__RCOut__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> RCOut { RCOut { header : std_msgs :: msg :: Header :: from_native (& msg . header) , channels : msg . channels . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . channels . update (& self . channels) ; } } impl Default for RCOut { fn default () -> Self { let msg_native = WrappedNativeMsg :: < RCOut > :: new () ; RCOut :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct RTCM { pub header : std_msgs :: msg :: Header , pub data : Vec < u8 > } impl WrappedTypesupport for RTCM { type CStruct = mavros_msgs__msg__RTCM ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__msg__RTCM () } } fn create_msg () -> * mut mavros_msgs__msg__RTCM { unsafe { mavros_msgs__msg__RTCM__create () } } fn destroy_msg (msg : * mut mavros_msgs__msg__RTCM) -> () { unsafe { mavros_msgs__msg__RTCM__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> RTCM { RTCM { header : std_msgs :: msg :: Header :: from_native (& msg . header) , data : msg . data . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . data . update (& self . data) ; } } impl Default for RTCM { fn default () -> Self { let msg_native = WrappedNativeMsg :: < RTCM > :: new () ; RTCM :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct RTKBaseline { pub header : std_msgs :: msg :: Header , pub time_last_baseline_ms : u32 , pub rtk_receiver_id : u8 , pub wn : u16 , pub tow : u32 , pub rtk_health : u8 , pub rtk_rate : u8 , pub nsats : u8 , pub baseline_coords_type : u8 , pub baseline_a_mm : i32 , pub baseline_b_mm : i32 , pub baseline_c_mm : i32 , pub accuracy : u32 , pub iar_num_hypotheses : i32 } impl WrappedTypesupport for RTKBaseline { type CStruct = mavros_msgs__msg__RTKBaseline ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__msg__RTKBaseline () } } fn create_msg () -> * mut mavros_msgs__msg__RTKBaseline { unsafe { mavros_msgs__msg__RTKBaseline__create () } } fn destroy_msg (msg : * mut mavros_msgs__msg__RTKBaseline) -> () { unsafe { mavros_msgs__msg__RTKBaseline__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> RTKBaseline { RTKBaseline { header : std_msgs :: msg :: Header :: from_native (& msg . header) , time_last_baseline_ms : msg . time_last_baseline_ms , rtk_receiver_id : msg . rtk_receiver_id , wn : msg . wn , tow : msg . tow , rtk_health : msg . rtk_health , rtk_rate : msg . rtk_rate , nsats : msg . nsats , baseline_coords_type : msg . baseline_coords_type , baseline_a_mm : msg . baseline_a_mm , baseline_b_mm : msg . baseline_b_mm , baseline_c_mm : msg . baseline_c_mm , accuracy : msg . accuracy , iar_num_hypotheses : msg . iar_num_hypotheses , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . time_last_baseline_ms = self . time_last_baseline_ms ; msg . rtk_receiver_id = self . rtk_receiver_id ; msg . wn = self . wn ; msg . tow = self . tow ; msg . rtk_health = self . rtk_health ; msg . rtk_rate = self . rtk_rate ; msg . nsats = self . nsats ; msg . baseline_coords_type = self . baseline_coords_type ; msg . baseline_a_mm = self . baseline_a_mm ; msg . baseline_b_mm = self . baseline_b_mm ; msg . baseline_c_mm = self . baseline_c_mm ; msg . accuracy = self . accuracy ; msg . iar_num_hypotheses = self . iar_num_hypotheses ; } } impl Default for RTKBaseline { fn default () -> Self { let msg_native = WrappedNativeMsg :: < RTKBaseline > :: new () ; RTKBaseline :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl RTKBaseline { pub const RTK_BASELINE_COORDINATE_SYSTEM_ECEF : _bindgen_ty_748 = mavros_msgs__msg__RTKBaseline__RTK_BASELINE_COORDINATE_SYSTEM_ECEF ; pub const RTK_BASELINE_COORDINATE_SYSTEM_NED : _bindgen_ty_749 = mavros_msgs__msg__RTKBaseline__RTK_BASELINE_COORDINATE_SYSTEM_NED ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct RadioStatus { pub header : std_msgs :: msg :: Header , pub rssi : u8 , pub remrssi : u8 , pub txbuf : u8 , pub noise : u8 , pub remnoise : u8 , pub rxerrors : u16 , pub fixed : u16 , pub rssi_dbm : f32 , pub remrssi_dbm : f32 } impl WrappedTypesupport for RadioStatus { type CStruct = mavros_msgs__msg__RadioStatus ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__msg__RadioStatus () } } fn create_msg () -> * mut mavros_msgs__msg__RadioStatus { unsafe { mavros_msgs__msg__RadioStatus__create () } } fn destroy_msg (msg : * mut mavros_msgs__msg__RadioStatus) -> () { unsafe { mavros_msgs__msg__RadioStatus__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> RadioStatus { RadioStatus { header : std_msgs :: msg :: Header :: from_native (& msg . header) , rssi : msg . rssi , remrssi : msg . remrssi , txbuf : msg . txbuf , noise : msg . noise , remnoise : msg . remnoise , rxerrors : msg . rxerrors , fixed : msg . fixed , rssi_dbm : msg . rssi_dbm , remrssi_dbm : msg . remrssi_dbm , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . rssi = self . rssi ; msg . remrssi = self . remrssi ; msg . txbuf = self . txbuf ; msg . noise = self . noise ; msg . remnoise = self . remnoise ; msg . rxerrors = self . rxerrors ; msg . fixed = self . fixed ; msg . rssi_dbm = self . rssi_dbm ; msg . remrssi_dbm = self . remrssi_dbm ; } } impl Default for RadioStatus { fn default () -> Self { let msg_native = WrappedNativeMsg :: < RadioStatus > :: new () ; RadioStatus :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct State { pub header : std_msgs :: msg :: Header , pub connected : bool , pub armed : bool , pub guided : bool , pub manual_input : bool , pub mode : std :: string :: String , pub system_status : u8 } impl WrappedTypesupport for State { type CStruct = mavros_msgs__msg__State ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__msg__State () } } fn create_msg () -> * mut mavros_msgs__msg__State { unsafe { mavros_msgs__msg__State__create () } } fn destroy_msg (msg : * mut mavros_msgs__msg__State) -> () { unsafe { mavros_msgs__msg__State__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> State { State { header : std_msgs :: msg :: Header :: from_native (& msg . header) , connected : msg . connected , armed : msg . armed , guided : msg . guided , manual_input : msg . manual_input , mode : msg . mode . to_str () . to_owned () , system_status : msg . system_status , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . connected = self . connected ; msg . armed = self . armed ; msg . guided = self . guided ; msg . manual_input = self . manual_input ; msg . mode . assign (& self . mode) ; msg . system_status = self . system_status ; } } impl Default for State { fn default () -> Self { let msg_native = WrappedNativeMsg :: < State > :: new () ; State :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl State { pub const MODE_APM_COPTER_ACRO : & [u8 ; 5usize] = mavros_msgs__msg__State__MODE_APM_COPTER_ACRO ; pub const MODE_APM_COPTER_ALT_HOLD : & [u8 ; 9usize] = mavros_msgs__msg__State__MODE_APM_COPTER_ALT_HOLD ; pub const MODE_APM_COPTER_AUTO : & [u8 ; 5usize] = mavros_msgs__msg__State__MODE_APM_COPTER_AUTO ; pub const MODE_APM_COPTER_AUTOTUNE : & [u8 ; 9usize] = mavros_msgs__msg__State__MODE_APM_COPTER_AUTOTUNE ; pub const MODE_APM_COPTER_AVOID_ADSB : & [u8 ; 11usize] = mavros_msgs__msg__State__MODE_APM_COPTER_AVOID_ADSB ; pub const MODE_APM_COPTER_BRAKE : & [u8 ; 6usize] = mavros_msgs__msg__State__MODE_APM_COPTER_BRAKE ; pub const MODE_APM_COPTER_CIRCLE : & [u8 ; 7usize] = mavros_msgs__msg__State__MODE_APM_COPTER_CIRCLE ; pub const MODE_APM_COPTER_DRIFT : & [u8 ; 6usize] = mavros_msgs__msg__State__MODE_APM_COPTER_DRIFT ; pub const MODE_APM_COPTER_FLIP : & [u8 ; 5usize] = mavros_msgs__msg__State__MODE_APM_COPTER_FLIP ; pub const MODE_APM_COPTER_GUIDED : & [u8 ; 7usize] = mavros_msgs__msg__State__MODE_APM_COPTER_GUIDED ; pub const MODE_APM_COPTER_GUIDED_NOGPS : & [u8 ; 13usize] = mavros_msgs__msg__State__MODE_APM_COPTER_GUIDED_NOGPS ; pub const MODE_APM_COPTER_LAND : & [u8 ; 5usize] = mavros_msgs__msg__State__MODE_APM_COPTER_LAND ; pub const MODE_APM_COPTER_LOITER : & [u8 ; 7usize] = mavros_msgs__msg__State__MODE_APM_COPTER_LOITER ; pub const MODE_APM_COPTER_OF_LOITER : & [u8 ; 10usize] = mavros_msgs__msg__State__MODE_APM_COPTER_OF_LOITER ; pub const MODE_APM_COPTER_POSHOLD : & [u8 ; 8usize] = mavros_msgs__msg__State__MODE_APM_COPTER_POSHOLD ; pub const MODE_APM_COPTER_POSITION : & [u8 ; 9usize] = mavros_msgs__msg__State__MODE_APM_COPTER_POSITION ; pub const MODE_APM_COPTER_RTL : & [u8 ; 4usize] = mavros_msgs__msg__State__MODE_APM_COPTER_RTL ; pub const MODE_APM_COPTER_SPORT : & [u8 ; 6usize] = mavros_msgs__msg__State__MODE_APM_COPTER_SPORT ; pub const MODE_APM_COPTER_STABILIZE : & [u8 ; 10usize] = mavros_msgs__msg__State__MODE_APM_COPTER_STABILIZE ; pub const MODE_APM_COPTER_THROW : & [u8 ; 6usize] = mavros_msgs__msg__State__MODE_APM_COPTER_THROW ; pub const MODE_APM_PLANE_ACRO : & [u8 ; 5usize] = mavros_msgs__msg__State__MODE_APM_PLANE_ACRO ; pub const MODE_APM_PLANE_AUTO : & [u8 ; 5usize] = mavros_msgs__msg__State__MODE_APM_PLANE_AUTO ; pub const MODE_APM_PLANE_AUTOTUNE : & [u8 ; 9usize] = mavros_msgs__msg__State__MODE_APM_PLANE_AUTOTUNE ; pub const MODE_APM_PLANE_CIRCLE : & [u8 ; 7usize] = mavros_msgs__msg__State__MODE_APM_PLANE_CIRCLE ; pub const MODE_APM_PLANE_CRUISE : & [u8 ; 7usize] = mavros_msgs__msg__State__MODE_APM_PLANE_CRUISE ; pub const MODE_APM_PLANE_FBWA : & [u8 ; 5usize] = mavros_msgs__msg__State__MODE_APM_PLANE_FBWA ; pub const MODE_APM_PLANE_FBWB : & [u8 ; 5usize] = mavros_msgs__msg__State__MODE_APM_PLANE_FBWB ; pub const MODE_APM_PLANE_GUIDED : & [u8 ; 7usize] = mavros_msgs__msg__State__MODE_APM_PLANE_GUIDED ; pub const MODE_APM_PLANE_INITIALISING : & [u8 ; 13usize] = mavros_msgs__msg__State__MODE_APM_PLANE_INITIALISING ; pub const MODE_APM_PLANE_LAND : & [u8 ; 5usize] = mavros_msgs__msg__State__MODE_APM_PLANE_LAND ; pub const MODE_APM_PLANE_LOITER : & [u8 ; 7usize] = mavros_msgs__msg__State__MODE_APM_PLANE_LOITER ; pub const MODE_APM_PLANE_MANUAL : & [u8 ; 7usize] = mavros_msgs__msg__State__MODE_APM_PLANE_MANUAL ; pub const MODE_APM_PLANE_QHOVER : & [u8 ; 7usize] = mavros_msgs__msg__State__MODE_APM_PLANE_QHOVER ; pub const MODE_APM_PLANE_QLAND : & [u8 ; 6usize] = mavros_msgs__msg__State__MODE_APM_PLANE_QLAND ; pub const MODE_APM_PLANE_QLOITER : & [u8 ; 8usize] = mavros_msgs__msg__State__MODE_APM_PLANE_QLOITER ; pub const MODE_APM_PLANE_QRTL : & [u8 ; 5usize] = mavros_msgs__msg__State__MODE_APM_PLANE_QRTL ; pub const MODE_APM_PLANE_QSTABILIZE : & [u8 ; 11usize] = mavros_msgs__msg__State__MODE_APM_PLANE_QSTABILIZE ; pub const MODE_APM_PLANE_RTL : & [u8 ; 4usize] = mavros_msgs__msg__State__MODE_APM_PLANE_RTL ; pub const MODE_APM_PLANE_STABILIZE : & [u8 ; 10usize] = mavros_msgs__msg__State__MODE_APM_PLANE_STABILIZE ; pub const MODE_APM_PLANE_TRAINING : & [u8 ; 9usize] = mavros_msgs__msg__State__MODE_APM_PLANE_TRAINING ; pub const MODE_APM_ROVER_AUTO : & [u8 ; 5usize] = mavros_msgs__msg__State__MODE_APM_ROVER_AUTO ; pub const MODE_APM_ROVER_GUIDED : & [u8 ; 7usize] = mavros_msgs__msg__State__MODE_APM_ROVER_GUIDED ; pub const MODE_APM_ROVER_HOLD : & [u8 ; 5usize] = mavros_msgs__msg__State__MODE_APM_ROVER_HOLD ; pub const MODE_APM_ROVER_INITIALISING : & [u8 ; 13usize] = mavros_msgs__msg__State__MODE_APM_ROVER_INITIALISING ; pub const MODE_APM_ROVER_LEARNING : & [u8 ; 9usize] = mavros_msgs__msg__State__MODE_APM_ROVER_LEARNING ; pub const MODE_APM_ROVER_MANUAL : & [u8 ; 7usize] = mavros_msgs__msg__State__MODE_APM_ROVER_MANUAL ; pub const MODE_APM_ROVER_RTL : & [u8 ; 4usize] = mavros_msgs__msg__State__MODE_APM_ROVER_RTL ; pub const MODE_APM_ROVER_STEERING : & [u8 ; 9usize] = mavros_msgs__msg__State__MODE_APM_ROVER_STEERING ; pub const MODE_PX4_ACRO : & [u8 ; 5usize] = mavros_msgs__msg__State__MODE_PX4_ACRO ; pub const MODE_PX4_ALTITUDE : & [u8 ; 7usize] = mavros_msgs__msg__State__MODE_PX4_ALTITUDE ; pub const MODE_PX4_LAND : & [u8 ; 10usize] = mavros_msgs__msg__State__MODE_PX4_LAND ; pub const MODE_PX4_LOITER : & [u8 ; 12usize] = mavros_msgs__msg__State__MODE_PX4_LOITER ; pub const MODE_PX4_MANUAL : & [u8 ; 7usize] = mavros_msgs__msg__State__MODE_PX4_MANUAL ; pub const MODE_PX4_MISSION : & [u8 ; 13usize] = mavros_msgs__msg__State__MODE_PX4_MISSION ; pub const MODE_PX4_OFFBOARD : & [u8 ; 9usize] = mavros_msgs__msg__State__MODE_PX4_OFFBOARD ; pub const MODE_PX4_POSITION : & [u8 ; 7usize] = mavros_msgs__msg__State__MODE_PX4_POSITION ; pub const MODE_PX4_RATTITUDE : & [u8 ; 10usize] = mavros_msgs__msg__State__MODE_PX4_RATTITUDE ; pub const MODE_PX4_READY : & [u8 ; 11usize] = mavros_msgs__msg__State__MODE_PX4_READY ; pub const MODE_PX4_RTGS : & [u8 ; 10usize] = mavros_msgs__msg__State__MODE_PX4_RTGS ; pub const MODE_PX4_RTL : & [u8 ; 9usize] = mavros_msgs__msg__State__MODE_PX4_RTL ; pub const MODE_PX4_STABILIZED : & [u8 ; 11usize] = mavros_msgs__msg__State__MODE_PX4_STABILIZED ; pub const MODE_PX4_TAKEOFF : & [u8 ; 13usize] = mavros_msgs__msg__State__MODE_PX4_TAKEOFF ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct StatusText { pub header : std_msgs :: msg :: Header , pub severity : u8 , pub text : std :: string :: String } impl WrappedTypesupport for StatusText { type CStruct = mavros_msgs__msg__StatusText ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__msg__StatusText () } } fn create_msg () -> * mut mavros_msgs__msg__StatusText { unsafe { mavros_msgs__msg__StatusText__create () } } fn destroy_msg (msg : * mut mavros_msgs__msg__StatusText) -> () { unsafe { mavros_msgs__msg__StatusText__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> StatusText { StatusText { header : std_msgs :: msg :: Header :: from_native (& msg . header) , severity : msg . severity , text : msg . text . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . severity = self . severity ; msg . text . assign (& self . text) ; } } impl Default for StatusText { fn default () -> Self { let msg_native = WrappedNativeMsg :: < StatusText > :: new () ; StatusText :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl StatusText { pub const ALERT : _bindgen_ty_751 = mavros_msgs__msg__StatusText__ALERT ; pub const CRITICAL : _bindgen_ty_752 = mavros_msgs__msg__StatusText__CRITICAL ; pub const DEBUG : _bindgen_ty_757 = mavros_msgs__msg__StatusText__DEBUG ; pub const EMERGENCY : _bindgen_ty_750 = mavros_msgs__msg__StatusText__EMERGENCY ; pub const ERROR : _bindgen_ty_753 = mavros_msgs__msg__StatusText__ERROR ; pub const INFO : _bindgen_ty_756 = mavros_msgs__msg__StatusText__INFO ; pub const NOTICE : _bindgen_ty_755 = mavros_msgs__msg__StatusText__NOTICE ; pub const WARNING : _bindgen_ty_754 = mavros_msgs__msg__StatusText__WARNING ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct TerrainReport { pub header : std_msgs :: msg :: Header , pub latitude : f64 , pub longitude : f64 , pub spacing : u16 , pub terrain_height : f32 , pub current_height : f32 , pub pending : u16 , pub loaded : u16 } impl WrappedTypesupport for TerrainReport { type CStruct = mavros_msgs__msg__TerrainReport ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__msg__TerrainReport () } } fn create_msg () -> * mut mavros_msgs__msg__TerrainReport { unsafe { mavros_msgs__msg__TerrainReport__create () } } fn destroy_msg (msg : * mut mavros_msgs__msg__TerrainReport) -> () { unsafe { mavros_msgs__msg__TerrainReport__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> TerrainReport { TerrainReport { header : std_msgs :: msg :: Header :: from_native (& msg . header) , latitude : msg . latitude , longitude : msg . longitude , spacing : msg . spacing , terrain_height : msg . terrain_height , current_height : msg . current_height , pending : msg . pending , loaded : msg . loaded , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . latitude = self . latitude ; msg . longitude = self . longitude ; msg . spacing = self . spacing ; msg . terrain_height = self . terrain_height ; msg . current_height = self . current_height ; msg . pending = self . pending ; msg . loaded = self . loaded ; } } impl Default for TerrainReport { fn default () -> Self { let msg_native = WrappedNativeMsg :: < TerrainReport > :: new () ; TerrainReport :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Thrust { pub header : std_msgs :: msg :: Header , pub thrust : f32 } impl WrappedTypesupport for Thrust { type CStruct = mavros_msgs__msg__Thrust ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__msg__Thrust () } } fn create_msg () -> * mut mavros_msgs__msg__Thrust { unsafe { mavros_msgs__msg__Thrust__create () } } fn destroy_msg (msg : * mut mavros_msgs__msg__Thrust) -> () { unsafe { mavros_msgs__msg__Thrust__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Thrust { Thrust { header : std_msgs :: msg :: Header :: from_native (& msg . header) , thrust : msg . thrust , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . thrust = self . thrust ; } } impl Default for Thrust { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Thrust > :: new () ; Thrust :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct TimesyncStatus { pub header : std_msgs :: msg :: Header , pub remote_timestamp_ns : u64 , pub observed_offset_ns : i64 , pub estimated_offset_ns : i64 , pub round_trip_time_ms : f32 } impl WrappedTypesupport for TimesyncStatus { type CStruct = mavros_msgs__msg__TimesyncStatus ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__msg__TimesyncStatus () } } fn create_msg () -> * mut mavros_msgs__msg__TimesyncStatus { unsafe { mavros_msgs__msg__TimesyncStatus__create () } } fn destroy_msg (msg : * mut mavros_msgs__msg__TimesyncStatus) -> () { unsafe { mavros_msgs__msg__TimesyncStatus__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> TimesyncStatus { TimesyncStatus { header : std_msgs :: msg :: Header :: from_native (& msg . header) , remote_timestamp_ns : msg . remote_timestamp_ns , observed_offset_ns : msg . observed_offset_ns , estimated_offset_ns : msg . estimated_offset_ns , round_trip_time_ms : msg . round_trip_time_ms , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . remote_timestamp_ns = self . remote_timestamp_ns ; msg . observed_offset_ns = self . observed_offset_ns ; msg . estimated_offset_ns = self . estimated_offset_ns ; msg . round_trip_time_ms = self . round_trip_time_ms ; } } impl Default for TimesyncStatus { fn default () -> Self { let msg_native = WrappedNativeMsg :: < TimesyncStatus > :: new () ; TimesyncStatus :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Trajectory { pub header : std_msgs :: msg :: Header , # [serde (rename = "type")] pub type_ : u8 , pub point_1 : mavros_msgs :: msg :: PositionTarget , pub point_2 : mavros_msgs :: msg :: PositionTarget , pub point_3 : mavros_msgs :: msg :: PositionTarget , pub point_4 : mavros_msgs :: msg :: PositionTarget , pub point_5 : mavros_msgs :: msg :: PositionTarget , pub point_valid : Vec < u8 > , pub command : Vec < u16 > , pub time_horizon : Vec < f32 > } impl WrappedTypesupport for Trajectory { type CStruct = mavros_msgs__msg__Trajectory ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__msg__Trajectory () } } fn create_msg () -> * mut mavros_msgs__msg__Trajectory { unsafe { mavros_msgs__msg__Trajectory__create () } } fn destroy_msg (msg : * mut mavros_msgs__msg__Trajectory) -> () { unsafe { mavros_msgs__msg__Trajectory__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Trajectory { Trajectory { header : std_msgs :: msg :: Header :: from_native (& msg . header) , type_ : msg . type_ , point_1 : mavros_msgs :: msg :: PositionTarget :: from_native (& msg . point_1) , point_2 : mavros_msgs :: msg :: PositionTarget :: from_native (& msg . point_2) , point_3 : mavros_msgs :: msg :: PositionTarget :: from_native (& msg . point_3) , point_4 : mavros_msgs :: msg :: PositionTarget :: from_native (& msg . point_4) , point_5 : mavros_msgs :: msg :: PositionTarget :: from_native (& msg . point_5) , point_valid : msg . point_valid . to_vec () , command : msg . command . to_vec () , time_horizon : msg . time_horizon . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . type_ = self . type_ ; self . point_1 . copy_to_native (& mut msg . point_1) ; self . point_2 . copy_to_native (& mut msg . point_2) ; self . point_3 . copy_to_native (& mut msg . point_3) ; self . point_4 . copy_to_native (& mut msg . point_4) ; self . point_5 . copy_to_native (& mut msg . point_5) ; assert_eq ! (self . point_valid . len () , 5usize , "Field {} is fixed size of {}!" , "point_valid" , 5usize) ; msg . point_valid . copy_from_slice (& self . point_valid [.. 5usize]) ; assert_eq ! (self . command . len () , 5usize , "Field {} is fixed size of {}!" , "command" , 5usize) ; msg . command . copy_from_slice (& self . command [.. 5usize]) ; assert_eq ! (self . time_horizon . len () , 5usize , "Field {} is fixed size of {}!" , "time_horizon" , 5usize) ; msg . time_horizon . copy_from_slice (& self . time_horizon [.. 5usize]) ; } } impl Default for Trajectory { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Trajectory > :: new () ; Trajectory :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl Trajectory { pub const MAV_TRAJECTORY_REPRESENTATION_BEZIER : _bindgen_ty_759 = mavros_msgs__msg__Trajectory__MAV_TRAJECTORY_REPRESENTATION_BEZIER ; pub const MAV_TRAJECTORY_REPRESENTATION_WAYPOINTS : _bindgen_ty_758 = mavros_msgs__msg__Trajectory__MAV_TRAJECTORY_REPRESENTATION_WAYPOINTS ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Tunnel { pub target_system : u8 , pub target_component : u8 , pub payload_type : u16 , pub payload_length : u8 , pub payload : Vec < u8 > } impl WrappedTypesupport for Tunnel { type CStruct = mavros_msgs__msg__Tunnel ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__msg__Tunnel () } } fn create_msg () -> * mut mavros_msgs__msg__Tunnel { unsafe { mavros_msgs__msg__Tunnel__create () } } fn destroy_msg (msg : * mut mavros_msgs__msg__Tunnel) -> () { unsafe { mavros_msgs__msg__Tunnel__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Tunnel { Tunnel { target_system : msg . target_system , target_component : msg . target_component , payload_type : msg . payload_type , payload_length : msg . payload_length , payload : msg . payload . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . target_system = self . target_system ; msg . target_component = self . target_component ; msg . payload_type = self . payload_type ; msg . payload_length = self . payload_length ; assert_eq ! (self . payload . len () , 128usize , "Field {} is fixed size of {}!" , "payload" , 128usize) ; msg . payload . copy_from_slice (& self . payload [.. 128usize]) ; } } impl Default for Tunnel { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Tunnel > :: new () ; Tunnel :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl Tunnel { pub const PAYLOAD_TYPE_STORM32_RESERVED0 : _bindgen_ty_761 = mavros_msgs__msg__Tunnel__PAYLOAD_TYPE_STORM32_RESERVED0 ; pub const PAYLOAD_TYPE_STORM32_RESERVED1 : _bindgen_ty_762 = mavros_msgs__msg__Tunnel__PAYLOAD_TYPE_STORM32_RESERVED1 ; pub const PAYLOAD_TYPE_STORM32_RESERVED2 : _bindgen_ty_763 = mavros_msgs__msg__Tunnel__PAYLOAD_TYPE_STORM32_RESERVED2 ; pub const PAYLOAD_TYPE_STORM32_RESERVED3 : _bindgen_ty_764 = mavros_msgs__msg__Tunnel__PAYLOAD_TYPE_STORM32_RESERVED3 ; pub const PAYLOAD_TYPE_STORM32_RESERVED4 : _bindgen_ty_765 = mavros_msgs__msg__Tunnel__PAYLOAD_TYPE_STORM32_RESERVED4 ; pub const PAYLOAD_TYPE_STORM32_RESERVED5 : _bindgen_ty_766 = mavros_msgs__msg__Tunnel__PAYLOAD_TYPE_STORM32_RESERVED5 ; pub const PAYLOAD_TYPE_STORM32_RESERVED6 : _bindgen_ty_767 = mavros_msgs__msg__Tunnel__PAYLOAD_TYPE_STORM32_RESERVED6 ; pub const PAYLOAD_TYPE_STORM32_RESERVED7 : _bindgen_ty_768 = mavros_msgs__msg__Tunnel__PAYLOAD_TYPE_STORM32_RESERVED7 ; pub const PAYLOAD_TYPE_STORM32_RESERVED8 : _bindgen_ty_769 = mavros_msgs__msg__Tunnel__PAYLOAD_TYPE_STORM32_RESERVED8 ; pub const PAYLOAD_TYPE_STORM32_RESERVED9 : _bindgen_ty_770 = mavros_msgs__msg__Tunnel__PAYLOAD_TYPE_STORM32_RESERVED9 ; pub const PAYLOAD_TYPE_UNKNOWN : _bindgen_ty_760 = mavros_msgs__msg__Tunnel__PAYLOAD_TYPE_UNKNOWN ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct VehicleInfo { pub header : std_msgs :: msg :: Header , pub available_info : u8 , pub sysid : u8 , pub compid : u8 , pub autopilot : u8 , # [serde (rename = "type")] pub type_ : u8 , pub system_status : u8 , pub base_mode : u8 , pub custom_mode : u32 , pub mode : std :: string :: String , pub mode_id : u32 , pub capabilities : u64 , pub flight_sw_version : u32 , pub middleware_sw_version : u32 , pub os_sw_version : u32 , pub board_version : u32 , pub flight_custom_version : std :: string :: String , pub vendor_id : u16 , pub product_id : u16 , pub uid : u64 } impl WrappedTypesupport for VehicleInfo { type CStruct = mavros_msgs__msg__VehicleInfo ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__msg__VehicleInfo () } } fn create_msg () -> * mut mavros_msgs__msg__VehicleInfo { unsafe { mavros_msgs__msg__VehicleInfo__create () } } fn destroy_msg (msg : * mut mavros_msgs__msg__VehicleInfo) -> () { unsafe { mavros_msgs__msg__VehicleInfo__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> VehicleInfo { VehicleInfo { header : std_msgs :: msg :: Header :: from_native (& msg . header) , available_info : msg . available_info , sysid : msg . sysid , compid : msg . compid , autopilot : msg . autopilot , type_ : msg . type_ , system_status : msg . system_status , base_mode : msg . base_mode , custom_mode : msg . custom_mode , mode : msg . mode . to_str () . to_owned () , mode_id : msg . mode_id , capabilities : msg . capabilities , flight_sw_version : msg . flight_sw_version , middleware_sw_version : msg . middleware_sw_version , os_sw_version : msg . os_sw_version , board_version : msg . board_version , flight_custom_version : msg . flight_custom_version . to_str () . to_owned () , vendor_id : msg . vendor_id , product_id : msg . product_id , uid : msg . uid , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . available_info = self . available_info ; msg . sysid = self . sysid ; msg . compid = self . compid ; msg . autopilot = self . autopilot ; msg . type_ = self . type_ ; msg . system_status = self . system_status ; msg . base_mode = self . base_mode ; msg . custom_mode = self . custom_mode ; msg . mode . assign (& self . mode) ; msg . mode_id = self . mode_id ; msg . capabilities = self . capabilities ; msg . flight_sw_version = self . flight_sw_version ; msg . middleware_sw_version = self . middleware_sw_version ; msg . os_sw_version = self . os_sw_version ; msg . board_version = self . board_version ; msg . flight_custom_version . assign (& self . flight_custom_version) ; msg . vendor_id = self . vendor_id ; msg . product_id = self . product_id ; msg . uid = self . uid ; } } impl Default for VehicleInfo { fn default () -> Self { let msg_native = WrappedNativeMsg :: < VehicleInfo > :: new () ; VehicleInfo :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl VehicleInfo { pub const HAVE_INFO_AUTOPILOT_VERSION : _bindgen_ty_772 = mavros_msgs__msg__VehicleInfo__HAVE_INFO_AUTOPILOT_VERSION ; pub const HAVE_INFO_HEARTBEAT : _bindgen_ty_771 = mavros_msgs__msg__VehicleInfo__HAVE_INFO_HEARTBEAT ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct VfrHud { pub header : std_msgs :: msg :: Header , pub airspeed : f32 , pub groundspeed : f32 , pub heading : i16 , pub throttle : f32 , pub altitude : f32 , pub climb : f32 } impl WrappedTypesupport for VfrHud { type CStruct = mavros_msgs__msg__VfrHud ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__msg__VfrHud () } } fn create_msg () -> * mut mavros_msgs__msg__VfrHud { unsafe { mavros_msgs__msg__VfrHud__create () } } fn destroy_msg (msg : * mut mavros_msgs__msg__VfrHud) -> () { unsafe { mavros_msgs__msg__VfrHud__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> VfrHud { VfrHud { header : std_msgs :: msg :: Header :: from_native (& msg . header) , airspeed : msg . airspeed , groundspeed : msg . groundspeed , heading : msg . heading , throttle : msg . throttle , altitude : msg . altitude , climb : msg . climb , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . airspeed = self . airspeed ; msg . groundspeed = self . groundspeed ; msg . heading = self . heading ; msg . throttle = self . throttle ; msg . altitude = self . altitude ; msg . climb = self . climb ; } } impl Default for VfrHud { fn default () -> Self { let msg_native = WrappedNativeMsg :: < VfrHud > :: new () ; VfrHud :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Vibration { pub header : std_msgs :: msg :: Header , pub vibration : geometry_msgs :: msg :: Vector3 , pub clipping : Vec < f32 > } impl WrappedTypesupport for Vibration { type CStruct = mavros_msgs__msg__Vibration ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__msg__Vibration () } } fn create_msg () -> * mut mavros_msgs__msg__Vibration { unsafe { mavros_msgs__msg__Vibration__create () } } fn destroy_msg (msg : * mut mavros_msgs__msg__Vibration) -> () { unsafe { mavros_msgs__msg__Vibration__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Vibration { Vibration { header : std_msgs :: msg :: Header :: from_native (& msg . header) , vibration : geometry_msgs :: msg :: Vector3 :: from_native (& msg . vibration) , clipping : msg . clipping . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; self . vibration . copy_to_native (& mut msg . vibration) ; assert_eq ! (self . clipping . len () , 3usize , "Field {} is fixed size of {}!" , "clipping" , 3usize) ; msg . clipping . copy_from_slice (& self . clipping [.. 3usize]) ; } } impl Default for Vibration { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Vibration > :: new () ; Vibration :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Waypoint { pub frame : u8 , pub command : u16 , pub is_current : bool , pub autocontinue : bool , pub param1 : f32 , pub param2 : f32 , pub param3 : f32 , pub param4 : f32 , pub x_lat : f64 , pub y_long : f64 , pub z_alt : f64 } impl WrappedTypesupport for Waypoint { type CStruct = mavros_msgs__msg__Waypoint ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__msg__Waypoint () } } fn create_msg () -> * mut mavros_msgs__msg__Waypoint { unsafe { mavros_msgs__msg__Waypoint__create () } } fn destroy_msg (msg : * mut mavros_msgs__msg__Waypoint) -> () { unsafe { mavros_msgs__msg__Waypoint__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Waypoint { Waypoint { frame : msg . frame , command : msg . command , is_current : msg . is_current , autocontinue : msg . autocontinue , param1 : msg . param1 , param2 : msg . param2 , param3 : msg . param3 , param4 : msg . param4 , x_lat : msg . x_lat , y_long : msg . y_long , z_alt : msg . z_alt , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . frame = self . frame ; msg . command = self . command ; msg . is_current = self . is_current ; msg . autocontinue = self . autocontinue ; msg . param1 = self . param1 ; msg . param2 = self . param2 ; msg . param3 = self . param3 ; msg . param4 = self . param4 ; msg . x_lat = self . x_lat ; msg . y_long = self . y_long ; msg . z_alt = self . z_alt ; } } impl Default for Waypoint { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Waypoint > :: new () ; Waypoint :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl Waypoint { pub const FRAME_BODY_FRD : _bindgen_ty_785 = mavros_msgs__msg__Waypoint__FRAME_BODY_FRD ; pub const FRAME_BODY_NED : _bindgen_ty_781 = mavros_msgs__msg__Waypoint__FRAME_BODY_NED ; pub const FRAME_BODY_OFFSET_NED : _bindgen_ty_782 = mavros_msgs__msg__Waypoint__FRAME_BODY_OFFSET_NED ; pub const FRAME_GLOBAL : _bindgen_ty_773 = mavros_msgs__msg__Waypoint__FRAME_GLOBAL ; pub const FRAME_GLOBAL_INT : _bindgen_ty_778 = mavros_msgs__msg__Waypoint__FRAME_GLOBAL_INT ; pub const FRAME_GLOBAL_RELATIVE_ALT_INT : _bindgen_ty_779 = mavros_msgs__msg__Waypoint__FRAME_GLOBAL_RELATIVE_ALT_INT ; pub const FRAME_GLOBAL_REL_ALT : _bindgen_ty_776 = mavros_msgs__msg__Waypoint__FRAME_GLOBAL_REL_ALT ; pub const FRAME_GLOBAL_TERRAIN_ALT : _bindgen_ty_783 = mavros_msgs__msg__Waypoint__FRAME_GLOBAL_TERRAIN_ALT ; pub const FRAME_GLOBAL_TERRAIN_ALT_INT : _bindgen_ty_784 = mavros_msgs__msg__Waypoint__FRAME_GLOBAL_TERRAIN_ALT_INT ; pub const FRAME_LOCAL_ENU : _bindgen_ty_777 = mavros_msgs__msg__Waypoint__FRAME_LOCAL_ENU ; pub const FRAME_LOCAL_FLU : _bindgen_ty_794 = mavros_msgs__msg__Waypoint__FRAME_LOCAL_FLU ; pub const FRAME_LOCAL_FRD : _bindgen_ty_793 = mavros_msgs__msg__Waypoint__FRAME_LOCAL_FRD ; pub const FRAME_LOCAL_NED : _bindgen_ty_774 = mavros_msgs__msg__Waypoint__FRAME_LOCAL_NED ; pub const FRAME_LOCAL_OFFSET_NED : _bindgen_ty_780 = mavros_msgs__msg__Waypoint__FRAME_LOCAL_OFFSET_NED ; pub const FRAME_MISSION : _bindgen_ty_775 = mavros_msgs__msg__Waypoint__FRAME_MISSION ; pub const FRAME_RESERVED_13 : _bindgen_ty_786 = mavros_msgs__msg__Waypoint__FRAME_RESERVED_13 ; pub const FRAME_RESERVED_14 : _bindgen_ty_787 = mavros_msgs__msg__Waypoint__FRAME_RESERVED_14 ; pub const FRAME_RESERVED_15 : _bindgen_ty_788 = mavros_msgs__msg__Waypoint__FRAME_RESERVED_15 ; pub const FRAME_RESERVED_16 : _bindgen_ty_789 = mavros_msgs__msg__Waypoint__FRAME_RESERVED_16 ; pub const FRAME_RESERVED_17 : _bindgen_ty_790 = mavros_msgs__msg__Waypoint__FRAME_RESERVED_17 ; pub const FRAME_RESERVED_18 : _bindgen_ty_791 = mavros_msgs__msg__Waypoint__FRAME_RESERVED_18 ; pub const FRAME_RESERVED_19 : _bindgen_ty_792 = mavros_msgs__msg__Waypoint__FRAME_RESERVED_19 ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct WaypointList { pub current_seq : u16 , pub waypoints : Vec < mavros_msgs :: msg :: Waypoint > } impl WrappedTypesupport for WaypointList { type CStruct = mavros_msgs__msg__WaypointList ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__msg__WaypointList () } } fn create_msg () -> * mut mavros_msgs__msg__WaypointList { unsafe { mavros_msgs__msg__WaypointList__create () } } fn destroy_msg (msg : * mut mavros_msgs__msg__WaypointList) -> () { unsafe { mavros_msgs__msg__WaypointList__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> WaypointList { WaypointList { current_seq : msg . current_seq , waypoints : { let mut temp = Vec :: with_capacity (msg . waypoints . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . waypoints . data , msg . waypoints . size) } ; for s in slice { temp . push (mavros_msgs :: msg :: Waypoint :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . current_seq = self . current_seq ; unsafe { mavros_msgs__msg__Waypoint__Sequence__fini (& mut msg . waypoints) ; mavros_msgs__msg__Waypoint__Sequence__init (& mut msg . waypoints , self . waypoints . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . waypoints . data , msg . waypoints . size) ; for (t , s) in slice . iter_mut () . zip (& self . waypoints) { s . copy_to_native (t) ; } } } } impl Default for WaypointList { fn default () -> Self { let msg_native = WrappedNativeMsg :: < WaypointList > :: new () ; WaypointList :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct WaypointReached { pub header : std_msgs :: msg :: Header , pub wp_seq : u16 } impl WrappedTypesupport for WaypointReached { type CStruct = mavros_msgs__msg__WaypointReached ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__msg__WaypointReached () } } fn create_msg () -> * mut mavros_msgs__msg__WaypointReached { unsafe { mavros_msgs__msg__WaypointReached__create () } } fn destroy_msg (msg : * mut mavros_msgs__msg__WaypointReached) -> () { unsafe { mavros_msgs__msg__WaypointReached__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> WaypointReached { WaypointReached { header : std_msgs :: msg :: Header :: from_native (& msg . header) , wp_seq : msg . wp_seq , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . wp_seq = self . wp_seq ; } } impl Default for WaypointReached { fn default () -> Self { let msg_native = WrappedNativeMsg :: < WaypointReached > :: new () ; WaypointReached :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct WheelOdomStamped { pub header : std_msgs :: msg :: Header , pub data : Vec < f64 > } impl WrappedTypesupport for WheelOdomStamped { type CStruct = mavros_msgs__msg__WheelOdomStamped ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__msg__WheelOdomStamped () } } fn create_msg () -> * mut mavros_msgs__msg__WheelOdomStamped { unsafe { mavros_msgs__msg__WheelOdomStamped__create () } } fn destroy_msg (msg : * mut mavros_msgs__msg__WheelOdomStamped) -> () { unsafe { mavros_msgs__msg__WheelOdomStamped__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> WheelOdomStamped { WheelOdomStamped { header : std_msgs :: msg :: Header :: from_native (& msg . header) , data : msg . data . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . data . update (& self . data) ; } } impl Default for WheelOdomStamped { fn default () -> Self { let msg_native = WrappedNativeMsg :: < WheelOdomStamped > :: new () ; WheelOdomStamped :: from_native (& msg_native) } } } pub mod srv { # [allow (non_snake_case)] pub mod CommandAck { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__mavros_msgs__srv__CommandAck () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub command : u16 , pub result : u8 , pub progress : u8 , pub result_param2 : u32 } impl WrappedTypesupport for Request { type CStruct = mavros_msgs__srv__CommandAck_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__srv__CommandAck_Request () } } fn create_msg () -> * mut mavros_msgs__srv__CommandAck_Request { unsafe { mavros_msgs__srv__CommandAck_Request__create () } } fn destroy_msg (msg : * mut mavros_msgs__srv__CommandAck_Request) -> () { unsafe { mavros_msgs__srv__CommandAck_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { command : msg . command , result : msg . result , progress : msg . progress , result_param2 : msg . result_param2 , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . command = self . command ; msg . result = self . result ; msg . progress = self . progress ; msg . result_param2 = self . result_param2 ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool , pub result : u8 } impl WrappedTypesupport for Response { type CStruct = mavros_msgs__srv__CommandAck_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__srv__CommandAck_Response () } } fn create_msg () -> * mut mavros_msgs__srv__CommandAck_Response { unsafe { mavros_msgs__srv__CommandAck_Response__create () } } fn destroy_msg (msg : * mut mavros_msgs__srv__CommandAck_Response) -> () { unsafe { mavros_msgs__srv__CommandAck_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , result : msg . result , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; msg . result = self . result ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod CommandBool { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__mavros_msgs__srv__CommandBool () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub value : bool } impl WrappedTypesupport for Request { type CStruct = mavros_msgs__srv__CommandBool_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__srv__CommandBool_Request () } } fn create_msg () -> * mut mavros_msgs__srv__CommandBool_Request { unsafe { mavros_msgs__srv__CommandBool_Request__create () } } fn destroy_msg (msg : * mut mavros_msgs__srv__CommandBool_Request) -> () { unsafe { mavros_msgs__srv__CommandBool_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { value : msg . value , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . value = self . value ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool , pub result : u8 } impl WrappedTypesupport for Response { type CStruct = mavros_msgs__srv__CommandBool_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__srv__CommandBool_Response () } } fn create_msg () -> * mut mavros_msgs__srv__CommandBool_Response { unsafe { mavros_msgs__srv__CommandBool_Response__create () } } fn destroy_msg (msg : * mut mavros_msgs__srv__CommandBool_Response) -> () { unsafe { mavros_msgs__srv__CommandBool_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , result : msg . result , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; msg . result = self . result ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod CommandHome { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__mavros_msgs__srv__CommandHome () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub current_gps : bool , pub yaw : f32 , pub latitude : f32 , pub longitude : f32 , pub altitude : f32 } impl WrappedTypesupport for Request { type CStruct = mavros_msgs__srv__CommandHome_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__srv__CommandHome_Request () } } fn create_msg () -> * mut mavros_msgs__srv__CommandHome_Request { unsafe { mavros_msgs__srv__CommandHome_Request__create () } } fn destroy_msg (msg : * mut mavros_msgs__srv__CommandHome_Request) -> () { unsafe { mavros_msgs__srv__CommandHome_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { current_gps : msg . current_gps , yaw : msg . yaw , latitude : msg . latitude , longitude : msg . longitude , altitude : msg . altitude , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . current_gps = self . current_gps ; msg . yaw = self . yaw ; msg . latitude = self . latitude ; msg . longitude = self . longitude ; msg . altitude = self . altitude ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool , pub result : u8 } impl WrappedTypesupport for Response { type CStruct = mavros_msgs__srv__CommandHome_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__srv__CommandHome_Response () } } fn create_msg () -> * mut mavros_msgs__srv__CommandHome_Response { unsafe { mavros_msgs__srv__CommandHome_Response__create () } } fn destroy_msg (msg : * mut mavros_msgs__srv__CommandHome_Response) -> () { unsafe { mavros_msgs__srv__CommandHome_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , result : msg . result , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; msg . result = self . result ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod CommandInt { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__mavros_msgs__srv__CommandInt () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub broadcast : bool , pub frame : u8 , pub command : u16 , pub current : u8 , pub autocontinue : u8 , pub param1 : f32 , pub param2 : f32 , pub param3 : f32 , pub param4 : f32 , pub x : i32 , pub y : i32 , pub z : f32 } impl WrappedTypesupport for Request { type CStruct = mavros_msgs__srv__CommandInt_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__srv__CommandInt_Request () } } fn create_msg () -> * mut mavros_msgs__srv__CommandInt_Request { unsafe { mavros_msgs__srv__CommandInt_Request__create () } } fn destroy_msg (msg : * mut mavros_msgs__srv__CommandInt_Request) -> () { unsafe { mavros_msgs__srv__CommandInt_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { broadcast : msg . broadcast , frame : msg . frame , command : msg . command , current : msg . current , autocontinue : msg . autocontinue , param1 : msg . param1 , param2 : msg . param2 , param3 : msg . param3 , param4 : msg . param4 , x : msg . x , y : msg . y , z : msg . z , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . broadcast = self . broadcast ; msg . frame = self . frame ; msg . command = self . command ; msg . current = self . current ; msg . autocontinue = self . autocontinue ; msg . param1 = self . param1 ; msg . param2 = self . param2 ; msg . param3 = self . param3 ; msg . param4 = self . param4 ; msg . x = self . x ; msg . y = self . y ; msg . z = self . z ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool } impl WrappedTypesupport for Response { type CStruct = mavros_msgs__srv__CommandInt_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__srv__CommandInt_Response () } } fn create_msg () -> * mut mavros_msgs__srv__CommandInt_Response { unsafe { mavros_msgs__srv__CommandInt_Response__create () } } fn destroy_msg (msg : * mut mavros_msgs__srv__CommandInt_Response) -> () { unsafe { mavros_msgs__srv__CommandInt_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod CommandLong { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__mavros_msgs__srv__CommandLong () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub broadcast : bool , pub command : u16 , pub confirmation : u8 , pub param1 : f32 , pub param2 : f32 , pub param3 : f32 , pub param4 : f32 , pub param5 : f32 , pub param6 : f32 , pub param7 : f32 } impl WrappedTypesupport for Request { type CStruct = mavros_msgs__srv__CommandLong_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__srv__CommandLong_Request () } } fn create_msg () -> * mut mavros_msgs__srv__CommandLong_Request { unsafe { mavros_msgs__srv__CommandLong_Request__create () } } fn destroy_msg (msg : * mut mavros_msgs__srv__CommandLong_Request) -> () { unsafe { mavros_msgs__srv__CommandLong_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { broadcast : msg . broadcast , command : msg . command , confirmation : msg . confirmation , param1 : msg . param1 , param2 : msg . param2 , param3 : msg . param3 , param4 : msg . param4 , param5 : msg . param5 , param6 : msg . param6 , param7 : msg . param7 , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . broadcast = self . broadcast ; msg . command = self . command ; msg . confirmation = self . confirmation ; msg . param1 = self . param1 ; msg . param2 = self . param2 ; msg . param3 = self . param3 ; msg . param4 = self . param4 ; msg . param5 = self . param5 ; msg . param6 = self . param6 ; msg . param7 = self . param7 ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool , pub result : u8 } impl WrappedTypesupport for Response { type CStruct = mavros_msgs__srv__CommandLong_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__srv__CommandLong_Response () } } fn create_msg () -> * mut mavros_msgs__srv__CommandLong_Response { unsafe { mavros_msgs__srv__CommandLong_Response__create () } } fn destroy_msg (msg : * mut mavros_msgs__srv__CommandLong_Response) -> () { unsafe { mavros_msgs__srv__CommandLong_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , result : msg . result , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; msg . result = self . result ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod CommandTOL { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__mavros_msgs__srv__CommandTOL () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub min_pitch : f32 , pub yaw : f32 , pub latitude : f32 , pub longitude : f32 , pub altitude : f32 } impl WrappedTypesupport for Request { type CStruct = mavros_msgs__srv__CommandTOL_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__srv__CommandTOL_Request () } } fn create_msg () -> * mut mavros_msgs__srv__CommandTOL_Request { unsafe { mavros_msgs__srv__CommandTOL_Request__create () } } fn destroy_msg (msg : * mut mavros_msgs__srv__CommandTOL_Request) -> () { unsafe { mavros_msgs__srv__CommandTOL_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { min_pitch : msg . min_pitch , yaw : msg . yaw , latitude : msg . latitude , longitude : msg . longitude , altitude : msg . altitude , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . min_pitch = self . min_pitch ; msg . yaw = self . yaw ; msg . latitude = self . latitude ; msg . longitude = self . longitude ; msg . altitude = self . altitude ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool , pub result : u8 } impl WrappedTypesupport for Response { type CStruct = mavros_msgs__srv__CommandTOL_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__srv__CommandTOL_Response () } } fn create_msg () -> * mut mavros_msgs__srv__CommandTOL_Response { unsafe { mavros_msgs__srv__CommandTOL_Response__create () } } fn destroy_msg (msg : * mut mavros_msgs__srv__CommandTOL_Response) -> () { unsafe { mavros_msgs__srv__CommandTOL_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , result : msg . result , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; msg . result = self . result ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod CommandTriggerControl { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__mavros_msgs__srv__CommandTriggerControl () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub trigger_enable : bool , pub sequence_reset : bool , pub trigger_pause : bool } impl WrappedTypesupport for Request { type CStruct = mavros_msgs__srv__CommandTriggerControl_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__srv__CommandTriggerControl_Request () } } fn create_msg () -> * mut mavros_msgs__srv__CommandTriggerControl_Request { unsafe { mavros_msgs__srv__CommandTriggerControl_Request__create () } } fn destroy_msg (msg : * mut mavros_msgs__srv__CommandTriggerControl_Request) -> () { unsafe { mavros_msgs__srv__CommandTriggerControl_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { trigger_enable : msg . trigger_enable , sequence_reset : msg . sequence_reset , trigger_pause : msg . trigger_pause , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . trigger_enable = self . trigger_enable ; msg . sequence_reset = self . sequence_reset ; msg . trigger_pause = self . trigger_pause ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool , pub result : u8 } impl WrappedTypesupport for Response { type CStruct = mavros_msgs__srv__CommandTriggerControl_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__srv__CommandTriggerControl_Response () } } fn create_msg () -> * mut mavros_msgs__srv__CommandTriggerControl_Response { unsafe { mavros_msgs__srv__CommandTriggerControl_Response__create () } } fn destroy_msg (msg : * mut mavros_msgs__srv__CommandTriggerControl_Response) -> () { unsafe { mavros_msgs__srv__CommandTriggerControl_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , result : msg . result , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; msg . result = self . result ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod CommandTriggerInterval { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__mavros_msgs__srv__CommandTriggerInterval () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub cycle_time : f32 , pub integration_time : f32 } impl WrappedTypesupport for Request { type CStruct = mavros_msgs__srv__CommandTriggerInterval_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__srv__CommandTriggerInterval_Request () } } fn create_msg () -> * mut mavros_msgs__srv__CommandTriggerInterval_Request { unsafe { mavros_msgs__srv__CommandTriggerInterval_Request__create () } } fn destroy_msg (msg : * mut mavros_msgs__srv__CommandTriggerInterval_Request) -> () { unsafe { mavros_msgs__srv__CommandTriggerInterval_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { cycle_time : msg . cycle_time , integration_time : msg . integration_time , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . cycle_time = self . cycle_time ; msg . integration_time = self . integration_time ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool , pub result : u8 } impl WrappedTypesupport for Response { type CStruct = mavros_msgs__srv__CommandTriggerInterval_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__srv__CommandTriggerInterval_Response () } } fn create_msg () -> * mut mavros_msgs__srv__CommandTriggerInterval_Response { unsafe { mavros_msgs__srv__CommandTriggerInterval_Response__create () } } fn destroy_msg (msg : * mut mavros_msgs__srv__CommandTriggerInterval_Response) -> () { unsafe { mavros_msgs__srv__CommandTriggerInterval_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , result : msg . result , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; msg . result = self . result ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod CommandVtolTransition { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__mavros_msgs__srv__CommandVtolTransition () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub header : std_msgs :: msg :: Header , pub state : u8 } impl WrappedTypesupport for Request { type CStruct = mavros_msgs__srv__CommandVtolTransition_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__srv__CommandVtolTransition_Request () } } fn create_msg () -> * mut mavros_msgs__srv__CommandVtolTransition_Request { unsafe { mavros_msgs__srv__CommandVtolTransition_Request__create () } } fn destroy_msg (msg : * mut mavros_msgs__srv__CommandVtolTransition_Request) -> () { unsafe { mavros_msgs__srv__CommandVtolTransition_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { header : std_msgs :: msg :: Header :: from_native (& msg . header) , state : msg . state , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . state = self . state ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl Request { pub const STATE_FW : _bindgen_ty_796 = mavros_msgs__srv__CommandVtolTransition_Request__STATE_FW ; pub const STATE_MC : _bindgen_ty_795 = mavros_msgs__srv__CommandVtolTransition_Request__STATE_MC ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool , pub result : u8 } impl WrappedTypesupport for Response { type CStruct = mavros_msgs__srv__CommandVtolTransition_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__srv__CommandVtolTransition_Response () } } fn create_msg () -> * mut mavros_msgs__srv__CommandVtolTransition_Response { unsafe { mavros_msgs__srv__CommandVtolTransition_Response__create () } } fn destroy_msg (msg : * mut mavros_msgs__srv__CommandVtolTransition_Response) -> () { unsafe { mavros_msgs__srv__CommandVtolTransition_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , result : msg . result , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; msg . result = self . result ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod EndpointAdd { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__mavros_msgs__srv__EndpointAdd () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub url : std :: string :: String , # [serde (rename = "type")] pub type_ : u8 } impl WrappedTypesupport for Request { type CStruct = mavros_msgs__srv__EndpointAdd_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__srv__EndpointAdd_Request () } } fn create_msg () -> * mut mavros_msgs__srv__EndpointAdd_Request { unsafe { mavros_msgs__srv__EndpointAdd_Request__create () } } fn destroy_msg (msg : * mut mavros_msgs__srv__EndpointAdd_Request) -> () { unsafe { mavros_msgs__srv__EndpointAdd_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { url : msg . url . to_str () . to_owned () , type_ : msg . type_ , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . url . assign (& self . url) ; msg . type_ = self . type_ ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl Request { pub const TYPE_FCU : _bindgen_ty_797 = mavros_msgs__srv__EndpointAdd_Request__TYPE_FCU ; pub const TYPE_GCS : _bindgen_ty_798 = mavros_msgs__srv__EndpointAdd_Request__TYPE_GCS ; pub const TYPE_UAS : _bindgen_ty_799 = mavros_msgs__srv__EndpointAdd_Request__TYPE_UAS ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub successful : bool , pub reason : std :: string :: String , pub id : u32 } impl WrappedTypesupport for Response { type CStruct = mavros_msgs__srv__EndpointAdd_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__srv__EndpointAdd_Response () } } fn create_msg () -> * mut mavros_msgs__srv__EndpointAdd_Response { unsafe { mavros_msgs__srv__EndpointAdd_Response__create () } } fn destroy_msg (msg : * mut mavros_msgs__srv__EndpointAdd_Response) -> () { unsafe { mavros_msgs__srv__EndpointAdd_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { successful : msg . successful , reason : msg . reason . to_str () . to_owned () , id : msg . id , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . successful = self . successful ; msg . reason . assign (& self . reason) ; msg . id = self . id ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod EndpointDel { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__mavros_msgs__srv__EndpointDel () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub id : u32 , pub url : std :: string :: String , # [serde (rename = "type")] pub type_ : u8 } impl WrappedTypesupport for Request { type CStruct = mavros_msgs__srv__EndpointDel_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__srv__EndpointDel_Request () } } fn create_msg () -> * mut mavros_msgs__srv__EndpointDel_Request { unsafe { mavros_msgs__srv__EndpointDel_Request__create () } } fn destroy_msg (msg : * mut mavros_msgs__srv__EndpointDel_Request) -> () { unsafe { mavros_msgs__srv__EndpointDel_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { id : msg . id , url : msg . url . to_str () . to_owned () , type_ : msg . type_ , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . id = self . id ; msg . url . assign (& self . url) ; msg . type_ = self . type_ ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl Request { pub const TYPE_FCU : _bindgen_ty_800 = mavros_msgs__srv__EndpointDel_Request__TYPE_FCU ; pub const TYPE_GCS : _bindgen_ty_801 = mavros_msgs__srv__EndpointDel_Request__TYPE_GCS ; pub const TYPE_UAS : _bindgen_ty_802 = mavros_msgs__srv__EndpointDel_Request__TYPE_UAS ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub successful : bool } impl WrappedTypesupport for Response { type CStruct = mavros_msgs__srv__EndpointDel_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__srv__EndpointDel_Response () } } fn create_msg () -> * mut mavros_msgs__srv__EndpointDel_Response { unsafe { mavros_msgs__srv__EndpointDel_Response__create () } } fn destroy_msg (msg : * mut mavros_msgs__srv__EndpointDel_Response) -> () { unsafe { mavros_msgs__srv__EndpointDel_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { successful : msg . successful , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . successful = self . successful ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod FileChecksum { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__mavros_msgs__srv__FileChecksum () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub file_path : std :: string :: String } impl WrappedTypesupport for Request { type CStruct = mavros_msgs__srv__FileChecksum_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__srv__FileChecksum_Request () } } fn create_msg () -> * mut mavros_msgs__srv__FileChecksum_Request { unsafe { mavros_msgs__srv__FileChecksum_Request__create () } } fn destroy_msg (msg : * mut mavros_msgs__srv__FileChecksum_Request) -> () { unsafe { mavros_msgs__srv__FileChecksum_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { file_path : msg . file_path . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . file_path . assign (& self . file_path) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub crc32 : u32 , pub success : bool , pub r_errno : i32 } impl WrappedTypesupport for Response { type CStruct = mavros_msgs__srv__FileChecksum_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__srv__FileChecksum_Response () } } fn create_msg () -> * mut mavros_msgs__srv__FileChecksum_Response { unsafe { mavros_msgs__srv__FileChecksum_Response__create () } } fn destroy_msg (msg : * mut mavros_msgs__srv__FileChecksum_Response) -> () { unsafe { mavros_msgs__srv__FileChecksum_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { crc32 : msg . crc32 , success : msg . success , r_errno : msg . r_errno , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . crc32 = self . crc32 ; msg . success = self . success ; msg . r_errno = self . r_errno ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod FileClose { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__mavros_msgs__srv__FileClose () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub file_path : std :: string :: String } impl WrappedTypesupport for Request { type CStruct = mavros_msgs__srv__FileClose_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__srv__FileClose_Request () } } fn create_msg () -> * mut mavros_msgs__srv__FileClose_Request { unsafe { mavros_msgs__srv__FileClose_Request__create () } } fn destroy_msg (msg : * mut mavros_msgs__srv__FileClose_Request) -> () { unsafe { mavros_msgs__srv__FileClose_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { file_path : msg . file_path . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . file_path . assign (& self . file_path) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool , pub r_errno : i32 } impl WrappedTypesupport for Response { type CStruct = mavros_msgs__srv__FileClose_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__srv__FileClose_Response () } } fn create_msg () -> * mut mavros_msgs__srv__FileClose_Response { unsafe { mavros_msgs__srv__FileClose_Response__create () } } fn destroy_msg (msg : * mut mavros_msgs__srv__FileClose_Response) -> () { unsafe { mavros_msgs__srv__FileClose_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , r_errno : msg . r_errno , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; msg . r_errno = self . r_errno ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod FileList { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__mavros_msgs__srv__FileList () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub dir_path : std :: string :: String } impl WrappedTypesupport for Request { type CStruct = mavros_msgs__srv__FileList_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__srv__FileList_Request () } } fn create_msg () -> * mut mavros_msgs__srv__FileList_Request { unsafe { mavros_msgs__srv__FileList_Request__create () } } fn destroy_msg (msg : * mut mavros_msgs__srv__FileList_Request) -> () { unsafe { mavros_msgs__srv__FileList_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { dir_path : msg . dir_path . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . dir_path . assign (& self . dir_path) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub list : Vec < mavros_msgs :: msg :: FileEntry > , pub success : bool , pub r_errno : i32 } impl WrappedTypesupport for Response { type CStruct = mavros_msgs__srv__FileList_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__srv__FileList_Response () } } fn create_msg () -> * mut mavros_msgs__srv__FileList_Response { unsafe { mavros_msgs__srv__FileList_Response__create () } } fn destroy_msg (msg : * mut mavros_msgs__srv__FileList_Response) -> () { unsafe { mavros_msgs__srv__FileList_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { list : { let mut temp = Vec :: with_capacity (msg . list . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . list . data , msg . list . size) } ; for s in slice { temp . push (mavros_msgs :: msg :: FileEntry :: from_native (s)) ; } temp } , success : msg . success , r_errno : msg . r_errno , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { unsafe { mavros_msgs__msg__FileEntry__Sequence__fini (& mut msg . list) ; mavros_msgs__msg__FileEntry__Sequence__init (& mut msg . list , self . list . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . list . data , msg . list . size) ; for (t , s) in slice . iter_mut () . zip (& self . list) { s . copy_to_native (t) ; } } msg . success = self . success ; msg . r_errno = self . r_errno ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod FileMakeDir { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__mavros_msgs__srv__FileMakeDir () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub dir_path : std :: string :: String } impl WrappedTypesupport for Request { type CStruct = mavros_msgs__srv__FileMakeDir_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__srv__FileMakeDir_Request () } } fn create_msg () -> * mut mavros_msgs__srv__FileMakeDir_Request { unsafe { mavros_msgs__srv__FileMakeDir_Request__create () } } fn destroy_msg (msg : * mut mavros_msgs__srv__FileMakeDir_Request) -> () { unsafe { mavros_msgs__srv__FileMakeDir_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { dir_path : msg . dir_path . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . dir_path . assign (& self . dir_path) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool , pub r_errno : i32 } impl WrappedTypesupport for Response { type CStruct = mavros_msgs__srv__FileMakeDir_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__srv__FileMakeDir_Response () } } fn create_msg () -> * mut mavros_msgs__srv__FileMakeDir_Response { unsafe { mavros_msgs__srv__FileMakeDir_Response__create () } } fn destroy_msg (msg : * mut mavros_msgs__srv__FileMakeDir_Response) -> () { unsafe { mavros_msgs__srv__FileMakeDir_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , r_errno : msg . r_errno , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; msg . r_errno = self . r_errno ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod FileOpen { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__mavros_msgs__srv__FileOpen () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub file_path : std :: string :: String , pub mode : u8 } impl WrappedTypesupport for Request { type CStruct = mavros_msgs__srv__FileOpen_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__srv__FileOpen_Request () } } fn create_msg () -> * mut mavros_msgs__srv__FileOpen_Request { unsafe { mavros_msgs__srv__FileOpen_Request__create () } } fn destroy_msg (msg : * mut mavros_msgs__srv__FileOpen_Request) -> () { unsafe { mavros_msgs__srv__FileOpen_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { file_path : msg . file_path . to_str () . to_owned () , mode : msg . mode , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . file_path . assign (& self . file_path) ; msg . mode = self . mode ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl Request { pub const MODE_CREATE : _bindgen_ty_805 = mavros_msgs__srv__FileOpen_Request__MODE_CREATE ; pub const MODE_READ : _bindgen_ty_803 = mavros_msgs__srv__FileOpen_Request__MODE_READ ; pub const MODE_WRITE : _bindgen_ty_804 = mavros_msgs__srv__FileOpen_Request__MODE_WRITE ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub size : u32 , pub success : bool , pub r_errno : i32 } impl WrappedTypesupport for Response { type CStruct = mavros_msgs__srv__FileOpen_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__srv__FileOpen_Response () } } fn create_msg () -> * mut mavros_msgs__srv__FileOpen_Response { unsafe { mavros_msgs__srv__FileOpen_Response__create () } } fn destroy_msg (msg : * mut mavros_msgs__srv__FileOpen_Response) -> () { unsafe { mavros_msgs__srv__FileOpen_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { size : msg . size , success : msg . success , r_errno : msg . r_errno , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . size = self . size ; msg . success = self . success ; msg . r_errno = self . r_errno ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod FileRead { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__mavros_msgs__srv__FileRead () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub file_path : std :: string :: String , pub offset : u64 , pub size : u64 } impl WrappedTypesupport for Request { type CStruct = mavros_msgs__srv__FileRead_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__srv__FileRead_Request () } } fn create_msg () -> * mut mavros_msgs__srv__FileRead_Request { unsafe { mavros_msgs__srv__FileRead_Request__create () } } fn destroy_msg (msg : * mut mavros_msgs__srv__FileRead_Request) -> () { unsafe { mavros_msgs__srv__FileRead_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { file_path : msg . file_path . to_str () . to_owned () , offset : msg . offset , size : msg . size , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . file_path . assign (& self . file_path) ; msg . offset = self . offset ; msg . size = self . size ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub data : Vec < u8 > , pub success : bool , pub r_errno : i32 } impl WrappedTypesupport for Response { type CStruct = mavros_msgs__srv__FileRead_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__srv__FileRead_Response () } } fn create_msg () -> * mut mavros_msgs__srv__FileRead_Response { unsafe { mavros_msgs__srv__FileRead_Response__create () } } fn destroy_msg (msg : * mut mavros_msgs__srv__FileRead_Response) -> () { unsafe { mavros_msgs__srv__FileRead_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { data : msg . data . to_vec () , success : msg . success , r_errno : msg . r_errno , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . data . update (& self . data) ; msg . success = self . success ; msg . r_errno = self . r_errno ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod FileRemove { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__mavros_msgs__srv__FileRemove () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub file_path : std :: string :: String } impl WrappedTypesupport for Request { type CStruct = mavros_msgs__srv__FileRemove_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__srv__FileRemove_Request () } } fn create_msg () -> * mut mavros_msgs__srv__FileRemove_Request { unsafe { mavros_msgs__srv__FileRemove_Request__create () } } fn destroy_msg (msg : * mut mavros_msgs__srv__FileRemove_Request) -> () { unsafe { mavros_msgs__srv__FileRemove_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { file_path : msg . file_path . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . file_path . assign (& self . file_path) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool , pub r_errno : i32 } impl WrappedTypesupport for Response { type CStruct = mavros_msgs__srv__FileRemove_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__srv__FileRemove_Response () } } fn create_msg () -> * mut mavros_msgs__srv__FileRemove_Response { unsafe { mavros_msgs__srv__FileRemove_Response__create () } } fn destroy_msg (msg : * mut mavros_msgs__srv__FileRemove_Response) -> () { unsafe { mavros_msgs__srv__FileRemove_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , r_errno : msg . r_errno , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; msg . r_errno = self . r_errno ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod FileRemoveDir { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__mavros_msgs__srv__FileRemoveDir () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub dir_path : std :: string :: String } impl WrappedTypesupport for Request { type CStruct = mavros_msgs__srv__FileRemoveDir_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__srv__FileRemoveDir_Request () } } fn create_msg () -> * mut mavros_msgs__srv__FileRemoveDir_Request { unsafe { mavros_msgs__srv__FileRemoveDir_Request__create () } } fn destroy_msg (msg : * mut mavros_msgs__srv__FileRemoveDir_Request) -> () { unsafe { mavros_msgs__srv__FileRemoveDir_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { dir_path : msg . dir_path . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . dir_path . assign (& self . dir_path) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool , pub r_errno : i32 } impl WrappedTypesupport for Response { type CStruct = mavros_msgs__srv__FileRemoveDir_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__srv__FileRemoveDir_Response () } } fn create_msg () -> * mut mavros_msgs__srv__FileRemoveDir_Response { unsafe { mavros_msgs__srv__FileRemoveDir_Response__create () } } fn destroy_msg (msg : * mut mavros_msgs__srv__FileRemoveDir_Response) -> () { unsafe { mavros_msgs__srv__FileRemoveDir_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , r_errno : msg . r_errno , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; msg . r_errno = self . r_errno ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod FileRename { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__mavros_msgs__srv__FileRename () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub old_path : std :: string :: String , pub new_path : std :: string :: String } impl WrappedTypesupport for Request { type CStruct = mavros_msgs__srv__FileRename_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__srv__FileRename_Request () } } fn create_msg () -> * mut mavros_msgs__srv__FileRename_Request { unsafe { mavros_msgs__srv__FileRename_Request__create () } } fn destroy_msg (msg : * mut mavros_msgs__srv__FileRename_Request) -> () { unsafe { mavros_msgs__srv__FileRename_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { old_path : msg . old_path . to_str () . to_owned () , new_path : msg . new_path . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . old_path . assign (& self . old_path) ; msg . new_path . assign (& self . new_path) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool , pub r_errno : i32 } impl WrappedTypesupport for Response { type CStruct = mavros_msgs__srv__FileRename_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__srv__FileRename_Response () } } fn create_msg () -> * mut mavros_msgs__srv__FileRename_Response { unsafe { mavros_msgs__srv__FileRename_Response__create () } } fn destroy_msg (msg : * mut mavros_msgs__srv__FileRename_Response) -> () { unsafe { mavros_msgs__srv__FileRename_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , r_errno : msg . r_errno , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; msg . r_errno = self . r_errno ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod FileTruncate { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__mavros_msgs__srv__FileTruncate () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub file_path : std :: string :: String , pub length : u64 } impl WrappedTypesupport for Request { type CStruct = mavros_msgs__srv__FileTruncate_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__srv__FileTruncate_Request () } } fn create_msg () -> * mut mavros_msgs__srv__FileTruncate_Request { unsafe { mavros_msgs__srv__FileTruncate_Request__create () } } fn destroy_msg (msg : * mut mavros_msgs__srv__FileTruncate_Request) -> () { unsafe { mavros_msgs__srv__FileTruncate_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { file_path : msg . file_path . to_str () . to_owned () , length : msg . length , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . file_path . assign (& self . file_path) ; msg . length = self . length ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool , pub r_errno : i32 } impl WrappedTypesupport for Response { type CStruct = mavros_msgs__srv__FileTruncate_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__srv__FileTruncate_Response () } } fn create_msg () -> * mut mavros_msgs__srv__FileTruncate_Response { unsafe { mavros_msgs__srv__FileTruncate_Response__create () } } fn destroy_msg (msg : * mut mavros_msgs__srv__FileTruncate_Response) -> () { unsafe { mavros_msgs__srv__FileTruncate_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , r_errno : msg . r_errno , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; msg . r_errno = self . r_errno ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod FileWrite { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__mavros_msgs__srv__FileWrite () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub file_path : std :: string :: String , pub offset : u64 , pub data : Vec < u8 > } impl WrappedTypesupport for Request { type CStruct = mavros_msgs__srv__FileWrite_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__srv__FileWrite_Request () } } fn create_msg () -> * mut mavros_msgs__srv__FileWrite_Request { unsafe { mavros_msgs__srv__FileWrite_Request__create () } } fn destroy_msg (msg : * mut mavros_msgs__srv__FileWrite_Request) -> () { unsafe { mavros_msgs__srv__FileWrite_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { file_path : msg . file_path . to_str () . to_owned () , offset : msg . offset , data : msg . data . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . file_path . assign (& self . file_path) ; msg . offset = self . offset ; msg . data . update (& self . data) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool , pub r_errno : i32 } impl WrappedTypesupport for Response { type CStruct = mavros_msgs__srv__FileWrite_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__srv__FileWrite_Response () } } fn create_msg () -> * mut mavros_msgs__srv__FileWrite_Response { unsafe { mavros_msgs__srv__FileWrite_Response__create () } } fn destroy_msg (msg : * mut mavros_msgs__srv__FileWrite_Response) -> () { unsafe { mavros_msgs__srv__FileWrite_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , r_errno : msg . r_errno , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; msg . r_errno = self . r_errno ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod LogRequestData { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__mavros_msgs__srv__LogRequestData () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub id : u16 , pub offset : u32 , pub count : u32 } impl WrappedTypesupport for Request { type CStruct = mavros_msgs__srv__LogRequestData_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__srv__LogRequestData_Request () } } fn create_msg () -> * mut mavros_msgs__srv__LogRequestData_Request { unsafe { mavros_msgs__srv__LogRequestData_Request__create () } } fn destroy_msg (msg : * mut mavros_msgs__srv__LogRequestData_Request) -> () { unsafe { mavros_msgs__srv__LogRequestData_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { id : msg . id , offset : msg . offset , count : msg . count , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . id = self . id ; msg . offset = self . offset ; msg . count = self . count ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool } impl WrappedTypesupport for Response { type CStruct = mavros_msgs__srv__LogRequestData_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__srv__LogRequestData_Response () } } fn create_msg () -> * mut mavros_msgs__srv__LogRequestData_Response { unsafe { mavros_msgs__srv__LogRequestData_Response__create () } } fn destroy_msg (msg : * mut mavros_msgs__srv__LogRequestData_Response) -> () { unsafe { mavros_msgs__srv__LogRequestData_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod LogRequestEnd { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__mavros_msgs__srv__LogRequestEnd () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { } impl WrappedTypesupport for Request { type CStruct = mavros_msgs__srv__LogRequestEnd_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__srv__LogRequestEnd_Request () } } fn create_msg () -> * mut mavros_msgs__srv__LogRequestEnd_Request { unsafe { mavros_msgs__srv__LogRequestEnd_Request__create () } } fn destroy_msg (msg : * mut mavros_msgs__srv__LogRequestEnd_Request) -> () { unsafe { mavros_msgs__srv__LogRequestEnd_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool } impl WrappedTypesupport for Response { type CStruct = mavros_msgs__srv__LogRequestEnd_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__srv__LogRequestEnd_Response () } } fn create_msg () -> * mut mavros_msgs__srv__LogRequestEnd_Response { unsafe { mavros_msgs__srv__LogRequestEnd_Response__create () } } fn destroy_msg (msg : * mut mavros_msgs__srv__LogRequestEnd_Response) -> () { unsafe { mavros_msgs__srv__LogRequestEnd_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod LogRequestList { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__mavros_msgs__srv__LogRequestList () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub start : u16 , pub end : u16 } impl WrappedTypesupport for Request { type CStruct = mavros_msgs__srv__LogRequestList_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__srv__LogRequestList_Request () } } fn create_msg () -> * mut mavros_msgs__srv__LogRequestList_Request { unsafe { mavros_msgs__srv__LogRequestList_Request__create () } } fn destroy_msg (msg : * mut mavros_msgs__srv__LogRequestList_Request) -> () { unsafe { mavros_msgs__srv__LogRequestList_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { start : msg . start , end : msg . end , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . start = self . start ; msg . end = self . end ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool } impl WrappedTypesupport for Response { type CStruct = mavros_msgs__srv__LogRequestList_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__srv__LogRequestList_Response () } } fn create_msg () -> * mut mavros_msgs__srv__LogRequestList_Response { unsafe { mavros_msgs__srv__LogRequestList_Response__create () } } fn destroy_msg (msg : * mut mavros_msgs__srv__LogRequestList_Response) -> () { unsafe { mavros_msgs__srv__LogRequestList_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod MessageInterval { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__mavros_msgs__srv__MessageInterval () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub message_id : u32 , pub message_rate : f32 } impl WrappedTypesupport for Request { type CStruct = mavros_msgs__srv__MessageInterval_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__srv__MessageInterval_Request () } } fn create_msg () -> * mut mavros_msgs__srv__MessageInterval_Request { unsafe { mavros_msgs__srv__MessageInterval_Request__create () } } fn destroy_msg (msg : * mut mavros_msgs__srv__MessageInterval_Request) -> () { unsafe { mavros_msgs__srv__MessageInterval_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { message_id : msg . message_id , message_rate : msg . message_rate , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . message_id = self . message_id ; msg . message_rate = self . message_rate ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool } impl WrappedTypesupport for Response { type CStruct = mavros_msgs__srv__MessageInterval_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__srv__MessageInterval_Response () } } fn create_msg () -> * mut mavros_msgs__srv__MessageInterval_Response { unsafe { mavros_msgs__srv__MessageInterval_Response__create () } } fn destroy_msg (msg : * mut mavros_msgs__srv__MessageInterval_Response) -> () { unsafe { mavros_msgs__srv__MessageInterval_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod MountConfigure { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__mavros_msgs__srv__MountConfigure () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub header : std_msgs :: msg :: Header , pub mode : u8 , pub stabilize_roll : bool , pub stabilize_pitch : bool , pub stabilize_yaw : bool , pub roll_input : u8 , pub pitch_input : u8 , pub yaw_input : u8 } impl WrappedTypesupport for Request { type CStruct = mavros_msgs__srv__MountConfigure_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__srv__MountConfigure_Request () } } fn create_msg () -> * mut mavros_msgs__srv__MountConfigure_Request { unsafe { mavros_msgs__srv__MountConfigure_Request__create () } } fn destroy_msg (msg : * mut mavros_msgs__srv__MountConfigure_Request) -> () { unsafe { mavros_msgs__srv__MountConfigure_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { header : std_msgs :: msg :: Header :: from_native (& msg . header) , mode : msg . mode , stabilize_roll : msg . stabilize_roll , stabilize_pitch : msg . stabilize_pitch , stabilize_yaw : msg . stabilize_yaw , roll_input : msg . roll_input , pitch_input : msg . pitch_input , yaw_input : msg . yaw_input , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . mode = self . mode ; msg . stabilize_roll = self . stabilize_roll ; msg . stabilize_pitch = self . stabilize_pitch ; msg . stabilize_yaw = self . stabilize_yaw ; msg . roll_input = self . roll_input ; msg . pitch_input = self . pitch_input ; msg . yaw_input = self . yaw_input ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl Request { pub const INPUT_ANGLE_ABSOLUTE_FRAME : _bindgen_ty_813 = mavros_msgs__srv__MountConfigure_Request__INPUT_ANGLE_ABSOLUTE_FRAME ; pub const INPUT_ANGLE_BODY_FRAME : _bindgen_ty_811 = mavros_msgs__srv__MountConfigure_Request__INPUT_ANGLE_BODY_FRAME ; pub const INPUT_ANGULAR_RATE : _bindgen_ty_812 = mavros_msgs__srv__MountConfigure_Request__INPUT_ANGULAR_RATE ; pub const MODE_GPS_POINT : _bindgen_ty_810 = mavros_msgs__srv__MountConfigure_Request__MODE_GPS_POINT ; pub const MODE_MAVLINK_TARGETING : _bindgen_ty_808 = mavros_msgs__srv__MountConfigure_Request__MODE_MAVLINK_TARGETING ; pub const MODE_NEUTRAL : _bindgen_ty_807 = mavros_msgs__srv__MountConfigure_Request__MODE_NEUTRAL ; pub const MODE_RC_TARGETING : _bindgen_ty_809 = mavros_msgs__srv__MountConfigure_Request__MODE_RC_TARGETING ; pub const MODE_RETRACT : _bindgen_ty_806 = mavros_msgs__srv__MountConfigure_Request__MODE_RETRACT ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool , pub result : u8 } impl WrappedTypesupport for Response { type CStruct = mavros_msgs__srv__MountConfigure_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__srv__MountConfigure_Response () } } fn create_msg () -> * mut mavros_msgs__srv__MountConfigure_Response { unsafe { mavros_msgs__srv__MountConfigure_Response__create () } } fn destroy_msg (msg : * mut mavros_msgs__srv__MountConfigure_Response) -> () { unsafe { mavros_msgs__srv__MountConfigure_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , result : msg . result , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; msg . result = self . result ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod ParamGet { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__mavros_msgs__srv__ParamGet () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub param_id : std :: string :: String } impl WrappedTypesupport for Request { type CStruct = mavros_msgs__srv__ParamGet_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__srv__ParamGet_Request () } } fn create_msg () -> * mut mavros_msgs__srv__ParamGet_Request { unsafe { mavros_msgs__srv__ParamGet_Request__create () } } fn destroy_msg (msg : * mut mavros_msgs__srv__ParamGet_Request) -> () { unsafe { mavros_msgs__srv__ParamGet_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { param_id : msg . param_id . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . param_id . assign (& self . param_id) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool , pub value : mavros_msgs :: msg :: ParamValue } impl WrappedTypesupport for Response { type CStruct = mavros_msgs__srv__ParamGet_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__srv__ParamGet_Response () } } fn create_msg () -> * mut mavros_msgs__srv__ParamGet_Response { unsafe { mavros_msgs__srv__ParamGet_Response__create () } } fn destroy_msg (msg : * mut mavros_msgs__srv__ParamGet_Response) -> () { unsafe { mavros_msgs__srv__ParamGet_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , value : mavros_msgs :: msg :: ParamValue :: from_native (& msg . value) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; self . value . copy_to_native (& mut msg . value) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod ParamPull { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__mavros_msgs__srv__ParamPull () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub force_pull : bool } impl WrappedTypesupport for Request { type CStruct = mavros_msgs__srv__ParamPull_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__srv__ParamPull_Request () } } fn create_msg () -> * mut mavros_msgs__srv__ParamPull_Request { unsafe { mavros_msgs__srv__ParamPull_Request__create () } } fn destroy_msg (msg : * mut mavros_msgs__srv__ParamPull_Request) -> () { unsafe { mavros_msgs__srv__ParamPull_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { force_pull : msg . force_pull , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . force_pull = self . force_pull ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool , pub param_received : u32 } impl WrappedTypesupport for Response { type CStruct = mavros_msgs__srv__ParamPull_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__srv__ParamPull_Response () } } fn create_msg () -> * mut mavros_msgs__srv__ParamPull_Response { unsafe { mavros_msgs__srv__ParamPull_Response__create () } } fn destroy_msg (msg : * mut mavros_msgs__srv__ParamPull_Response) -> () { unsafe { mavros_msgs__srv__ParamPull_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , param_received : msg . param_received , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; msg . param_received = self . param_received ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod ParamPush { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__mavros_msgs__srv__ParamPush () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { } impl WrappedTypesupport for Request { type CStruct = mavros_msgs__srv__ParamPush_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__srv__ParamPush_Request () } } fn create_msg () -> * mut mavros_msgs__srv__ParamPush_Request { unsafe { mavros_msgs__srv__ParamPush_Request__create () } } fn destroy_msg (msg : * mut mavros_msgs__srv__ParamPush_Request) -> () { unsafe { mavros_msgs__srv__ParamPush_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool , pub param_transfered : u32 } impl WrappedTypesupport for Response { type CStruct = mavros_msgs__srv__ParamPush_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__srv__ParamPush_Response () } } fn create_msg () -> * mut mavros_msgs__srv__ParamPush_Response { unsafe { mavros_msgs__srv__ParamPush_Response__create () } } fn destroy_msg (msg : * mut mavros_msgs__srv__ParamPush_Response) -> () { unsafe { mavros_msgs__srv__ParamPush_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , param_transfered : msg . param_transfered , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; msg . param_transfered = self . param_transfered ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod ParamSet { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__mavros_msgs__srv__ParamSet () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub param_id : std :: string :: String , pub value : mavros_msgs :: msg :: ParamValue } impl WrappedTypesupport for Request { type CStruct = mavros_msgs__srv__ParamSet_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__srv__ParamSet_Request () } } fn create_msg () -> * mut mavros_msgs__srv__ParamSet_Request { unsafe { mavros_msgs__srv__ParamSet_Request__create () } } fn destroy_msg (msg : * mut mavros_msgs__srv__ParamSet_Request) -> () { unsafe { mavros_msgs__srv__ParamSet_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { param_id : msg . param_id . to_str () . to_owned () , value : mavros_msgs :: msg :: ParamValue :: from_native (& msg . value) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . param_id . assign (& self . param_id) ; self . value . copy_to_native (& mut msg . value) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool , pub value : mavros_msgs :: msg :: ParamValue } impl WrappedTypesupport for Response { type CStruct = mavros_msgs__srv__ParamSet_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__srv__ParamSet_Response () } } fn create_msg () -> * mut mavros_msgs__srv__ParamSet_Response { unsafe { mavros_msgs__srv__ParamSet_Response__create () } } fn destroy_msg (msg : * mut mavros_msgs__srv__ParamSet_Response) -> () { unsafe { mavros_msgs__srv__ParamSet_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , value : mavros_msgs :: msg :: ParamValue :: from_native (& msg . value) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; self . value . copy_to_native (& mut msg . value) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod ParamSetV2 { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__mavros_msgs__srv__ParamSetV2 () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub force_set : bool , pub param_id : std :: string :: String , pub value : rcl_interfaces :: msg :: ParameterValue } impl WrappedTypesupport for Request { type CStruct = mavros_msgs__srv__ParamSetV2_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__srv__ParamSetV2_Request () } } fn create_msg () -> * mut mavros_msgs__srv__ParamSetV2_Request { unsafe { mavros_msgs__srv__ParamSetV2_Request__create () } } fn destroy_msg (msg : * mut mavros_msgs__srv__ParamSetV2_Request) -> () { unsafe { mavros_msgs__srv__ParamSetV2_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { force_set : msg . force_set , param_id : msg . param_id . to_str () . to_owned () , value : rcl_interfaces :: msg :: ParameterValue :: from_native (& msg . value) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . force_set = self . force_set ; msg . param_id . assign (& self . param_id) ; self . value . copy_to_native (& mut msg . value) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool , pub value : rcl_interfaces :: msg :: ParameterValue } impl WrappedTypesupport for Response { type CStruct = mavros_msgs__srv__ParamSetV2_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__srv__ParamSetV2_Response () } } fn create_msg () -> * mut mavros_msgs__srv__ParamSetV2_Response { unsafe { mavros_msgs__srv__ParamSetV2_Response__create () } } fn destroy_msg (msg : * mut mavros_msgs__srv__ParamSetV2_Response) -> () { unsafe { mavros_msgs__srv__ParamSetV2_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , value : rcl_interfaces :: msg :: ParameterValue :: from_native (& msg . value) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; self . value . copy_to_native (& mut msg . value) ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod SetMavFrame { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__mavros_msgs__srv__SetMavFrame () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub mav_frame : u8 } impl WrappedTypesupport for Request { type CStruct = mavros_msgs__srv__SetMavFrame_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__srv__SetMavFrame_Request () } } fn create_msg () -> * mut mavros_msgs__srv__SetMavFrame_Request { unsafe { mavros_msgs__srv__SetMavFrame_Request__create () } } fn destroy_msg (msg : * mut mavros_msgs__srv__SetMavFrame_Request) -> () { unsafe { mavros_msgs__srv__SetMavFrame_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { mav_frame : msg . mav_frame , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . mav_frame = self . mav_frame ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl Request { pub const FRAME_BODY_FRD : _bindgen_ty_826 = mavros_msgs__srv__SetMavFrame_Request__FRAME_BODY_FRD ; pub const FRAME_BODY_NED : _bindgen_ty_822 = mavros_msgs__srv__SetMavFrame_Request__FRAME_BODY_NED ; pub const FRAME_BODY_OFFSET_NED : _bindgen_ty_823 = mavros_msgs__srv__SetMavFrame_Request__FRAME_BODY_OFFSET_NED ; pub const FRAME_GLOBAL : _bindgen_ty_814 = mavros_msgs__srv__SetMavFrame_Request__FRAME_GLOBAL ; pub const FRAME_GLOBAL_INT : _bindgen_ty_819 = mavros_msgs__srv__SetMavFrame_Request__FRAME_GLOBAL_INT ; pub const FRAME_GLOBAL_RELATIVE_ALT : _bindgen_ty_817 = mavros_msgs__srv__SetMavFrame_Request__FRAME_GLOBAL_RELATIVE_ALT ; pub const FRAME_GLOBAL_RELATIVE_ALT_INT : _bindgen_ty_820 = mavros_msgs__srv__SetMavFrame_Request__FRAME_GLOBAL_RELATIVE_ALT_INT ; pub const FRAME_GLOBAL_TERRAIN_ALT : _bindgen_ty_824 = mavros_msgs__srv__SetMavFrame_Request__FRAME_GLOBAL_TERRAIN_ALT ; pub const FRAME_GLOBAL_TERRAIN_ALT_INT : _bindgen_ty_825 = mavros_msgs__srv__SetMavFrame_Request__FRAME_GLOBAL_TERRAIN_ALT_INT ; pub const FRAME_LOCAL_ENU : _bindgen_ty_818 = mavros_msgs__srv__SetMavFrame_Request__FRAME_LOCAL_ENU ; pub const FRAME_LOCAL_FLU : _bindgen_ty_835 = mavros_msgs__srv__SetMavFrame_Request__FRAME_LOCAL_FLU ; pub const FRAME_LOCAL_FRD : _bindgen_ty_834 = mavros_msgs__srv__SetMavFrame_Request__FRAME_LOCAL_FRD ; pub const FRAME_LOCAL_NED : _bindgen_ty_815 = mavros_msgs__srv__SetMavFrame_Request__FRAME_LOCAL_NED ; pub const FRAME_LOCAL_OFFSET_NED : _bindgen_ty_821 = mavros_msgs__srv__SetMavFrame_Request__FRAME_LOCAL_OFFSET_NED ; pub const FRAME_MISSION : _bindgen_ty_816 = mavros_msgs__srv__SetMavFrame_Request__FRAME_MISSION ; pub const FRAME_RESERVED_13 : _bindgen_ty_827 = mavros_msgs__srv__SetMavFrame_Request__FRAME_RESERVED_13 ; pub const FRAME_RESERVED_14 : _bindgen_ty_828 = mavros_msgs__srv__SetMavFrame_Request__FRAME_RESERVED_14 ; pub const FRAME_RESERVED_15 : _bindgen_ty_829 = mavros_msgs__srv__SetMavFrame_Request__FRAME_RESERVED_15 ; pub const FRAME_RESERVED_16 : _bindgen_ty_830 = mavros_msgs__srv__SetMavFrame_Request__FRAME_RESERVED_16 ; pub const FRAME_RESERVED_17 : _bindgen_ty_831 = mavros_msgs__srv__SetMavFrame_Request__FRAME_RESERVED_17 ; pub const FRAME_RESERVED_18 : _bindgen_ty_832 = mavros_msgs__srv__SetMavFrame_Request__FRAME_RESERVED_18 ; pub const FRAME_RESERVED_19 : _bindgen_ty_833 = mavros_msgs__srv__SetMavFrame_Request__FRAME_RESERVED_19 ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool } impl WrappedTypesupport for Response { type CStruct = mavros_msgs__srv__SetMavFrame_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__srv__SetMavFrame_Response () } } fn create_msg () -> * mut mavros_msgs__srv__SetMavFrame_Response { unsafe { mavros_msgs__srv__SetMavFrame_Response__create () } } fn destroy_msg (msg : * mut mavros_msgs__srv__SetMavFrame_Response) -> () { unsafe { mavros_msgs__srv__SetMavFrame_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod SetMode { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__mavros_msgs__srv__SetMode () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub base_mode : u8 , pub custom_mode : std :: string :: String } impl WrappedTypesupport for Request { type CStruct = mavros_msgs__srv__SetMode_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__srv__SetMode_Request () } } fn create_msg () -> * mut mavros_msgs__srv__SetMode_Request { unsafe { mavros_msgs__srv__SetMode_Request__create () } } fn destroy_msg (msg : * mut mavros_msgs__srv__SetMode_Request) -> () { unsafe { mavros_msgs__srv__SetMode_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { base_mode : msg . base_mode , custom_mode : msg . custom_mode . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . base_mode = self . base_mode ; msg . custom_mode . assign (& self . custom_mode) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl Request { pub const MAV_MODE_AUTO_ARMED : _bindgen_ty_844 = mavros_msgs__srv__SetMode_Request__MAV_MODE_AUTO_ARMED ; pub const MAV_MODE_AUTO_DISARMED : _bindgen_ty_843 = mavros_msgs__srv__SetMode_Request__MAV_MODE_AUTO_DISARMED ; pub const MAV_MODE_GUIDED_ARMED : _bindgen_ty_842 = mavros_msgs__srv__SetMode_Request__MAV_MODE_GUIDED_ARMED ; pub const MAV_MODE_GUIDED_DISARMED : _bindgen_ty_841 = mavros_msgs__srv__SetMode_Request__MAV_MODE_GUIDED_DISARMED ; pub const MAV_MODE_MANUAL_ARMED : _bindgen_ty_840 = mavros_msgs__srv__SetMode_Request__MAV_MODE_MANUAL_ARMED ; pub const MAV_MODE_MANUAL_DISARMED : _bindgen_ty_839 = mavros_msgs__srv__SetMode_Request__MAV_MODE_MANUAL_DISARMED ; pub const MAV_MODE_PREFLIGHT : _bindgen_ty_836 = mavros_msgs__srv__SetMode_Request__MAV_MODE_PREFLIGHT ; pub const MAV_MODE_STABILIZE_ARMED : _bindgen_ty_838 = mavros_msgs__srv__SetMode_Request__MAV_MODE_STABILIZE_ARMED ; pub const MAV_MODE_STABILIZE_DISARMED : _bindgen_ty_837 = mavros_msgs__srv__SetMode_Request__MAV_MODE_STABILIZE_DISARMED ; pub const MAV_MODE_TEST_ARMED : _bindgen_ty_846 = mavros_msgs__srv__SetMode_Request__MAV_MODE_TEST_ARMED ; pub const MAV_MODE_TEST_DISARMED : _bindgen_ty_845 = mavros_msgs__srv__SetMode_Request__MAV_MODE_TEST_DISARMED ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub mode_sent : bool } impl WrappedTypesupport for Response { type CStruct = mavros_msgs__srv__SetMode_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__srv__SetMode_Response () } } fn create_msg () -> * mut mavros_msgs__srv__SetMode_Response { unsafe { mavros_msgs__srv__SetMode_Response__create () } } fn destroy_msg (msg : * mut mavros_msgs__srv__SetMode_Response) -> () { unsafe { mavros_msgs__srv__SetMode_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { mode_sent : msg . mode_sent , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . mode_sent = self . mode_sent ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod StreamRate { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__mavros_msgs__srv__StreamRate () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub stream_id : u8 , pub message_rate : u16 , pub on_off : bool } impl WrappedTypesupport for Request { type CStruct = mavros_msgs__srv__StreamRate_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__srv__StreamRate_Request () } } fn create_msg () -> * mut mavros_msgs__srv__StreamRate_Request { unsafe { mavros_msgs__srv__StreamRate_Request__create () } } fn destroy_msg (msg : * mut mavros_msgs__srv__StreamRate_Request) -> () { unsafe { mavros_msgs__srv__StreamRate_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { stream_id : msg . stream_id , message_rate : msg . message_rate , on_off : msg . on_off , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . stream_id = self . stream_id ; msg . message_rate = self . message_rate ; msg . on_off = self . on_off ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl Request { pub const STREAM_ALL : _bindgen_ty_847 = mavros_msgs__srv__StreamRate_Request__STREAM_ALL ; pub const STREAM_EXTENDED_STATUS : _bindgen_ty_849 = mavros_msgs__srv__StreamRate_Request__STREAM_EXTENDED_STATUS ; pub const STREAM_EXTRA1 : _bindgen_ty_853 = mavros_msgs__srv__StreamRate_Request__STREAM_EXTRA1 ; pub const STREAM_EXTRA2 : _bindgen_ty_854 = mavros_msgs__srv__StreamRate_Request__STREAM_EXTRA2 ; pub const STREAM_EXTRA3 : _bindgen_ty_855 = mavros_msgs__srv__StreamRate_Request__STREAM_EXTRA3 ; pub const STREAM_POSITION : _bindgen_ty_852 = mavros_msgs__srv__StreamRate_Request__STREAM_POSITION ; pub const STREAM_RAW_CONTROLLER : _bindgen_ty_851 = mavros_msgs__srv__StreamRate_Request__STREAM_RAW_CONTROLLER ; pub const STREAM_RAW_SENSORS : _bindgen_ty_848 = mavros_msgs__srv__StreamRate_Request__STREAM_RAW_SENSORS ; pub const STREAM_RC_CHANNELS : _bindgen_ty_850 = mavros_msgs__srv__StreamRate_Request__STREAM_RC_CHANNELS ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { } impl WrappedTypesupport for Response { type CStruct = mavros_msgs__srv__StreamRate_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__srv__StreamRate_Response () } } fn create_msg () -> * mut mavros_msgs__srv__StreamRate_Response { unsafe { mavros_msgs__srv__StreamRate_Response__create () } } fn destroy_msg (msg : * mut mavros_msgs__srv__StreamRate_Response) -> () { unsafe { mavros_msgs__srv__StreamRate_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod VehicleInfoGet { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__mavros_msgs__srv__VehicleInfoGet () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub sysid : u8 , pub compid : u8 , pub get_all : bool } impl WrappedTypesupport for Request { type CStruct = mavros_msgs__srv__VehicleInfoGet_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__srv__VehicleInfoGet_Request () } } fn create_msg () -> * mut mavros_msgs__srv__VehicleInfoGet_Request { unsafe { mavros_msgs__srv__VehicleInfoGet_Request__create () } } fn destroy_msg (msg : * mut mavros_msgs__srv__VehicleInfoGet_Request) -> () { unsafe { mavros_msgs__srv__VehicleInfoGet_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { sysid : msg . sysid , compid : msg . compid , get_all : msg . get_all , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . sysid = self . sysid ; msg . compid = self . compid ; msg . get_all = self . get_all ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl Request { pub const GET_MY_COMPID : _bindgen_ty_857 = mavros_msgs__srv__VehicleInfoGet_Request__GET_MY_COMPID ; pub const GET_MY_SYSID : _bindgen_ty_856 = mavros_msgs__srv__VehicleInfoGet_Request__GET_MY_SYSID ; } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool , pub vehicles : Vec < mavros_msgs :: msg :: VehicleInfo > } impl WrappedTypesupport for Response { type CStruct = mavros_msgs__srv__VehicleInfoGet_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__srv__VehicleInfoGet_Response () } } fn create_msg () -> * mut mavros_msgs__srv__VehicleInfoGet_Response { unsafe { mavros_msgs__srv__VehicleInfoGet_Response__create () } } fn destroy_msg (msg : * mut mavros_msgs__srv__VehicleInfoGet_Response) -> () { unsafe { mavros_msgs__srv__VehicleInfoGet_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , vehicles : { let mut temp = Vec :: with_capacity (msg . vehicles . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . vehicles . data , msg . vehicles . size) } ; for s in slice { temp . push (mavros_msgs :: msg :: VehicleInfo :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; unsafe { mavros_msgs__msg__VehicleInfo__Sequence__fini (& mut msg . vehicles) ; mavros_msgs__msg__VehicleInfo__Sequence__init (& mut msg . vehicles , self . vehicles . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . vehicles . data , msg . vehicles . size) ; for (t , s) in slice . iter_mut () . zip (& self . vehicles) { s . copy_to_native (t) ; } } } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod WaypointClear { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__mavros_msgs__srv__WaypointClear () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { } impl WrappedTypesupport for Request { type CStruct = mavros_msgs__srv__WaypointClear_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__srv__WaypointClear_Request () } } fn create_msg () -> * mut mavros_msgs__srv__WaypointClear_Request { unsafe { mavros_msgs__srv__WaypointClear_Request__create () } } fn destroy_msg (msg : * mut mavros_msgs__srv__WaypointClear_Request) -> () { unsafe { mavros_msgs__srv__WaypointClear_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool } impl WrappedTypesupport for Response { type CStruct = mavros_msgs__srv__WaypointClear_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__srv__WaypointClear_Response () } } fn create_msg () -> * mut mavros_msgs__srv__WaypointClear_Response { unsafe { mavros_msgs__srv__WaypointClear_Response__create () } } fn destroy_msg (msg : * mut mavros_msgs__srv__WaypointClear_Response) -> () { unsafe { mavros_msgs__srv__WaypointClear_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod WaypointPull { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__mavros_msgs__srv__WaypointPull () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { } impl WrappedTypesupport for Request { type CStruct = mavros_msgs__srv__WaypointPull_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__srv__WaypointPull_Request () } } fn create_msg () -> * mut mavros_msgs__srv__WaypointPull_Request { unsafe { mavros_msgs__srv__WaypointPull_Request__create () } } fn destroy_msg (msg : * mut mavros_msgs__srv__WaypointPull_Request) -> () { unsafe { mavros_msgs__srv__WaypointPull_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool , pub wp_received : u32 } impl WrappedTypesupport for Response { type CStruct = mavros_msgs__srv__WaypointPull_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__srv__WaypointPull_Response () } } fn create_msg () -> * mut mavros_msgs__srv__WaypointPull_Response { unsafe { mavros_msgs__srv__WaypointPull_Response__create () } } fn destroy_msg (msg : * mut mavros_msgs__srv__WaypointPull_Response) -> () { unsafe { mavros_msgs__srv__WaypointPull_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , wp_received : msg . wp_received , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; msg . wp_received = self . wp_received ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod WaypointPush { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__mavros_msgs__srv__WaypointPush () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub start_index : u16 , pub waypoints : Vec < mavros_msgs :: msg :: Waypoint > } impl WrappedTypesupport for Request { type CStruct = mavros_msgs__srv__WaypointPush_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__srv__WaypointPush_Request () } } fn create_msg () -> * mut mavros_msgs__srv__WaypointPush_Request { unsafe { mavros_msgs__srv__WaypointPush_Request__create () } } fn destroy_msg (msg : * mut mavros_msgs__srv__WaypointPush_Request) -> () { unsafe { mavros_msgs__srv__WaypointPush_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { start_index : msg . start_index , waypoints : { let mut temp = Vec :: with_capacity (msg . waypoints . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . waypoints . data , msg . waypoints . size) } ; for s in slice { temp . push (mavros_msgs :: msg :: Waypoint :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . start_index = self . start_index ; unsafe { mavros_msgs__msg__Waypoint__Sequence__fini (& mut msg . waypoints) ; mavros_msgs__msg__Waypoint__Sequence__init (& mut msg . waypoints , self . waypoints . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . waypoints . data , msg . waypoints . size) ; for (t , s) in slice . iter_mut () . zip (& self . waypoints) { s . copy_to_native (t) ; } } } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool , pub wp_transfered : u32 } impl WrappedTypesupport for Response { type CStruct = mavros_msgs__srv__WaypointPush_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__srv__WaypointPush_Response () } } fn create_msg () -> * mut mavros_msgs__srv__WaypointPush_Response { unsafe { mavros_msgs__srv__WaypointPush_Response__create () } } fn destroy_msg (msg : * mut mavros_msgs__srv__WaypointPush_Response) -> () { unsafe { mavros_msgs__srv__WaypointPush_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , wp_transfered : msg . wp_transfered , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; msg . wp_transfered = self . wp_transfered ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod WaypointSetCurrent { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__mavros_msgs__srv__WaypointSetCurrent () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub wp_seq : u16 } impl WrappedTypesupport for Request { type CStruct = mavros_msgs__srv__WaypointSetCurrent_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__srv__WaypointSetCurrent_Request () } } fn create_msg () -> * mut mavros_msgs__srv__WaypointSetCurrent_Request { unsafe { mavros_msgs__srv__WaypointSetCurrent_Request__create () } } fn destroy_msg (msg : * mut mavros_msgs__srv__WaypointSetCurrent_Request) -> () { unsafe { mavros_msgs__srv__WaypointSetCurrent_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { wp_seq : msg . wp_seq , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . wp_seq = self . wp_seq ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool } impl WrappedTypesupport for Response { type CStruct = mavros_msgs__srv__WaypointSetCurrent_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__mavros_msgs__srv__WaypointSetCurrent_Response () } } fn create_msg () -> * mut mavros_msgs__srv__WaypointSetCurrent_Response { unsafe { mavros_msgs__srv__WaypointSetCurrent_Response__create () } } fn destroy_msg (msg : * mut mavros_msgs__srv__WaypointSetCurrent_Response) -> () { unsafe { mavros_msgs__srv__WaypointSetCurrent_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } }