pub mod msg { use super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Status { pub operating_mode : u16 , pub area_number : u16 , pub error_status : bool , pub error_code : u16 , pub lockout_status : bool , pub distance : u16 , pub angle : f32 } impl WrappedTypesupport for Status { type CStruct = urg_node_msgs__msg__Status ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__urg_node_msgs__msg__Status () } } fn create_msg () -> * mut urg_node_msgs__msg__Status { unsafe { urg_node_msgs__msg__Status__create () } } fn destroy_msg (msg : * mut urg_node_msgs__msg__Status) -> () { unsafe { urg_node_msgs__msg__Status__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Status { Status { operating_mode : msg . operating_mode , area_number : msg . area_number , error_status : msg . error_status , error_code : msg . error_code , lockout_status : msg . lockout_status , distance : msg . distance , angle : msg . angle , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . operating_mode = self . operating_mode ; msg . area_number = self . area_number ; msg . error_status = self . error_status ; msg . error_code = self . error_code ; msg . lockout_status = self . lockout_status ; msg . distance = self . distance ; msg . angle = self . angle ; } } impl Default for Status { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Status > :: new () ; Status :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl Status { pub const NORMAL : _bindgen_ty_2545 = urg_node_msgs__msg__Status__NORMAL ; pub const SETTING : _bindgen_ty_2546 = urg_node_msgs__msg__Status__SETTING ; } }