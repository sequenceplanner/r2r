pub mod srv { # [allow (non_snake_case)] pub mod SetInt { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__webots_ros2_msgs__srv__SetInt () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub value : i32 } impl WrappedTypesupport for Request { type CStruct = webots_ros2_msgs__srv__SetInt_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__webots_ros2_msgs__srv__SetInt_Request () } } fn create_msg () -> * mut webots_ros2_msgs__srv__SetInt_Request { unsafe { webots_ros2_msgs__srv__SetInt_Request__create () } } fn destroy_msg (msg : * mut webots_ros2_msgs__srv__SetInt_Request) -> () { unsafe { webots_ros2_msgs__srv__SetInt_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { value : msg . value , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . value = self . value ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool } impl WrappedTypesupport for Response { type CStruct = webots_ros2_msgs__srv__SetInt_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__webots_ros2_msgs__srv__SetInt_Response () } } fn create_msg () -> * mut webots_ros2_msgs__srv__SetInt_Response { unsafe { webots_ros2_msgs__srv__SetInt_Response__create () } } fn destroy_msg (msg : * mut webots_ros2_msgs__srv__SetInt_Response) -> () { unsafe { webots_ros2_msgs__srv__SetInt_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } # [allow (non_snake_case)] pub mod SpawnUrdfRobot { use super :: super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] pub struct Service () ; impl WrappedServiceTypeSupport for Service { type Request = Request ; type Response = Response ; fn get_ts () -> & 'static rosidl_service_type_support_t { unsafe { & * rosidl_typesupport_c__get_service_type_support_handle__webots_ros2_msgs__srv__SpawnUrdfRobot () } } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Request { pub robot : webots_ros2_msgs :: msg :: UrdfRobot } impl WrappedTypesupport for Request { type CStruct = webots_ros2_msgs__srv__SpawnUrdfRobot_Request ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__webots_ros2_msgs__srv__SpawnUrdfRobot_Request () } } fn create_msg () -> * mut webots_ros2_msgs__srv__SpawnUrdfRobot_Request { unsafe { webots_ros2_msgs__srv__SpawnUrdfRobot_Request__create () } } fn destroy_msg (msg : * mut webots_ros2_msgs__srv__SpawnUrdfRobot_Request) -> () { unsafe { webots_ros2_msgs__srv__SpawnUrdfRobot_Request__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Request { Request { robot : webots_ros2_msgs :: msg :: UrdfRobot :: from_native (& msg . robot) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . robot . copy_to_native (& mut msg . robot) ; } } impl Default for Request { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Request > :: new () ; Request :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Response { pub success : bool } impl WrappedTypesupport for Response { type CStruct = webots_ros2_msgs__srv__SpawnUrdfRobot_Response ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__webots_ros2_msgs__srv__SpawnUrdfRobot_Response () } } fn create_msg () -> * mut webots_ros2_msgs__srv__SpawnUrdfRobot_Response { unsafe { webots_ros2_msgs__srv__SpawnUrdfRobot_Response__create () } } fn destroy_msg (msg : * mut webots_ros2_msgs__srv__SpawnUrdfRobot_Response) -> () { unsafe { webots_ros2_msgs__srv__SpawnUrdfRobot_Response__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Response { Response { success : msg . success , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . success = self . success ; } } impl Default for Response { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Response > :: new () ; Response :: from_native (& msg_native) } } } } pub mod msg { use super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct CameraRecognitionObject { pub id : i32 , pub pose : geometry_msgs :: msg :: PoseStamped , pub bbox : vision_msgs :: msg :: BoundingBox2D , pub colors : Vec < std_msgs :: msg :: ColorRGBA > , pub model : std :: string :: String } impl WrappedTypesupport for CameraRecognitionObject { type CStruct = webots_ros2_msgs__msg__CameraRecognitionObject ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__webots_ros2_msgs__msg__CameraRecognitionObject () } } fn create_msg () -> * mut webots_ros2_msgs__msg__CameraRecognitionObject { unsafe { webots_ros2_msgs__msg__CameraRecognitionObject__create () } } fn destroy_msg (msg : * mut webots_ros2_msgs__msg__CameraRecognitionObject) -> () { unsafe { webots_ros2_msgs__msg__CameraRecognitionObject__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> CameraRecognitionObject { CameraRecognitionObject { id : msg . id , pose : geometry_msgs :: msg :: PoseStamped :: from_native (& msg . pose) , bbox : vision_msgs :: msg :: BoundingBox2D :: from_native (& msg . bbox) , colors : { let mut temp = Vec :: with_capacity (msg . colors . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . colors . data , msg . colors . size) } ; for s in slice { temp . push (std_msgs :: msg :: ColorRGBA :: from_native (s)) ; } temp } , model : msg . model . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . id = self . id ; self . pose . copy_to_native (& mut msg . pose) ; self . bbox . copy_to_native (& mut msg . bbox) ; unsafe { std_msgs__msg__ColorRGBA__Sequence__fini (& mut msg . colors) ; std_msgs__msg__ColorRGBA__Sequence__init (& mut msg . colors , self . colors . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . colors . data , msg . colors . size) ; for (t , s) in slice . iter_mut () . zip (& self . colors) { s . copy_to_native (t) ; } } msg . model . assign (& self . model) ; } } impl Default for CameraRecognitionObject { fn default () -> Self { let msg_native = WrappedNativeMsg :: < CameraRecognitionObject > :: new () ; CameraRecognitionObject :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct CameraRecognitionObjects { pub header : std_msgs :: msg :: Header , pub objects : Vec < webots_ros2_msgs :: msg :: CameraRecognitionObject > } impl WrappedTypesupport for CameraRecognitionObjects { type CStruct = webots_ros2_msgs__msg__CameraRecognitionObjects ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__webots_ros2_msgs__msg__CameraRecognitionObjects () } } fn create_msg () -> * mut webots_ros2_msgs__msg__CameraRecognitionObjects { unsafe { webots_ros2_msgs__msg__CameraRecognitionObjects__create () } } fn destroy_msg (msg : * mut webots_ros2_msgs__msg__CameraRecognitionObjects) -> () { unsafe { webots_ros2_msgs__msg__CameraRecognitionObjects__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> CameraRecognitionObjects { CameraRecognitionObjects { header : std_msgs :: msg :: Header :: from_native (& msg . header) , objects : { let mut temp = Vec :: with_capacity (msg . objects . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . objects . data , msg . objects . size) } ; for s in slice { temp . push (webots_ros2_msgs :: msg :: CameraRecognitionObject :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; unsafe { webots_ros2_msgs__msg__CameraRecognitionObject__Sequence__fini (& mut msg . objects) ; webots_ros2_msgs__msg__CameraRecognitionObject__Sequence__init (& mut msg . objects , self . objects . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . objects . data , msg . objects . size) ; for (t , s) in slice . iter_mut () . zip (& self . objects) { s . copy_to_native (t) ; } } } } impl Default for CameraRecognitionObjects { fn default () -> Self { let msg_native = WrappedNativeMsg :: < CameraRecognitionObjects > :: new () ; CameraRecognitionObjects :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct UrdfRobot { pub name : std :: string :: String , pub urdf_path : std :: string :: String , pub robot_description : std :: string :: String , pub relative_path_prefix : std :: string :: String , pub translation : std :: string :: String , pub rotation : std :: string :: String , pub normal : bool , pub box_collision : bool , pub init_pos : std :: string :: String } impl WrappedTypesupport for UrdfRobot { type CStruct = webots_ros2_msgs__msg__UrdfRobot ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__webots_ros2_msgs__msg__UrdfRobot () } } fn create_msg () -> * mut webots_ros2_msgs__msg__UrdfRobot { unsafe { webots_ros2_msgs__msg__UrdfRobot__create () } } fn destroy_msg (msg : * mut webots_ros2_msgs__msg__UrdfRobot) -> () { unsafe { webots_ros2_msgs__msg__UrdfRobot__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> UrdfRobot { UrdfRobot { name : msg . name . to_str () . to_owned () , urdf_path : msg . urdf_path . to_str () . to_owned () , robot_description : msg . robot_description . to_str () . to_owned () , relative_path_prefix : msg . relative_path_prefix . to_str () . to_owned () , translation : msg . translation . to_str () . to_owned () , rotation : msg . rotation . to_str () . to_owned () , normal : msg . normal , box_collision : msg . box_collision , init_pos : msg . init_pos . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . name . assign (& self . name) ; msg . urdf_path . assign (& self . urdf_path) ; msg . robot_description . assign (& self . robot_description) ; msg . relative_path_prefix . assign (& self . relative_path_prefix) ; msg . translation . assign (& self . translation) ; msg . rotation . assign (& self . rotation) ; msg . normal = self . normal ; msg . box_collision = self . box_collision ; msg . init_pos . assign (& self . init_pos) ; } } impl Default for UrdfRobot { fn default () -> Self { let msg_native = WrappedNativeMsg :: < UrdfRobot > :: new () ; UrdfRobot :: from_native (& msg_native) } } }