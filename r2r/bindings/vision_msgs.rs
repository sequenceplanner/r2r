pub mod msg { use super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct BoundingBox2D { pub center : geometry_msgs :: msg :: Pose2D , pub size_x : f64 , pub size_y : f64 } impl WrappedTypesupport for BoundingBox2D { type CStruct = vision_msgs__msg__BoundingBox2D ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__vision_msgs__msg__BoundingBox2D () } } fn create_msg () -> * mut vision_msgs__msg__BoundingBox2D { unsafe { vision_msgs__msg__BoundingBox2D__create () } } fn destroy_msg (msg : * mut vision_msgs__msg__BoundingBox2D) -> () { unsafe { vision_msgs__msg__BoundingBox2D__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> BoundingBox2D { BoundingBox2D { center : geometry_msgs :: msg :: Pose2D :: from_native (& msg . center) , size_x : msg . size_x , size_y : msg . size_y , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . center . copy_to_native (& mut msg . center) ; msg . size_x = self . size_x ; msg . size_y = self . size_y ; } } impl Default for BoundingBox2D { fn default () -> Self { let msg_native = WrappedNativeMsg :: < BoundingBox2D > :: new () ; BoundingBox2D :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct BoundingBox3D { pub center : geometry_msgs :: msg :: Pose , pub size : geometry_msgs :: msg :: Vector3 } impl WrappedTypesupport for BoundingBox3D { type CStruct = vision_msgs__msg__BoundingBox3D ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__vision_msgs__msg__BoundingBox3D () } } fn create_msg () -> * mut vision_msgs__msg__BoundingBox3D { unsafe { vision_msgs__msg__BoundingBox3D__create () } } fn destroy_msg (msg : * mut vision_msgs__msg__BoundingBox3D) -> () { unsafe { vision_msgs__msg__BoundingBox3D__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> BoundingBox3D { BoundingBox3D { center : geometry_msgs :: msg :: Pose :: from_native (& msg . center) , size : geometry_msgs :: msg :: Vector3 :: from_native (& msg . size) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . center . copy_to_native (& mut msg . center) ; self . size . copy_to_native (& mut msg . size) ; } } impl Default for BoundingBox3D { fn default () -> Self { let msg_native = WrappedNativeMsg :: < BoundingBox3D > :: new () ; BoundingBox3D :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct BoundingBox3DArray { pub header : std_msgs :: msg :: Header , pub boxes : Vec < vision_msgs :: msg :: BoundingBox3D > } impl WrappedTypesupport for BoundingBox3DArray { type CStruct = vision_msgs__msg__BoundingBox3DArray ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__vision_msgs__msg__BoundingBox3DArray () } } fn create_msg () -> * mut vision_msgs__msg__BoundingBox3DArray { unsafe { vision_msgs__msg__BoundingBox3DArray__create () } } fn destroy_msg (msg : * mut vision_msgs__msg__BoundingBox3DArray) -> () { unsafe { vision_msgs__msg__BoundingBox3DArray__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> BoundingBox3DArray { BoundingBox3DArray { header : std_msgs :: msg :: Header :: from_native (& msg . header) , boxes : { let mut temp = Vec :: with_capacity (msg . boxes . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . boxes . data , msg . boxes . size) } ; for s in slice { temp . push (vision_msgs :: msg :: BoundingBox3D :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; unsafe { vision_msgs__msg__BoundingBox3D__Sequence__fini (& mut msg . boxes) ; vision_msgs__msg__BoundingBox3D__Sequence__init (& mut msg . boxes , self . boxes . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . boxes . data , msg . boxes . size) ; for (t , s) in slice . iter_mut () . zip (& self . boxes) { s . copy_to_native (t) ; } } } } impl Default for BoundingBox3DArray { fn default () -> Self { let msg_native = WrappedNativeMsg :: < BoundingBox3DArray > :: new () ; BoundingBox3DArray :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Classification { pub header : std_msgs :: msg :: Header , pub results : Vec < vision_msgs :: msg :: ObjectHypothesis > } impl WrappedTypesupport for Classification { type CStruct = vision_msgs__msg__Classification ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__vision_msgs__msg__Classification () } } fn create_msg () -> * mut vision_msgs__msg__Classification { unsafe { vision_msgs__msg__Classification__create () } } fn destroy_msg (msg : * mut vision_msgs__msg__Classification) -> () { unsafe { vision_msgs__msg__Classification__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Classification { Classification { header : std_msgs :: msg :: Header :: from_native (& msg . header) , results : { let mut temp = Vec :: with_capacity (msg . results . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . results . data , msg . results . size) } ; for s in slice { temp . push (vision_msgs :: msg :: ObjectHypothesis :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; unsafe { vision_msgs__msg__ObjectHypothesis__Sequence__fini (& mut msg . results) ; vision_msgs__msg__ObjectHypothesis__Sequence__init (& mut msg . results , self . results . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . results . data , msg . results . size) ; for (t , s) in slice . iter_mut () . zip (& self . results) { s . copy_to_native (t) ; } } } } impl Default for Classification { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Classification > :: new () ; Classification :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Detection2D { pub header : std_msgs :: msg :: Header , pub results : Vec < vision_msgs :: msg :: ObjectHypothesisWithPose > , pub bbox : vision_msgs :: msg :: BoundingBox2D , pub id : std :: string :: String } impl WrappedTypesupport for Detection2D { type CStruct = vision_msgs__msg__Detection2D ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__vision_msgs__msg__Detection2D () } } fn create_msg () -> * mut vision_msgs__msg__Detection2D { unsafe { vision_msgs__msg__Detection2D__create () } } fn destroy_msg (msg : * mut vision_msgs__msg__Detection2D) -> () { unsafe { vision_msgs__msg__Detection2D__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Detection2D { Detection2D { header : std_msgs :: msg :: Header :: from_native (& msg . header) , results : { let mut temp = Vec :: with_capacity (msg . results . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . results . data , msg . results . size) } ; for s in slice { temp . push (vision_msgs :: msg :: ObjectHypothesisWithPose :: from_native (s)) ; } temp } , bbox : vision_msgs :: msg :: BoundingBox2D :: from_native (& msg . bbox) , id : msg . id . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; unsafe { vision_msgs__msg__ObjectHypothesisWithPose__Sequence__fini (& mut msg . results) ; vision_msgs__msg__ObjectHypothesisWithPose__Sequence__init (& mut msg . results , self . results . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . results . data , msg . results . size) ; for (t , s) in slice . iter_mut () . zip (& self . results) { s . copy_to_native (t) ; } } self . bbox . copy_to_native (& mut msg . bbox) ; msg . id . assign (& self . id) ; } } impl Default for Detection2D { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Detection2D > :: new () ; Detection2D :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Detection2DArray { pub header : std_msgs :: msg :: Header , pub detections : Vec < vision_msgs :: msg :: Detection2D > } impl WrappedTypesupport for Detection2DArray { type CStruct = vision_msgs__msg__Detection2DArray ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__vision_msgs__msg__Detection2DArray () } } fn create_msg () -> * mut vision_msgs__msg__Detection2DArray { unsafe { vision_msgs__msg__Detection2DArray__create () } } fn destroy_msg (msg : * mut vision_msgs__msg__Detection2DArray) -> () { unsafe { vision_msgs__msg__Detection2DArray__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Detection2DArray { Detection2DArray { header : std_msgs :: msg :: Header :: from_native (& msg . header) , detections : { let mut temp = Vec :: with_capacity (msg . detections . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . detections . data , msg . detections . size) } ; for s in slice { temp . push (vision_msgs :: msg :: Detection2D :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; unsafe { vision_msgs__msg__Detection2D__Sequence__fini (& mut msg . detections) ; vision_msgs__msg__Detection2D__Sequence__init (& mut msg . detections , self . detections . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . detections . data , msg . detections . size) ; for (t , s) in slice . iter_mut () . zip (& self . detections) { s . copy_to_native (t) ; } } } } impl Default for Detection2DArray { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Detection2DArray > :: new () ; Detection2DArray :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Detection3D { pub header : std_msgs :: msg :: Header , pub results : Vec < vision_msgs :: msg :: ObjectHypothesisWithPose > , pub bbox : vision_msgs :: msg :: BoundingBox3D , pub id : std :: string :: String } impl WrappedTypesupport for Detection3D { type CStruct = vision_msgs__msg__Detection3D ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__vision_msgs__msg__Detection3D () } } fn create_msg () -> * mut vision_msgs__msg__Detection3D { unsafe { vision_msgs__msg__Detection3D__create () } } fn destroy_msg (msg : * mut vision_msgs__msg__Detection3D) -> () { unsafe { vision_msgs__msg__Detection3D__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Detection3D { Detection3D { header : std_msgs :: msg :: Header :: from_native (& msg . header) , results : { let mut temp = Vec :: with_capacity (msg . results . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . results . data , msg . results . size) } ; for s in slice { temp . push (vision_msgs :: msg :: ObjectHypothesisWithPose :: from_native (s)) ; } temp } , bbox : vision_msgs :: msg :: BoundingBox3D :: from_native (& msg . bbox) , id : msg . id . to_str () . to_owned () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; unsafe { vision_msgs__msg__ObjectHypothesisWithPose__Sequence__fini (& mut msg . results) ; vision_msgs__msg__ObjectHypothesisWithPose__Sequence__init (& mut msg . results , self . results . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . results . data , msg . results . size) ; for (t , s) in slice . iter_mut () . zip (& self . results) { s . copy_to_native (t) ; } } self . bbox . copy_to_native (& mut msg . bbox) ; msg . id . assign (& self . id) ; } } impl Default for Detection3D { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Detection3D > :: new () ; Detection3D :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct Detection3DArray { pub header : std_msgs :: msg :: Header , pub detections : Vec < vision_msgs :: msg :: Detection3D > } impl WrappedTypesupport for Detection3DArray { type CStruct = vision_msgs__msg__Detection3DArray ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__vision_msgs__msg__Detection3DArray () } } fn create_msg () -> * mut vision_msgs__msg__Detection3DArray { unsafe { vision_msgs__msg__Detection3DArray__create () } } fn destroy_msg (msg : * mut vision_msgs__msg__Detection3DArray) -> () { unsafe { vision_msgs__msg__Detection3DArray__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> Detection3DArray { Detection3DArray { header : std_msgs :: msg :: Header :: from_native (& msg . header) , detections : { let mut temp = Vec :: with_capacity (msg . detections . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . detections . data , msg . detections . size) } ; for s in slice { temp . push (vision_msgs :: msg :: Detection3D :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; unsafe { vision_msgs__msg__Detection3D__Sequence__fini (& mut msg . detections) ; vision_msgs__msg__Detection3D__Sequence__init (& mut msg . detections , self . detections . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . detections . data , msg . detections . size) ; for (t , s) in slice . iter_mut () . zip (& self . detections) { s . copy_to_native (t) ; } } } } impl Default for Detection3DArray { fn default () -> Self { let msg_native = WrappedNativeMsg :: < Detection3DArray > :: new () ; Detection3DArray :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ObjectHypothesis { pub class_id : std :: string :: String , pub score : f64 } impl WrappedTypesupport for ObjectHypothesis { type CStruct = vision_msgs__msg__ObjectHypothesis ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__vision_msgs__msg__ObjectHypothesis () } } fn create_msg () -> * mut vision_msgs__msg__ObjectHypothesis { unsafe { vision_msgs__msg__ObjectHypothesis__create () } } fn destroy_msg (msg : * mut vision_msgs__msg__ObjectHypothesis) -> () { unsafe { vision_msgs__msg__ObjectHypothesis__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ObjectHypothesis { ObjectHypothesis { class_id : msg . class_id . to_str () . to_owned () , score : msg . score , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . class_id . assign (& self . class_id) ; msg . score = self . score ; } } impl Default for ObjectHypothesis { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ObjectHypothesis > :: new () ; ObjectHypothesis :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ObjectHypothesisWithPose { pub hypothesis : vision_msgs :: msg :: ObjectHypothesis , pub pose : geometry_msgs :: msg :: PoseWithCovariance } impl WrappedTypesupport for ObjectHypothesisWithPose { type CStruct = vision_msgs__msg__ObjectHypothesisWithPose ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__vision_msgs__msg__ObjectHypothesisWithPose () } } fn create_msg () -> * mut vision_msgs__msg__ObjectHypothesisWithPose { unsafe { vision_msgs__msg__ObjectHypothesisWithPose__create () } } fn destroy_msg (msg : * mut vision_msgs__msg__ObjectHypothesisWithPose) -> () { unsafe { vision_msgs__msg__ObjectHypothesisWithPose__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ObjectHypothesisWithPose { ObjectHypothesisWithPose { hypothesis : vision_msgs :: msg :: ObjectHypothesis :: from_native (& msg . hypothesis) , pose : geometry_msgs :: msg :: PoseWithCovariance :: from_native (& msg . pose) , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . hypothesis . copy_to_native (& mut msg . hypothesis) ; self . pose . copy_to_native (& mut msg . pose) ; } } impl Default for ObjectHypothesisWithPose { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ObjectHypothesisWithPose > :: new () ; ObjectHypothesisWithPose :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct VisionInfo { pub header : std_msgs :: msg :: Header , pub method : std :: string :: String , pub database_location : std :: string :: String , pub database_version : i32 } impl WrappedTypesupport for VisionInfo { type CStruct = vision_msgs__msg__VisionInfo ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__vision_msgs__msg__VisionInfo () } } fn create_msg () -> * mut vision_msgs__msg__VisionInfo { unsafe { vision_msgs__msg__VisionInfo__create () } } fn destroy_msg (msg : * mut vision_msgs__msg__VisionInfo) -> () { unsafe { vision_msgs__msg__VisionInfo__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> VisionInfo { VisionInfo { header : std_msgs :: msg :: Header :: from_native (& msg . header) , method : msg . method . to_str () . to_owned () , database_location : msg . database_location . to_str () . to_owned () , database_version : msg . database_version , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . method . assign (& self . method) ; msg . database_location . assign (& self . database_location) ; msg . database_version = self . database_version ; } } impl Default for VisionInfo { fn default () -> Self { let msg_native = WrappedNativeMsg :: < VisionInfo > :: new () ; VisionInfo :: from_native (& msg_native) } } }