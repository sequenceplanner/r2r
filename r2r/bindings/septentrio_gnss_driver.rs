pub mod msg { use super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct AttCovEuler { pub header : std_msgs :: msg :: Header , pub block_header : septentrio_gnss_driver :: msg :: BlockHeader , pub error : u8 , pub cov_headhead : f32 , pub cov_pitchpitch : f32 , pub cov_rollroll : f32 , pub cov_headpitch : f32 , pub cov_headroll : f32 , pub cov_pitchroll : f32 } impl WrappedTypesupport for AttCovEuler { type CStruct = septentrio_gnss_driver__msg__AttCovEuler ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__septentrio_gnss_driver__msg__AttCovEuler () } } fn create_msg () -> * mut septentrio_gnss_driver__msg__AttCovEuler { unsafe { septentrio_gnss_driver__msg__AttCovEuler__create () } } fn destroy_msg (msg : * mut septentrio_gnss_driver__msg__AttCovEuler) -> () { unsafe { septentrio_gnss_driver__msg__AttCovEuler__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> AttCovEuler { AttCovEuler { header : std_msgs :: msg :: Header :: from_native (& msg . header) , block_header : septentrio_gnss_driver :: msg :: BlockHeader :: from_native (& msg . block_header) , error : msg . error , cov_headhead : msg . cov_headhead , cov_pitchpitch : msg . cov_pitchpitch , cov_rollroll : msg . cov_rollroll , cov_headpitch : msg . cov_headpitch , cov_headroll : msg . cov_headroll , cov_pitchroll : msg . cov_pitchroll , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; self . block_header . copy_to_native (& mut msg . block_header) ; msg . error = self . error ; msg . cov_headhead = self . cov_headhead ; msg . cov_pitchpitch = self . cov_pitchpitch ; msg . cov_rollroll = self . cov_rollroll ; msg . cov_headpitch = self . cov_headpitch ; msg . cov_headroll = self . cov_headroll ; msg . cov_pitchroll = self . cov_pitchroll ; } } impl Default for AttCovEuler { fn default () -> Self { let msg_native = WrappedNativeMsg :: < AttCovEuler > :: new () ; AttCovEuler :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct AttEuler { pub header : std_msgs :: msg :: Header , pub block_header : septentrio_gnss_driver :: msg :: BlockHeader , pub nr_sv : u8 , pub error : u8 , pub mode : u16 , pub heading : f32 , pub pitch : f32 , pub roll : f32 , pub pitch_dot : f32 , pub roll_dot : f32 , pub heading_dot : f32 } impl WrappedTypesupport for AttEuler { type CStruct = septentrio_gnss_driver__msg__AttEuler ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__septentrio_gnss_driver__msg__AttEuler () } } fn create_msg () -> * mut septentrio_gnss_driver__msg__AttEuler { unsafe { septentrio_gnss_driver__msg__AttEuler__create () } } fn destroy_msg (msg : * mut septentrio_gnss_driver__msg__AttEuler) -> () { unsafe { septentrio_gnss_driver__msg__AttEuler__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> AttEuler { AttEuler { header : std_msgs :: msg :: Header :: from_native (& msg . header) , block_header : septentrio_gnss_driver :: msg :: BlockHeader :: from_native (& msg . block_header) , nr_sv : msg . nr_sv , error : msg . error , mode : msg . mode , heading : msg . heading , pitch : msg . pitch , roll : msg . roll , pitch_dot : msg . pitch_dot , roll_dot : msg . roll_dot , heading_dot : msg . heading_dot , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; self . block_header . copy_to_native (& mut msg . block_header) ; msg . nr_sv = self . nr_sv ; msg . error = self . error ; msg . mode = self . mode ; msg . heading = self . heading ; msg . pitch = self . pitch ; msg . roll = self . roll ; msg . pitch_dot = self . pitch_dot ; msg . roll_dot = self . roll_dot ; msg . heading_dot = self . heading_dot ; } } impl Default for AttEuler { fn default () -> Self { let msg_native = WrappedNativeMsg :: < AttEuler > :: new () ; AttEuler :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct BaseVectorCart { pub header : std_msgs :: msg :: Header , pub block_header : septentrio_gnss_driver :: msg :: BlockHeader , pub n : u8 , pub sb_length : u8 , pub vector_info_cart : Vec < septentrio_gnss_driver :: msg :: VectorInfoCart > } impl WrappedTypesupport for BaseVectorCart { type CStruct = septentrio_gnss_driver__msg__BaseVectorCart ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__septentrio_gnss_driver__msg__BaseVectorCart () } } fn create_msg () -> * mut septentrio_gnss_driver__msg__BaseVectorCart { unsafe { septentrio_gnss_driver__msg__BaseVectorCart__create () } } fn destroy_msg (msg : * mut septentrio_gnss_driver__msg__BaseVectorCart) -> () { unsafe { septentrio_gnss_driver__msg__BaseVectorCart__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> BaseVectorCart { BaseVectorCart { header : std_msgs :: msg :: Header :: from_native (& msg . header) , block_header : septentrio_gnss_driver :: msg :: BlockHeader :: from_native (& msg . block_header) , n : msg . n , sb_length : msg . sb_length , vector_info_cart : { let mut temp = Vec :: with_capacity (msg . vector_info_cart . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . vector_info_cart . data , msg . vector_info_cart . size) } ; for s in slice { temp . push (septentrio_gnss_driver :: msg :: VectorInfoCart :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; self . block_header . copy_to_native (& mut msg . block_header) ; msg . n = self . n ; msg . sb_length = self . sb_length ; unsafe { septentrio_gnss_driver__msg__VectorInfoCart__Sequence__fini (& mut msg . vector_info_cart) ; septentrio_gnss_driver__msg__VectorInfoCart__Sequence__init (& mut msg . vector_info_cart , self . vector_info_cart . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . vector_info_cart . data , msg . vector_info_cart . size) ; for (t , s) in slice . iter_mut () . zip (& self . vector_info_cart) { s . copy_to_native (t) ; } } } } impl Default for BaseVectorCart { fn default () -> Self { let msg_native = WrappedNativeMsg :: < BaseVectorCart > :: new () ; BaseVectorCart :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct BaseVectorGeod { pub header : std_msgs :: msg :: Header , pub block_header : septentrio_gnss_driver :: msg :: BlockHeader , pub n : u8 , pub sb_length : u8 , pub vector_info_geod : Vec < septentrio_gnss_driver :: msg :: VectorInfoGeod > } impl WrappedTypesupport for BaseVectorGeod { type CStruct = septentrio_gnss_driver__msg__BaseVectorGeod ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__septentrio_gnss_driver__msg__BaseVectorGeod () } } fn create_msg () -> * mut septentrio_gnss_driver__msg__BaseVectorGeod { unsafe { septentrio_gnss_driver__msg__BaseVectorGeod__create () } } fn destroy_msg (msg : * mut septentrio_gnss_driver__msg__BaseVectorGeod) -> () { unsafe { septentrio_gnss_driver__msg__BaseVectorGeod__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> BaseVectorGeod { BaseVectorGeod { header : std_msgs :: msg :: Header :: from_native (& msg . header) , block_header : septentrio_gnss_driver :: msg :: BlockHeader :: from_native (& msg . block_header) , n : msg . n , sb_length : msg . sb_length , vector_info_geod : { let mut temp = Vec :: with_capacity (msg . vector_info_geod . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . vector_info_geod . data , msg . vector_info_geod . size) } ; for s in slice { temp . push (septentrio_gnss_driver :: msg :: VectorInfoGeod :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; self . block_header . copy_to_native (& mut msg . block_header) ; msg . n = self . n ; msg . sb_length = self . sb_length ; unsafe { septentrio_gnss_driver__msg__VectorInfoGeod__Sequence__fini (& mut msg . vector_info_geod) ; septentrio_gnss_driver__msg__VectorInfoGeod__Sequence__init (& mut msg . vector_info_geod , self . vector_info_geod . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . vector_info_geod . data , msg . vector_info_geod . size) ; for (t , s) in slice . iter_mut () . zip (& self . vector_info_geod) { s . copy_to_native (t) ; } } } } impl Default for BaseVectorGeod { fn default () -> Self { let msg_native = WrappedNativeMsg :: < BaseVectorGeod > :: new () ; BaseVectorGeod :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct BlockHeader { pub sync_1 : u8 , pub sync_2 : u8 , pub crc : u16 , pub id : u16 , pub revision : u8 , pub length : u16 , pub tow : u32 , pub wnc : u16 } impl WrappedTypesupport for BlockHeader { type CStruct = septentrio_gnss_driver__msg__BlockHeader ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__septentrio_gnss_driver__msg__BlockHeader () } } fn create_msg () -> * mut septentrio_gnss_driver__msg__BlockHeader { unsafe { septentrio_gnss_driver__msg__BlockHeader__create () } } fn destroy_msg (msg : * mut septentrio_gnss_driver__msg__BlockHeader) -> () { unsafe { septentrio_gnss_driver__msg__BlockHeader__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> BlockHeader { BlockHeader { sync_1 : msg . sync_1 , sync_2 : msg . sync_2 , crc : msg . crc , id : msg . id , revision : msg . revision , length : msg . length , tow : msg . tow , wnc : msg . wnc , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . sync_1 = self . sync_1 ; msg . sync_2 = self . sync_2 ; msg . crc = self . crc ; msg . id = self . id ; msg . revision = self . revision ; msg . length = self . length ; msg . tow = self . tow ; msg . wnc = self . wnc ; } } impl Default for BlockHeader { fn default () -> Self { let msg_native = WrappedNativeMsg :: < BlockHeader > :: new () ; BlockHeader :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ExtSensorMeas { pub header : std_msgs :: msg :: Header , pub block_header : septentrio_gnss_driver :: msg :: BlockHeader , pub n : u8 , pub sb_length : u8 , pub source : Vec < u8 > , pub sensor_model : Vec < u8 > , # [serde (rename = "type")] pub type_ : Vec < u8 > , pub obs_info : Vec < u8 > , pub acceleration_x : f64 , pub acceleration_y : f64 , pub acceleration_z : f64 , pub angular_rate_x : f64 , pub angular_rate_y : f64 , pub angular_rate_z : f64 , pub velocity_x : f32 , pub velocity_y : f32 , pub velocity_z : f32 , pub std_dev_x : f32 , pub std_dev_y : f32 , pub std_dev_z : f32 , pub sensor_temperature : f32 , pub zero_velocity_flag : f64 } impl WrappedTypesupport for ExtSensorMeas { type CStruct = septentrio_gnss_driver__msg__ExtSensorMeas ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__septentrio_gnss_driver__msg__ExtSensorMeas () } } fn create_msg () -> * mut septentrio_gnss_driver__msg__ExtSensorMeas { unsafe { septentrio_gnss_driver__msg__ExtSensorMeas__create () } } fn destroy_msg (msg : * mut septentrio_gnss_driver__msg__ExtSensorMeas) -> () { unsafe { septentrio_gnss_driver__msg__ExtSensorMeas__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ExtSensorMeas { ExtSensorMeas { header : std_msgs :: msg :: Header :: from_native (& msg . header) , block_header : septentrio_gnss_driver :: msg :: BlockHeader :: from_native (& msg . block_header) , n : msg . n , sb_length : msg . sb_length , source : msg . source . to_vec () , sensor_model : msg . sensor_model . to_vec () , type_ : msg . type_ . to_vec () , obs_info : msg . obs_info . to_vec () , acceleration_x : msg . acceleration_x , acceleration_y : msg . acceleration_y , acceleration_z : msg . acceleration_z , angular_rate_x : msg . angular_rate_x , angular_rate_y : msg . angular_rate_y , angular_rate_z : msg . angular_rate_z , velocity_x : msg . velocity_x , velocity_y : msg . velocity_y , velocity_z : msg . velocity_z , std_dev_x : msg . std_dev_x , std_dev_y : msg . std_dev_y , std_dev_z : msg . std_dev_z , sensor_temperature : msg . sensor_temperature , zero_velocity_flag : msg . zero_velocity_flag , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; self . block_header . copy_to_native (& mut msg . block_header) ; msg . n = self . n ; msg . sb_length = self . sb_length ; msg . source . update (& self . source) ; msg . sensor_model . update (& self . sensor_model) ; msg . type_ . update (& self . type_) ; msg . obs_info . update (& self . obs_info) ; msg . acceleration_x = self . acceleration_x ; msg . acceleration_y = self . acceleration_y ; msg . acceleration_z = self . acceleration_z ; msg . angular_rate_x = self . angular_rate_x ; msg . angular_rate_y = self . angular_rate_y ; msg . angular_rate_z = self . angular_rate_z ; msg . velocity_x = self . velocity_x ; msg . velocity_y = self . velocity_y ; msg . velocity_z = self . velocity_z ; msg . std_dev_x = self . std_dev_x ; msg . std_dev_y = self . std_dev_y ; msg . std_dev_z = self . std_dev_z ; msg . sensor_temperature = self . sensor_temperature ; msg . zero_velocity_flag = self . zero_velocity_flag ; } } impl Default for ExtSensorMeas { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ExtSensorMeas > :: new () ; ExtSensorMeas :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct IMUSetup { pub header : std_msgs :: msg :: Header , pub block_header : septentrio_gnss_driver :: msg :: BlockHeader , pub serial_port : u8 , pub ant_lever_arm_x : f32 , pub ant_lever_arm_y : f32 , pub ant_lever_arm_z : f32 , pub theta_x : f32 , pub theta_y : f32 , pub theta_z : f32 } impl WrappedTypesupport for IMUSetup { type CStruct = septentrio_gnss_driver__msg__IMUSetup ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__septentrio_gnss_driver__msg__IMUSetup () } } fn create_msg () -> * mut septentrio_gnss_driver__msg__IMUSetup { unsafe { septentrio_gnss_driver__msg__IMUSetup__create () } } fn destroy_msg (msg : * mut septentrio_gnss_driver__msg__IMUSetup) -> () { unsafe { septentrio_gnss_driver__msg__IMUSetup__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> IMUSetup { IMUSetup { header : std_msgs :: msg :: Header :: from_native (& msg . header) , block_header : septentrio_gnss_driver :: msg :: BlockHeader :: from_native (& msg . block_header) , serial_port : msg . serial_port , ant_lever_arm_x : msg . ant_lever_arm_x , ant_lever_arm_y : msg . ant_lever_arm_y , ant_lever_arm_z : msg . ant_lever_arm_z , theta_x : msg . theta_x , theta_y : msg . theta_y , theta_z : msg . theta_z , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; self . block_header . copy_to_native (& mut msg . block_header) ; msg . serial_port = self . serial_port ; msg . ant_lever_arm_x = self . ant_lever_arm_x ; msg . ant_lever_arm_y = self . ant_lever_arm_y ; msg . ant_lever_arm_z = self . ant_lever_arm_z ; msg . theta_x = self . theta_x ; msg . theta_y = self . theta_y ; msg . theta_z = self . theta_z ; } } impl Default for IMUSetup { fn default () -> Self { let msg_native = WrappedNativeMsg :: < IMUSetup > :: new () ; IMUSetup :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct INSNavCart { pub header : std_msgs :: msg :: Header , pub block_header : septentrio_gnss_driver :: msg :: BlockHeader , pub gnss_mode : u8 , pub error : u8 , pub info : u16 , pub gnss_age : u16 , pub x : f64 , pub y : f64 , pub z : f64 , pub accuracy : u16 , pub latency : u16 , pub datum : u8 , pub sb_list : u16 , pub x_std_dev : f32 , pub y_std_dev : f32 , pub z_std_dev : f32 , pub xy_cov : f32 , pub xz_cov : f32 , pub yz_cov : f32 , pub heading : f32 , pub pitch : f32 , pub roll : f32 , pub heading_std_dev : f32 , pub pitch_std_dev : f32 , pub roll_std_dev : f32 , pub heading_pitch_cov : f32 , pub heading_roll_cov : f32 , pub pitch_roll_cov : f32 , pub vx : f32 , pub vy : f32 , pub vz : f32 , pub vx_std_dev : f32 , pub vy_std_dev : f32 , pub vz_std_dev : f32 , pub vx_vy_cov : f32 , pub vx_vz_cov : f32 , pub vy_vz_cov : f32 } impl WrappedTypesupport for INSNavCart { type CStruct = septentrio_gnss_driver__msg__INSNavCart ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__septentrio_gnss_driver__msg__INSNavCart () } } fn create_msg () -> * mut septentrio_gnss_driver__msg__INSNavCart { unsafe { septentrio_gnss_driver__msg__INSNavCart__create () } } fn destroy_msg (msg : * mut septentrio_gnss_driver__msg__INSNavCart) -> () { unsafe { septentrio_gnss_driver__msg__INSNavCart__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> INSNavCart { INSNavCart { header : std_msgs :: msg :: Header :: from_native (& msg . header) , block_header : septentrio_gnss_driver :: msg :: BlockHeader :: from_native (& msg . block_header) , gnss_mode : msg . gnss_mode , error : msg . error , info : msg . info , gnss_age : msg . gnss_age , x : msg . x , y : msg . y , z : msg . z , accuracy : msg . accuracy , latency : msg . latency , datum : msg . datum , sb_list : msg . sb_list , x_std_dev : msg . x_std_dev , y_std_dev : msg . y_std_dev , z_std_dev : msg . z_std_dev , xy_cov : msg . xy_cov , xz_cov : msg . xz_cov , yz_cov : msg . yz_cov , heading : msg . heading , pitch : msg . pitch , roll : msg . roll , heading_std_dev : msg . heading_std_dev , pitch_std_dev : msg . pitch_std_dev , roll_std_dev : msg . roll_std_dev , heading_pitch_cov : msg . heading_pitch_cov , heading_roll_cov : msg . heading_roll_cov , pitch_roll_cov : msg . pitch_roll_cov , vx : msg . vx , vy : msg . vy , vz : msg . vz , vx_std_dev : msg . vx_std_dev , vy_std_dev : msg . vy_std_dev , vz_std_dev : msg . vz_std_dev , vx_vy_cov : msg . vx_vy_cov , vx_vz_cov : msg . vx_vz_cov , vy_vz_cov : msg . vy_vz_cov , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; self . block_header . copy_to_native (& mut msg . block_header) ; msg . gnss_mode = self . gnss_mode ; msg . error = self . error ; msg . info = self . info ; msg . gnss_age = self . gnss_age ; msg . x = self . x ; msg . y = self . y ; msg . z = self . z ; msg . accuracy = self . accuracy ; msg . latency = self . latency ; msg . datum = self . datum ; msg . sb_list = self . sb_list ; msg . x_std_dev = self . x_std_dev ; msg . y_std_dev = self . y_std_dev ; msg . z_std_dev = self . z_std_dev ; msg . xy_cov = self . xy_cov ; msg . xz_cov = self . xz_cov ; msg . yz_cov = self . yz_cov ; msg . heading = self . heading ; msg . pitch = self . pitch ; msg . roll = self . roll ; msg . heading_std_dev = self . heading_std_dev ; msg . pitch_std_dev = self . pitch_std_dev ; msg . roll_std_dev = self . roll_std_dev ; msg . heading_pitch_cov = self . heading_pitch_cov ; msg . heading_roll_cov = self . heading_roll_cov ; msg . pitch_roll_cov = self . pitch_roll_cov ; msg . vx = self . vx ; msg . vy = self . vy ; msg . vz = self . vz ; msg . vx_std_dev = self . vx_std_dev ; msg . vy_std_dev = self . vy_std_dev ; msg . vz_std_dev = self . vz_std_dev ; msg . vx_vy_cov = self . vx_vy_cov ; msg . vx_vz_cov = self . vx_vz_cov ; msg . vy_vz_cov = self . vy_vz_cov ; } } impl Default for INSNavCart { fn default () -> Self { let msg_native = WrappedNativeMsg :: < INSNavCart > :: new () ; INSNavCart :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct INSNavGeod { pub header : std_msgs :: msg :: Header , pub block_header : septentrio_gnss_driver :: msg :: BlockHeader , pub gnss_mode : u8 , pub error : u8 , pub info : u16 , pub gnss_age : u16 , pub latitude : f64 , pub longitude : f64 , pub height : f64 , pub undulation : f32 , pub accuracy : u16 , pub latency : u16 , pub datum : u8 , pub sb_list : u16 , pub latitude_std_dev : f32 , pub longitude_std_dev : f32 , pub height_std_dev : f32 , pub latitude_longitude_cov : f32 , pub latitude_height_cov : f32 , pub longitude_height_cov : f32 , pub heading : f32 , pub pitch : f32 , pub roll : f32 , pub heading_std_dev : f32 , pub pitch_std_dev : f32 , pub roll_std_dev : f32 , pub heading_pitch_cov : f32 , pub heading_roll_cov : f32 , pub pitch_roll_cov : f32 , pub ve : f32 , pub vn : f32 , pub vu : f32 , pub ve_std_dev : f32 , pub vn_std_dev : f32 , pub vu_std_dev : f32 , pub ve_vn_cov : f32 , pub ve_vu_cov : f32 , pub vn_vu_cov : f32 } impl WrappedTypesupport for INSNavGeod { type CStruct = septentrio_gnss_driver__msg__INSNavGeod ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__septentrio_gnss_driver__msg__INSNavGeod () } } fn create_msg () -> * mut septentrio_gnss_driver__msg__INSNavGeod { unsafe { septentrio_gnss_driver__msg__INSNavGeod__create () } } fn destroy_msg (msg : * mut septentrio_gnss_driver__msg__INSNavGeod) -> () { unsafe { septentrio_gnss_driver__msg__INSNavGeod__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> INSNavGeod { INSNavGeod { header : std_msgs :: msg :: Header :: from_native (& msg . header) , block_header : septentrio_gnss_driver :: msg :: BlockHeader :: from_native (& msg . block_header) , gnss_mode : msg . gnss_mode , error : msg . error , info : msg . info , gnss_age : msg . gnss_age , latitude : msg . latitude , longitude : msg . longitude , height : msg . height , undulation : msg . undulation , accuracy : msg . accuracy , latency : msg . latency , datum : msg . datum , sb_list : msg . sb_list , latitude_std_dev : msg . latitude_std_dev , longitude_std_dev : msg . longitude_std_dev , height_std_dev : msg . height_std_dev , latitude_longitude_cov : msg . latitude_longitude_cov , latitude_height_cov : msg . latitude_height_cov , longitude_height_cov : msg . longitude_height_cov , heading : msg . heading , pitch : msg . pitch , roll : msg . roll , heading_std_dev : msg . heading_std_dev , pitch_std_dev : msg . pitch_std_dev , roll_std_dev : msg . roll_std_dev , heading_pitch_cov : msg . heading_pitch_cov , heading_roll_cov : msg . heading_roll_cov , pitch_roll_cov : msg . pitch_roll_cov , ve : msg . ve , vn : msg . vn , vu : msg . vu , ve_std_dev : msg . ve_std_dev , vn_std_dev : msg . vn_std_dev , vu_std_dev : msg . vu_std_dev , ve_vn_cov : msg . ve_vn_cov , ve_vu_cov : msg . ve_vu_cov , vn_vu_cov : msg . vn_vu_cov , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; self . block_header . copy_to_native (& mut msg . block_header) ; msg . gnss_mode = self . gnss_mode ; msg . error = self . error ; msg . info = self . info ; msg . gnss_age = self . gnss_age ; msg . latitude = self . latitude ; msg . longitude = self . longitude ; msg . height = self . height ; msg . undulation = self . undulation ; msg . accuracy = self . accuracy ; msg . latency = self . latency ; msg . datum = self . datum ; msg . sb_list = self . sb_list ; msg . latitude_std_dev = self . latitude_std_dev ; msg . longitude_std_dev = self . longitude_std_dev ; msg . height_std_dev = self . height_std_dev ; msg . latitude_longitude_cov = self . latitude_longitude_cov ; msg . latitude_height_cov = self . latitude_height_cov ; msg . longitude_height_cov = self . longitude_height_cov ; msg . heading = self . heading ; msg . pitch = self . pitch ; msg . roll = self . roll ; msg . heading_std_dev = self . heading_std_dev ; msg . pitch_std_dev = self . pitch_std_dev ; msg . roll_std_dev = self . roll_std_dev ; msg . heading_pitch_cov = self . heading_pitch_cov ; msg . heading_roll_cov = self . heading_roll_cov ; msg . pitch_roll_cov = self . pitch_roll_cov ; msg . ve = self . ve ; msg . vn = self . vn ; msg . vu = self . vu ; msg . ve_std_dev = self . ve_std_dev ; msg . vn_std_dev = self . vn_std_dev ; msg . vu_std_dev = self . vu_std_dev ; msg . ve_vn_cov = self . ve_vn_cov ; msg . ve_vu_cov = self . ve_vu_cov ; msg . vn_vu_cov = self . vn_vu_cov ; } } impl Default for INSNavGeod { fn default () -> Self { let msg_native = WrappedNativeMsg :: < INSNavGeod > :: new () ; INSNavGeod :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct MeasEpoch { pub header : std_msgs :: msg :: Header , pub block_header : septentrio_gnss_driver :: msg :: BlockHeader , pub n : u8 , pub sb1_length : u8 , pub sb2_length : u8 , pub common_flags : u8 , pub cum_clk_jumps : u8 , pub type1 : Vec < septentrio_gnss_driver :: msg :: MeasEpochChannelType1 > } impl WrappedTypesupport for MeasEpoch { type CStruct = septentrio_gnss_driver__msg__MeasEpoch ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__septentrio_gnss_driver__msg__MeasEpoch () } } fn create_msg () -> * mut septentrio_gnss_driver__msg__MeasEpoch { unsafe { septentrio_gnss_driver__msg__MeasEpoch__create () } } fn destroy_msg (msg : * mut septentrio_gnss_driver__msg__MeasEpoch) -> () { unsafe { septentrio_gnss_driver__msg__MeasEpoch__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> MeasEpoch { MeasEpoch { header : std_msgs :: msg :: Header :: from_native (& msg . header) , block_header : septentrio_gnss_driver :: msg :: BlockHeader :: from_native (& msg . block_header) , n : msg . n , sb1_length : msg . sb1_length , sb2_length : msg . sb2_length , common_flags : msg . common_flags , cum_clk_jumps : msg . cum_clk_jumps , type1 : { let mut temp = Vec :: with_capacity (msg . type1 . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . type1 . data , msg . type1 . size) } ; for s in slice { temp . push (septentrio_gnss_driver :: msg :: MeasEpochChannelType1 :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; self . block_header . copy_to_native (& mut msg . block_header) ; msg . n = self . n ; msg . sb1_length = self . sb1_length ; msg . sb2_length = self . sb2_length ; msg . common_flags = self . common_flags ; msg . cum_clk_jumps = self . cum_clk_jumps ; unsafe { septentrio_gnss_driver__msg__MeasEpochChannelType1__Sequence__fini (& mut msg . type1) ; septentrio_gnss_driver__msg__MeasEpochChannelType1__Sequence__init (& mut msg . type1 , self . type1 . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . type1 . data , msg . type1 . size) ; for (t , s) in slice . iter_mut () . zip (& self . type1) { s . copy_to_native (t) ; } } } } impl Default for MeasEpoch { fn default () -> Self { let msg_native = WrappedNativeMsg :: < MeasEpoch > :: new () ; MeasEpoch :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct MeasEpochChannelType1 { pub rx_channel : u8 , # [serde (rename = "type")] pub type_ : u8 , pub sv_id : u8 , pub misc : u8 , pub code_lsb : u32 , pub doppler : i32 , pub carrier_lsb : u16 , pub carrier_msb : i8 , pub cn0 : u8 , pub lock_time : u16 , pub obs_info : u8 , pub n2 : u8 , pub type2 : Vec < septentrio_gnss_driver :: msg :: MeasEpochChannelType2 > } impl WrappedTypesupport for MeasEpochChannelType1 { type CStruct = septentrio_gnss_driver__msg__MeasEpochChannelType1 ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__septentrio_gnss_driver__msg__MeasEpochChannelType1 () } } fn create_msg () -> * mut septentrio_gnss_driver__msg__MeasEpochChannelType1 { unsafe { septentrio_gnss_driver__msg__MeasEpochChannelType1__create () } } fn destroy_msg (msg : * mut septentrio_gnss_driver__msg__MeasEpochChannelType1) -> () { unsafe { septentrio_gnss_driver__msg__MeasEpochChannelType1__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> MeasEpochChannelType1 { MeasEpochChannelType1 { rx_channel : msg . rx_channel , type_ : msg . type_ , sv_id : msg . sv_id , misc : msg . misc , code_lsb : msg . code_lsb , doppler : msg . doppler , carrier_lsb : msg . carrier_lsb , carrier_msb : msg . carrier_msb , cn0 : msg . cn0 , lock_time : msg . lock_time , obs_info : msg . obs_info , n2 : msg . n2 , type2 : { let mut temp = Vec :: with_capacity (msg . type2 . size) ; let slice = unsafe { std :: slice :: from_raw_parts (msg . type2 . data , msg . type2 . size) } ; for s in slice { temp . push (septentrio_gnss_driver :: msg :: MeasEpochChannelType2 :: from_native (s)) ; } temp } , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . rx_channel = self . rx_channel ; msg . type_ = self . type_ ; msg . sv_id = self . sv_id ; msg . misc = self . misc ; msg . code_lsb = self . code_lsb ; msg . doppler = self . doppler ; msg . carrier_lsb = self . carrier_lsb ; msg . carrier_msb = self . carrier_msb ; msg . cn0 = self . cn0 ; msg . lock_time = self . lock_time ; msg . obs_info = self . obs_info ; msg . n2 = self . n2 ; unsafe { septentrio_gnss_driver__msg__MeasEpochChannelType2__Sequence__fini (& mut msg . type2) ; septentrio_gnss_driver__msg__MeasEpochChannelType2__Sequence__init (& mut msg . type2 , self . type2 . len ()) ; let slice = std :: slice :: from_raw_parts_mut (msg . type2 . data , msg . type2 . size) ; for (t , s) in slice . iter_mut () . zip (& self . type2) { s . copy_to_native (t) ; } } } } impl Default for MeasEpochChannelType1 { fn default () -> Self { let msg_native = WrappedNativeMsg :: < MeasEpochChannelType1 > :: new () ; MeasEpochChannelType1 :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct MeasEpochChannelType2 { # [serde (rename = "type")] pub type_ : u8 , pub lock_time : u8 , pub cn0 : u8 , pub offsets_msb : u8 , pub carrier_msb : i8 , pub obs_info : u8 , pub code_offset_lsb : u16 , pub carrier_lsb : u16 , pub doppler_offset_lsb : u16 } impl WrappedTypesupport for MeasEpochChannelType2 { type CStruct = septentrio_gnss_driver__msg__MeasEpochChannelType2 ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__septentrio_gnss_driver__msg__MeasEpochChannelType2 () } } fn create_msg () -> * mut septentrio_gnss_driver__msg__MeasEpochChannelType2 { unsafe { septentrio_gnss_driver__msg__MeasEpochChannelType2__create () } } fn destroy_msg (msg : * mut septentrio_gnss_driver__msg__MeasEpochChannelType2) -> () { unsafe { septentrio_gnss_driver__msg__MeasEpochChannelType2__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> MeasEpochChannelType2 { MeasEpochChannelType2 { type_ : msg . type_ , lock_time : msg . lock_time , cn0 : msg . cn0 , offsets_msb : msg . offsets_msb , carrier_msb : msg . carrier_msb , obs_info : msg . obs_info , code_offset_lsb : msg . code_offset_lsb , carrier_lsb : msg . carrier_lsb , doppler_offset_lsb : msg . doppler_offset_lsb , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . type_ = self . type_ ; msg . lock_time = self . lock_time ; msg . cn0 = self . cn0 ; msg . offsets_msb = self . offsets_msb ; msg . carrier_msb = self . carrier_msb ; msg . obs_info = self . obs_info ; msg . code_offset_lsb = self . code_offset_lsb ; msg . carrier_lsb = self . carrier_lsb ; msg . doppler_offset_lsb = self . doppler_offset_lsb ; } } impl Default for MeasEpochChannelType2 { fn default () -> Self { let msg_native = WrappedNativeMsg :: < MeasEpochChannelType2 > :: new () ; MeasEpochChannelType2 :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct PVTCartesian { pub header : std_msgs :: msg :: Header , pub block_header : septentrio_gnss_driver :: msg :: BlockHeader , pub mode : u8 , pub error : u8 , pub x : f64 , pub y : f64 , pub z : f64 , pub undulation : f32 , pub vx : f32 , pub vy : f32 , pub vz : f32 , pub cog : f32 , pub rx_clk_bias : f64 , pub rx_clk_drift : f32 , pub time_system : u8 , pub datum : u8 , pub nr_sv : u8 , pub wa_corr_info : u8 , pub reference_id : u16 , pub mean_corr_age : u16 , pub signal_info : u32 , pub alert_flag : u8 , pub nr_bases : u8 , pub ppp_info : u16 , pub latency : u16 , pub h_accuracy : u16 , pub v_accuracy : u16 , pub misc : u8 } impl WrappedTypesupport for PVTCartesian { type CStruct = septentrio_gnss_driver__msg__PVTCartesian ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__septentrio_gnss_driver__msg__PVTCartesian () } } fn create_msg () -> * mut septentrio_gnss_driver__msg__PVTCartesian { unsafe { septentrio_gnss_driver__msg__PVTCartesian__create () } } fn destroy_msg (msg : * mut septentrio_gnss_driver__msg__PVTCartesian) -> () { unsafe { septentrio_gnss_driver__msg__PVTCartesian__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> PVTCartesian { PVTCartesian { header : std_msgs :: msg :: Header :: from_native (& msg . header) , block_header : septentrio_gnss_driver :: msg :: BlockHeader :: from_native (& msg . block_header) , mode : msg . mode , error : msg . error , x : msg . x , y : msg . y , z : msg . z , undulation : msg . undulation , vx : msg . vx , vy : msg . vy , vz : msg . vz , cog : msg . cog , rx_clk_bias : msg . rx_clk_bias , rx_clk_drift : msg . rx_clk_drift , time_system : msg . time_system , datum : msg . datum , nr_sv : msg . nr_sv , wa_corr_info : msg . wa_corr_info , reference_id : msg . reference_id , mean_corr_age : msg . mean_corr_age , signal_info : msg . signal_info , alert_flag : msg . alert_flag , nr_bases : msg . nr_bases , ppp_info : msg . ppp_info , latency : msg . latency , h_accuracy : msg . h_accuracy , v_accuracy : msg . v_accuracy , misc : msg . misc , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; self . block_header . copy_to_native (& mut msg . block_header) ; msg . mode = self . mode ; msg . error = self . error ; msg . x = self . x ; msg . y = self . y ; msg . z = self . z ; msg . undulation = self . undulation ; msg . vx = self . vx ; msg . vy = self . vy ; msg . vz = self . vz ; msg . cog = self . cog ; msg . rx_clk_bias = self . rx_clk_bias ; msg . rx_clk_drift = self . rx_clk_drift ; msg . time_system = self . time_system ; msg . datum = self . datum ; msg . nr_sv = self . nr_sv ; msg . wa_corr_info = self . wa_corr_info ; msg . reference_id = self . reference_id ; msg . mean_corr_age = self . mean_corr_age ; msg . signal_info = self . signal_info ; msg . alert_flag = self . alert_flag ; msg . nr_bases = self . nr_bases ; msg . ppp_info = self . ppp_info ; msg . latency = self . latency ; msg . h_accuracy = self . h_accuracy ; msg . v_accuracy = self . v_accuracy ; msg . misc = self . misc ; } } impl Default for PVTCartesian { fn default () -> Self { let msg_native = WrappedNativeMsg :: < PVTCartesian > :: new () ; PVTCartesian :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct PVTGeodetic { pub header : std_msgs :: msg :: Header , pub block_header : septentrio_gnss_driver :: msg :: BlockHeader , pub mode : u8 , pub error : u8 , pub latitude : f64 , pub longitude : f64 , pub height : f64 , pub undulation : f32 , pub vn : f32 , pub ve : f32 , pub vu : f32 , pub cog : f32 , pub rx_clk_bias : f64 , pub rx_clk_drift : f32 , pub time_system : u8 , pub datum : u8 , pub nr_sv : u8 , pub wa_corr_info : u8 , pub reference_id : u16 , pub mean_corr_age : u16 , pub signal_info : u32 , pub alert_flag : u8 , pub nr_bases : u8 , pub ppp_info : u16 , pub latency : u16 , pub h_accuracy : u16 , pub v_accuracy : u16 , pub misc : u8 } impl WrappedTypesupport for PVTGeodetic { type CStruct = septentrio_gnss_driver__msg__PVTGeodetic ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__septentrio_gnss_driver__msg__PVTGeodetic () } } fn create_msg () -> * mut septentrio_gnss_driver__msg__PVTGeodetic { unsafe { septentrio_gnss_driver__msg__PVTGeodetic__create () } } fn destroy_msg (msg : * mut septentrio_gnss_driver__msg__PVTGeodetic) -> () { unsafe { septentrio_gnss_driver__msg__PVTGeodetic__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> PVTGeodetic { PVTGeodetic { header : std_msgs :: msg :: Header :: from_native (& msg . header) , block_header : septentrio_gnss_driver :: msg :: BlockHeader :: from_native (& msg . block_header) , mode : msg . mode , error : msg . error , latitude : msg . latitude , longitude : msg . longitude , height : msg . height , undulation : msg . undulation , vn : msg . vn , ve : msg . ve , vu : msg . vu , cog : msg . cog , rx_clk_bias : msg . rx_clk_bias , rx_clk_drift : msg . rx_clk_drift , time_system : msg . time_system , datum : msg . datum , nr_sv : msg . nr_sv , wa_corr_info : msg . wa_corr_info , reference_id : msg . reference_id , mean_corr_age : msg . mean_corr_age , signal_info : msg . signal_info , alert_flag : msg . alert_flag , nr_bases : msg . nr_bases , ppp_info : msg . ppp_info , latency : msg . latency , h_accuracy : msg . h_accuracy , v_accuracy : msg . v_accuracy , misc : msg . misc , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; self . block_header . copy_to_native (& mut msg . block_header) ; msg . mode = self . mode ; msg . error = self . error ; msg . latitude = self . latitude ; msg . longitude = self . longitude ; msg . height = self . height ; msg . undulation = self . undulation ; msg . vn = self . vn ; msg . ve = self . ve ; msg . vu = self . vu ; msg . cog = self . cog ; msg . rx_clk_bias = self . rx_clk_bias ; msg . rx_clk_drift = self . rx_clk_drift ; msg . time_system = self . time_system ; msg . datum = self . datum ; msg . nr_sv = self . nr_sv ; msg . wa_corr_info = self . wa_corr_info ; msg . reference_id = self . reference_id ; msg . mean_corr_age = self . mean_corr_age ; msg . signal_info = self . signal_info ; msg . alert_flag = self . alert_flag ; msg . nr_bases = self . nr_bases ; msg . ppp_info = self . ppp_info ; msg . latency = self . latency ; msg . h_accuracy = self . h_accuracy ; msg . v_accuracy = self . v_accuracy ; msg . misc = self . misc ; } } impl Default for PVTGeodetic { fn default () -> Self { let msg_native = WrappedNativeMsg :: < PVTGeodetic > :: new () ; PVTGeodetic :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct PosCovCartesian { pub header : std_msgs :: msg :: Header , pub block_header : septentrio_gnss_driver :: msg :: BlockHeader , pub mode : u8 , pub error : u8 , pub cov_xx : f32 , pub cov_yy : f32 , pub cov_zz : f32 , pub cov_bb : f32 , pub cov_xy : f32 , pub cov_xz : f32 , pub cov_xb : f32 , pub cov_yz : f32 , pub cov_yb : f32 , pub cov_zb : f32 } impl WrappedTypesupport for PosCovCartesian { type CStruct = septentrio_gnss_driver__msg__PosCovCartesian ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__septentrio_gnss_driver__msg__PosCovCartesian () } } fn create_msg () -> * mut septentrio_gnss_driver__msg__PosCovCartesian { unsafe { septentrio_gnss_driver__msg__PosCovCartesian__create () } } fn destroy_msg (msg : * mut septentrio_gnss_driver__msg__PosCovCartesian) -> () { unsafe { septentrio_gnss_driver__msg__PosCovCartesian__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> PosCovCartesian { PosCovCartesian { header : std_msgs :: msg :: Header :: from_native (& msg . header) , block_header : septentrio_gnss_driver :: msg :: BlockHeader :: from_native (& msg . block_header) , mode : msg . mode , error : msg . error , cov_xx : msg . cov_xx , cov_yy : msg . cov_yy , cov_zz : msg . cov_zz , cov_bb : msg . cov_bb , cov_xy : msg . cov_xy , cov_xz : msg . cov_xz , cov_xb : msg . cov_xb , cov_yz : msg . cov_yz , cov_yb : msg . cov_yb , cov_zb : msg . cov_zb , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; self . block_header . copy_to_native (& mut msg . block_header) ; msg . mode = self . mode ; msg . error = self . error ; msg . cov_xx = self . cov_xx ; msg . cov_yy = self . cov_yy ; msg . cov_zz = self . cov_zz ; msg . cov_bb = self . cov_bb ; msg . cov_xy = self . cov_xy ; msg . cov_xz = self . cov_xz ; msg . cov_xb = self . cov_xb ; msg . cov_yz = self . cov_yz ; msg . cov_yb = self . cov_yb ; msg . cov_zb = self . cov_zb ; } } impl Default for PosCovCartesian { fn default () -> Self { let msg_native = WrappedNativeMsg :: < PosCovCartesian > :: new () ; PosCovCartesian :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct PosCovGeodetic { pub header : std_msgs :: msg :: Header , pub block_header : septentrio_gnss_driver :: msg :: BlockHeader , pub mode : u8 , pub error : u8 , pub cov_latlat : f32 , pub cov_lonlon : f32 , pub cov_hgthgt : f32 , pub cov_bb : f32 , pub cov_latlon : f32 , pub cov_lathgt : f32 , pub cov_latb : f32 , pub cov_lonhgt : f32 , pub cov_lonb : f32 , pub cov_hb : f32 } impl WrappedTypesupport for PosCovGeodetic { type CStruct = septentrio_gnss_driver__msg__PosCovGeodetic ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__septentrio_gnss_driver__msg__PosCovGeodetic () } } fn create_msg () -> * mut septentrio_gnss_driver__msg__PosCovGeodetic { unsafe { septentrio_gnss_driver__msg__PosCovGeodetic__create () } } fn destroy_msg (msg : * mut septentrio_gnss_driver__msg__PosCovGeodetic) -> () { unsafe { septentrio_gnss_driver__msg__PosCovGeodetic__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> PosCovGeodetic { PosCovGeodetic { header : std_msgs :: msg :: Header :: from_native (& msg . header) , block_header : septentrio_gnss_driver :: msg :: BlockHeader :: from_native (& msg . block_header) , mode : msg . mode , error : msg . error , cov_latlat : msg . cov_latlat , cov_lonlon : msg . cov_lonlon , cov_hgthgt : msg . cov_hgthgt , cov_bb : msg . cov_bb , cov_latlon : msg . cov_latlon , cov_lathgt : msg . cov_lathgt , cov_latb : msg . cov_latb , cov_lonhgt : msg . cov_lonhgt , cov_lonb : msg . cov_lonb , cov_hb : msg . cov_hb , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; self . block_header . copy_to_native (& mut msg . block_header) ; msg . mode = self . mode ; msg . error = self . error ; msg . cov_latlat = self . cov_latlat ; msg . cov_lonlon = self . cov_lonlon ; msg . cov_hgthgt = self . cov_hgthgt ; msg . cov_bb = self . cov_bb ; msg . cov_latlon = self . cov_latlon ; msg . cov_lathgt = self . cov_lathgt ; msg . cov_latb = self . cov_latb ; msg . cov_lonhgt = self . cov_lonhgt ; msg . cov_lonb = self . cov_lonb ; msg . cov_hb = self . cov_hb ; } } impl Default for PosCovGeodetic { fn default () -> Self { let msg_native = WrappedNativeMsg :: < PosCovGeodetic > :: new () ; PosCovGeodetic :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct ReceiverTime { pub header : std_msgs :: msg :: Header , pub block_header : septentrio_gnss_driver :: msg :: BlockHeader , pub utc_year : i8 , pub utc_month : i8 , pub utc_day : i8 , pub utc_hour : i8 , pub utc_min : i8 , pub utc_second : i8 , pub delta_ls : i8 , pub sync_level : u8 } impl WrappedTypesupport for ReceiverTime { type CStruct = septentrio_gnss_driver__msg__ReceiverTime ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__septentrio_gnss_driver__msg__ReceiverTime () } } fn create_msg () -> * mut septentrio_gnss_driver__msg__ReceiverTime { unsafe { septentrio_gnss_driver__msg__ReceiverTime__create () } } fn destroy_msg (msg : * mut septentrio_gnss_driver__msg__ReceiverTime) -> () { unsafe { septentrio_gnss_driver__msg__ReceiverTime__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> ReceiverTime { ReceiverTime { header : std_msgs :: msg :: Header :: from_native (& msg . header) , block_header : septentrio_gnss_driver :: msg :: BlockHeader :: from_native (& msg . block_header) , utc_year : msg . utc_year , utc_month : msg . utc_month , utc_day : msg . utc_day , utc_hour : msg . utc_hour , utc_min : msg . utc_min , utc_second : msg . utc_second , delta_ls : msg . delta_ls , sync_level : msg . sync_level , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; self . block_header . copy_to_native (& mut msg . block_header) ; msg . utc_year = self . utc_year ; msg . utc_month = self . utc_month ; msg . utc_day = self . utc_day ; msg . utc_hour = self . utc_hour ; msg . utc_min = self . utc_min ; msg . utc_second = self . utc_second ; msg . delta_ls = self . delta_ls ; msg . sync_level = self . sync_level ; } } impl Default for ReceiverTime { fn default () -> Self { let msg_native = WrappedNativeMsg :: < ReceiverTime > :: new () ; ReceiverTime :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct VectorInfoCart { pub nr_sv : u8 , pub error : u8 , pub mode : u8 , pub misc : u8 , pub delta_x : f64 , pub delta_y : f64 , pub delta_z : f64 , pub delta_vx : f32 , pub delta_vy : f32 , pub delta_vz : f32 , pub azimuth : u16 , pub elevation : i16 , pub reference_id : u16 , pub corr_age : u16 , pub signal_info : u32 } impl WrappedTypesupport for VectorInfoCart { type CStruct = septentrio_gnss_driver__msg__VectorInfoCart ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__septentrio_gnss_driver__msg__VectorInfoCart () } } fn create_msg () -> * mut septentrio_gnss_driver__msg__VectorInfoCart { unsafe { septentrio_gnss_driver__msg__VectorInfoCart__create () } } fn destroy_msg (msg : * mut septentrio_gnss_driver__msg__VectorInfoCart) -> () { unsafe { septentrio_gnss_driver__msg__VectorInfoCart__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> VectorInfoCart { VectorInfoCart { nr_sv : msg . nr_sv , error : msg . error , mode : msg . mode , misc : msg . misc , delta_x : msg . delta_x , delta_y : msg . delta_y , delta_z : msg . delta_z , delta_vx : msg . delta_vx , delta_vy : msg . delta_vy , delta_vz : msg . delta_vz , azimuth : msg . azimuth , elevation : msg . elevation , reference_id : msg . reference_id , corr_age : msg . corr_age , signal_info : msg . signal_info , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . nr_sv = self . nr_sv ; msg . error = self . error ; msg . mode = self . mode ; msg . misc = self . misc ; msg . delta_x = self . delta_x ; msg . delta_y = self . delta_y ; msg . delta_z = self . delta_z ; msg . delta_vx = self . delta_vx ; msg . delta_vy = self . delta_vy ; msg . delta_vz = self . delta_vz ; msg . azimuth = self . azimuth ; msg . elevation = self . elevation ; msg . reference_id = self . reference_id ; msg . corr_age = self . corr_age ; msg . signal_info = self . signal_info ; } } impl Default for VectorInfoCart { fn default () -> Self { let msg_native = WrappedNativeMsg :: < VectorInfoCart > :: new () ; VectorInfoCart :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct VectorInfoGeod { pub nr_sv : u8 , pub error : u8 , pub mode : u8 , pub misc : u8 , pub delta_east : f64 , pub delta_north : f64 , pub delta_up : f64 , pub delta_ve : f32 , pub delta_vn : f32 , pub delta_vu : f32 , pub azimuth : u16 , pub elevation : i16 , pub reference_id : u16 , pub corr_age : u16 , pub signal_info : u32 } impl WrappedTypesupport for VectorInfoGeod { type CStruct = septentrio_gnss_driver__msg__VectorInfoGeod ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__septentrio_gnss_driver__msg__VectorInfoGeod () } } fn create_msg () -> * mut septentrio_gnss_driver__msg__VectorInfoGeod { unsafe { septentrio_gnss_driver__msg__VectorInfoGeod__create () } } fn destroy_msg (msg : * mut septentrio_gnss_driver__msg__VectorInfoGeod) -> () { unsafe { septentrio_gnss_driver__msg__VectorInfoGeod__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> VectorInfoGeod { VectorInfoGeod { nr_sv : msg . nr_sv , error : msg . error , mode : msg . mode , misc : msg . misc , delta_east : msg . delta_east , delta_north : msg . delta_north , delta_up : msg . delta_up , delta_ve : msg . delta_ve , delta_vn : msg . delta_vn , delta_vu : msg . delta_vu , azimuth : msg . azimuth , elevation : msg . elevation , reference_id : msg . reference_id , corr_age : msg . corr_age , signal_info : msg . signal_info , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { msg . nr_sv = self . nr_sv ; msg . error = self . error ; msg . mode = self . mode ; msg . misc = self . misc ; msg . delta_east = self . delta_east ; msg . delta_north = self . delta_north ; msg . delta_up = self . delta_up ; msg . delta_ve = self . delta_ve ; msg . delta_vn = self . delta_vn ; msg . delta_vu = self . delta_vu ; msg . azimuth = self . azimuth ; msg . elevation = self . elevation ; msg . reference_id = self . reference_id ; msg . corr_age = self . corr_age ; msg . signal_info = self . signal_info ; } } impl Default for VectorInfoGeod { fn default () -> Self { let msg_native = WrappedNativeMsg :: < VectorInfoGeod > :: new () ; VectorInfoGeod :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct VelCovCartesian { pub header : std_msgs :: msg :: Header , pub block_header : septentrio_gnss_driver :: msg :: BlockHeader , pub mode : u8 , pub error : u8 , pub cov_vxvx : f32 , pub cov_vyvy : f32 , pub cov_vzvz : f32 , pub cov_dtdt : f32 , pub cov_vxvy : f32 , pub cov_vxvz : f32 , pub cov_vxdt : f32 , pub cov_vyvz : f32 , pub cov_vydt : f32 , pub cov_vzdt : f32 } impl WrappedTypesupport for VelCovCartesian { type CStruct = septentrio_gnss_driver__msg__VelCovCartesian ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__septentrio_gnss_driver__msg__VelCovCartesian () } } fn create_msg () -> * mut septentrio_gnss_driver__msg__VelCovCartesian { unsafe { septentrio_gnss_driver__msg__VelCovCartesian__create () } } fn destroy_msg (msg : * mut septentrio_gnss_driver__msg__VelCovCartesian) -> () { unsafe { septentrio_gnss_driver__msg__VelCovCartesian__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> VelCovCartesian { VelCovCartesian { header : std_msgs :: msg :: Header :: from_native (& msg . header) , block_header : septentrio_gnss_driver :: msg :: BlockHeader :: from_native (& msg . block_header) , mode : msg . mode , error : msg . error , cov_vxvx : msg . cov_vxvx , cov_vyvy : msg . cov_vyvy , cov_vzvz : msg . cov_vzvz , cov_dtdt : msg . cov_dtdt , cov_vxvy : msg . cov_vxvy , cov_vxvz : msg . cov_vxvz , cov_vxdt : msg . cov_vxdt , cov_vyvz : msg . cov_vyvz , cov_vydt : msg . cov_vydt , cov_vzdt : msg . cov_vzdt , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; self . block_header . copy_to_native (& mut msg . block_header) ; msg . mode = self . mode ; msg . error = self . error ; msg . cov_vxvx = self . cov_vxvx ; msg . cov_vyvy = self . cov_vyvy ; msg . cov_vzvz = self . cov_vzvz ; msg . cov_dtdt = self . cov_dtdt ; msg . cov_vxvy = self . cov_vxvy ; msg . cov_vxvz = self . cov_vxvz ; msg . cov_vxdt = self . cov_vxdt ; msg . cov_vyvz = self . cov_vyvz ; msg . cov_vydt = self . cov_vydt ; msg . cov_vzdt = self . cov_vzdt ; } } impl Default for VelCovCartesian { fn default () -> Self { let msg_native = WrappedNativeMsg :: < VelCovCartesian > :: new () ; VelCovCartesian :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct VelCovGeodetic { pub header : std_msgs :: msg :: Header , pub block_header : septentrio_gnss_driver :: msg :: BlockHeader , pub mode : u8 , pub error : u8 , pub cov_vnvn : f32 , pub cov_veve : f32 , pub cov_vuvu : f32 , pub cov_dtdt : f32 , pub cov_vnve : f32 , pub cov_vnvu : f32 , pub cov_vndt : f32 , pub cov_vevu : f32 , pub cov_vedt : f32 , pub cov_vudt : f32 } impl WrappedTypesupport for VelCovGeodetic { type CStruct = septentrio_gnss_driver__msg__VelCovGeodetic ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__septentrio_gnss_driver__msg__VelCovGeodetic () } } fn create_msg () -> * mut septentrio_gnss_driver__msg__VelCovGeodetic { unsafe { septentrio_gnss_driver__msg__VelCovGeodetic__create () } } fn destroy_msg (msg : * mut septentrio_gnss_driver__msg__VelCovGeodetic) -> () { unsafe { septentrio_gnss_driver__msg__VelCovGeodetic__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> VelCovGeodetic { VelCovGeodetic { header : std_msgs :: msg :: Header :: from_native (& msg . header) , block_header : septentrio_gnss_driver :: msg :: BlockHeader :: from_native (& msg . block_header) , mode : msg . mode , error : msg . error , cov_vnvn : msg . cov_vnvn , cov_veve : msg . cov_veve , cov_vuvu : msg . cov_vuvu , cov_dtdt : msg . cov_dtdt , cov_vnve : msg . cov_vnve , cov_vnvu : msg . cov_vnvu , cov_vndt : msg . cov_vndt , cov_vevu : msg . cov_vevu , cov_vedt : msg . cov_vedt , cov_vudt : msg . cov_vudt , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; self . block_header . copy_to_native (& mut msg . block_header) ; msg . mode = self . mode ; msg . error = self . error ; msg . cov_vnvn = self . cov_vnvn ; msg . cov_veve = self . cov_veve ; msg . cov_vuvu = self . cov_vuvu ; msg . cov_dtdt = self . cov_dtdt ; msg . cov_vnve = self . cov_vnve ; msg . cov_vnvu = self . cov_vnvu ; msg . cov_vndt = self . cov_vndt ; msg . cov_vevu = self . cov_vevu ; msg . cov_vedt = self . cov_vedt ; msg . cov_vudt = self . cov_vudt ; } } impl Default for VelCovGeodetic { fn default () -> Self { let msg_native = WrappedNativeMsg :: < VelCovGeodetic > :: new () ; VelCovGeodetic :: from_native (& msg_native) } } # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct VelSensorSetup { pub header : std_msgs :: msg :: Header , pub block_header : septentrio_gnss_driver :: msg :: BlockHeader , pub port : u8 , pub lever_arm_x : f32 , pub lever_arm_y : f32 , pub lever_arm_z : f32 } impl WrappedTypesupport for VelSensorSetup { type CStruct = septentrio_gnss_driver__msg__VelSensorSetup ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__septentrio_gnss_driver__msg__VelSensorSetup () } } fn create_msg () -> * mut septentrio_gnss_driver__msg__VelSensorSetup { unsafe { septentrio_gnss_driver__msg__VelSensorSetup__create () } } fn destroy_msg (msg : * mut septentrio_gnss_driver__msg__VelSensorSetup) -> () { unsafe { septentrio_gnss_driver__msg__VelSensorSetup__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> VelSensorSetup { VelSensorSetup { header : std_msgs :: msg :: Header :: from_native (& msg . header) , block_header : septentrio_gnss_driver :: msg :: BlockHeader :: from_native (& msg . block_header) , port : msg . port , lever_arm_x : msg . lever_arm_x , lever_arm_y : msg . lever_arm_y , lever_arm_z : msg . lever_arm_z , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; self . block_header . copy_to_native (& mut msg . block_header) ; msg . port = self . port ; msg . lever_arm_x = self . lever_arm_x ; msg . lever_arm_y = self . lever_arm_y ; msg . lever_arm_z = self . lever_arm_z ; } } impl Default for VelSensorSetup { fn default () -> Self { let msg_native = WrappedNativeMsg :: < VelSensorSetup > :: new () ; VelSensorSetup :: from_native (& msg_native) } } }