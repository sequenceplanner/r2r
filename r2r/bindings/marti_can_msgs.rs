pub mod msg { use super :: super :: * ; # [derive (Clone , Debug , PartialEq , Serialize , Deserialize)] # [serde (default)] pub struct CanFrame { pub header : std_msgs :: msg :: Header , pub id : u32 , pub msg_type : u8 , pub data_length : u8 , pub data : Vec < u8 > } impl WrappedTypesupport for CanFrame { type CStruct = marti_can_msgs__msg__CanFrame ; fn get_ts () -> & 'static rosidl_message_type_support_t { unsafe { & * rosidl_typesupport_c__get_message_type_support_handle__marti_can_msgs__msg__CanFrame () } } fn create_msg () -> * mut marti_can_msgs__msg__CanFrame { unsafe { marti_can_msgs__msg__CanFrame__create () } } fn destroy_msg (msg : * mut marti_can_msgs__msg__CanFrame) -> () { unsafe { marti_can_msgs__msg__CanFrame__destroy (msg) } ; } fn from_native (# [allow (unused)] msg : & Self :: CStruct) -> CanFrame { CanFrame { header : std_msgs :: msg :: Header :: from_native (& msg . header) , id : msg . id , msg_type : msg . msg_type , data_length : msg . data_length , data : msg . data . to_vec () , } } fn copy_to_native (& self , # [allow (unused)] msg : & mut Self :: CStruct) { self . header . copy_to_native (& mut msg . header) ; msg . id = self . id ; msg . msg_type = self . msg_type ; msg . data_length = self . data_length ; assert_eq ! (self . data . len () , 8usize , "Field {} is fixed size of {}!" , "data" , 8usize) ; msg . data . copy_from_slice (& self . data [.. 8usize]) ; } } impl Default for CanFrame { fn default () -> Self { let msg_native = WrappedNativeMsg :: < CanFrame > :: new () ; CanFrame :: from_native (& msg_native) } } # [allow (non_upper_case_globals)] impl CanFrame { pub const MSGTYPE_EXTENDED : _bindgen_ty_434 = marti_can_msgs__msg__CanFrame__MSGTYPE_EXTENDED ; pub const MSGTYPE_RTR : _bindgen_ty_433 = marti_can_msgs__msg__CanFrame__MSGTYPE_RTR ; pub const MSGTYPE_STANDARD : _bindgen_ty_432 = marti_can_msgs__msg__CanFrame__MSGTYPE_STANDARD ; pub const MSGTYPE_STATUS : _bindgen_ty_435 = marti_can_msgs__msg__CanFrame__MSGTYPE_STATUS ; } }