/* automatically generated by rust-bindgen 0.63.0 */

pub const RCL_RET_ACTION_NAME_INVALID: u32 = 2000;
pub const RCL_RET_ACTION_GOAL_ACCEPTED: u32 = 2100;
pub const RCL_RET_ACTION_GOAL_REJECTED: u32 = 2101;
pub const RCL_RET_ACTION_CLIENT_INVALID: u32 = 2102;
pub const RCL_RET_ACTION_CLIENT_TAKE_FAILED: u32 = 2103;
pub const RCL_RET_ACTION_SERVER_INVALID: u32 = 2200;
pub const RCL_RET_ACTION_SERVER_TAKE_FAILED: u32 = 2201;
pub const RCL_RET_ACTION_GOAL_HANDLE_INVALID: u32 = 2300;
pub const RCL_RET_ACTION_GOAL_EVENT_INVALID: u32 = 2301;
pub type rcl_action_goal_info_t = action_msgs__msg__GoalInfo;
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rcl_action_goal_status_array_t {
    pub _bindgen_opaque_blob: [u64; 8usize],
}
#[test]
fn bindgen_test_layout_rcl_action_goal_status_array_t() {
    assert_eq!(
        ::std::mem::size_of::<rcl_action_goal_status_array_t>(),
        64usize,
        concat!("Size of: ", stringify!(rcl_action_goal_status_array_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_action_goal_status_array_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_action_goal_status_array_t))
    );
}
pub type rcl_action_cancel_request_t = action_msgs__srv__CancelGoal_Request;
#[repr(C)]
pub struct rcl_action_cancel_response_t {
    pub msg: action_msgs__srv__CancelGoal_Response,
    pub allocator: rcl_allocator_t,
}
#[test]
fn bindgen_test_layout_rcl_action_cancel_response_t() {
    const UNINIT: ::std::mem::MaybeUninit<rcl_action_cancel_response_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rcl_action_cancel_response_t>(),
        72usize,
        concat!("Size of: ", stringify!(rcl_action_cancel_response_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_action_cancel_response_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_action_cancel_response_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_action_cancel_response_t),
            "::",
            stringify!(msg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rcl_action_cancel_response_t),
            "::",
            stringify!(allocator)
        )
    );
}
pub type rcl_action_goal_state_t = u8;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rcl_action_goal_event_t {
    GOAL_EVENT_EXECUTE = 0,
    GOAL_EVENT_CANCEL_GOAL = 1,
    GOAL_EVENT_SUCCEED = 2,
    GOAL_EVENT_ABORT = 3,
    GOAL_EVENT_CANCELED = 4,
    GOAL_EVENT_NUM_EVENTS = 5,
}
extern "C" {
    pub fn rcl_action_get_zero_initialized_goal_info() -> rcl_action_goal_info_t;
}
extern "C" {
    pub fn rcl_action_get_zero_initialized_goal_status_array() -> rcl_action_goal_status_array_t;
}
extern "C" {
    pub fn rcl_action_get_zero_initialized_cancel_request() -> rcl_action_cancel_request_t;
}
extern "C" {
    pub fn rcl_action_get_zero_initialized_cancel_response() -> rcl_action_cancel_response_t;
}
extern "C" {
    pub fn rcl_action_goal_status_array_init(
        status_array: *mut rcl_action_goal_status_array_t,
        num_status: usize,
        allocator: rcl_allocator_t,
    ) -> rcl_ret_t;
}
extern "C" {
    pub fn rcl_action_goal_status_array_fini(
        status_array: *mut rcl_action_goal_status_array_t,
    ) -> rcl_ret_t;
}
extern "C" {
    pub fn rcl_action_cancel_response_init(
        cancel_response: *mut rcl_action_cancel_response_t,
        num_goals_canceling: usize,
        allocator: rcl_allocator_t,
    ) -> rcl_ret_t;
}
extern "C" {
    pub fn rcl_action_cancel_response_fini(
        cancel_response: *mut rcl_action_cancel_response_t,
    ) -> rcl_ret_t;
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rcl_action_client_t {
    pub _bindgen_opaque_blob: u64,
}
#[test]
fn bindgen_test_layout_rcl_action_client_t() {
    assert_eq!(
        ::std::mem::size_of::<rcl_action_client_t>(),
        8usize,
        concat!("Size of: ", stringify!(rcl_action_client_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_action_client_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_action_client_t))
    );
}
#[repr(C)]
#[repr(align(8))]
pub struct rcl_action_client_options_t {
    pub _bindgen_opaque_blob: [u64; 60usize],
}
#[test]
fn bindgen_test_layout_rcl_action_client_options_t() {
    assert_eq!(
        ::std::mem::size_of::<rcl_action_client_options_t>(),
        480usize,
        concat!("Size of: ", stringify!(rcl_action_client_options_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_action_client_options_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_action_client_options_t))
    );
}
extern "C" {
    pub fn rcl_action_get_zero_initialized_client() -> rcl_action_client_t;
}
extern "C" {
    pub fn rcl_action_client_init(
        action_client: *mut rcl_action_client_t,
        node: *mut rcl_node_t,
        type_support: *const rosidl_action_type_support_t,
        action_name: *const ::std::os::raw::c_char,
        options: *const rcl_action_client_options_t,
    ) -> rcl_ret_t;
}
extern "C" {
    pub fn rcl_action_client_fini(
        action_client: *mut rcl_action_client_t,
        node: *mut rcl_node_t,
    ) -> rcl_ret_t;
}
extern "C" {
    pub fn rcl_action_client_get_default_options() -> rcl_action_client_options_t;
}
extern "C" {
    pub fn rcl_action_server_is_available(
        node: *const rcl_node_t,
        client: *const rcl_action_client_t,
        is_available: *mut bool,
    ) -> rcl_ret_t;
}
extern "C" {
    pub fn rcl_action_send_goal_request(
        action_client: *const rcl_action_client_t,
        ros_goal_request: *const ::std::os::raw::c_void,
        sequence_number: *mut i64,
    ) -> rcl_ret_t;
}
extern "C" {
    pub fn rcl_action_take_goal_response(
        action_client: *const rcl_action_client_t,
        response_header: *mut rmw_request_id_t,
        ros_goal_response: *mut ::std::os::raw::c_void,
    ) -> rcl_ret_t;
}
extern "C" {
    pub fn rcl_action_take_feedback(
        action_client: *const rcl_action_client_t,
        ros_feedback: *mut ::std::os::raw::c_void,
    ) -> rcl_ret_t;
}
extern "C" {
    pub fn rcl_action_take_status(
        action_client: *const rcl_action_client_t,
        ros_status_array: *mut ::std::os::raw::c_void,
    ) -> rcl_ret_t;
}
extern "C" {
    pub fn rcl_action_send_result_request(
        action_client: *const rcl_action_client_t,
        ros_result_request: *const ::std::os::raw::c_void,
        sequence_number: *mut i64,
    ) -> rcl_ret_t;
}
extern "C" {
    pub fn rcl_action_take_result_response(
        action_client: *const rcl_action_client_t,
        response_header: *mut rmw_request_id_t,
        ros_result: *mut ::std::os::raw::c_void,
    ) -> rcl_ret_t;
}
extern "C" {
    pub fn rcl_action_send_cancel_request(
        action_client: *const rcl_action_client_t,
        ros_cancel_request: *const ::std::os::raw::c_void,
        sequence_number: *mut i64,
    ) -> rcl_ret_t;
}
extern "C" {
    pub fn rcl_action_take_cancel_response(
        action_client: *const rcl_action_client_t,
        response_header: *mut rmw_request_id_t,
        ros_cancel_response: *mut ::std::os::raw::c_void,
    ) -> rcl_ret_t;
}
extern "C" {
    pub fn rcl_action_client_get_action_name(
        action_client: *const rcl_action_client_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rcl_action_client_get_options(
        action_client: *const rcl_action_client_t,
    ) -> *const rcl_action_client_options_t;
}
extern "C" {
    pub fn rcl_action_client_is_valid(action_client: *const rcl_action_client_t) -> bool;
}
extern "C" {
    pub fn rcl_action_transition_goal_state(
        state: rcl_action_goal_state_t,
        event: rcl_action_goal_event_t,
    ) -> rcl_action_goal_state_t;
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rcl_action_goal_handle_t {
    pub _bindgen_opaque_blob: u64,
}
#[test]
fn bindgen_test_layout_rcl_action_goal_handle_t() {
    assert_eq!(
        ::std::mem::size_of::<rcl_action_goal_handle_t>(),
        8usize,
        concat!("Size of: ", stringify!(rcl_action_goal_handle_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_action_goal_handle_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_action_goal_handle_t))
    );
}
extern "C" {
    pub fn rcl_action_get_zero_initialized_goal_handle() -> rcl_action_goal_handle_t;
}
extern "C" {
    pub fn rcl_action_goal_handle_init(
        goal_handle: *mut rcl_action_goal_handle_t,
        goal_info: *const rcl_action_goal_info_t,
        allocator: rcl_allocator_t,
    ) -> rcl_ret_t;
}
extern "C" {
    pub fn rcl_action_goal_handle_fini(goal_handle: *mut rcl_action_goal_handle_t) -> rcl_ret_t;
}
extern "C" {
    pub fn rcl_action_update_goal_state(
        goal_handle: *mut rcl_action_goal_handle_t,
        goal_event: rcl_action_goal_event_t,
    ) -> rcl_ret_t;
}
extern "C" {
    pub fn rcl_action_goal_handle_get_info(
        goal_handle: *const rcl_action_goal_handle_t,
        goal_info: *mut rcl_action_goal_info_t,
    ) -> rcl_ret_t;
}
extern "C" {
    pub fn rcl_action_goal_handle_get_status(
        goal_handle: *const rcl_action_goal_handle_t,
        status: *mut rcl_action_goal_state_t,
    ) -> rcl_ret_t;
}
extern "C" {
    pub fn rcl_action_goal_handle_is_active(goal_handle: *const rcl_action_goal_handle_t) -> bool;
}
extern "C" {
    pub fn rcl_action_goal_handle_is_cancelable(
        goal_handle: *const rcl_action_goal_handle_t,
    ) -> bool;
}
extern "C" {
    pub fn rcl_action_goal_handle_is_valid(goal_handle: *const rcl_action_goal_handle_t) -> bool;
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct rcl_action_server_t {
    pub _bindgen_opaque_blob: u64,
}
#[test]
fn bindgen_test_layout_rcl_action_server_t() {
    assert_eq!(
        ::std::mem::size_of::<rcl_action_server_t>(),
        8usize,
        concat!("Size of: ", stringify!(rcl_action_server_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_action_server_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_action_server_t))
    );
}
#[repr(C)]
#[repr(align(8))]
pub struct rcl_action_server_options_t {
    pub _bindgen_opaque_blob: [u64; 61usize],
}
#[test]
fn bindgen_test_layout_rcl_action_server_options_t() {
    assert_eq!(
        ::std::mem::size_of::<rcl_action_server_options_t>(),
        488usize,
        concat!("Size of: ", stringify!(rcl_action_server_options_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rcl_action_server_options_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rcl_action_server_options_t))
    );
}
extern "C" {
    pub fn rcl_action_get_zero_initialized_server() -> rcl_action_server_t;
}
extern "C" {
    pub fn rcl_action_server_init(
        action_server: *mut rcl_action_server_t,
        node: *mut rcl_node_t,
        clock: *mut rcl_clock_t,
        type_support: *const rosidl_action_type_support_t,
        action_name: *const ::std::os::raw::c_char,
        options: *const rcl_action_server_options_t,
    ) -> rcl_ret_t;
}
extern "C" {
    pub fn rcl_action_server_fini(
        action_server: *mut rcl_action_server_t,
        node: *mut rcl_node_t,
    ) -> rcl_ret_t;
}
extern "C" {
    pub fn rcl_action_server_get_default_options() -> rcl_action_server_options_t;
}
extern "C" {
    pub fn rcl_action_take_goal_request(
        action_server: *const rcl_action_server_t,
        request_header: *mut rmw_request_id_t,
        ros_goal_request: *mut ::std::os::raw::c_void,
    ) -> rcl_ret_t;
}
extern "C" {
    pub fn rcl_action_send_goal_response(
        action_server: *const rcl_action_server_t,
        response_header: *mut rmw_request_id_t,
        ros_goal_response: *mut ::std::os::raw::c_void,
    ) -> rcl_ret_t;
}
extern "C" {
    pub fn rcl_action_accept_new_goal(
        action_server: *mut rcl_action_server_t,
        goal_info: *const rcl_action_goal_info_t,
    ) -> *mut rcl_action_goal_handle_t;
}
extern "C" {
    pub fn rcl_action_publish_feedback(
        action_server: *const rcl_action_server_t,
        ros_feedback: *mut ::std::os::raw::c_void,
    ) -> rcl_ret_t;
}
extern "C" {
    pub fn rcl_action_get_goal_status_array(
        action_server: *const rcl_action_server_t,
        status_message: *mut rcl_action_goal_status_array_t,
    ) -> rcl_ret_t;
}
extern "C" {
    pub fn rcl_action_publish_status(
        action_server: *const rcl_action_server_t,
        status_message: *const ::std::os::raw::c_void,
    ) -> rcl_ret_t;
}
extern "C" {
    pub fn rcl_action_take_result_request(
        action_server: *const rcl_action_server_t,
        request_header: *mut rmw_request_id_t,
        ros_result_request: *mut ::std::os::raw::c_void,
    ) -> rcl_ret_t;
}
extern "C" {
    pub fn rcl_action_send_result_response(
        action_server: *const rcl_action_server_t,
        response_header: *mut rmw_request_id_t,
        ros_result_response: *mut ::std::os::raw::c_void,
    ) -> rcl_ret_t;
}
extern "C" {
    pub fn rcl_action_expire_goals(
        action_server: *const rcl_action_server_t,
        expired_goals: *mut rcl_action_goal_info_t,
        expired_goals_capacity: usize,
        num_expired: *mut usize,
    ) -> rcl_ret_t;
}
extern "C" {
    pub fn rcl_action_notify_goal_done(action_server: *const rcl_action_server_t) -> rcl_ret_t;
}
extern "C" {
    pub fn rcl_action_take_cancel_request(
        action_server: *const rcl_action_server_t,
        request_header: *mut rmw_request_id_t,
        ros_cancel_request: *mut ::std::os::raw::c_void,
    ) -> rcl_ret_t;
}
extern "C" {
    pub fn rcl_action_process_cancel_request(
        action_server: *const rcl_action_server_t,
        cancel_request: *const rcl_action_cancel_request_t,
        cancel_response: *mut rcl_action_cancel_response_t,
    ) -> rcl_ret_t;
}
extern "C" {
    pub fn rcl_action_send_cancel_response(
        action_server: *const rcl_action_server_t,
        response_header: *mut rmw_request_id_t,
        ros_cancel_response: *mut ::std::os::raw::c_void,
    ) -> rcl_ret_t;
}
extern "C" {
    pub fn rcl_action_server_get_action_name(
        action_server: *const rcl_action_server_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rcl_action_server_get_options(
        action_server: *const rcl_action_server_t,
    ) -> *const rcl_action_server_options_t;
}
extern "C" {
    pub fn rcl_action_server_get_goal_handles(
        action_server: *const rcl_action_server_t,
        goal_handles: *mut *mut *mut rcl_action_goal_handle_t,
        num_goals: *mut usize,
    ) -> rcl_ret_t;
}
extern "C" {
    pub fn rcl_action_server_goal_exists(
        action_server: *const rcl_action_server_t,
        goal_info: *const rcl_action_goal_info_t,
    ) -> bool;
}
extern "C" {
    pub fn rcl_action_server_is_valid(action_server: *const rcl_action_server_t) -> bool;
}
extern "C" {
    pub fn rcl_action_server_is_valid_except_context(
        action_server: *const rcl_action_server_t,
    ) -> bool;
}
extern "C" {
    pub fn rcl_action_get_client_names_and_types_by_node(
        node: *const rcl_node_t,
        allocator: *mut rcl_allocator_t,
        node_name: *const ::std::os::raw::c_char,
        node_namespace: *const ::std::os::raw::c_char,
        action_names_and_types: *mut rcl_names_and_types_t,
    ) -> rcl_ret_t;
}
extern "C" {
    pub fn rcl_action_get_server_names_and_types_by_node(
        node: *const rcl_node_t,
        allocator: *mut rcl_allocator_t,
        node_name: *const ::std::os::raw::c_char,
        node_namespace: *const ::std::os::raw::c_char,
        action_names_and_types: *mut rcl_names_and_types_t,
    ) -> rcl_ret_t;
}
extern "C" {
    pub fn rcl_action_get_names_and_types(
        node: *const rcl_node_t,
        allocator: *mut rcl_allocator_t,
        action_names_and_types: *mut rcl_names_and_types_t,
    ) -> rcl_ret_t;
}
extern "C" {
    pub fn rcl_action_wait_set_add_action_client(
        wait_set: *mut rcl_wait_set_t,
        action_client: *const rcl_action_client_t,
        client_index: *mut usize,
        subscription_index: *mut usize,
    ) -> rcl_ret_t;
}
extern "C" {
    pub fn rcl_action_wait_set_add_action_server(
        wait_set: *mut rcl_wait_set_t,
        action_server: *const rcl_action_server_t,
        service_index: *mut usize,
    ) -> rcl_ret_t;
}
extern "C" {
    pub fn rcl_action_client_wait_set_get_num_entities(
        action_client: *const rcl_action_client_t,
        num_subscriptions: *mut usize,
        num_guard_conditions: *mut usize,
        num_timers: *mut usize,
        num_clients: *mut usize,
        num_services: *mut usize,
    ) -> rcl_ret_t;
}
extern "C" {
    pub fn rcl_action_server_wait_set_get_num_entities(
        action_server: *const rcl_action_server_t,
        num_subscriptions: *mut usize,
        num_guard_conditions: *mut usize,
        num_timers: *mut usize,
        num_clients: *mut usize,
        num_services: *mut usize,
    ) -> rcl_ret_t;
}
extern "C" {
    pub fn rcl_action_client_wait_set_get_entities_ready(
        wait_set: *const rcl_wait_set_t,
        action_client: *const rcl_action_client_t,
        is_feedback_ready: *mut bool,
        is_status_ready: *mut bool,
        is_goal_response_ready: *mut bool,
        is_cancel_response_ready: *mut bool,
        is_result_response_ready: *mut bool,
    ) -> rcl_ret_t;
}
extern "C" {
    pub fn rcl_action_server_wait_set_get_entities_ready(
        wait_set: *const rcl_wait_set_t,
        action_server: *const rcl_action_server_t,
        is_goal_request_ready: *mut bool,
        is_cancel_request_ready: *mut bool,
        is_result_request_ready: *mut bool,
        is_goal_expired: *mut bool,
    ) -> rcl_ret_t;
}
